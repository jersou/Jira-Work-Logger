#!/usr/bin/env -S deno run -A
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _updateAssetsBundle_dec, _frontendPath_dec, _assetsBundlePath_dec, _onListen_dec, _routes_dec, _assets_dec, _update_dec, _openInBrowserAppMode_dec, _openInBrowser_dec, _port_dec, _hostname_dec, _init, _a, _DesktopWebApp_instances, handleRequest_fn, openInBrowser_fn, loadAssets_fn, _issuesCache_dec, _sockets_dec, _notExitIfNoClient_dec, _b, _init2, _c;
function filterInPlace(array, predicate) {
  let outputIndex = 0;
  for (const cur of array) {
    if (!predicate(cur)) {
      continue;
    }
    array[outputIndex] = cur;
    outputIndex += 1;
  }
  array.splice(outputIndex);
  return array;
}
function deepMerge(record, other, options) {
  return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
  const result = {};
  const keys = /* @__PURE__ */ new Set([
    ...getKeys(record),
    ...getKeys(other)
  ]);
  for (const key of keys) {
    if (key === "__proto__") {
      continue;
    }
    const a = record[key];
    if (!Object.hasOwn(other, key)) {
      result[key] = a;
      continue;
    }
    const b = other[key];
    if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
      seen.add(a);
      seen.add(b);
      result[key] = mergeObjects(a, b, seen, options);
      continue;
    }
    result[key] = b;
  }
  return result;
}
function mergeObjects(left, right, seen, options = {
  arrays: "merge",
  sets: "merge",
  maps: "merge"
}) {
  if (isMergeable(left) && isMergeable(right)) {
    return deepMergeInternal(left, right, seen, options);
  }
  if (isIterable(left) && isIterable(right)) {
    if (Array.isArray(left) && Array.isArray(right)) {
      if (options.arrays === "merge") {
        return left.concat(right);
      }
      return right;
    }
    if (left instanceof Map && right instanceof Map) {
      if (options.maps === "merge") {
        return new Map([
          ...left,
          ...right
        ]);
      }
      return right;
    }
    if (left instanceof Set && right instanceof Set) {
      if (options.sets === "merge") {
        return /* @__PURE__ */ new Set([
          ...left,
          ...right
        ]);
      }
      return right;
    }
  }
  return right;
}
function isMergeable(value) {
  return Object.getPrototypeOf(value) === Object.prototype;
}
function isIterable(value) {
  return typeof value[Symbol.iterator] === "function";
}
function isNonNullObject(value) {
  return value !== null && typeof value === "object";
}
function getKeys(record) {
  const result = Object.getOwnPropertySymbols(record);
  filterInPlace(
    result,
    (key) => Object.prototype.propertyIsEnumerable.call(record, key)
  );
  result.push(...Object.keys(record));
  return result;
}
function addSymbolMetadata(target, prop, key, val) {
  let roorMetadata;
  let propName;
  if (prop.addInitializer) {
    roorMetadata = prop.metadata;
    propName = prop.name;
  } else {
    if (!target.constructor[Symbol.metadata]) {
      target.constructor[Symbol.metadata] = {};
    }
    roorMetadata = target.constructor[Symbol.metadata];
    propName = prop;
  }
  if (!roorMetadata.clite) {
    roorMetadata.clite = {};
  }
  const metadata = roorMetadata.clite;
  if (!metadata[key]) {
    metadata[key] = {};
  }
  if (Object.hasOwn(metadata[key], propName)) {
    if (!Array.isArray(metadata[key][propName])) {
      metadata[key][propName] = [metadata[key][propName]];
    }
    metadata[key][propName].push(val);
  } else {
    metadata[key][propName] = val;
  }
}
function getCliteSymbolMetadata(obj) {
  const prototypes = [];
  let o = obj;
  while (o = Reflect.getPrototypeOf(o)) {
    prototypes.unshift(o);
  }
  let metadata = {};
  for (const prototype of prototypes) {
    const protMeta = prototype.constructor[Symbol.metadata]?.clite || {};
    metadata = deepMerge(metadata, protMeta);
  }
  return metadata;
}
function help(description) {
  return (target, prop) => addSymbolMetadata(target, prop, "help", description);
}
function type(typeHelp) {
  return (target, prop) => addSymbolMetadata(target, prop, "types", typeHelp);
}
function hidden() {
  return (target, prop) => addSymbolMetadata(target, prop, "hidden", true);
}
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : false;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code4) {
  return enabled ? `${code4.open}${str.replace(code4.regexp, code4.open)}${code4.close}` : str;
}
function bold(str) {
  return run(str, code([1], 22));
}
function underline(str) {
  return run(str, code([4], 24));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([90], 39));
}
function bgRed(str) {
  return run(str, code([41], 49));
}
var ANSI_PATTERN = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
var { ceil } = Math;
var peq = new Uint32Array(1114112);
var CAPITALIZED_WORD_REGEXP = /\p{Lu}\p{Ll}+/u;
var ACRONYM_REGEXP = /\p{Lu}+(?=(\p{Lu}\p{Ll})|\P{L}|\b)/u;
var LOWERCASED_WORD_REGEXP = /(\p{Ll}+)/u;
var ANY_LETTERS = /\p{L}+/u;
var DIGITS_REGEXP = /\p{N}+/u;
var WORD_OR_NUMBER_REGEXP = new RegExp(
  `${CAPITALIZED_WORD_REGEXP.source}|${ACRONYM_REGEXP.source}|${LOWERCASED_WORD_REGEXP.source}|${ANY_LETTERS.source}|${DIGITS_REGEXP.source}`,
  "gu"
);
function splitToWords(input) {
  return input.match(WORD_OR_NUMBER_REGEXP) ?? [];
}
function capitalizeWord(word) {
  return word ? word?.[0]?.toLocaleUpperCase() + word.slice(1).toLocaleLowerCase() : word;
}
function toCamelCase(input) {
  input = input.trim();
  const [first = "", ...rest] = splitToWords(input);
  return [first.toLocaleLowerCase(), ...rest.map(capitalizeWord)].join("");
}
function toKebabCase(input) {
  input = input.trim();
  return splitToWords(input).join("-").toLocaleLowerCase();
}
function toSnakeCase(input) {
  input = input.trim();
  return splitToWords(input).join("_").toLocaleLowerCase();
}
var COMMENTS_REGEX = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
var ARGUMENT_NAMES_REGEX = /\((?<args>.*?)\)/m;
function getFunctionArgNames(func) {
  const fnStr = func.toString().replace(COMMENTS_REGEX, "");
  const argNames = ARGUMENT_NAMES_REGEX.exec(fnStr);
  return argNames?.[1].length && argNames?.[1]?.replace(/\s*=\s*[^,]+\s*/g, "").split(",").map((arg) => arg.replace(/[\s()]+/g, "")) || [];
}
function getMethodNames(obj) {
  const prototype = Object.getPrototypeOf(obj);
  return prototype.constructor.name === "Object" ? Object.getOwnPropertyNames(obj).filter((n) => typeof obj[n] === "function") : getMethodNamesDeep(obj);
}
function getMethodNamesDeep(obj) {
  const methods = [];
  let o = obj;
  while (o = Reflect.getPrototypeOf(o)) {
    if (o.constructor.name !== "Object") {
      methods.unshift(
        ...Reflect.ownKeys(o).filter(
          (k) => typeof k === "string" && k !== "constructor" && !methods.includes(k)
        )
      );
    }
  }
  return methods;
}
function getFieldNames(obj) {
  return Object.getOwnPropertyNames(obj).filter((n) => typeof obj[n] !== "function");
}
function getMethodArgNames(obj, methodName) {
  const prototype = Object.getPrototypeOf(obj);
  if (prototype.constructor.name === "Object") {
    return getFunctionArgNames(obj[methodName]);
  } else {
    return getFunctionArgNames(prototype[methodName]);
  }
}
var boldUnder = (str) => bold(underline(str));
function align(input) {
  const maxCol0 = input.reduce((prev, cur) => Math.max(prev, cur[0].length), 0);
  const maxCol1 = input.reduce((prev, cur) => Math.max(prev, cur[1].length), 0);
  const maxCol23 = input.reduce(
    (prev, cur) => Math.max(prev, cur[2].length + cur[3].length),
    0
  ) + 1;
  return input.map(
    ([col0, col1, col2, col3]) => [
      col0.padStart(maxCol0),
      col1.padEnd(maxCol1) + " ",
      col2.padEnd(maxCol23 - col3.length),
      col3
    ].join("").trimEnd()
  );
}
function genCommandHelp(obj, metadata, helpLines) {
  const methods = [
    ...Object.keys(metadata.methods).filter((m) => !metadata.methods[m]?.hidden),
    ...metadata.subcommands.filter(
      (f) => !metadata.fields[f]?.hidden && !metadata.methods[f]?.hidden
    )
  ];
  if (methods.length > 0) {
    helpLines.push(boldUnder(`
Command${methods.length > 1 ? "s" : ""}:`));
    const linesCols = [];
    for (const method of methods) {
      let col1 = bold(`  ${method}`);
      if (!metadata.subcommands.includes(method)) {
        const args = getMethodArgNames(obj, method);
        if (args.length > 0) {
          col1 += " " + args.map((arg) => `<${arg}>`).join(" ");
        }
      } else {
        col1 += " --help | [sub Options / cmd / args]";
      }
      let col2 = metadata.methods?.[method]?.help ?? "";
      if (method === metadata.defaultCommand) {
        col2 += col2.length ? " " : "";
        col2 += bold("[default]");
      }
      linesCols.push(["", col1, col2, ""]);
    }
    helpLines.push(...align(linesCols));
  }
}
function genOptionsHelp(obj, metadata, helpLines, config) {
  const allFields = Object.keys(metadata.fields);
  const fields = allFields.filter((f) => !metadata.fields[f]?.hidden);
  helpLines.push(boldUnder(`
Option${fields.length ? "s" : ""}:`));
  const linesCols = [];
  linesCols.push([
    bold(` -h,`),
    bold(` --help`),
    "Show this help",
    gray("[default: false]")
  ]);
  if (config?.configCli || metadata.jsonConfig) {
    const configHelp = config?.configCli || metadata.jsonConfig;
    linesCols.push([
      bold(""),
      bold(` --config`),
      typeof configHelp === "string" ? configHelp : "Use this json file or string to read the options",
      gray("[string]")
    ]);
  }
  for (const field of fields) {
    const alias = [...metadata.fields[field]?.alias ?? []];
    const aliasHelp = alias.map((a) => a.length === 1 ? `-${a},` : `--${toKebabCase(a)},`).join(" ");
    const col0 = bold(` ${aliasHelp}`);
    const col1 = bold(` --${toKebabCase(field)}`);
    let col2 = "";
    let col3 = "";
    const help2 = metadata.fields[field]?.help ?? "";
    if (help2) {
      col2 += help2;
    }
    const defaultValue = metadata.fields[field]?.defaultHelp ?? obj[field];
    if (defaultValue != void 0) {
      const defaultHelp = typeof defaultValue === "string" ? `"${defaultValue}"` : defaultValue;
      col3 = gray(`[default: ${defaultHelp}]`);
    } else {
      const type2 = metadata.fields[field]?.type;
      if (type2) {
        col3 = gray(`[${type2}]`);
      }
    }
    linesCols.push([col0, col1, col2, col3]);
    if (metadata.fields[field]?.negatable) {
      linesCols.push([
        bold(" "),
        bold(` --${toKebabCase("no_" + field)}`),
        typeof metadata.fields[field]?.negatable === "string" ? metadata.fields[field]?.negatable : "",
        ""
      ]);
    }
  }
  helpLines.push(...align(linesCols));
}
function genHelp(obj, metadata, config) {
  const helpLines = [];
  if (metadata.help) {
    helpLines.push(metadata.help + "\n");
  }
  const name = Object.getPrototypeOf(obj).constructor.name;
  const mainFile = config?.mainFile ?? config?.meta?.url?.replace(/.*\//, "./") ?? `<${name} file>`;
  let usage = `${boldUnder("Usage:")} `;
  if (metadata.usage) {
    usage = `${usage}${metadata.usage}`;
  } else if (config?.noCommand || metadata.noCommand) {
    usage = `${usage}${mainFile} [Options] [--] [args]`;
  } else {
    usage = `${usage}${mainFile} [Options] [--] [command [command args]]`;
  }
  helpLines.push(usage);
  if (!config?.noCommand && !metadata.noCommand) {
    genCommandHelp(obj, metadata, helpLines);
  }
  genOptionsHelp(obj, metadata, helpLines, config);
  return helpLines.join("\n");
}
var FLAG_REGEXP = /^(?:-(?:(?<doubleDash>-)(?<negated>no-)?)?)(?<key>.+?)(?:=(?<value>.+?))?$/s;
var LETTER_REGEXP = /[A-Za-z]/;
var NUMBER_REGEXP = /-?\d+(\.\d*)?(e-?\d+)?$/;
var HYPHEN_REGEXP = /^(-|--)[^-]/;
var VALUE_REGEXP = /=(?<value>.+)/;
var FLAG_NAME_REGEXP = /^--[^=]+$/;
var SPECIAL_CHAR_REGEXP = /\W/;
var NON_WHITESPACE_REGEXP = /\S/;
function isNumber(string) {
  return NON_WHITESPACE_REGEXP.test(string) && Number.isFinite(Number(string));
}
function setNested(object, keys, value, collect = false) {
  keys = [...keys];
  const key = keys.pop();
  keys.forEach((key2) => object = object[key2] ??= {});
  if (collect) {
    const v = object[key];
    if (Array.isArray(v)) {
      v.push(value);
      return;
    }
    value = v ? [v, value] : [value];
  }
  object[key] = value;
}
function hasNested(object, keys) {
  for (const key of keys) {
    const value = object[key];
    if (!Object.hasOwn(object, key)) return false;
    object = value;
  }
  return true;
}
function aliasIsBoolean(aliasMap, booleanSet, key) {
  const set = aliasMap.get(key);
  if (set === void 0) return false;
  for (const alias of set) if (booleanSet.has(alias)) return true;
  return false;
}
function isBooleanString(value) {
  return value === "true" || value === "false";
}
function parseBooleanString(value) {
  return value !== "false";
}
function parseArgs(args, options) {
  const {
    "--": doubleDash = false,
    alias = {},
    boolean = false,
    default: defaults = {},
    stopEarly = false,
    string = [],
    collect = [],
    negatable = [],
    unknown: unknownFn = (i) => i
  } = options ?? {};
  const aliasMap = /* @__PURE__ */ new Map();
  const booleanSet = /* @__PURE__ */ new Set();
  const stringSet = /* @__PURE__ */ new Set();
  const collectSet = /* @__PURE__ */ new Set();
  const negatableSet = /* @__PURE__ */ new Set();
  let allBools = false;
  if (alias) {
    for (const [key, value] of Object.entries(alias)) {
      if (value === void 0) {
        throw new TypeError("Alias value must be defined");
      }
      const aliases = Array.isArray(value) ? value : [value];
      aliasMap.set(key, new Set(aliases));
      aliases.forEach(
        (alias2) => aliasMap.set(
          alias2,
          /* @__PURE__ */ new Set([key, ...aliases.filter((it) => it !== alias2)])
        )
      );
    }
  }
  if (boolean) {
    if (typeof boolean === "boolean") {
      allBools = boolean;
    } else {
      const booleanArgs = Array.isArray(boolean) ? boolean : [boolean];
      for (const key of booleanArgs.filter(Boolean)) {
        booleanSet.add(key);
        aliasMap.get(key)?.forEach((al) => {
          booleanSet.add(al);
        });
      }
    }
  }
  if (string) {
    const stringArgs = Array.isArray(string) ? string : [string];
    for (const key of stringArgs.filter(Boolean)) {
      stringSet.add(key);
      aliasMap.get(key)?.forEach((al) => stringSet.add(al));
    }
  }
  if (collect) {
    const collectArgs = Array.isArray(collect) ? collect : [collect];
    for (const key of collectArgs.filter(Boolean)) {
      collectSet.add(key);
      aliasMap.get(key)?.forEach((al) => collectSet.add(al));
    }
  }
  if (negatable) {
    const negatableArgs = Array.isArray(negatable) ? negatable : [negatable];
    for (const key of negatableArgs.filter(Boolean)) {
      negatableSet.add(key);
      aliasMap.get(key)?.forEach((alias2) => negatableSet.add(alias2));
    }
  }
  const argv = { _: [] };
  function setArgument(key, value, arg, collect2) {
    if (!booleanSet.has(key) && !stringSet.has(key) && !aliasMap.has(key) && !(allBools && FLAG_NAME_REGEXP.test(arg)) && unknownFn?.(arg, key, value) === false) {
      return;
    }
    if (typeof value === "string" && !stringSet.has(key)) {
      value = isNumber(value) ? Number(value) : value;
    }
    const collectable = collect2 && collectSet.has(key);
    setNested(argv, key.split("."), value, collectable);
    aliasMap.get(key)?.forEach((key2) => {
      setNested(argv, key2.split("."), value, collectable);
    });
  }
  let notFlags = [];
  const index = args.indexOf("--");
  if (index !== -1) {
    notFlags = args.slice(index + 1);
    args = args.slice(0, index);
  }
  argsLoop:
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const groups = arg.match(FLAG_REGEXP)?.groups;
      if (groups) {
        const { doubleDash: doubleDash2, negated } = groups;
        let key = groups.key;
        let value = groups.value;
        if (doubleDash2) {
          if (value) {
            if (booleanSet.has(key)) value = parseBooleanString(value);
            setArgument(key, value, arg, true);
            continue;
          }
          if (negated) {
            if (negatableSet.has(key)) {
              setArgument(key, false, arg, false);
              continue;
            }
            key = `no-${key}`;
          }
          const next = args[i + 1];
          if (next) {
            if (!booleanSet.has(key) && !allBools && !next.startsWith("-") && (!aliasMap.has(key) || !aliasIsBoolean(aliasMap, booleanSet, key))) {
              value = next;
              i++;
              setArgument(key, value, arg, true);
              continue;
            }
            if (isBooleanString(next)) {
              value = parseBooleanString(next);
              i++;
              setArgument(key, value, arg, true);
              continue;
            }
          }
          value = stringSet.has(key) ? "" : true;
          setArgument(key, value, arg, true);
          continue;
        }
        const letters = arg.slice(1, -1).split("");
        for (const [j, letter] of letters.entries()) {
          const next = arg.slice(j + 2);
          if (next === "-") {
            setArgument(letter, next, arg, true);
            continue;
          }
          if (LETTER_REGEXP.test(letter)) {
            const groups2 = VALUE_REGEXP.exec(next)?.groups;
            if (groups2) {
              setArgument(letter, groups2.value, arg, true);
              continue argsLoop;
            }
            if (NUMBER_REGEXP.test(next)) {
              setArgument(letter, next, arg, true);
              continue argsLoop;
            }
          }
          if (letters[j + 1]?.match(SPECIAL_CHAR_REGEXP)) {
            setArgument(letter, arg.slice(j + 2), arg, true);
            continue argsLoop;
          }
          setArgument(letter, stringSet.has(letter) ? "" : true, arg, true);
        }
        key = arg.slice(-1);
        if (key === "-") continue;
        const nextArg = args[i + 1];
        if (nextArg) {
          if (!HYPHEN_REGEXP.test(nextArg) && !booleanSet.has(key) && (!aliasMap.has(key) || !aliasIsBoolean(aliasMap, booleanSet, key))) {
            setArgument(key, nextArg, arg, true);
            i++;
            continue;
          }
          if (isBooleanString(nextArg)) {
            const value2 = parseBooleanString(nextArg);
            setArgument(key, value2, arg, true);
            i++;
            continue;
          }
        }
        setArgument(key, stringSet.has(key) ? "" : true, arg, true);
        continue;
      }
      if (unknownFn?.(arg) !== false) {
        argv._.push(
          stringSet.has("_") || !isNumber(arg) ? arg : Number(arg)
        );
      }
      if (stopEarly) {
        argv._.push(...args.slice(i + 1));
        break;
      }
    }
  for (const [key, value] of Object.entries(defaults)) {
    const keys = key.split(".");
    if (!hasNested(argv, keys)) {
      setNested(argv, keys, value);
      aliasMap.get(key)?.forEach(
        (key2) => setNested(argv, key2.split("."), value)
      );
    }
  }
  for (const key of booleanSet.keys()) {
    const keys = key.split(".");
    if (!hasNested(argv, keys)) {
      const value = collectSet.has(key) ? [] : false;
      setNested(argv, keys, value);
    }
  }
  for (const key of stringSet.keys()) {
    const keys = key.split(".");
    if (!hasNested(argv, keys) && collectSet.has(key)) {
      setNested(argv, keys, []);
    }
  }
  if (doubleDash) {
    argv["--"] = notFlags;
  } else {
    argv._.push(...notFlags);
  }
  return argv;
}
function parseArgs2(obj, metadata, config) {
  const argsResult = {
    options: {},
    commandArgs: []
  };
  const args = getArgs(config);
  const stringProp = [];
  const arrayProp = [];
  const booleanProp = [];
  const defaultValues = {};
  const alias = { help: ["h"] };
  const negatable = Object.entries(metadata.fields).filter(([, v]) => v?.negatable).map(([k]) => k);
  for (const name of Object.keys(metadata.fields)) {
    alias[name] = metadata.fields[name]?.alias ?? [];
    const kebabCase = toKebabCase(name);
    if (name !== kebabCase) {
      alias[name].push(kebabCase);
    }
    switch (typeof obj[name]) {
      case "boolean":
        booleanProp.push(name);
        defaultValues[name] = obj[name];
        break;
      case "string":
        stringProp.push(name);
        break;
      case "object":
        if (Array.isArray(obj[name])) {
          arrayProp.push(name);
        }
    }
  }
  const stdRes = parseArgs(args, {
    negatable: negatable.map(toKebabCase),
    string: stringProp.map(toKebabCase),
    boolean: booleanProp.map(toKebabCase),
    collect: arrayProp.map(toKebabCase),
    default: defaultValues,
    alias,
    stopEarly: true
  });
  for (const key of Object.keys(stdRes)) {
    if (defaultValues[key] === stdRes[key]) {
      delete stdRes[key];
    }
    const keyCamel = toCamelCase(key);
    if (keyCamel !== key && defaultValues[keyCamel] === stdRes[key]) {
      delete stdRes[key];
    }
  }
  const fields = Object.keys(metadata.fields);
  const fieldsKebabCase = fields.map(toKebabCase);
  const aliasKey = Object.values(alias).flat();
  for (const [key, value] of Object.entries(stdRes)) {
    if (key === "_") {
      if (config?.noCommand || !!metadata.noCommand) {
        argsResult.command = metadata.defaultCommand ?? "main";
        argsResult.commandArgs = stdRes._;
      } else if (stdRes._.length > 0) {
        argsResult.command = stdRes._[0].toString();
        argsResult.commandArgs = stdRes._.slice(1);
      }
    } else {
      if (key !== "help" && !fieldsKebabCase.includes(key) && !fields.includes(key) && !aliasKey.includes(key) && !((config?.configCli || metadata.jsonConfig) && key === "config")) {
        throw new Error(`The option "${key}" doesn't exist`, {
          cause: { clite: true }
        });
      }
      argsResult.options[toCamelCase(key)] = value;
    }
  }
  return argsResult;
}
function fillFields(parseResult, obj, metadata, config) {
  const aliasNames = Object.entries(metadata.fields).flatMap(([, v]) => v?.alias);
  const fields = Object.keys(metadata.fields);
  for (const option of getFieldNames(parseResult.options)) {
    if (fields.includes(option)) {
      obj[option] = parseResult.options[option];
    } else if (fields.includes(toSnakeCase(option))) {
      obj[toSnakeCase(option)] = parseResult.options[option];
    } else if (!aliasNames.includes(option) && (option !== "config" || !(config?.configCli || metadata.jsonConfig))) {
      throw new Error(`The option "${option}" doesn't exist`, {
        cause: { clite: true }
      });
    }
  }
}
function getArgs(config) {
  const gt = globalThis;
  return config?.args || gt["Deno"]?.args || gt["process"]?.argv.slice(2) || [];
}
function convertCommandArg(v) {
  switch (true) {
    case v === "true":
      return true;
    case v === "false":
      return false;
    case (typeof v === "string" && !isNaN(v) && !isNaN(parseFloat(v))):
      return parseFloat(v);
    default:
      return v;
  }
}
function processCommandResult(result, config) {
  if (result != void 0 && !config?.dontPrintResult) {
    Promise.resolve(result).then((res) => res != void 0 && console.log(res));
  }
}
function runCommand(res) {
  if (res.command === "--help") {
    console.error(res.help);
    return res.help;
  } else if (res.subcommand) {
    return runCommand(res.subcommand);
  } else {
    const result = res.obj[res.command](...res.commandArgs);
    processCommandResult(result, res.config);
    return result;
  }
}
function getCliteMetadata(obj) {
  const symb = getCliteSymbolMetadata(obj);
  const subcommands = [
    ...Object.keys(symb.subcommand ?? {}),
    ...Object.getOwnPropertyNames(obj).filter(
      (prop) => obj[`_${prop}_subcommand`] === true
    )
  ];
  const methods = getMethodNames(obj).filter((method) => !method.startsWith("_") && !method.startsWith("#"));
  const constructorName = Object.getPrototypeOf(obj).constructor.name;
  const metadata = {
    fields: {},
    methods: {},
    defaultCommand: getDefaultCommand(methods),
    subcommands,
    help: symb.help?.[constructorName] ?? obj._help,
    usage: symb.usage?.[constructorName] ?? obj._usage,
    noCommand: symb.noCommand?.[constructorName] || obj._no_command,
    jsonConfig: symb.jsonConfig?.[constructorName] || obj._json_config
  };
  getFieldNames(obj).filter((f) => !f.startsWith("_") && !f.startsWith("#")).forEach((f) => metadata.fields[f] = {
    alias: [...symb.alias?.[f] || [], ...obj[`_${f}_alias`] ?? []],
    help: symb.help?.[f] || obj[`_${f}_help`],
    type: symb.types?.[f] ?? obj[`_${f}_type`],
    defaultHelp: symb.defaults?.[f] ?? obj[`_${f}_default`],
    negatable: symb.negatables?.[f] ?? obj[`_${f}_negatable`],
    hidden: symb.hidden?.[f] ?? obj[`_${f}_hidden`]
  });
  methods.forEach(
    (method) => metadata.methods[method] = {
      help: symb.help?.[method] || obj[`_${method}_help`],
      hidden: symb.hidden?.[method] ?? obj[`_${method}_hidden`]
    }
  );
  return metadata;
}
function getDefaultCommand(methods) {
  return methods.length == 1 ? methods[0] : methods.includes("main") ? "main" : void 0;
}
var fs = void 0;
function loadConfig(parseResult, obj) {
  const pathOrJson = parseResult.options.config;
  try {
    if (pathOrJson.match(/^\s*{/)) {
      Object.assign(obj, JSON.parse(pathOrJson));
    } else {
      if (globalThis["Deno"]?.args) {
        Object.assign(obj, JSON.parse(Deno.readTextFileSync(pathOrJson)));
      } else if (fs) {
        Object.assign(obj, JSON.parse(fs.readFileSync(pathOrJson, "utf8")));
      } else {
        throw new Error("Load config is not implemented in this runtime");
      }
    }
    obj.config = pathOrJson;
  } catch (error) {
    throw new Error(
      `Error while loading the config "${pathOrJson}"`,
      { cause: { clite: true, error } }
    );
  }
}
function cliteRun(objOrClass, config) {
  const res = cliteParse(objOrClass, config);
  if (!config?.meta || config?.meta.main) {
    try {
      return runCommand(res);
    } catch (e) {
      if (e.cause?.clite || config?.printHelpOnError) {
        console.error(bgRed(bold("An error occurred ! The help :")));
        console.error(res.help);
        console.error();
        console.error(bgRed(bold("The error :")));
      }
      throw e;
    }
  }
}
function cliteParse(objOrClass, config) {
  const obj = typeof objOrClass === "function" ? new objOrClass() : objOrClass;
  const metadata = getCliteMetadata(obj);
  const help2 = genHelp(obj, metadata, config);
  try {
    const parseResult = parseArgs2(obj, metadata, config);
    if (Object.keys(parseResult.options).includes("help")) {
      return { obj, command: "--help", commandArgs: [], config, help: help2 };
    } else {
      if (config?.configCli || metadata.jsonConfig) {
        if (Object.keys(parseResult.options).includes("config")) {
          loadConfig(parseResult, obj);
        } else {
          obj.config = void 0;
        }
      }
      const command = parseResult.command ?? metadata.defaultCommand;
      if (!command) {
        throw new Error(`no method defined or no "main" method`, {
          cause: { clite: true }
        });
      }
      fillFields(parseResult, obj, metadata, config);
      if (metadata.subcommands.includes(command)) {
        const subcommandObj = typeof obj[command] === "function" ? new obj[command]() : obj[command];
        subcommandObj._clite_parent = obj;
        const args = parseResult.commandArgs.map((e) => e.toString());
        const subcommand = cliteParse(subcommandObj, { ...config, args });
        return { obj, command, commandArgs: [], config, help: help2, subcommand };
      } else if (!Object.hasOwn(metadata.methods, command) && !getMethodNames(obj).includes(command)) {
        throw new Error(`The command "${command}" doesn't exist`, {
          cause: { clite: true }
        });
      }
      const commandArgs = config?.dontConvertCmdArgs ? parseResult.commandArgs : parseResult.commandArgs.map(convertCommandArg);
      return { obj, command, commandArgs, config, help: help2 };
    }
  } catch (e) {
    if (e.cause?.clite || config?.printHelpOnError) {
      console.error(bgRed(bold("An error occurred ! The help :")));
      console.error(`${help2}
${bgRed(bold("The error :"))}`);
    }
    throw e;
  }
}
var AssertionError = class extends Error {
  /** Constructs a new instance.
   *
   * @param message The error message.
   * @param options Additional options. This argument is still unstable. It may change in the future release.
   */
  constructor(message, options) {
    super(message, options);
    this.name = "AssertionError";
  }
};
var { Deno: Deno3 } = globalThis;
var noColor2 = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : false;
var ANSI_PATTERN2 = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}
var encoder = new TextEncoder();
function getTypeName(value) {
  const type2 = typeof value;
  if (type2 !== "object") {
    return type2;
  } else if (value === null) {
    return "null";
  } else {
    return value?.constructor?.name ?? "object";
  }
}
function validateBinaryLike(source) {
  if (typeof source === "string") {
    return encoder.encode(source);
  } else if (source instanceof Uint8Array) {
    return source;
  } else if (source instanceof ArrayBuffer) {
    return new Uint8Array(source);
  }
  throw new TypeError(
    `Cannot validate the input as it must be a Uint8Array, a string, or an ArrayBuffer: received a value of the type ${getTypeName(source)}`
  );
}
var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
var revLookup = [];
lookup.forEach((c, i) => revLookup[c.charCodeAt(0)] = i);
var base58alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encodeBase64(data) {
  const uint8 = validateBinaryLike(data);
  let result = "";
  let i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decodeBase64(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
var hexTable = new TextEncoder().encode("0123456789abcdef");
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var AB = new ArrayBuffer(8);
var U32_VIEW = new Uint32Array(AB);
var U64_VIEW = new BigUint64Array(AB);
var isWindows = globalThis.Deno?.build.os === "windows" || globalThis.navigator?.platform?.startsWith("Win") || globalThis.process?.platform?.startsWith("win") || false;
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError(
      `Path must be a string, received "${JSON.stringify(path)}"`
    );
  }
}
function assertArg(path) {
  assertPath(path);
  if (path.length === 0) return ".";
}
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code4;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) code4 = path.charCodeAt(i);
    else if (isPathSeparator3(code4)) break;
    else code4 = CHAR_FORWARD_SLASH;
    if (isPathSeparator3(code4)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += `${separator}..`;
          else res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
        else res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code4 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function isPosixPathSeparator(code4) {
  return code4 === CHAR_FORWARD_SLASH;
}
function normalize(path) {
  assertArg(path);
  const isAbsolute7 = isPosixPathSeparator(path.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator(
    path.charCodeAt(path.length - 1)
  );
  path = normalizeString(path, !isAbsolute7, "/", isPosixPathSeparator);
  if (path.length === 0 && !isAbsolute7) path = ".";
  if (path.length > 0 && trailingSeparator) path += "/";
  if (isAbsolute7) return `/${path}`;
  return path;
}
function join(...paths) {
  if (paths.length === 0) return ".";
  paths.forEach((path) => assertPath(path));
  const joined = paths.filter((path) => path.length > 0).join("/");
  return joined === "" ? "." : normalize(joined);
}
function isPosixPathSeparator2(code4) {
  return code4 === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code4) {
  return code4 === CHAR_FORWARD_SLASH || code4 === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code4) {
  return code4 >= CHAR_LOWERCASE_A && code4 <= CHAR_LOWERCASE_Z || code4 >= CHAR_UPPERCASE_A && code4 <= CHAR_UPPERCASE_Z;
}
function normalize2(path) {
  assertArg(path);
  const len = path.length;
  let rootEnd = 0;
  let device;
  let isAbsolute7 = false;
  const code4 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code4)) {
      isAbsolute7 = true;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code4)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) {
            isAbsolute7 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code4)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(
      path.slice(rootEnd),
      !isAbsolute7,
      "\\",
      isPathSeparator
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute7) tail = ".";
  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute7) {
      if (tail.length > 0) return `\\${tail}`;
      else return "\\";
    }
    return tail;
  } else if (isAbsolute7) {
    if (tail.length > 0) return `${device}\\${tail}`;
    else return `${device}\\`;
  }
  return device + tail;
}
function join2(...paths) {
  paths.forEach((path) => assertPath(path));
  paths = paths.filter((path) => path.length > 0);
  if (paths.length === 0) return ".";
  let needsReplace = true;
  let slashCount = 0;
  const firstPart = paths[0];
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  let joined = paths.join("\\");
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
    }
    if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize2(joined);
}
function join3(...paths) {
  return isWindows ? join2(...paths) : join(...paths);
}
function assertArg2(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError(
      `URL must be a file URL: received "${url.protocol}"`
    );
  }
  return url;
}
function fromFileUrl(url) {
  url = assertArg2(url);
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function fromFileUrl2(url) {
  url = assertArg2(url);
  let path = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path = `\\\\${url.hostname}${path}`;
  }
  return path;
}
function fromFileUrl3(url) {
  return isWindows ? fromFileUrl2(url) : fromFileUrl(url);
}
function toPathString(pathUrl) {
  return pathUrl instanceof URL ? fromFileUrl3(pathUrl) : pathUrl;
}
async function emptyDir(dir) {
  try {
    const items = await Array.fromAsync(Deno.readDir(dir));
    await Promise.all(items.map((item) => {
      if (item && item.name) {
        const filepath = join3(toPathString(dir), item.name);
        return Deno.remove(filepath, { recursive: true });
      }
    }));
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    await Deno.mkdir(dir, { recursive: true });
  }
}
function emptyDirSync(dir) {
  try {
    const items = [...Deno.readDirSync(dir)];
    while (items.length) {
      const item = items.shift();
      if (item && item.name) {
        const filepath = join3(toPathString(dir), item.name);
        Deno.removeSync(filepath, { recursive: true });
      }
    }
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    Deno.mkdirSync(dir, { recursive: true });
  }
}
function getFileInfoType(fileInfo) {
  return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : void 0;
}
async function ensureDir(dir) {
  try {
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    await Deno.mkdir(dir, { recursive: true });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = await Deno.stat(dir);
    throwIfNotDirectory(fileInfo);
  }
}
function ensureDirSync(dir) {
  try {
    const fileInfo = Deno.statSync(dir);
    throwIfNotDirectory(fileInfo);
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    Deno.mkdirSync(dir, { recursive: true });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = Deno.statSync(dir);
    throwIfNotDirectory(fileInfo);
  }
}
function throwIfNotDirectory(fileInfo) {
  if (!fileInfo.isDirectory) {
    throw new Error(
      `Failed to ensure directory exists: expected 'dir', got '${getFileInfoType(fileInfo)}'`
    );
  }
}
function assertArg3(path) {
  assertPath(path);
  if (path.length === 0) return ".";
}
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i = segment.length - 1; i > 0; i--) {
    if (isSep(segment.charCodeAt(i))) {
      end = i;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}
function dirname(path) {
  assertArg3(path);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i = path.length - 1; i >= 1; --i) {
    if (isPosixPathSeparator(path.charCodeAt(i))) {
      if (matchedNonSeparator) {
        end = i;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators(
    path.slice(0, end),
    isPosixPathSeparator
  );
}
function dirname2(path) {
  assertArg3(path);
  const len = path.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code4 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code4)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code4)) {
      if (path.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code4)) {
    return path;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator(path.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1) return ".";
    else end = rootEnd;
  }
  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator2);
}
function dirname3(path) {
  return isWindows ? dirname2(path) : dirname(path);
}
async function ensureFile(filePath) {
  try {
    const stat = await Deno.lstat(filePath);
    if (!stat.isFile) {
      throw new Error(
        `Failed to ensure file exists: expected 'file', got '${getFileInfoType(stat)}'`
      );
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      await ensureDir(dirname3(toPathString(filePath)));
      await Deno.writeFile(filePath, new Uint8Array());
      return;
    }
    throw err;
  }
}
function ensureFileSync(filePath) {
  try {
    const stat = Deno.lstatSync(filePath);
    if (!stat.isFile) {
      throw new Error(
        `Failed to ensure file exists: expected 'file', got '${getFileInfoType(stat)}'`
      );
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      ensureDirSync(dirname3(toPathString(filePath)));
      Deno.writeFileSync(filePath, new Uint8Array());
      return;
    }
    throw err;
  }
}
function resolve(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) path = pathSegments[i];
    else {
      const { Deno: Deno6 } = globalThis;
      if (typeof Deno6?.cwd !== "function") {
        throw new TypeError(
          "Resolved a relative path without a current working directory (CWD)"
        );
      }
      path = Deno6.cwd();
    }
    assertPath(path);
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
  }
  resolvedPath = normalizeString(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) return `/${resolvedPath}`;
    else return "/";
  } else if (resolvedPath.length > 0) return resolvedPath;
  else return ".";
}
function resolve2(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path;
    const { Deno: Deno6 } = globalThis;
    if (i >= 0) {
      path = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno6?.cwd !== "function") {
        throw new TypeError(
          "Resolved a drive-letter-less path without a current working directory (CWD)"
        );
      }
      path = Deno6.cwd();
    } else {
      if (typeof Deno6?.env?.get !== "function" || typeof Deno6?.cwd !== "function") {
        throw new TypeError(
          "Resolved a relative path without a current working directory (CWD)"
        );
      }
      path = Deno6.cwd();
      if (path === void 0 || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path = `${resolvedDevice}\\`;
      }
    }
    assertPath(path);
    const len = path.length;
    if (len === 0) continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute7 = false;
    const code4 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code4)) {
        isAbsolute7 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code4)) {
        if (path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path.charCodeAt(2))) {
              isAbsolute7 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code4)) {
      rootEnd = 1;
      isAbsolute7 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute7;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0) break;
  }
  resolvedTail = normalizeString(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function resolve3(...pathSegments) {
  return isWindows ? resolve2(...pathSegments) : resolve(...pathSegments);
}
var isWindows2 = Deno.build.os === "windows";
async function exists(path, options) {
  try {
    const stat = await Deno.stat(path);
    if (options && (options.isReadable || options.isDirectory || options.isFile)) {
      if (options.isDirectory && options.isFile) {
        throw new TypeError(
          "ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together"
        );
      }
      if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
        return false;
      }
      if (options.isReadable) {
        return fileIsReadable(stat);
      }
    }
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error instanceof Deno.errors.PermissionDenied) {
      if ((await Deno.permissions.query({ name: "read", path })).state === "granted") {
        return !options?.isReadable;
      }
    }
    throw error;
  }
}
function existsSync(path, options) {
  try {
    const stat = Deno.statSync(path);
    if (options && (options.isReadable || options.isDirectory || options.isFile)) {
      if (options.isDirectory && options.isFile) {
        throw new TypeError(
          "ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together"
        );
      }
      if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
        return false;
      }
      if (options.isReadable) {
        return fileIsReadable(stat);
      }
    }
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error instanceof Deno.errors.PermissionDenied) {
      if (Deno.permissions.querySync({ name: "read", path }).state === "granted") {
        return !options?.isReadable;
      }
    }
    throw error;
  }
}
function fileIsReadable(stat) {
  if (stat.mode === null) {
    return true;
  } else if (Deno.uid() === stat.uid) {
    return (stat.mode & 256) === 256;
  } else if (Deno.gid() === stat.gid) {
    return (stat.mode & 32) === 32;
  }
  return (stat.mode & 4) === 4;
}
function isAbsolute(path) {
  assertPath(path);
  return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
}
function isAbsolute2(path) {
  assertPath(path);
  const len = path.length;
  if (len === 0) return false;
  const code4 = path.charCodeAt(0);
  if (isPathSeparator(code4)) {
    return true;
  } else if (isWindowsDeviceRoot(code4)) {
    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path.charCodeAt(2))) return true;
    }
  }
  return false;
}
function isAbsolute3(path) {
  return isWindows ? isAbsolute2(path) : isAbsolute(path);
}
var SEPARATOR3 = isWindows ? "\\" : "/";
function stripSuffix(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i = suffix.length - 1; i >= 0; --i) {
    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}
function lastPathSegment(path, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path.length;
  for (let i = path.length - 1; i >= start; --i) {
    if (isSep(path.charCodeAt(i))) {
      if (matchedNonSeparator) {
        start = i + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i + 1;
    }
  }
  return path.slice(start, end);
}
function assertArgs(path, suffix) {
  assertPath(path);
  if (path.length === 0) return path;
  if (typeof suffix !== "string") {
    throw new TypeError(
      `Suffix must be a string, received "${JSON.stringify(suffix)}"`
    );
  }
}
function basename(path, suffix = "") {
  assertArgs(path, suffix);
  const lastSegment = lastPathSegment(path, isPosixPathSeparator);
  const strippedSegment = stripTrailingSeparators(
    lastSegment,
    isPosixPathSeparator
  );
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function basename2(path, suffix = "") {
  assertArgs(path, suffix);
  let start = 0;
  if (path.length >= 2) {
    const drive = path.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path.charCodeAt(1) === CHAR_COLON) start = 2;
    }
  }
  const lastSegment = lastPathSegment(path, isPathSeparator, start);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function basename3(path, suffix = "") {
  return isWindows ? basename2(path, suffix) : basename(path, suffix);
}
function normalize3(path) {
  return isWindows ? normalize2(path) : normalize(path);
}
async function createWalkEntry(path) {
  path = toPathString(path);
  path = normalize3(path);
  const name = basename3(path);
  const info = await Deno.stat(path);
  return {
    path,
    name,
    isFile: info.isFile,
    isDirectory: info.isDirectory,
    isSymlink: info.isSymlink
  };
}
function include(path, exts, match, skip) {
  if (exts && !exts.some((ext) => path.endsWith(ext))) {
    return false;
  }
  if (match && !match.some((pattern) => !!path.match(pattern))) {
    return false;
  }
  if (skip && skip.some((pattern) => !!path.match(pattern))) {
    return false;
  }
  return true;
}
async function* walk(root, options) {
  let {
    maxDepth = Infinity,
    includeFiles = true,
    includeDirs = true,
    includeSymlinks = true,
    followSymlinks = false,
    canonicalize = true,
    exts = void 0,
    match = void 0,
    skip = void 0
  } = options ?? {};
  if (maxDepth < 0) {
    return;
  }
  root = toPathString(root);
  if (exts) {
    exts = exts.map((ext) => ext.startsWith(".") ? ext : `.${ext}`);
  }
  if (includeDirs && include(root, exts, match, skip)) {
    yield await createWalkEntry(root);
  }
  if (maxDepth < 1 || !include(root, void 0, void 0, skip)) {
    return;
  }
  for await (const entry of Deno.readDir(root)) {
    let path = join3(root, entry.name);
    let { isSymlink, isDirectory: isDirectory3 } = entry;
    if (isSymlink) {
      if (!followSymlinks) {
        if (includeSymlinks && include(path, exts, match, skip)) {
          yield { path, ...entry };
        }
        continue;
      }
      const realPath = await Deno.realPath(path);
      if (canonicalize) {
        path = realPath;
      }
      ({ isSymlink, isDirectory: isDirectory3 } = await Deno.lstat(realPath));
    }
    if (isSymlink || isDirectory3) {
      const opts = {
        maxDepth: maxDepth - 1,
        includeFiles,
        includeDirs,
        includeSymlinks,
        followSymlinks
      };
      if (exts !== void 0) {
        opts.exts = exts;
      }
      if (match !== void 0) {
        opts.match = match;
      }
      if (skip !== void 0) {
        opts.skip = skip;
      }
      yield* walk(path, opts);
    } else if (includeFiles && include(path, exts, match, skip)) {
      yield { path, ...entry };
    }
  }
}
var isWindows3 = Deno.build.os === "windows";
function isSubdir(src, dest, sep = SEPARATOR3) {
  src = toPathString(src);
  dest = toPathString(dest);
  if (resolve3(src) === resolve3(dest)) {
    return false;
  }
  const srcArray = src.split(sep);
  const destArray = dest.split(sep);
  return srcArray.every((current, i) => destArray[i] === current);
}
var EXISTS_ERROR = new Deno.errors.AlreadyExists("dest already exists.");
var isWindows4 = Deno.build.os === "windows";
function assertIsDate(date, name) {
  if (date === null) {
    throw new Error(`${name} is unavailable`);
  }
}
async function ensureValidCopy(src, dest, options) {
  let destStat;
  try {
    destStat = await Deno.lstat(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options.isFolder && !destStat.isDirectory) {
    throw new Error(
      `Cannot overwrite non-directory '${dest}' with directory '${src}'`
    );
  }
  if (!options.overwrite) {
    throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
  }
  return destStat;
}
function ensureValidCopySync(src, dest, options) {
  let destStat;
  try {
    destStat = Deno.lstatSync(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options.isFolder && !destStat.isDirectory) {
    throw new Error(
      `Cannot overwrite non-directory '${dest}' with directory '${src}'`
    );
  }
  if (!options.overwrite) {
    throw new Deno.errors.AlreadyExists(`'${dest}' already exists`);
  }
  return destStat;
}
async function copyFile(src, dest, options) {
  await ensureValidCopy(src, dest, options);
  await Deno.copyFile(src, dest);
  if (options.preserveTimestamps) {
    const statInfo = await Deno.stat(src);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
  }
}
function copyFileSync(src, dest, options) {
  ensureValidCopySync(src, dest, options);
  Deno.copyFileSync(src, dest);
  if (options.preserveTimestamps) {
    const statInfo = Deno.statSync(src);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copySymLink(src, dest, options) {
  await ensureValidCopy(src, dest, options);
  const originSrcFilePath = await Deno.readLink(src);
  const type2 = getFileInfoType(await Deno.lstat(src));
  if (isWindows4) {
    await Deno.symlink(originSrcFilePath, dest, {
      type: type2 === "dir" ? "dir" : "file"
    });
  } else {
    await Deno.symlink(originSrcFilePath, dest);
  }
  if (options.preserveTimestamps) {
    const statInfo = await Deno.lstat(src);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
  }
}
function copySymlinkSync(src, dest, options) {
  ensureValidCopySync(src, dest, options);
  const originSrcFilePath = Deno.readLinkSync(src);
  const type2 = getFileInfoType(Deno.lstatSync(src));
  if (isWindows4) {
    Deno.symlinkSync(originSrcFilePath, dest, {
      type: type2 === "dir" ? "dir" : "file"
    });
  } else {
    Deno.symlinkSync(originSrcFilePath, dest);
  }
  if (options.preserveTimestamps) {
    const statInfo = Deno.lstatSync(src);
    assertIsDate(statInfo.atime, "statInfo.atime");
    assertIsDate(statInfo.mtime, "statInfo.mtime");
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copyDir(src, dest, options) {
  const destStat = await ensureValidCopy(src, dest, {
    ...options,
    isFolder: true
  });
  if (!destStat) {
    await ensureDir(dest);
  }
  if (options.preserveTimestamps) {
    const srcStatInfo = await Deno.stat(src);
    assertIsDate(srcStatInfo.atime, "statInfo.atime");
    assertIsDate(srcStatInfo.mtime, "statInfo.mtime");
    await Deno.utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  src = toPathString(src);
  dest = toPathString(dest);
  const promises = [];
  for await (const entry of Deno.readDir(src)) {
    const srcPath = join3(src, entry.name);
    const destPath = join3(dest, basename3(srcPath));
    if (entry.isSymlink) {
      promises.push(copySymLink(srcPath, destPath, options));
    } else if (entry.isDirectory) {
      promises.push(copyDir(srcPath, destPath, options));
    } else if (entry.isFile) {
      promises.push(copyFile(srcPath, destPath, options));
    }
  }
  await Promise.all(promises);
}
function copyDirSync(src, dest, options) {
  const destStat = ensureValidCopySync(src, dest, {
    ...options,
    isFolder: true
  });
  if (!destStat) {
    ensureDirSync(dest);
  }
  if (options.preserveTimestamps) {
    const srcStatInfo = Deno.statSync(src);
    assertIsDate(srcStatInfo.atime, "statInfo.atime");
    assertIsDate(srcStatInfo.mtime, "statInfo.mtime");
    Deno.utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  src = toPathString(src);
  dest = toPathString(dest);
  for (const entry of Deno.readDirSync(src)) {
    const srcPath = join3(src, entry.name);
    const destPath = join3(dest, basename3(srcPath));
    if (entry.isSymlink) {
      copySymlinkSync(srcPath, destPath, options);
    } else if (entry.isDirectory) {
      copyDirSync(srcPath, destPath, options);
    } else if (entry.isFile) {
      copyFileSync(srcPath, destPath, options);
    }
  }
}
async function copy(src, dest, options = {}) {
  src = resolve3(toPathString(src));
  dest = resolve3(toPathString(dest));
  if (src === dest) {
    throw new Error("Source and destination cannot be the same");
  }
  const srcStat = await Deno.lstat(src);
  if (srcStat.isDirectory && isSubdir(src, dest)) {
    throw new Error(
      `Cannot copy '${src}' to a subdirectory of itself: '${dest}'`
    );
  }
  if (srcStat.isSymlink) {
    await copySymLink(src, dest, options);
  } else if (srcStat.isDirectory) {
    await copyDir(src, dest, options);
  } else if (srcStat.isFile) {
    await copyFile(src, dest, options);
  }
}
function copySync(src, dest, options = {}) {
  src = resolve3(toPathString(src));
  dest = resolve3(toPathString(dest));
  if (src === dest) {
    throw new Error("Source and destination cannot be the same");
  }
  const srcStat = Deno.lstatSync(src);
  if (srcStat.isDirectory && isSubdir(src, dest)) {
    throw new Error(
      `Cannot copy '${src}' to a subdirectory of itself: '${dest}'`
    );
  }
  if (srcStat.isSymlink) {
    copySymlinkSync(src, dest, options);
  } else if (srcStat.isDirectory) {
    copyDirSync(src, dest, options);
  } else if (srcStat.isFile) {
    copyFileSync(src, dest, options);
  }
}
var LF = "\n";
var CRLF = "\r\n";
var EOL = Deno?.build.os === "windows" ? CRLF : LF;
function consumeToken(v) {
  const notPos = indexOf(v, isNotTokenChar);
  if (notPos === -1) {
    return [v, ""];
  }
  if (notPos === 0) {
    return ["", v];
  }
  return [v.slice(0, notPos), v.slice(notPos)];
}
function consumeValue(v) {
  if (!v) {
    return ["", v];
  }
  if (v[0] !== `"`) {
    return consumeToken(v);
  }
  let value = "";
  for (let i = 1; i < v.length; i++) {
    const r = v[i];
    if (r === `"`) {
      return [value, v.slice(i + 1)];
    }
    const next = v[i + 1];
    if (r === "\\" && typeof next === "string" && isTSpecial(next)) {
      value += next;
      i++;
      continue;
    }
    if (r === "\r" || r === "\n") {
      return ["", v];
    }
    value += v[i];
  }
  return ["", v];
}
function consumeMediaParam(v) {
  let rest = v.trimStart();
  if (!rest.startsWith(";")) {
    return ["", "", v];
  }
  rest = rest.slice(1);
  rest = rest.trimStart();
  let param;
  [param, rest] = consumeToken(rest);
  param = param.toLowerCase();
  if (!param) {
    return ["", "", v];
  }
  rest = rest.slice(1);
  rest = rest.trimStart();
  const [value, rest2] = consumeValue(rest);
  if (value === "" && rest2 === rest) {
    return ["", "", v];
  }
  rest = rest2;
  return [param, value, rest];
}
function decode2331Encoding(v) {
  const sv = v.split(`'`, 3);
  if (sv.length !== 3) {
    return void 0;
  }
  const [sv0, , sv2] = sv;
  const charset = sv0.toLowerCase();
  if (!charset) {
    return void 0;
  }
  if (charset !== "us-ascii" && charset !== "utf-8") {
    return void 0;
  }
  const encv = decodeURI(sv2);
  if (!encv) {
    return void 0;
  }
  return encv;
}
function indexOf(s, fn) {
  let i = -1;
  for (const v of s) {
    i++;
    if (fn(v)) {
      return i;
    }
  }
  return -1;
}
function isIterator(obj) {
  if (obj === null || obj === void 0) {
    return false;
  }
  return typeof obj[Symbol.iterator] === "function";
}
function isToken(s) {
  if (!s) {
    return false;
  }
  return indexOf(s, isNotTokenChar) < 0;
}
function isNotTokenChar(r) {
  return !isTokenChar(r);
}
function isTokenChar(r) {
  const code4 = r.charCodeAt(0);
  return code4 > 32 && code4 < 127 && !isTSpecial(r);
}
function isTSpecial(r) {
  return r[0] ? `()<>@,;:\\"/[]?=`.includes(r[0]) : false;
}
var CHAR_CODE_SPACE = " ".charCodeAt(0);
var CHAR_CODE_TILDE = "~".charCodeAt(0);
function needsEncoding(s) {
  for (const b of s) {
    const charCode = b.charCodeAt(0);
    if ((charCode < CHAR_CODE_SPACE || charCode > CHAR_CODE_TILDE) && b !== "	") {
      return true;
    }
  }
  return false;
}
var SEMICOLON_REGEXP = /^\s*;\s*$/;
function parseMediaType(type2) {
  const [base] = type2.split(";");
  const mediaType = base.toLowerCase().trim();
  const params = {};
  const continuation = /* @__PURE__ */ new Map();
  type2 = type2.slice(base.length);
  while (type2.length) {
    type2 = type2.trimStart();
    if (type2.length === 0) {
      break;
    }
    const [key, value, rest] = consumeMediaParam(type2);
    if (!key) {
      if (SEMICOLON_REGEXP.test(rest)) {
        break;
      }
      throw new TypeError(
        `Cannot parse media type: invalid parameter "${type2}"`
      );
    }
    let pmap = params;
    const [baseName, rest2] = key.split("*");
    if (baseName && rest2 !== void 0) {
      if (!continuation.has(baseName)) {
        continuation.set(baseName, {});
      }
      pmap = continuation.get(baseName);
    }
    if (key in pmap) {
      throw new TypeError("Cannot parse media type: duplicate key");
    }
    pmap[key] = value;
    type2 = rest;
  }
  let str = "";
  for (const [key, pieceMap] of continuation) {
    const singlePartKey = `${key}*`;
    const type3 = pieceMap[singlePartKey];
    if (type3) {
      const decv = decode2331Encoding(type3);
      if (decv) {
        params[key] = decv;
      }
      continue;
    }
    str = "";
    let valid = false;
    for (let n = 0; ; n++) {
      const simplePart = `${key}*${n}`;
      let type4 = pieceMap[simplePart];
      if (type4) {
        valid = true;
        str += type4;
        continue;
      }
      const encodedPart = `${simplePart}*`;
      type4 = pieceMap[encodedPart];
      if (!type4) {
        break;
      }
      valid = true;
      if (n === 0) {
        const decv = decode2331Encoding(type4);
        if (decv) {
          str += decv;
        }
      } else {
        const decv = decodeURI(type4);
        str += decv;
      }
    }
    if (valid) {
      params[key] = str;
    }
  }
  return [mediaType, Object.keys(params).length ? params : void 0];
}
var db_default = {
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/3gpp-ims+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpphal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/3gpphalforms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/ace+cbor": {
    "source": "iana"
  },
  "application/ace+json": {
    "source": "iana",
    "compressible": true
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/activity+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aif+cbor": {
    "source": "iana"
  },
  "application/aif+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-cdni+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-cdnifilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-propmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-propmapparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamcontrol+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/appinstaller": {
    "compressible": false,
    "extensions": ["appinstaller"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/appx": {
    "compressible": false,
    "extensions": ["appx"]
  },
  "application/appxbundle": {
    "compressible": false,
    "extensions": ["appxbundle"]
  },
  "application/at+jwt": {
    "source": "iana"
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomdeleted"]
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dwd"]
  },
  "application/atsc-dynamic-event-message": {
    "source": "iana"
  },
  "application/atsc-held+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["held"]
  },
  "application/atsc-rdt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-rsat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsat"]
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/automationml-aml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["aml"]
  },
  "application/automationml-amlx+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["amlx"]
  },
  "application/bacnet-xdd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xcs"]
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/captive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/cbor-seq": {
    "source": "iana"
  },
  "application/cccex": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ccxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ccxml"]
  },
  "application/cda+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/cdfx+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdfx"]
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cellml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/city+json": {
    "source": "iana",
    "compressible": true
  },
  "application/clr": {
    "source": "iana"
  },
  "application/clue+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/clue_info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-payload": {
    "source": "iana"
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/concise-problem-details+cbor": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cose": {
    "source": "iana"
  },
  "application/cose-key": {
    "source": "iana"
  },
  "application/cose-key-set": {
    "source": "iana"
  },
  "application/cose-x509": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cpl"]
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cstadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cwl": {
    "source": "iana",
    "extensions": ["cwl"]
  },
  "application/cwl+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cwt": {
    "source": "iana"
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpd"]
  },
  "application/dash-patch+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpp"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dicom+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/dns+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dns-message": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dbk"]
  },
  "application/dots+cbor": {
    "source": "iana"
  },
  "application/dskpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ecma"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/efi": {
    "source": "iana"
  },
  "application/elm+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/elm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.cap+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.ecall.msd": {
    "source": "iana"
  },
  "application/emergencycalldata.legacyesn+json": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.veds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emma+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emotionml"]
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/epub+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/expect-ct-report+json": {
    "source": "iana",
    "compressible": true
  },
  "application/express": {
    "source": "iana",
    "extensions": ["exp"]
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdf": {
    "source": "iana",
    "extensions": ["fdf"]
  },
  "application/fdt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fdt"]
  },
  "application/fhir+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fhir+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fido.trusted-apps+json": {
    "compressible": true
  },
  "application/fits": {
    "source": "iana"
  },
  "application/flexfec": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false
  },
  "application/framework-attributes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/geo+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["geojson"]
  },
  "application/geo+json-seq": {
    "source": "iana"
  },
  "application/geopackage+sqlite3": {
    "source": "iana"
  },
  "application/geoxacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/gltf-buffer": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gz"]
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/hjson": {
    "extensions": ["hjson"]
  },
  "application/hl7v2+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ink", "inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["its"]
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar", "war", "ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
  "application/javascript": {
    "source": "apache",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js"]
  },
  "application/jf2feed+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jose": {
    "source": "iana"
  },
  "application/jose+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jrd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jscalendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["json", "map"]
  },
  "application/json-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json-seq": {
    "source": "iana"
  },
  "application/json5": {
    "extensions": ["json5"]
  },
  "application/jsonml+json": {
    "source": "apache",
    "compressible": true,
    "extensions": ["jsonml"]
  },
  "application/jwk+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwk-set+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwt": {
    "source": "iana"
  },
  "application/kpml-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/kpml-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ld+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["jsonld"]
  },
  "application/lgr+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lgr"]
  },
  "application/link-format": {
    "source": "iana"
  },
  "application/linkset": {
    "source": "iana"
  },
  "application/linkset+json": {
    "source": "iana",
    "compressible": true
  },
  "application/load-control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/logout+jwt": {
    "source": "iana"
  },
  "application/lost+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lostxml"]
  },
  "application/lostsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lpf+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/lxf": {
    "source": "iana"
  },
  "application/mac-binhex40": {
    "source": "iana",
    "extensions": ["hqx"]
  },
  "application/mac-compactpro": {
    "source": "apache",
    "extensions": ["cpt"]
  },
  "application/macwriteii": {
    "source": "iana"
  },
  "application/mads+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mads"]
  },
  "application/manifest+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["webmanifest"]
  },
  "application/marc": {
    "source": "iana",
    "extensions": ["mrc"]
  },
  "application/marcxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mrcx"]
  },
  "application/mathematica": {
    "source": "iana",
    "extensions": ["ma", "nb", "mb"]
  },
  "application/mathml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mathml"]
  },
  "application/mathml-content+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mathml-presentation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-associated-procedure-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-deregister+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-envelope+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-protection-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-reception-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-schedule+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-user-service-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbox": {
    "source": "iana",
    "extensions": ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpf"]
  },
  "application/media_control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mediaservercontrol+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mscml"]
  },
  "application/merge-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/metalink+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["metalink"]
  },
  "application/metalink4+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["meta4"]
  },
  "application/mets+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mets"]
  },
  "application/mf4": {
    "source": "iana"
  },
  "application/mikey": {
    "source": "iana"
  },
  "application/mipc": {
    "source": "iana"
  },
  "application/missing-blocks+cbor-seq": {
    "source": "iana"
  },
  "application/mmt-aei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["maei"]
  },
  "application/mmt-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musd"]
  },
  "application/mods+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mods"]
  },
  "application/moss-keys": {
    "source": "iana"
  },
  "application/moss-signature": {
    "source": "iana"
  },
  "application/mosskey-data": {
    "source": "iana"
  },
  "application/mosskey-request": {
    "source": "iana"
  },
  "application/mp21": {
    "source": "iana",
    "extensions": ["m21", "mp21"]
  },
  "application/mp4": {
    "source": "iana",
    "extensions": ["mp4", "mpg4", "mp4s", "m4p"]
  },
  "application/mpeg4-generic": {
    "source": "iana"
  },
  "application/mpeg4-iod": {
    "source": "iana"
  },
  "application/mpeg4-iod-xmt": {
    "source": "iana"
  },
  "application/mrb-consumer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mrb-publish+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/msc-ivr+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msc-mixer+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msix": {
    "compressible": false,
    "extensions": ["msix"]
  },
  "application/msixbundle": {
    "compressible": false,
    "extensions": ["msixbundle"]
  },
  "application/msword": {
    "source": "iana",
    "compressible": false,
    "extensions": ["doc", "dot"]
  },
  "application/mud+json": {
    "source": "iana",
    "compressible": true
  },
  "application/multipart-core": {
    "source": "iana"
  },
  "application/mxf": {
    "source": "iana",
    "extensions": ["mxf"]
  },
  "application/n-quads": {
    "source": "iana",
    "extensions": ["nq"]
  },
  "application/n-triples": {
    "source": "iana",
    "extensions": ["nt"]
  },
  "application/nasdata": {
    "source": "iana"
  },
  "application/news-checkgroups": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-groupinfo": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-transmission": {
    "source": "iana"
  },
  "application/nlsml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/node": {
    "source": "iana",
    "extensions": ["cjs"]
  },
  "application/nss": {
    "source": "iana"
  },
  "application/oauth-authz-req+jwt": {
    "source": "iana"
  },
  "application/oblivious-dns-message": {
    "source": "iana"
  },
  "application/ocsp-request": {
    "source": "iana"
  },
  "application/ocsp-response": {
    "source": "iana"
  },
  "application/octet-stream": {
    "source": "iana",
    "compressible": false,
    "extensions": [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    "source": "iana",
    "extensions": ["oda"]
  },
  "application/odm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/odx": {
    "source": "iana"
  },
  "application/oebps-package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["opf"]
  },
  "application/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogx"]
  },
  "application/omdoc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["omdoc"]
  },
  "application/onenote": {
    "source": "apache",
    "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"]
  },
  "application/opc-nodeset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/oscore": {
    "source": "iana"
  },
  "application/oxps": {
    "source": "iana",
    "extensions": ["oxps"]
  },
  "application/p21": {
    "source": "iana"
  },
  "application/p21+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/p2p-overlay+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["relo"]
  },
  "application/parityfec": {
    "source": "iana"
  },
  "application/passport": {
    "source": "iana"
  },
  "application/patch-ops-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
  "application/pdx": {
    "source": "iana"
  },
  "application/pem-certificate-chain": {
    "source": "iana"
  },
  "application/pgp-encrypted": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pgp"]
  },
  "application/pgp-keys": {
    "source": "iana",
    "extensions": ["asc"]
  },
  "application/pgp-signature": {
    "source": "iana",
    "extensions": ["sig", "asc"]
  },
  "application/pics-rules": {
    "source": "apache",
    "extensions": ["prf"]
  },
  "application/pidf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pidf-diff+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pkcs10": {
    "source": "iana",
    "extensions": ["p10"]
  },
  "application/pkcs12": {
    "source": "iana"
  },
  "application/pkcs7-mime": {
    "source": "iana",
    "extensions": ["p7m", "p7c"]
  },
  "application/pkcs7-signature": {
    "source": "iana",
    "extensions": ["p7s"]
  },
  "application/pkcs8": {
    "source": "iana",
    "extensions": ["p8"]
  },
  "application/pkcs8-encrypted": {
    "source": "iana"
  },
  "application/pkix-attr-cert": {
    "source": "iana",
    "extensions": ["ac"]
  },
  "application/pkix-cert": {
    "source": "iana",
    "extensions": ["cer"]
  },
  "application/pkix-crl": {
    "source": "iana",
    "extensions": ["crl"]
  },
  "application/pkix-pkipath": {
    "source": "iana",
    "extensions": ["pkipath"]
  },
  "application/pkixcmp": {
    "source": "iana",
    "extensions": ["pki"]
  },
  "application/pls+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pls"]
  },
  "application/poc-settings+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/postscript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ai", "eps", "ps"]
  },
  "application/ppsp-tracker+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/provenance+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["provx"]
  },
  "application/prs.alvestrand.titrax-sheet": {
    "source": "iana"
  },
  "application/prs.cww": {
    "source": "iana",
    "extensions": ["cww"]
  },
  "application/prs.cyn": {
    "source": "iana",
    "charset": "7-BIT"
  },
  "application/prs.hpub+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/prs.nprend": {
    "source": "iana"
  },
  "application/prs.plucker": {
    "source": "iana"
  },
  "application/prs.rdf-xml-crypt": {
    "source": "iana"
  },
  "application/prs.xsf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xsf"]
  },
  "application/pskc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pskcxml"]
  },
  "application/pvd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/qsig": {
    "source": "iana"
  },
  "application/raml+yaml": {
    "compressible": true,
    "extensions": ["raml"]
  },
  "application/raptorfec": {
    "source": "iana"
  },
  "application/rdap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/rdf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rdf", "owl"]
  },
  "application/reginfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    "source": "iana",
    "extensions": ["rnc"]
  },
  "application/remote-printing": {
    "source": "apache"
  },
  "application/reputon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/resource-lists+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rl"]
  },
  "application/resource-lists-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rld"]
  },
  "application/rfc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/riscos": {
    "source": "iana"
  },
  "application/rlmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/rls-services+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rs"]
  },
  "application/route-apd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rapd"]
  },
  "application/route-s-tsid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sls"]
  },
  "application/route-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rusd"]
  },
  "application/rpki-checklist": {
    "source": "iana"
  },
  "application/rpki-ghostbusters": {
    "source": "iana",
    "extensions": ["gbr"]
  },
  "application/rpki-manifest": {
    "source": "iana",
    "extensions": ["mft"]
  },
  "application/rpki-publication": {
    "source": "iana"
  },
  "application/rpki-roa": {
    "source": "iana",
    "extensions": ["roa"]
  },
  "application/rpki-updown": {
    "source": "iana"
  },
  "application/rsd+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rsd"]
  },
  "application/rss+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rss"]
  },
  "application/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "application/rtploopback": {
    "source": "iana"
  },
  "application/rtx": {
    "source": "iana"
  },
  "application/samlassertion+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/samlmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sarif+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sarif-external-properties+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sbe": {
    "source": "iana"
  },
  "application/sbml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sbml"]
  },
  "application/scaip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/scim+json": {
    "source": "iana",
    "compressible": true
  },
  "application/scvp-cv-request": {
    "source": "iana",
    "extensions": ["scq"]
  },
  "application/scvp-cv-response": {
    "source": "iana",
    "extensions": ["scs"]
  },
  "application/scvp-vp-request": {
    "source": "iana",
    "extensions": ["spq"]
  },
  "application/scvp-vp-response": {
    "source": "iana",
    "extensions": ["spp"]
  },
  "application/sdp": {
    "source": "iana",
    "extensions": ["sdp"]
  },
  "application/secevent+jwt": {
    "source": "iana"
  },
  "application/senml+cbor": {
    "source": "iana"
  },
  "application/senml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["senmlx"]
  },
  "application/senml-etch+cbor": {
    "source": "iana"
  },
  "application/senml-etch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml-exi": {
    "source": "iana"
  },
  "application/sensml+cbor": {
    "source": "iana"
  },
  "application/sensml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sensml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sensmlx"]
  },
  "application/sensml-exi": {
    "source": "iana"
  },
  "application/sep+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sep-exi": {
    "source": "iana"
  },
  "application/session-info": {
    "source": "iana"
  },
  "application/set-payment": {
    "source": "iana"
  },
  "application/set-payment-initiation": {
    "source": "iana",
    "extensions": ["setpay"]
  },
  "application/set-registration": {
    "source": "iana"
  },
  "application/set-registration-initiation": {
    "source": "iana",
    "extensions": ["setreg"]
  },
  "application/sgml": {
    "source": "iana"
  },
  "application/sgml-open-catalog": {
    "source": "iana"
  },
  "application/shf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["shf"]
  },
  "application/sieve": {
    "source": "iana",
    "extensions": ["siv", "sieve"]
  },
  "application/simple-filter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/simple-message-summary": {
    "source": "iana"
  },
  "application/simplesymbolcontainer": {
    "source": "iana"
  },
  "application/sipc": {
    "source": "iana"
  },
  "application/slate": {
    "source": "iana"
  },
  "application/smil": {
    "source": "apache"
  },
  "application/smil+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["smi", "smil"]
  },
  "application/smpte336m": {
    "source": "iana"
  },
  "application/soap+fastinfoset": {
    "source": "iana"
  },
  "application/soap+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sparql-query": {
    "source": "iana",
    "extensions": ["rq"]
  },
  "application/sparql-results+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["srx"]
  },
  "application/spdx+json": {
    "source": "iana",
    "compressible": true
  },
  "application/spirits-event+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sql": {
    "source": "iana",
    "extensions": ["sql"]
  },
  "application/srgs": {
    "source": "iana",
    "extensions": ["gram"]
  },
  "application/srgs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["grxml"]
  },
  "application/sru+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sru"]
  },
  "application/ssdl+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ssdl"]
  },
  "application/ssml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ssml"]
  },
  "application/stix+json": {
    "source": "iana",
    "compressible": true
  },
  "application/swid+cbor": {
    "source": "iana"
  },
  "application/swid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["swidtag"]
  },
  "application/tamp-apex-update": {
    "source": "iana"
  },
  "application/tamp-apex-update-confirm": {
    "source": "iana"
  },
  "application/tamp-community-update": {
    "source": "iana"
  },
  "application/tamp-community-update-confirm": {
    "source": "iana"
  },
  "application/tamp-error": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    "source": "iana"
  },
  "application/tamp-status-query": {
    "source": "iana"
  },
  "application/tamp-status-response": {
    "source": "iana"
  },
  "application/tamp-update": {
    "source": "iana"
  },
  "application/tamp-update-confirm": {
    "source": "iana"
  },
  "application/tar": {
    "compressible": true
  },
  "application/taxii+json": {
    "source": "iana",
    "compressible": true
  },
  "application/td+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tei", "teicorpus"]
  },
  "application/tetra_isi": {
    "source": "iana"
  },
  "application/thraud+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tfi"]
  },
  "application/timestamp-query": {
    "source": "iana"
  },
  "application/timestamp-reply": {
    "source": "iana"
  },
  "application/timestamped-data": {
    "source": "iana",
    "extensions": ["tsd"]
  },
  "application/tlsrpt+gzip": {
    "source": "iana"
  },
  "application/tlsrpt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tnauthlist": {
    "source": "iana"
  },
  "application/token-introspection+jwt": {
    "source": "iana"
  },
  "application/toml": {
    "compressible": true,
    "extensions": ["toml"]
  },
  "application/trickle-ice-sdpfrag": {
    "source": "iana"
  },
  "application/trig": {
    "source": "iana",
    "extensions": ["trig"]
  },
  "application/ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttml"]
  },
  "application/tve-trigger": {
    "source": "iana"
  },
  "application/tzif": {
    "source": "iana"
  },
  "application/tzif-leap": {
    "source": "iana"
  },
  "application/ubjson": {
    "compressible": false,
    "extensions": ["ubj"]
  },
  "application/ulpfec": {
    "source": "iana"
  },
  "application/urc-grpsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-ressheet+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsheet"]
  },
  "application/urc-targetdesc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["td"]
  },
  "application/urc-uisocketdesc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vemmi": {
    "source": "iana"
  },
  "application/vividence.scriptfile": {
    "source": "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["1km"]
  },
  "application/vnd.3gpp-prose+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3a+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3ach+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc8+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    "source": "iana"
  },
  "application/vnd.3gpp.5gnas": {
    "source": "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.bsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gmop+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gtpc": {
    "source": "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    "source": "iana"
  },
  "application/vnd.3gpp.lpp": {
    "source": "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-payload": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-regroup+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mid-call+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ngap": {
    "source": "iana"
  },
  "application/vnd.3gpp.pfcp": {
    "source": "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    "source": "iana",
    "extensions": ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    "source": "iana",
    "extensions": ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    "source": "iana",
    "extensions": ["pvb"]
  },
  "application/vnd.3gpp.s1ap": {
    "source": "iana"
  },
  "application/vnd.3gpp.seal-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.seal-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ussd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.vae-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp2.tcap": {
    "source": "iana",
    "extensions": ["tcap"]
  },
  "application/vnd.3lightssoftware.imagescal": {
    "source": "iana"
  },
  "application/vnd.3m.post-it-notes": {
    "source": "iana",
    "extensions": ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    "source": "iana",
    "extensions": ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    "source": "iana",
    "extensions": ["imp"]
  },
  "application/vnd.acucobol": {
    "source": "iana",
    "extensions": ["acu"]
  },
  "application/vnd.acucorp": {
    "source": "iana",
    "extensions": ["atc", "acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    "source": "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    "source": "iana",
    "extensions": ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    "source": "iana",
    "extensions": ["fxp", "fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    "source": "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    "source": "apache",
    "extensions": ["xfdf"]
  },
  "application/vnd.aether.imp": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    "source": "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-charset": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    "source": "iana"
  },
  "application/vnd.afpc.modca": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    "source": "iana"
  },
  "application/vnd.age": {
    "source": "iana",
    "extensions": ["age"]
  },
  "application/vnd.ah-barcode": {
    "source": "apache"
  },
  "application/vnd.ahead.space": {
    "source": "iana",
    "extensions": ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    "source": "iana",
    "extensions": ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    "source": "iana",
    "extensions": ["azs"]
  },
  "application/vnd.amadeus+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.amazon.ebook": {
    "source": "apache",
    "extensions": ["azw"]
  },
  "application/vnd.amazon.mobi8-ebook": {
    "source": "iana"
  },
  "application/vnd.americandynamics.acc": {
    "source": "iana",
    "extensions": ["acc"]
  },
  "application/vnd.amiga.ami": {
    "source": "iana",
    "extensions": ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.android.ota": {
    "source": "iana"
  },
  "application/vnd.android.package-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["apk"]
  },
  "application/vnd.anki": {
    "source": "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    "source": "iana",
    "extensions": ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    "source": "apache",
    "extensions": ["fti"]
  },
  "application/vnd.antix.game-component": {
    "source": "iana",
    "extensions": ["atx"]
  },
  "application/vnd.apache.arrow.file": {
    "source": "iana"
  },
  "application/vnd.apache.arrow.stream": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.binary": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.compact": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.json": {
    "source": "iana"
  },
  "application/vnd.apexlang": {
    "source": "iana"
  },
  "application/vnd.api+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.aplextor.warrp+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apothekende.reservation+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apple.installer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpkg"]
  },
  "application/vnd.apple.keynote": {
    "source": "iana",
    "extensions": ["key"]
  },
  "application/vnd.apple.mpegurl": {
    "source": "iana",
    "extensions": ["m3u8"]
  },
  "application/vnd.apple.numbers": {
    "source": "iana",
    "extensions": ["numbers"]
  },
  "application/vnd.apple.pages": {
    "source": "iana",
    "extensions": ["pages"]
  },
  "application/vnd.apple.pkpass": {
    "compressible": false,
    "extensions": ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    "source": "apache"
  },
  "application/vnd.aristanetworks.swi": {
    "source": "iana",
    "extensions": ["swi"]
  },
  "application/vnd.artisan+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.artsquare": {
    "source": "iana"
  },
  "application/vnd.astraea-software.iota": {
    "source": "iana",
    "extensions": ["iota"]
  },
  "application/vnd.audiograph": {
    "source": "iana",
    "extensions": ["aep"]
  },
  "application/vnd.autopackage": {
    "source": "iana"
  },
  "application/vnd.avalon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.avistar+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.balsamiq.bmml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmml"]
  },
  "application/vnd.balsamiq.bmpr": {
    "source": "iana"
  },
  "application/vnd.banana-accounting": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.error": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bekitzur-stech+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.belightsoft.lhzd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.belightsoft.lhzl+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.bint.med-content": {
    "source": "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.blink-idb-value-wrapper": {
    "source": "iana"
  },
  "application/vnd.blueice.multipass": {
    "source": "iana",
    "extensions": ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    "source": "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    "source": "iana"
  },
  "application/vnd.bmi": {
    "source": "iana",
    "extensions": ["bmi"]
  },
  "application/vnd.bpf": {
    "source": "iana"
  },
  "application/vnd.bpf3": {
    "source": "iana"
  },
  "application/vnd.businessobjects": {
    "source": "iana",
    "extensions": ["rep"]
  },
  "application/vnd.byu.uapi+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cab-jscript": {
    "source": "iana"
  },
  "application/vnd.canon-cpdl": {
    "source": "iana"
  },
  "application/vnd.canon-lips": {
    "source": "iana"
  },
  "application/vnd.capasystems-pg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    "source": "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    "source": "iana"
  },
  "application/vnd.chemdraw+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdxml"]
  },
  "application/vnd.chess-pgn": {
    "source": "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    "source": "iana",
    "extensions": ["mmd"]
  },
  "application/vnd.ciedi": {
    "source": "iana"
  },
  "application/vnd.cinderella": {
    "source": "iana",
    "extensions": ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    "source": "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csl"]
  },
  "application/vnd.claymore": {
    "source": "iana",
    "extensions": ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    "source": "iana",
    "extensions": ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    "source": "iana",
    "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    "source": "iana",
    "extensions": ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    "source": "iana",
    "extensions": ["c11amz"]
  },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": {
    "source": "iana"
  },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": {
    "source": "iana"
  },
  "application/vnd.coffeescript": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    "source": "iana"
  },
  "application/vnd.collection+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.doc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.next+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.comicbook+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.comicbook-rar": {
    "source": "iana"
  },
  "application/vnd.commerce-battelle": {
    "source": "iana"
  },
  "application/vnd.commonspace": {
    "source": "iana",
    "extensions": ["csp"]
  },
  "application/vnd.contact.cmsg": {
    "source": "iana",
    "extensions": ["cdbcmsg"]
  },
  "application/vnd.coreos.ignition+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cosmocaller": {
    "source": "iana",
    "extensions": ["cmc"]
  },
  "application/vnd.crick.clicker": {
    "source": "iana",
    "extensions": ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    "source": "iana",
    "extensions": ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    "source": "iana",
    "extensions": ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    "source": "iana",
    "extensions": ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    "source": "iana",
    "extensions": ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wbs"]
  },
  "application/vnd.cryptii.pipe+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.crypto-shade-file": {
    "source": "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    "source": "iana"
  },
  "application/vnd.cryptomator.vault": {
    "source": "iana"
  },
  "application/vnd.ctc-posml": {
    "source": "iana",
    "extensions": ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cups-pdf": {
    "source": "iana"
  },
  "application/vnd.cups-postscript": {
    "source": "iana"
  },
  "application/vnd.cups-ppd": {
    "source": "iana",
    "extensions": ["ppd"]
  },
  "application/vnd.cups-raster": {
    "source": "iana"
  },
  "application/vnd.cups-raw": {
    "source": "iana"
  },
  "application/vnd.curl": {
    "source": "iana"
  },
  "application/vnd.curl.car": {
    "source": "apache",
    "extensions": ["car"]
  },
  "application/vnd.curl.pcurl": {
    "source": "apache",
    "extensions": ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cybank": {
    "source": "iana"
  },
  "application/vnd.cyclonedx+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cyclonedx+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.d3m-dataset": {
    "source": "iana"
  },
  "application/vnd.d3m-problem": {
    "source": "iana"
  },
  "application/vnd.dart": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    "source": "iana",
    "extensions": ["rdz"]
  },
  "application/vnd.datalog": {
    "source": "iana"
  },
  "application/vnd.datapackage+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dataresource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dbf": {
    "source": "iana",
    "extensions": ["dbf"]
  },
  "application/vnd.debian.binary-package": {
    "source": "iana"
  },
  "application/vnd.dece.data": {
    "source": "iana",
    "extensions": ["uvf", "uvvf", "uvd", "uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uvt", "uvvt"]
  },
  "application/vnd.dece.unspecified": {
    "source": "iana",
    "extensions": ["uvx", "uvvx"]
  },
  "application/vnd.dece.zip": {
    "source": "iana",
    "extensions": ["uvz", "uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    "source": "iana",
    "extensions": ["fe_launch"]
  },
  "application/vnd.desmume.movie": {
    "source": "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    "source": "iana"
  },
  "application/vnd.dm.delegation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dna": {
    "source": "iana",
    "extensions": ["dna"]
  },
  "application/vnd.document+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dolby.mlp": {
    "source": "apache",
    "extensions": ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    "source": "iana"
  },
  "application/vnd.dolby.mobile.2": {
    "source": "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    "source": "iana"
  },
  "application/vnd.dpgraph": {
    "source": "iana",
    "extensions": ["dpg"]
  },
  "application/vnd.dreamfactory": {
    "source": "iana",
    "extensions": ["dfac"]
  },
  "application/vnd.drive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ds-keypoint": {
    "source": "apache",
    "extensions": ["kpxx"]
  },
  "application/vnd.dtg.local": {
    "source": "iana"
  },
  "application/vnd.dtg.local.flash": {
    "source": "iana"
  },
  "application/vnd.dtg.local.html": {
    "source": "iana"
  },
  "application/vnd.dvb.ait": {
    "source": "iana",
    "extensions": ["ait"]
  },
  "application/vnd.dvb.dvbisl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.dvbj": {
    "source": "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-container+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-generic+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-init+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.pfr": {
    "source": "iana"
  },
  "application/vnd.dvb.service": {
    "source": "iana",
    "extensions": ["svc"]
  },
  "application/vnd.dxr": {
    "source": "iana"
  },
  "application/vnd.dynageo": {
    "source": "iana",
    "extensions": ["geo"]
  },
  "application/vnd.dzr": {
    "source": "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    "source": "iana"
  },
  "application/vnd.ecdis-update": {
    "source": "iana"
  },
  "application/vnd.ecip.rlp": {
    "source": "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ecowin.chart": {
    "source": "iana",
    "extensions": ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    "source": "iana"
  },
  "application/vnd.ecowin.series": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    "source": "iana"
  },
  "application/vnd.efi.img": {
    "source": "iana"
  },
  "application/vnd.efi.iso": {
    "source": "iana"
  },
  "application/vnd.eln+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.emclient.accessrequest+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.enliven": {
    "source": "iana",
    "extensions": ["nml"]
  },
  "application/vnd.enphase.envoy": {
    "source": "iana"
  },
  "application/vnd.eprints.data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.epson.esf": {
    "source": "iana",
    "extensions": ["esf"]
  },
  "application/vnd.epson.msf": {
    "source": "iana",
    "extensions": ["msf"]
  },
  "application/vnd.epson.quickanime": {
    "source": "iana",
    "extensions": ["qam"]
  },
  "application/vnd.epson.salt": {
    "source": "iana",
    "extensions": ["slt"]
  },
  "application/vnd.epson.ssf": {
    "source": "iana",
    "extensions": ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    "source": "iana"
  },
  "application/vnd.espass-espass+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.eszigno3+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es3", "et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.asic-e+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.asic-s+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.cug+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvservice+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mcid+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mheg5": {
    "source": "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.pstn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.sci+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.simservs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.timestamp-token": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.tsl.der": {
    "source": "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.eudora.data": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    "source": "iana"
  },
  "application/vnd.exstream-empower+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.exstream-package": {
    "source": "iana"
  },
  "application/vnd.ezpix-album": {
    "source": "iana",
    "extensions": ["ez2"]
  },
  "application/vnd.ezpix-package": {
    "source": "iana",
    "extensions": ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    "source": "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.fastcopy-disk-image": {
    "source": "iana"
  },
  "application/vnd.fdf": {
    "source": "apache",
    "extensions": ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    "source": "iana",
    "extensions": ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    "source": "iana",
    "extensions": ["seed", "dataless"]
  },
  "application/vnd.ffsns": {
    "source": "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.filmit.zfc": {
    "source": "iana"
  },
  "application/vnd.fints": {
    "source": "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    "source": "iana"
  },
  "application/vnd.flographit": {
    "source": "iana",
    "extensions": ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    "source": "iana",
    "extensions": ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    "source": "iana"
  },
  "application/vnd.framemaker": {
    "source": "iana",
    "extensions": ["fm", "frame", "maker", "book"]
  },
  "application/vnd.frogans.fnc": {
    "source": "apache",
    "extensions": ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    "source": "apache",
    "extensions": ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    "source": "iana",
    "extensions": ["fsc"]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    "source": "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    "source": "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fujitsu.oasys": {
    "source": "iana",
    "extensions": ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    "source": "iana",
    "extensions": ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    "source": "iana",
    "extensions": ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    "source": "iana",
    "extensions": ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    "source": "iana",
    "extensions": ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    "source": "iana"
  },
  "application/vnd.fujixerox.art4": {
    "source": "iana"
  },
  "application/vnd.fujixerox.ddd": {
    "source": "iana",
    "extensions": ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    "source": "iana",
    "extensions": ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    "source": "iana",
    "extensions": ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    "source": "iana"
  },
  "application/vnd.fut-misnet": {
    "source": "iana"
  },
  "application/vnd.futoin+cbor": {
    "source": "iana"
  },
  "application/vnd.futoin+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fuzzysheet": {
    "source": "iana",
    "extensions": ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    "source": "iana",
    "extensions": ["txd"]
  },
  "application/vnd.genozip": {
    "source": "iana"
  },
  "application/vnd.gentics.grd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gentoo.catmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gentoo.ebuild": {
    "source": "iana"
  },
  "application/vnd.gentoo.eclass": {
    "source": "iana"
  },
  "application/vnd.gentoo.gpkg": {
    "source": "iana"
  },
  "application/vnd.gentoo.manifest": {
    "source": "iana"
  },
  "application/vnd.gentoo.pkgmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gentoo.xpak": {
    "source": "iana"
  },
  "application/vnd.geo+json": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.geocube+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.geogebra.file": {
    "source": "iana",
    "extensions": ["ggb"]
  },
  "application/vnd.geogebra.slides": {
    "source": "iana"
  },
  "application/vnd.geogebra.tool": {
    "source": "iana",
    "extensions": ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    "source": "iana",
    "extensions": ["gex", "gre"]
  },
  "application/vnd.geonext": {
    "source": "iana",
    "extensions": ["gxt"]
  },
  "application/vnd.geoplan": {
    "source": "iana",
    "extensions": ["g2w"]
  },
  "application/vnd.geospace": {
    "source": "iana",
    "extensions": ["g3w"]
  },
  "application/vnd.gerber": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    "source": "iana"
  },
  "application/vnd.gmx": {
    "source": "iana",
    "extensions": ["gmx"]
  },
  "application/vnd.gnu.taler.exchange+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gnu.taler.merchant+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.google-apps.document": {
    "compressible": false,
    "extensions": ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    "compressible": false,
    "extensions": ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    "compressible": false,
    "extensions": ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    "source": "iana",
    "compressible": false,
    "extensions": ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gov.sk.e-form+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gpxsee.map+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.grafeq": {
    "source": "iana",
    "extensions": ["gqf", "gqs"]
  },
  "application/vnd.gridmp": {
    "source": "iana"
  },
  "application/vnd.groove-account": {
    "source": "iana",
    "extensions": ["gac"]
  },
  "application/vnd.groove-help": {
    "source": "iana",
    "extensions": ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    "source": "iana",
    "extensions": ["gim"]
  },
  "application/vnd.groove-injector": {
    "source": "iana",
    "extensions": ["grv"]
  },
  "application/vnd.groove-tool-message": {
    "source": "iana",
    "extensions": ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    "source": "iana",
    "extensions": ["tpl"]
  },
  "application/vnd.groove-vcard": {
    "source": "iana",
    "extensions": ["vcg"]
  },
  "application/vnd.hal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hal+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zmm"]
  },
  "application/vnd.hbci": {
    "source": "iana",
    "extensions": ["hbci"]
  },
  "application/vnd.hc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hcl-bireports": {
    "source": "iana"
  },
  "application/vnd.hdt": {
    "source": "iana"
  },
  "application/vnd.heroku+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hhe.lesson-player": {
    "source": "iana",
    "extensions": ["les"]
  },
  "application/vnd.hp-hpgl": {
    "source": "iana",
    "extensions": ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    "source": "iana",
    "extensions": ["hpid"]
  },
  "application/vnd.hp-hps": {
    "source": "iana",
    "extensions": ["hps"]
  },
  "application/vnd.hp-jlyt": {
    "source": "iana",
    "extensions": ["jlt"]
  },
  "application/vnd.hp-pcl": {
    "source": "iana",
    "extensions": ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    "source": "iana",
    "extensions": ["pclxl"]
  },
  "application/vnd.hsl": {
    "source": "iana"
  },
  "application/vnd.httphone": {
    "source": "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    "source": "iana",
    "extensions": ["sfd-hdstx"]
  },
  "application/vnd.hyper+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyper-item+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyperdrive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hzn-3d-crossword": {
    "source": "iana"
  },
  "application/vnd.ibm.afplinedata": {
    "source": "apache"
  },
  "application/vnd.ibm.electronic-media": {
    "source": "iana"
  },
  "application/vnd.ibm.minipay": {
    "source": "iana",
    "extensions": ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    "source": "apache",
    "extensions": ["afp", "listafp", "list3820"]
  },
  "application/vnd.ibm.rights-management": {
    "source": "iana",
    "extensions": ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    "source": "iana",
    "extensions": ["sc"]
  },
  "application/vnd.iccprofile": {
    "source": "iana",
    "extensions": ["icc", "icm"]
  },
  "application/vnd.ieee.1905": {
    "source": "iana"
  },
  "application/vnd.igloader": {
    "source": "iana",
    "extensions": ["igl"]
  },
  "application/vnd.imagemeter.folder+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.imagemeter.image+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.immervision-ivp": {
    "source": "iana",
    "extensions": ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    "source": "iana",
    "extensions": ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    "source": "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informedcontrol.rms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informix-visionary": {
    "source": "apache"
  },
  "application/vnd.infotech.project": {
    "source": "iana"
  },
  "application/vnd.infotech.project+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.innopath.wamp.notification": {
    "source": "iana"
  },
  "application/vnd.insors.igm": {
    "source": "iana",
    "extensions": ["igm"]
  },
  "application/vnd.intercon.formnet": {
    "source": "iana",
    "extensions": ["xpw", "xpx"]
  },
  "application/vnd.intergeo": {
    "source": "iana",
    "extensions": ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    "source": "iana"
  },
  "application/vnd.intertrust.nncp": {
    "source": "iana"
  },
  "application/vnd.intu.qbo": {
    "source": "iana",
    "extensions": ["qbo"]
  },
  "application/vnd.intu.qfx": {
    "source": "iana",
    "extensions": ["qfx"]
  },
  "application/vnd.ipld.car": {
    "source": "iana"
  },
  "application/vnd.ipld.dag-cbor": {
    "source": "iana"
  },
  "application/vnd.ipld.dag-json": {
    "source": "iana"
  },
  "application/vnd.ipld.raw": {
    "source": "iana"
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ipunplugged.rcprofile": {
    "source": "iana",
    "extensions": ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["irp"]
  },
  "application/vnd.is-xpr": {
    "source": "iana",
    "extensions": ["xpr"]
  },
  "application/vnd.isac.fcs": {
    "source": "iana",
    "extensions": ["fcs"]
  },
  "application/vnd.iso11783-10+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.jam": {
    "source": "iana",
    "extensions": ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    "source": "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-registration": {
    "source": "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-verification": {
    "source": "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    "source": "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    "source": "iana",
    "extensions": ["rms"]
  },
  "application/vnd.jisp": {
    "source": "iana",
    "extensions": ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    "source": "iana",
    "extensions": ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    "source": "iana"
  },
  "application/vnd.kahootz": {
    "source": "iana",
    "extensions": ["ktz", "ktr"]
  },
  "application/vnd.kde.karbon": {
    "source": "iana",
    "extensions": ["karbon"]
  },
  "application/vnd.kde.kchart": {
    "source": "iana",
    "extensions": ["chrt"]
  },
  "application/vnd.kde.kformula": {
    "source": "iana",
    "extensions": ["kfo"]
  },
  "application/vnd.kde.kivio": {
    "source": "iana",
    "extensions": ["flw"]
  },
  "application/vnd.kde.kontour": {
    "source": "iana",
    "extensions": ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    "source": "iana",
    "extensions": ["kpr", "kpt"]
  },
  "application/vnd.kde.kspread": {
    "source": "iana",
    "extensions": ["ksp"]
  },
  "application/vnd.kde.kword": {
    "source": "iana",
    "extensions": ["kwd", "kwt"]
  },
  "application/vnd.kenameaapp": {
    "source": "iana",
    "extensions": ["htke"]
  },
  "application/vnd.kidspiration": {
    "source": "iana",
    "extensions": ["kia"]
  },
  "application/vnd.kinar": {
    "source": "iana",
    "extensions": ["kne", "knp"]
  },
  "application/vnd.koan": {
    "source": "iana",
    "extensions": ["skp", "skd", "skt", "skm"]
  },
  "application/vnd.kodak-descriptor": {
    "source": "iana",
    "extensions": ["sse"]
  },
  "application/vnd.las": {
    "source": "iana"
  },
  "application/vnd.las.las+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.las.las+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lasxml"]
  },
  "application/vnd.laszip": {
    "source": "iana"
  },
  "application/vnd.leap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.liberty-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    "source": "iana",
    "extensions": ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lbe"]
  },
  "application/vnd.logipipe.circuit+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.loom": {
    "source": "iana"
  },
  "application/vnd.lotus-1-2-3": {
    "source": "iana",
    "extensions": ["123"]
  },
  "application/vnd.lotus-approach": {
    "source": "iana",
    "extensions": ["apr"]
  },
  "application/vnd.lotus-freelance": {
    "source": "iana",
    "extensions": ["pre"]
  },
  "application/vnd.lotus-notes": {
    "source": "iana",
    "extensions": ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    "source": "iana",
    "extensions": ["org"]
  },
  "application/vnd.lotus-screencam": {
    "source": "iana",
    "extensions": ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    "source": "iana",
    "extensions": ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    "source": "iana",
    "extensions": ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    "source": "iana",
    "extensions": ["mvt"]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.license+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.mdcf": {
    "source": "iana"
  },
  "application/vnd.mason+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.maxmind.maxmind-db": {
    "source": "iana"
  },
  "application/vnd.mcd": {
    "source": "iana",
    "extensions": ["mcd"]
  },
  "application/vnd.medcalcdata": {
    "source": "iana",
    "extensions": ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    "source": "iana",
    "extensions": ["cdkey"]
  },
  "application/vnd.medicalholodeck.recordxr": {
    "source": "iana"
  },
  "application/vnd.meridian-slingshot": {
    "source": "iana"
  },
  "application/vnd.mfer": {
    "source": "iana",
    "extensions": ["mwf"]
  },
  "application/vnd.mfmp": {
    "source": "iana",
    "extensions": ["mfm"]
  },
  "application/vnd.micro+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.micrografx.flo": {
    "source": "iana",
    "extensions": ["flo"]
  },
  "application/vnd.micrografx.igx": {
    "source": "iana",
    "extensions": ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    "source": "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    "source": "iana"
  },
  "application/vnd.miele+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.mif": {
    "source": "iana",
    "extensions": ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    "source": "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    "source": "iana"
  },
  "application/vnd.mobius.daf": {
    "source": "iana",
    "extensions": ["daf"]
  },
  "application/vnd.mobius.dis": {
    "source": "iana",
    "extensions": ["dis"]
  },
  "application/vnd.mobius.mbk": {
    "source": "iana",
    "extensions": ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    "source": "iana",
    "extensions": ["mqy"]
  },
  "application/vnd.mobius.msl": {
    "source": "iana",
    "extensions": ["msl"]
  },
  "application/vnd.mobius.plc": {
    "source": "iana",
    "extensions": ["plc"]
  },
  "application/vnd.mobius.txf": {
    "source": "iana",
    "extensions": ["txf"]
  },
  "application/vnd.mophun.application": {
    "source": "iana",
    "extensions": ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    "source": "iana",
    "extensions": ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    "source": "iana"
  },
  "application/vnd.motorola.iprm": {
    "source": "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    "source": "iana"
  },
  "application/vnd.ms-artgalry": {
    "source": "iana",
    "extensions": ["cil"]
  },
  "application/vnd.ms-asf": {
    "source": "iana"
  },
  "application/vnd.ms-cab-compressed": {
    "source": "iana",
    "extensions": ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    "source": "apache"
  },
  "application/vnd.ms-excel": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    "source": "iana",
    "extensions": ["chm"]
  },
  "application/vnd.ms-ims": {
    "source": "iana",
    "extensions": ["ims"]
  },
  "application/vnd.ms-lrm": {
    "source": "iana",
    "extensions": ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-officetheme": {
    "source": "iana",
    "extensions": ["thmx"]
  },
  "application/vnd.ms-opentype": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-outlook": {
    "compressible": false,
    "extensions": ["msg"]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    "source": "apache"
  },
  "application/vnd.ms-pki.seccat": {
    "source": "apache",
    "extensions": ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    "source": "apache",
    "extensions": ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-powerpoint": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ppt", "pps", "pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    "source": "iana",
    "extensions": ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    "source": "iana",
    "extensions": ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-printing.printticket+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-printschematicket+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-project": {
    "source": "iana",
    "extensions": ["mpp", "mpt"]
  },
  "application/vnd.ms-tnef": {
    "source": "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    "source": "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    "source": "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    "source": "iana",
    "extensions": ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["dotm"]
  },
  "application/vnd.ms-works": {
    "source": "iana",
    "extensions": ["wps", "wks", "wcm", "wdb"]
  },
  "application/vnd.ms-wpl": {
    "source": "iana",
    "extensions": ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xps"]
  },
  "application/vnd.msa-disk-image": {
    "source": "iana"
  },
  "application/vnd.mseq": {
    "source": "iana",
    "extensions": ["mseq"]
  },
  "application/vnd.msign": {
    "source": "iana"
  },
  "application/vnd.multiad.creator": {
    "source": "iana"
  },
  "application/vnd.multiad.creator.cif": {
    "source": "iana"
  },
  "application/vnd.music-niff": {
    "source": "iana"
  },
  "application/vnd.musician": {
    "source": "iana",
    "extensions": ["mus"]
  },
  "application/vnd.muvee.style": {
    "source": "iana",
    "extensions": ["msty"]
  },
  "application/vnd.mynfc": {
    "source": "iana",
    "extensions": ["taglet"]
  },
  "application/vnd.nacamar.ybrid+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ncd.control": {
    "source": "iana"
  },
  "application/vnd.ncd.reference": {
    "source": "iana"
  },
  "application/vnd.nearst.inv+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nebumind.line": {
    "source": "iana"
  },
  "application/vnd.nervana": {
    "source": "iana"
  },
  "application/vnd.netfpx": {
    "source": "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    "source": "iana",
    "extensions": ["nlu"]
  },
  "application/vnd.nimn": {
    "source": "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    "source": "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    "source": "iana"
  },
  "application/vnd.nitf": {
    "source": "iana",
    "extensions": ["ntf", "nitf"]
  },
  "application/vnd.noblenet-directory": {
    "source": "iana",
    "extensions": ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    "source": "iana",
    "extensions": ["nns"]
  },
  "application/vnd.noblenet-web": {
    "source": "iana",
    "extensions": ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.iptv.config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.isds-radio-presets": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ac"]
  },
  "application/vnd.nokia.n-gage.data": {
    "source": "iana",
    "extensions": ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    "source": "apache",
    "extensions": ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.radio-preset": {
    "source": "iana",
    "extensions": ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    "source": "iana",
    "extensions": ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    "source": "iana",
    "extensions": ["edm"]
  },
  "application/vnd.novadigm.edx": {
    "source": "iana",
    "extensions": ["edx"]
  },
  "application/vnd.novadigm.ext": {
    "source": "iana",
    "extensions": ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    "source": "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    "source": "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.base": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    "source": "iana",
    "extensions": ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    "source": "iana",
    "extensions": ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    "source": "apache",
    "extensions": ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    "source": "iana",
    "extensions": ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    "source": "iana",
    "extensions": ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    "source": "iana",
    "extensions": ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    "source": "iana",
    "extensions": ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    "source": "iana",
    "extensions": ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    "source": "iana",
    "extensions": ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    "source": "iana",
    "extensions": ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    "source": "iana",
    "extensions": ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    "source": "iana",
    "extensions": ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    "source": "iana",
    "extensions": ["oth"]
  },
  "application/vnd.obn": {
    "source": "iana"
  },
  "application/vnd.ocf+cbor": {
    "source": "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oftn.l10n+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.pae.gem": {
    "source": "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.spdlist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.ueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.userprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.olpc-sugar": {
    "source": "iana",
    "extensions": ["xo"]
  },
  "application/vnd.oma-scws-config": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-request": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-response": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.oma.bcast.imd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.ltkm": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sgdu": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.stkm": {
    "source": "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-pcc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.dcd": {
    "source": "iana"
  },
  "application/vnd.oma.dcdc": {
    "source": "iana"
  },
  "application/vnd.oma.dd2+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.group-usage-list+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+cbor": {
    "source": "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+tlv": {
    "source": "iana"
  },
  "application/vnd.oma.pal+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.final-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.groups+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.push": {
    "source": "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.xcap-directory+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-email+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-file+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-folder+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omaloc-supl-init": {
    "source": "iana"
  },
  "application/vnd.onepager": {
    "source": "iana"
  },
  "application/vnd.onepagertamp": {
    "source": "iana"
  },
  "application/vnd.onepagertamx": {
    "source": "iana"
  },
  "application/vnd.onepagertat": {
    "source": "iana"
  },
  "application/vnd.onepagertatp": {
    "source": "iana"
  },
  "application/vnd.onepagertatx": {
    "source": "iana"
  },
  "application/vnd.onvif.metadata": {
    "source": "iana"
  },
  "application/vnd.openblox.game+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["obgx"]
  },
  "application/vnd.openblox.game-binary": {
    "source": "iana"
  },
  "application/vnd.openeye.oeb": {
    "source": "iana"
  },
  "application/vnd.openofficeorg.extension": {
    "source": "apache",
    "extensions": ["oxt"]
  },
  "application/vnd.openstreetmap.data+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osm"]
  },
  "application/vnd.opentimestamps.ots": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    "source": "iana",
    "extensions": ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    "source": "iana",
    "extensions": ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    "source": "iana",
    "extensions": ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    "source": "iana",
    "extensions": ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    "source": "iana",
    "compressible": false,
    "extensions": ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    "source": "iana",
    "extensions": ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oracle.resource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.orange.indata": {
    "source": "iana"
  },
  "application/vnd.osa.netdeploy": {
    "source": "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    "source": "iana",
    "extensions": ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    "source": "iana"
  },
  "application/vnd.osgi.dp": {
    "source": "iana",
    "extensions": ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    "source": "iana",
    "extensions": ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oxli.countgraph": {
    "source": "iana"
  },
  "application/vnd.pagerduty+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.palm": {
    "source": "iana",
    "extensions": ["pdb", "pqa", "oprc"]
  },
  "application/vnd.panoply": {
    "source": "iana"
  },
  "application/vnd.paos.xml": {
    "source": "iana"
  },
  "application/vnd.patentdive": {
    "source": "iana"
  },
  "application/vnd.patientecommsdoc": {
    "source": "iana"
  },
  "application/vnd.pawaafile": {
    "source": "iana",
    "extensions": ["paw"]
  },
  "application/vnd.pcos": {
    "source": "iana"
  },
  "application/vnd.pg.format": {
    "source": "iana",
    "extensions": ["str"]
  },
  "application/vnd.pg.osasli": {
    "source": "iana",
    "extensions": ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    "source": "iana"
  },
  "application/vnd.picsel": {
    "source": "iana",
    "extensions": ["efif"]
  },
  "application/vnd.pmi.widget": {
    "source": "iana",
    "extensions": ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.pocketlearn": {
    "source": "iana",
    "extensions": ["plf"]
  },
  "application/vnd.powerbuilder6": {
    "source": "iana",
    "extensions": ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75-s": {
    "source": "iana"
  },
  "application/vnd.preminet": {
    "source": "iana"
  },
  "application/vnd.previewsystems.box": {
    "source": "iana",
    "extensions": ["box"]
  },
  "application/vnd.proteus.magazine": {
    "source": "iana",
    "extensions": ["mgz"]
  },
  "application/vnd.psfs": {
    "source": "iana"
  },
  "application/vnd.publishare-delta-tree": {
    "source": "iana",
    "extensions": ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    "source": "iana",
    "extensions": ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    "source": "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtm"]
  },
  "application/vnd.qualcomm.brew-app-res": {
    "source": "iana"
  },
  "application/vnd.quarantainenet": {
    "source": "iana"
  },
  "application/vnd.quark.quarkxpress": {
    "source": "iana",
    "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    "source": "iana"
  },
  "application/vnd.radisys.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rainstor.data": {
    "source": "iana"
  },
  "application/vnd.rapid": {
    "source": "iana"
  },
  "application/vnd.rar": {
    "source": "iana",
    "extensions": ["rar"]
  },
  "application/vnd.realvnc.bed": {
    "source": "iana",
    "extensions": ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    "source": "iana",
    "extensions": ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    "source": "iana"
  },
  "application/vnd.resilient.logic": {
    "source": "iana"
  },
  "application/vnd.restful+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rig.cryptonote": {
    "source": "iana",
    "extensions": ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    "source": "apache",
    "extensions": ["cod"]
  },
  "application/vnd.rn-realmedia": {
    "source": "apache",
    "extensions": ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    "source": "apache",
    "extensions": ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["link66"]
  },
  "application/vnd.rs-274x": {
    "source": "iana"
  },
  "application/vnd.ruckus.download": {
    "source": "iana"
  },
  "application/vnd.s3sms": {
    "source": "iana"
  },
  "application/vnd.sailingtracker.track": {
    "source": "iana",
    "extensions": ["st"]
  },
  "application/vnd.sar": {
    "source": "iana"
  },
  "application/vnd.sbm.cid": {
    "source": "iana"
  },
  "application/vnd.sbm.mid2": {
    "source": "iana"
  },
  "application/vnd.scribus": {
    "source": "iana"
  },
  "application/vnd.sealed.3df": {
    "source": "iana"
  },
  "application/vnd.sealed.csf": {
    "source": "iana"
  },
  "application/vnd.sealed.doc": {
    "source": "iana"
  },
  "application/vnd.sealed.eml": {
    "source": "iana"
  },
  "application/vnd.sealed.mht": {
    "source": "iana"
  },
  "application/vnd.sealed.net": {
    "source": "iana"
  },
  "application/vnd.sealed.ppt": {
    "source": "iana"
  },
  "application/vnd.sealed.tiff": {
    "source": "iana"
  },
  "application/vnd.sealed.xls": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    "source": "iana"
  },
  "application/vnd.seemail": {
    "source": "iana",
    "extensions": ["see"]
  },
  "application/vnd.seis+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.sema": {
    "source": "iana",
    "extensions": ["sema"]
  },
  "application/vnd.semd": {
    "source": "iana",
    "extensions": ["semd"]
  },
  "application/vnd.semf": {
    "source": "iana",
    "extensions": ["semf"]
  },
  "application/vnd.shade-save-file": {
    "source": "iana"
  },
  "application/vnd.shana.informed.formdata": {
    "source": "iana",
    "extensions": ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    "source": "iana",
    "extensions": ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    "source": "iana",
    "extensions": ["iif"]
  },
  "application/vnd.shana.informed.package": {
    "source": "iana",
    "extensions": ["ipk"]
  },
  "application/vnd.shootproof+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shopkick+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shp": {
    "source": "iana"
  },
  "application/vnd.shx": {
    "source": "iana"
  },
  "application/vnd.sigrok.session": {
    "source": "iana"
  },
  "application/vnd.simtech-mindmapper": {
    "source": "iana",
    "extensions": ["twd", "twds"]
  },
  "application/vnd.siren+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.smaf": {
    "source": "iana",
    "extensions": ["mmf"]
  },
  "application/vnd.smart.notebook": {
    "source": "iana"
  },
  "application/vnd.smart.teacher": {
    "source": "iana",
    "extensions": ["teacher"]
  },
  "application/vnd.smintio.portals.archive": {
    "source": "iana"
  },
  "application/vnd.snesdev-page-table": {
    "source": "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fo"]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    "source": "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sdkm", "sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    "source": "iana",
    "extensions": ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    "source": "iana",
    "extensions": ["sfs"]
  },
  "application/vnd.sqlite3": {
    "source": "iana"
  },
  "application/vnd.sss-cod": {
    "source": "iana"
  },
  "application/vnd.sss-dtf": {
    "source": "iana"
  },
  "application/vnd.sss-ntf": {
    "source": "iana"
  },
  "application/vnd.stardivision.calc": {
    "source": "apache",
    "extensions": ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    "source": "apache",
    "extensions": ["sda"]
  },
  "application/vnd.stardivision.impress": {
    "source": "apache",
    "extensions": ["sdd"]
  },
  "application/vnd.stardivision.math": {
    "source": "apache",
    "extensions": ["smf"]
  },
  "application/vnd.stardivision.writer": {
    "source": "apache",
    "extensions": ["sdw", "vor"]
  },
  "application/vnd.stardivision.writer-global": {
    "source": "apache",
    "extensions": ["sgl"]
  },
  "application/vnd.stepmania.package": {
    "source": "iana",
    "extensions": ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    "source": "iana",
    "extensions": ["sm"]
  },
  "application/vnd.street-stream": {
    "source": "iana"
  },
  "application/vnd.sun.wadl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wadl"]
  },
  "application/vnd.sun.xml.calc": {
    "source": "apache",
    "extensions": ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    "source": "apache",
    "extensions": ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    "source": "apache",
    "extensions": ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    "source": "apache",
    "extensions": ["std"]
  },
  "application/vnd.sun.xml.impress": {
    "source": "apache",
    "extensions": ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    "source": "apache",
    "extensions": ["sti"]
  },
  "application/vnd.sun.xml.math": {
    "source": "apache",
    "extensions": ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    "source": "apache",
    "extensions": ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    "source": "apache",
    "extensions": ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    "source": "apache",
    "extensions": ["stw"]
  },
  "application/vnd.sus-calendar": {
    "source": "iana",
    "extensions": ["sus", "susp"]
  },
  "application/vnd.svd": {
    "source": "iana",
    "extensions": ["svd"]
  },
  "application/vnd.swiftview-ics": {
    "source": "iana"
  },
  "application/vnd.sybyl.mol2": {
    "source": "iana"
  },
  "application/vnd.sycle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.syft+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.symbian.install": {
    "source": "apache",
    "extensions": ["sis", "sisx"]
  },
  "application/vnd.syncml+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["ddf"]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.syncml.ds.notification": {
    "source": "iana"
  },
  "application/vnd.tableschema+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tao.intent-module-archive": {
    "source": "iana",
    "extensions": ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    "source": "iana",
    "extensions": ["pcap", "cap", "dmp"]
  },
  "application/vnd.think-cell.ppttc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tml": {
    "source": "iana"
  },
  "application/vnd.tmobile-livetv": {
    "source": "iana",
    "extensions": ["tmo"]
  },
  "application/vnd.tri.onesource": {
    "source": "iana"
  },
  "application/vnd.trid.tpt": {
    "source": "iana",
    "extensions": ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    "source": "iana",
    "extensions": ["mxs"]
  },
  "application/vnd.trueapp": {
    "source": "iana",
    "extensions": ["tra"]
  },
  "application/vnd.truedoc": {
    "source": "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    "source": "iana"
  },
  "application/vnd.ufdl": {
    "source": "iana",
    "extensions": ["ufd", "ufdl"]
  },
  "application/vnd.uiq.theme": {
    "source": "iana",
    "extensions": ["utz"]
  },
  "application/vnd.umajin": {
    "source": "iana",
    "extensions": ["umj"]
  },
  "application/vnd.unity": {
    "source": "iana",
    "extensions": ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uoml", "uo"]
  },
  "application/vnd.uplanet.alert": {
    "source": "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.list": {
    "source": "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.signal": {
    "source": "iana"
  },
  "application/vnd.uri-map": {
    "source": "iana"
  },
  "application/vnd.valve.source.material": {
    "source": "iana"
  },
  "application/vnd.vcx": {
    "source": "iana",
    "extensions": ["vcx"]
  },
  "application/vnd.vd-study": {
    "source": "iana"
  },
  "application/vnd.vectorworks": {
    "source": "iana"
  },
  "application/vnd.vel+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.verimatrix.vcas": {
    "source": "iana"
  },
  "application/vnd.veritone.aion+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.veryant.thin": {
    "source": "iana"
  },
  "application/vnd.ves.encrypted": {
    "source": "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    "source": "iana"
  },
  "application/vnd.visio": {
    "source": "iana",
    "extensions": ["vsd", "vst", "vss", "vsw"]
  },
  "application/vnd.visionary": {
    "source": "iana",
    "extensions": ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    "source": "iana"
  },
  "application/vnd.vsf": {
    "source": "iana",
    "extensions": ["vsf"]
  },
  "application/vnd.wap.sic": {
    "source": "iana"
  },
  "application/vnd.wap.slc": {
    "source": "iana"
  },
  "application/vnd.wap.wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    "source": "iana",
    "extensions": ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    "source": "iana",
    "extensions": ["wmlsc"]
  },
  "application/vnd.wasmflow.wafl": {
    "source": "iana"
  },
  "application/vnd.webturbo": {
    "source": "iana",
    "extensions": ["wtb"]
  },
  "application/vnd.wfa.dpp": {
    "source": "iana"
  },
  "application/vnd.wfa.p2p": {
    "source": "iana"
  },
  "application/vnd.wfa.wsc": {
    "source": "iana"
  },
  "application/vnd.windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.wmc": {
    "source": "iana"
  },
  "application/vnd.wmf.bootstrap": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    "source": "iana"
  },
  "application/vnd.wolfram.player": {
    "source": "iana",
    "extensions": ["nbp"]
  },
  "application/vnd.wordlift": {
    "source": "iana"
  },
  "application/vnd.wordperfect": {
    "source": "iana",
    "extensions": ["wpd"]
  },
  "application/vnd.wqd": {
    "source": "iana",
    "extensions": ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    "source": "iana"
  },
  "application/vnd.wt.stf": {
    "source": "iana",
    "extensions": ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    "source": "iana"
  },
  "application/vnd.wv.csp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.wv.ssp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xacml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xara": {
    "source": "iana",
    "extensions": ["xar"]
  },
  "application/vnd.xfdl": {
    "source": "iana",
    "extensions": ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    "source": "iana"
  },
  "application/vnd.xmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xmpie.cpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.dpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.plan": {
    "source": "iana"
  },
  "application/vnd.xmpie.ppkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.xlim": {
    "source": "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    "source": "iana",
    "extensions": ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    "source": "iana",
    "extensions": ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    "source": "iana",
    "extensions": ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    "source": "iana",
    "extensions": ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    "source": "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    "source": "iana",
    "extensions": ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    "source": "iana",
    "extensions": ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    "source": "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    "source": "iana"
  },
  "application/vnd.yaoweme": {
    "source": "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    "source": "iana",
    "extensions": ["cmp"]
  },
  "application/vnd.zul": {
    "source": "iana",
    "extensions": ["zir", "zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zaz"]
  },
  "application/voicexml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vxml"]
  },
  "application/voucher-cms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vq-rtcpxr": {
    "source": "iana"
  },
  "application/wasm": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wasm"]
  },
  "application/watcherinfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wif"]
  },
  "application/webpush-options+json": {
    "source": "iana",
    "compressible": true
  },
  "application/whoispp-query": {
    "source": "iana"
  },
  "application/whoispp-response": {
    "source": "iana"
  },
  "application/widget": {
    "source": "iana",
    "extensions": ["wgt"]
  },
  "application/winhlp": {
    "source": "apache",
    "extensions": ["hlp"]
  },
  "application/wita": {
    "source": "iana"
  },
  "application/wordperfect5.1": {
    "source": "iana"
  },
  "application/wsdl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wsdl"]
  },
  "application/wspolicy+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wspolicy"]
  },
  "application/x-7z-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["7z"]
  },
  "application/x-abiword": {
    "source": "apache",
    "extensions": ["abw"]
  },
  "application/x-ace-compressed": {
    "source": "apache",
    "extensions": ["ace"]
  },
  "application/x-amf": {
    "source": "apache"
  },
  "application/x-apple-diskimage": {
    "source": "apache",
    "extensions": ["dmg"]
  },
  "application/x-arj": {
    "compressible": false,
    "extensions": ["arj"]
  },
  "application/x-authorware-bin": {
    "source": "apache",
    "extensions": ["aab", "x32", "u32", "vox"]
  },
  "application/x-authorware-map": {
    "source": "apache",
    "extensions": ["aam"]
  },
  "application/x-authorware-seg": {
    "source": "apache",
    "extensions": ["aas"]
  },
  "application/x-bcpio": {
    "source": "apache",
    "extensions": ["bcpio"]
  },
  "application/x-bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/x-bittorrent": {
    "source": "apache",
    "extensions": ["torrent"]
  },
  "application/x-blorb": {
    "source": "apache",
    "extensions": ["blb", "blorb"]
  },
  "application/x-bzip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz"]
  },
  "application/x-bzip2": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz2", "boz"]
  },
  "application/x-cbr": {
    "source": "apache",
    "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"]
  },
  "application/x-cdlink": {
    "source": "apache",
    "extensions": ["vcd"]
  },
  "application/x-cfs-compressed": {
    "source": "apache",
    "extensions": ["cfs"]
  },
  "application/x-chat": {
    "source": "apache",
    "extensions": ["chat"]
  },
  "application/x-chess-pgn": {
    "source": "apache",
    "extensions": ["pgn"]
  },
  "application/x-chrome-extension": {
    "extensions": ["crx"]
  },
  "application/x-cocoa": {
    "source": "nginx",
    "extensions": ["cco"]
  },
  "application/x-compress": {
    "source": "apache"
  },
  "application/x-conference": {
    "source": "apache",
    "extensions": ["nsc"]
  },
  "application/x-cpio": {
    "source": "apache",
    "extensions": ["cpio"]
  },
  "application/x-csh": {
    "source": "apache",
    "extensions": ["csh"]
  },
  "application/x-deb": {
    "compressible": false
  },
  "application/x-debian-package": {
    "source": "apache",
    "extensions": ["deb", "udeb"]
  },
  "application/x-dgc-compressed": {
    "source": "apache",
    "extensions": ["dgc"]
  },
  "application/x-director": {
    "source": "apache",
    "extensions": [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    "source": "apache",
    "extensions": ["wad"]
  },
  "application/x-dtbncx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ncx"]
  },
  "application/x-dtbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dtb"]
  },
  "application/x-dtbresource+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["res"]
  },
  "application/x-dvi": {
    "source": "apache",
    "compressible": false,
    "extensions": ["dvi"]
  },
  "application/x-envoy": {
    "source": "apache",
    "extensions": ["evy"]
  },
  "application/x-eva": {
    "source": "apache",
    "extensions": ["eva"]
  },
  "application/x-font-bdf": {
    "source": "apache",
    "extensions": ["bdf"]
  },
  "application/x-font-dos": {
    "source": "apache"
  },
  "application/x-font-framemaker": {
    "source": "apache"
  },
  "application/x-font-ghostscript": {
    "source": "apache",
    "extensions": ["gsf"]
  },
  "application/x-font-libgrx": {
    "source": "apache"
  },
  "application/x-font-linux-psf": {
    "source": "apache",
    "extensions": ["psf"]
  },
  "application/x-font-pcf": {
    "source": "apache",
    "extensions": ["pcf"]
  },
  "application/x-font-snf": {
    "source": "apache",
    "extensions": ["snf"]
  },
  "application/x-font-speedo": {
    "source": "apache"
  },
  "application/x-font-sunos-news": {
    "source": "apache"
  },
  "application/x-font-type1": {
    "source": "apache",
    "extensions": ["pfa", "pfb", "pfm", "afm"]
  },
  "application/x-font-vfont": {
    "source": "apache"
  },
  "application/x-freearc": {
    "source": "apache",
    "extensions": ["arc"]
  },
  "application/x-futuresplash": {
    "source": "apache",
    "extensions": ["spl"]
  },
  "application/x-gca-compressed": {
    "source": "apache",
    "extensions": ["gca"]
  },
  "application/x-glulx": {
    "source": "apache",
    "extensions": ["ulx"]
  },
  "application/x-gnumeric": {
    "source": "apache",
    "extensions": ["gnumeric"]
  },
  "application/x-gramps-xml": {
    "source": "apache",
    "extensions": ["gramps"]
  },
  "application/x-gtar": {
    "source": "apache",
    "extensions": ["gtar"]
  },
  "application/x-gzip": {
    "source": "apache"
  },
  "application/x-hdf": {
    "source": "apache",
    "extensions": ["hdf"]
  },
  "application/x-httpd-php": {
    "compressible": true,
    "extensions": ["php"]
  },
  "application/x-install-instructions": {
    "source": "apache",
    "extensions": ["install"]
  },
  "application/x-iso9660-image": {
    "source": "apache",
    "extensions": ["iso"]
  },
  "application/x-iwork-keynote-sffkey": {
    "extensions": ["key"]
  },
  "application/x-iwork-numbers-sffnumbers": {
    "extensions": ["numbers"]
  },
  "application/x-iwork-pages-sffpages": {
    "extensions": ["pages"]
  },
  "application/x-java-archive-diff": {
    "source": "nginx",
    "extensions": ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jnlp"]
  },
  "application/x-javascript": {
    "compressible": true
  },
  "application/x-keepass2": {
    "extensions": ["kdbx"]
  },
  "application/x-latex": {
    "source": "apache",
    "compressible": false,
    "extensions": ["latex"]
  },
  "application/x-lua-bytecode": {
    "extensions": ["luac"]
  },
  "application/x-lzh-compressed": {
    "source": "apache",
    "extensions": ["lzh", "lha"]
  },
  "application/x-makeself": {
    "source": "nginx",
    "extensions": ["run"]
  },
  "application/x-mie": {
    "source": "apache",
    "extensions": ["mie"]
  },
  "application/x-mobipocket-ebook": {
    "source": "apache",
    "extensions": ["prc", "mobi"]
  },
  "application/x-mpegurl": {
    "compressible": false
  },
  "application/x-ms-application": {
    "source": "apache",
    "extensions": ["application"]
  },
  "application/x-ms-shortcut": {
    "source": "apache",
    "extensions": ["lnk"]
  },
  "application/x-ms-wmd": {
    "source": "apache",
    "extensions": ["wmd"]
  },
  "application/x-ms-wmz": {
    "source": "apache",
    "extensions": ["wmz"]
  },
  "application/x-ms-xbap": {
    "source": "apache",
    "extensions": ["xbap"]
  },
  "application/x-msaccess": {
    "source": "apache",
    "extensions": ["mdb"]
  },
  "application/x-msbinder": {
    "source": "apache",
    "extensions": ["obd"]
  },
  "application/x-mscardfile": {
    "source": "apache",
    "extensions": ["crd"]
  },
  "application/x-msclip": {
    "source": "apache",
    "extensions": ["clp"]
  },
  "application/x-msdos-program": {
    "extensions": ["exe"]
  },
  "application/x-msdownload": {
    "source": "apache",
    "extensions": ["exe", "dll", "com", "bat", "msi"]
  },
  "application/x-msmediaview": {
    "source": "apache",
    "extensions": ["mvb", "m13", "m14"]
  },
  "application/x-msmetafile": {
    "source": "apache",
    "extensions": ["wmf", "wmz", "emf", "emz"]
  },
  "application/x-msmoney": {
    "source": "apache",
    "extensions": ["mny"]
  },
  "application/x-mspublisher": {
    "source": "apache",
    "extensions": ["pub"]
  },
  "application/x-msschedule": {
    "source": "apache",
    "extensions": ["scd"]
  },
  "application/x-msterminal": {
    "source": "apache",
    "extensions": ["trm"]
  },
  "application/x-mswrite": {
    "source": "apache",
    "extensions": ["wri"]
  },
  "application/x-netcdf": {
    "source": "apache",
    "extensions": ["nc", "cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    "compressible": true,
    "extensions": ["pac"]
  },
  "application/x-nzb": {
    "source": "apache",
    "extensions": ["nzb"]
  },
  "application/x-perl": {
    "source": "nginx",
    "extensions": ["pl", "pm"]
  },
  "application/x-pilot": {
    "source": "nginx",
    "extensions": ["prc", "pdb"]
  },
  "application/x-pkcs12": {
    "source": "apache",
    "compressible": false,
    "extensions": ["p12", "pfx"]
  },
  "application/x-pkcs7-certificates": {
    "source": "apache",
    "extensions": ["p7b", "spc"]
  },
  "application/x-pkcs7-certreqresp": {
    "source": "apache",
    "extensions": ["p7r"]
  },
  "application/x-pki-message": {
    "source": "iana"
  },
  "application/x-rar-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["rar"]
  },
  "application/x-redhat-package-manager": {
    "source": "nginx",
    "extensions": ["rpm"]
  },
  "application/x-research-info-systems": {
    "source": "apache",
    "extensions": ["ris"]
  },
  "application/x-sea": {
    "source": "nginx",
    "extensions": ["sea"]
  },
  "application/x-sh": {
    "source": "apache",
    "compressible": true,
    "extensions": ["sh"]
  },
  "application/x-shar": {
    "source": "apache",
    "extensions": ["shar"]
  },
  "application/x-shockwave-flash": {
    "source": "apache",
    "compressible": false,
    "extensions": ["swf"]
  },
  "application/x-silverlight-app": {
    "source": "apache",
    "extensions": ["xap"]
  },
  "application/x-sql": {
    "source": "apache",
    "extensions": ["sql"]
  },
  "application/x-stuffit": {
    "source": "apache",
    "compressible": false,
    "extensions": ["sit"]
  },
  "application/x-stuffitx": {
    "source": "apache",
    "extensions": ["sitx"]
  },
  "application/x-subrip": {
    "source": "apache",
    "extensions": ["srt"]
  },
  "application/x-sv4cpio": {
    "source": "apache",
    "extensions": ["sv4cpio"]
  },
  "application/x-sv4crc": {
    "source": "apache",
    "extensions": ["sv4crc"]
  },
  "application/x-t3vm-image": {
    "source": "apache",
    "extensions": ["t3"]
  },
  "application/x-tads": {
    "source": "apache",
    "extensions": ["gam"]
  },
  "application/x-tar": {
    "source": "apache",
    "compressible": true,
    "extensions": ["tar"]
  },
  "application/x-tcl": {
    "source": "apache",
    "extensions": ["tcl", "tk"]
  },
  "application/x-tex": {
    "source": "apache",
    "extensions": ["tex"]
  },
  "application/x-tex-tfm": {
    "source": "apache",
    "extensions": ["tfm"]
  },
  "application/x-texinfo": {
    "source": "apache",
    "extensions": ["texinfo", "texi"]
  },
  "application/x-tgif": {
    "source": "apache",
    "extensions": ["obj"]
  },
  "application/x-ustar": {
    "source": "apache",
    "extensions": ["ustar"]
  },
  "application/x-virtualbox-hdd": {
    "compressible": true,
    "extensions": ["hdd"]
  },
  "application/x-virtualbox-ova": {
    "compressible": true,
    "extensions": ["ova"]
  },
  "application/x-virtualbox-ovf": {
    "compressible": true,
    "extensions": ["ovf"]
  },
  "application/x-virtualbox-vbox": {
    "compressible": true,
    "extensions": ["vbox"]
  },
  "application/x-virtualbox-vbox-extpack": {
    "compressible": false,
    "extensions": ["vbox-extpack"]
  },
  "application/x-virtualbox-vdi": {
    "compressible": true,
    "extensions": ["vdi"]
  },
  "application/x-virtualbox-vhd": {
    "compressible": true,
    "extensions": ["vhd"]
  },
  "application/x-virtualbox-vmdk": {
    "compressible": true,
    "extensions": ["vmdk"]
  },
  "application/x-wais-source": {
    "source": "apache",
    "extensions": ["src"]
  },
  "application/x-web-app-manifest+json": {
    "compressible": true,
    "extensions": ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    "source": "iana",
    "compressible": true
  },
  "application/x-x509-ca-cert": {
    "source": "iana",
    "extensions": ["der", "crt", "pem"]
  },
  "application/x-x509-ca-ra-cert": {
    "source": "iana"
  },
  "application/x-x509-next-ca-cert": {
    "source": "iana"
  },
  "application/x-xfig": {
    "source": "apache",
    "extensions": ["fig"]
  },
  "application/x-xliff+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/x-xpinstall": {
    "source": "apache",
    "compressible": false,
    "extensions": ["xpi"]
  },
  "application/x-xz": {
    "source": "apache",
    "extensions": ["xz"]
  },
  "application/x-zmachine": {
    "source": "apache",
    "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
  },
  "application/x400-bp": {
    "source": "iana"
  },
  "application/xacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xaml+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xaml"]
  },
  "application/xcap-att+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xav"]
  },
  "application/xcap-caps+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xca"]
  },
  "application/xcap-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/xcap-el+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xel"]
  },
  "application/xcap-error+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcap-ns+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xns"]
  },
  "application/xcon-conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcon-conference-info-diff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xenc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xenc"]
  },
  "application/xfdf": {
    "source": "iana",
    "extensions": ["xfdf"]
  },
  "application/xhtml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtml", "xht"]
  },
  "application/xhtml-voice+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/xliff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml", "xsl", "xsd", "rng"]
  },
  "application/xml-dtd": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    "source": "iana"
  },
  "application/xml-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xmpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xop+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xop"]
  },
  "application/xproc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xpl"]
  },
  "application/xslt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xsl", "xslt"]
  },
  "application/xspf+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xspf"]
  },
  "application/xv+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mxml", "xhvml", "xvml", "xvm"]
  },
  "application/yang": {
    "source": "iana",
    "extensions": ["yang"]
  },
  "application/yang-data+cbor": {
    "source": "iana"
  },
  "application/yang-data+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yin+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["yin"]
  },
  "application/zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["zip"]
  },
  "application/zlib": {
    "source": "iana"
  },
  "application/zstd": {
    "source": "iana"
  },
  "audio/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "audio/32kadpcm": {
    "source": "iana"
  },
  "audio/3gpp": {
    "source": "iana",
    "compressible": false,
    "extensions": ["3gpp"]
  },
  "audio/3gpp2": {
    "source": "iana"
  },
  "audio/aac": {
    "source": "iana",
    "extensions": ["adts", "aac"]
  },
  "audio/ac3": {
    "source": "iana"
  },
  "audio/adpcm": {
    "source": "apache",
    "extensions": ["adp"]
  },
  "audio/amr": {
    "source": "iana",
    "extensions": ["amr"]
  },
  "audio/amr-wb": {
    "source": "iana"
  },
  "audio/amr-wb+": {
    "source": "iana"
  },
  "audio/aptx": {
    "source": "iana"
  },
  "audio/asc": {
    "source": "iana"
  },
  "audio/atrac-advanced-lossless": {
    "source": "iana"
  },
  "audio/atrac-x": {
    "source": "iana"
  },
  "audio/atrac3": {
    "source": "iana"
  },
  "audio/basic": {
    "source": "iana",
    "compressible": false,
    "extensions": ["au", "snd"]
  },
  "audio/bv16": {
    "source": "iana"
  },
  "audio/bv32": {
    "source": "iana"
  },
  "audio/clearmode": {
    "source": "iana"
  },
  "audio/cn": {
    "source": "iana"
  },
  "audio/dat12": {
    "source": "iana"
  },
  "audio/dls": {
    "source": "iana"
  },
  "audio/dsr-es201108": {
    "source": "iana"
  },
  "audio/dsr-es202050": {
    "source": "iana"
  },
  "audio/dsr-es202211": {
    "source": "iana"
  },
  "audio/dsr-es202212": {
    "source": "iana"
  },
  "audio/dv": {
    "source": "iana"
  },
  "audio/dvi4": {
    "source": "iana"
  },
  "audio/eac3": {
    "source": "iana"
  },
  "audio/encaprtp": {
    "source": "iana"
  },
  "audio/evrc": {
    "source": "iana"
  },
  "audio/evrc-qcp": {
    "source": "iana"
  },
  "audio/evrc0": {
    "source": "iana"
  },
  "audio/evrc1": {
    "source": "iana"
  },
  "audio/evrcb": {
    "source": "iana"
  },
  "audio/evrcb0": {
    "source": "iana"
  },
  "audio/evrcb1": {
    "source": "iana"
  },
  "audio/evrcnw": {
    "source": "iana"
  },
  "audio/evrcnw0": {
    "source": "iana"
  },
  "audio/evrcnw1": {
    "source": "iana"
  },
  "audio/evrcwb": {
    "source": "iana"
  },
  "audio/evrcwb0": {
    "source": "iana"
  },
  "audio/evrcwb1": {
    "source": "iana"
  },
  "audio/evs": {
    "source": "iana"
  },
  "audio/flexfec": {
    "source": "iana"
  },
  "audio/fwdred": {
    "source": "iana"
  },
  "audio/g711-0": {
    "source": "iana"
  },
  "audio/g719": {
    "source": "iana"
  },
  "audio/g722": {
    "source": "iana"
  },
  "audio/g7221": {
    "source": "iana"
  },
  "audio/g723": {
    "source": "iana"
  },
  "audio/g726-16": {
    "source": "iana"
  },
  "audio/g726-24": {
    "source": "iana"
  },
  "audio/g726-32": {
    "source": "iana"
  },
  "audio/g726-40": {
    "source": "iana"
  },
  "audio/g728": {
    "source": "iana"
  },
  "audio/g729": {
    "source": "iana"
  },
  "audio/g7291": {
    "source": "iana"
  },
  "audio/g729d": {
    "source": "iana"
  },
  "audio/g729e": {
    "source": "iana"
  },
  "audio/gsm": {
    "source": "iana"
  },
  "audio/gsm-efr": {
    "source": "iana"
  },
  "audio/gsm-hr-08": {
    "source": "iana"
  },
  "audio/ilbc": {
    "source": "iana"
  },
  "audio/ip-mr_v2.5": {
    "source": "iana"
  },
  "audio/isac": {
    "source": "apache"
  },
  "audio/l16": {
    "source": "iana"
  },
  "audio/l20": {
    "source": "iana"
  },
  "audio/l24": {
    "source": "iana",
    "compressible": false
  },
  "audio/l8": {
    "source": "iana"
  },
  "audio/lpc": {
    "source": "iana"
  },
  "audio/melp": {
    "source": "iana"
  },
  "audio/melp1200": {
    "source": "iana"
  },
  "audio/melp2400": {
    "source": "iana"
  },
  "audio/melp600": {
    "source": "iana"
  },
  "audio/mhas": {
    "source": "iana"
  },
  "audio/midi": {
    "source": "apache",
    "extensions": ["mid", "midi", "kar", "rmi"]
  },
  "audio/mobile-xmf": {
    "source": "iana",
    "extensions": ["mxmf"]
  },
  "audio/mp3": {
    "compressible": false,
    "extensions": ["mp3"]
  },
  "audio/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["m4a", "mp4a"]
  },
  "audio/mp4a-latm": {
    "source": "iana"
  },
  "audio/mpa": {
    "source": "iana"
  },
  "audio/mpa-robust": {
    "source": "iana"
  },
  "audio/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
  },
  "audio/mpeg4-generic": {
    "source": "iana"
  },
  "audio/musepack": {
    "source": "apache"
  },
  "audio/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["oga", "ogg", "spx", "opus"]
  },
  "audio/opus": {
    "source": "iana"
  },
  "audio/parityfec": {
    "source": "iana"
  },
  "audio/pcma": {
    "source": "iana"
  },
  "audio/pcma-wb": {
    "source": "iana"
  },
  "audio/pcmu": {
    "source": "iana"
  },
  "audio/pcmu-wb": {
    "source": "iana"
  },
  "audio/prs.sid": {
    "source": "iana"
  },
  "audio/qcelp": {
    "source": "iana"
  },
  "audio/raptorfec": {
    "source": "iana"
  },
  "audio/red": {
    "source": "iana"
  },
  "audio/rtp-enc-aescm128": {
    "source": "iana"
  },
  "audio/rtp-midi": {
    "source": "iana"
  },
  "audio/rtploopback": {
    "source": "iana"
  },
  "audio/rtx": {
    "source": "iana"
  },
  "audio/s3m": {
    "source": "apache",
    "extensions": ["s3m"]
  },
  "audio/scip": {
    "source": "iana"
  },
  "audio/silk": {
    "source": "apache",
    "extensions": ["sil"]
  },
  "audio/smv": {
    "source": "iana"
  },
  "audio/smv-qcp": {
    "source": "iana"
  },
  "audio/smv0": {
    "source": "iana"
  },
  "audio/sofa": {
    "source": "iana"
  },
  "audio/sp-midi": {
    "source": "iana"
  },
  "audio/speex": {
    "source": "iana"
  },
  "audio/t140c": {
    "source": "iana"
  },
  "audio/t38": {
    "source": "iana"
  },
  "audio/telephone-event": {
    "source": "iana"
  },
  "audio/tetra_acelp": {
    "source": "iana"
  },
  "audio/tetra_acelp_bb": {
    "source": "iana"
  },
  "audio/tone": {
    "source": "iana"
  },
  "audio/tsvcis": {
    "source": "iana"
  },
  "audio/uemclip": {
    "source": "iana"
  },
  "audio/ulpfec": {
    "source": "iana"
  },
  "audio/usac": {
    "source": "iana"
  },
  "audio/vdvi": {
    "source": "iana"
  },
  "audio/vmr-wb": {
    "source": "iana"
  },
  "audio/vnd.3gpp.iufp": {
    "source": "iana"
  },
  "audio/vnd.4sb": {
    "source": "iana"
  },
  "audio/vnd.audiokoz": {
    "source": "iana"
  },
  "audio/vnd.celp": {
    "source": "iana"
  },
  "audio/vnd.cisco.nse": {
    "source": "iana"
  },
  "audio/vnd.cmles.radio-events": {
    "source": "iana"
  },
  "audio/vnd.cns.anp1": {
    "source": "iana"
  },
  "audio/vnd.cns.inf1": {
    "source": "iana"
  },
  "audio/vnd.dece.audio": {
    "source": "iana",
    "extensions": ["uva", "uvva"]
  },
  "audio/vnd.digital-winds": {
    "source": "iana",
    "extensions": ["eol"]
  },
  "audio/vnd.dlna.adts": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    "source": "iana"
  },
  "audio/vnd.dolby.mlp": {
    "source": "iana"
  },
  "audio/vnd.dolby.mps": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2x": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2z": {
    "source": "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    "source": "iana"
  },
  "audio/vnd.dra": {
    "source": "iana",
    "extensions": ["dra"]
  },
  "audio/vnd.dts": {
    "source": "iana",
    "extensions": ["dts"]
  },
  "audio/vnd.dts.hd": {
    "source": "iana",
    "extensions": ["dtshd"]
  },
  "audio/vnd.dts.uhd": {
    "source": "iana"
  },
  "audio/vnd.dvb.file": {
    "source": "iana"
  },
  "audio/vnd.everad.plj": {
    "source": "iana"
  },
  "audio/vnd.hns.audio": {
    "source": "iana"
  },
  "audio/vnd.lucent.voice": {
    "source": "iana",
    "extensions": ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    "source": "iana",
    "extensions": ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    "source": "iana"
  },
  "audio/vnd.nortel.vbk": {
    "source": "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    "source": "iana",
    "extensions": ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    "source": "iana",
    "extensions": ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    "source": "iana",
    "extensions": ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    "source": "iana"
  },
  "audio/vnd.presonus.multitrack": {
    "source": "iana"
  },
  "audio/vnd.qcelp": {
    "source": "apache"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    "source": "iana"
  },
  "audio/vnd.rip": {
    "source": "iana",
    "extensions": ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    "compressible": false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    "source": "iana"
  },
  "audio/vnd.vmx.cvsd": {
    "source": "iana"
  },
  "audio/vnd.wave": {
    "compressible": false
  },
  "audio/vorbis": {
    "source": "iana",
    "compressible": false
  },
  "audio/vorbis-config": {
    "source": "iana"
  },
  "audio/wav": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/wave": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["weba"]
  },
  "audio/x-aac": {
    "source": "apache",
    "compressible": false,
    "extensions": ["aac"]
  },
  "audio/x-aiff": {
    "source": "apache",
    "extensions": ["aif", "aiff", "aifc"]
  },
  "audio/x-caf": {
    "source": "apache",
    "compressible": false,
    "extensions": ["caf"]
  },
  "audio/x-flac": {
    "source": "apache",
    "extensions": ["flac"]
  },
  "audio/x-m4a": {
    "source": "nginx",
    "extensions": ["m4a"]
  },
  "audio/x-matroska": {
    "source": "apache",
    "extensions": ["mka"]
  },
  "audio/x-mpegurl": {
    "source": "apache",
    "extensions": ["m3u"]
  },
  "audio/x-ms-wax": {
    "source": "apache",
    "extensions": ["wax"]
  },
  "audio/x-ms-wma": {
    "source": "apache",
    "extensions": ["wma"]
  },
  "audio/x-pn-realaudio": {
    "source": "apache",
    "extensions": ["ram", "ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    "source": "apache",
    "extensions": ["rmp"]
  },
  "audio/x-realaudio": {
    "source": "nginx",
    "extensions": ["ra"]
  },
  "audio/x-tta": {
    "source": "apache"
  },
  "audio/x-wav": {
    "source": "apache",
    "extensions": ["wav"]
  },
  "audio/xm": {
    "source": "apache",
    "extensions": ["xm"]
  },
  "chemical/x-cdx": {
    "source": "apache",
    "extensions": ["cdx"]
  },
  "chemical/x-cif": {
    "source": "apache",
    "extensions": ["cif"]
  },
  "chemical/x-cmdf": {
    "source": "apache",
    "extensions": ["cmdf"]
  },
  "chemical/x-cml": {
    "source": "apache",
    "extensions": ["cml"]
  },
  "chemical/x-csml": {
    "source": "apache",
    "extensions": ["csml"]
  },
  "chemical/x-pdb": {
    "source": "apache"
  },
  "chemical/x-xyz": {
    "source": "apache",
    "extensions": ["xyz"]
  },
  "font/collection": {
    "source": "iana",
    "extensions": ["ttc"]
  },
  "font/otf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["otf"]
  },
  "font/sfnt": {
    "source": "iana"
  },
  "font/ttf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttf"]
  },
  "font/woff": {
    "source": "iana",
    "extensions": ["woff"]
  },
  "font/woff2": {
    "source": "iana",
    "extensions": ["woff2"]
  },
  "image/aces": {
    "source": "iana",
    "extensions": ["exr"]
  },
  "image/apng": {
    "source": "iana",
    "compressible": false,
    "extensions": ["apng"]
  },
  "image/avci": {
    "source": "iana",
    "extensions": ["avci"]
  },
  "image/avcs": {
    "source": "iana",
    "extensions": ["avcs"]
  },
  "image/avif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["avif"]
  },
  "image/bmp": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmp", "dib"]
  },
  "image/cgm": {
    "source": "iana",
    "extensions": ["cgm"]
  },
  "image/dicom-rle": {
    "source": "iana",
    "extensions": ["drle"]
  },
  "image/dpx": {
    "source": "iana",
    "extensions": ["dpx"]
  },
  "image/emf": {
    "source": "iana",
    "extensions": ["emf"]
  },
  "image/fits": {
    "source": "iana",
    "extensions": ["fits"]
  },
  "image/g3fax": {
    "source": "iana",
    "extensions": ["g3"]
  },
  "image/gif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gif"]
  },
  "image/heic": {
    "source": "iana",
    "extensions": ["heic"]
  },
  "image/heic-sequence": {
    "source": "iana",
    "extensions": ["heics"]
  },
  "image/heif": {
    "source": "iana",
    "extensions": ["heif"]
  },
  "image/heif-sequence": {
    "source": "iana",
    "extensions": ["heifs"]
  },
  "image/hej2k": {
    "source": "iana",
    "extensions": ["hej2"]
  },
  "image/hsj2": {
    "source": "iana",
    "extensions": ["hsj2"]
  },
  "image/ief": {
    "source": "iana",
    "extensions": ["ief"]
  },
  "image/jls": {
    "source": "iana",
    "extensions": ["jls"]
  },
  "image/jp2": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jp2", "jpg2"]
  },
  "image/jpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpeg", "jpg", "jpe"]
  },
  "image/jph": {
    "source": "iana",
    "extensions": ["jph"]
  },
  "image/jphc": {
    "source": "iana",
    "extensions": ["jhc"]
  },
  "image/jpm": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpm", "jpgm"]
  },
  "image/jpx": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpx", "jpf"]
  },
  "image/jxr": {
    "source": "iana",
    "extensions": ["jxr"]
  },
  "image/jxra": {
    "source": "iana",
    "extensions": ["jxra"]
  },
  "image/jxrs": {
    "source": "iana",
    "extensions": ["jxrs"]
  },
  "image/jxs": {
    "source": "iana",
    "extensions": ["jxs"]
  },
  "image/jxsc": {
    "source": "iana",
    "extensions": ["jxsc"]
  },
  "image/jxsi": {
    "source": "iana",
    "extensions": ["jxsi"]
  },
  "image/jxss": {
    "source": "iana",
    "extensions": ["jxss"]
  },
  "image/ktx": {
    "source": "iana",
    "extensions": ["ktx"]
  },
  "image/ktx2": {
    "source": "iana",
    "extensions": ["ktx2"]
  },
  "image/naplps": {
    "source": "iana"
  },
  "image/pjpeg": {
    "compressible": false
  },
  "image/png": {
    "source": "iana",
    "compressible": false,
    "extensions": ["png"]
  },
  "image/prs.btif": {
    "source": "iana",
    "extensions": ["btif", "btf"]
  },
  "image/prs.pti": {
    "source": "iana",
    "extensions": ["pti"]
  },
  "image/pwg-raster": {
    "source": "iana"
  },
  "image/sgi": {
    "source": "apache",
    "extensions": ["sgi"]
  },
  "image/svg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["svg", "svgz"]
  },
  "image/t38": {
    "source": "iana",
    "extensions": ["t38"]
  },
  "image/tiff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["tif", "tiff"]
  },
  "image/tiff-fx": {
    "source": "iana",
    "extensions": ["tfx"]
  },
  "image/vnd.adobe.photoshop": {
    "source": "iana",
    "compressible": true,
    "extensions": ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    "source": "iana",
    "extensions": ["azv"]
  },
  "image/vnd.cns.inf2": {
    "source": "iana"
  },
  "image/vnd.dece.graphic": {
    "source": "iana",
    "extensions": ["uvi", "uvvi", "uvg", "uvvg"]
  },
  "image/vnd.djvu": {
    "source": "iana",
    "extensions": ["djvu", "djv"]
  },
  "image/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "image/vnd.dwg": {
    "source": "iana",
    "extensions": ["dwg"]
  },
  "image/vnd.dxf": {
    "source": "iana",
    "extensions": ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    "source": "iana",
    "extensions": ["fbs"]
  },
  "image/vnd.fpx": {
    "source": "iana",
    "extensions": ["fpx"]
  },
  "image/vnd.fst": {
    "source": "iana",
    "extensions": ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    "source": "iana",
    "extensions": ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    "source": "iana",
    "extensions": ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    "source": "iana"
  },
  "image/vnd.microsoft.icon": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/vnd.mix": {
    "source": "iana"
  },
  "image/vnd.mozilla.apng": {
    "source": "iana"
  },
  "image/vnd.ms-dds": {
    "compressible": true,
    "extensions": ["dds"]
  },
  "image/vnd.ms-modi": {
    "source": "iana",
    "extensions": ["mdi"]
  },
  "image/vnd.ms-photo": {
    "source": "apache",
    "extensions": ["wdp"]
  },
  "image/vnd.net-fpx": {
    "source": "iana",
    "extensions": ["npx"]
  },
  "image/vnd.pco.b16": {
    "source": "iana",
    "extensions": ["b16"]
  },
  "image/vnd.radiance": {
    "source": "iana"
  },
  "image/vnd.sealed.png": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    "source": "iana"
  },
  "image/vnd.svf": {
    "source": "iana"
  },
  "image/vnd.tencent.tap": {
    "source": "iana",
    "extensions": ["tap"]
  },
  "image/vnd.valve.source.texture": {
    "source": "iana",
    "extensions": ["vtf"]
  },
  "image/vnd.wap.wbmp": {
    "source": "iana",
    "extensions": ["wbmp"]
  },
  "image/vnd.xiff": {
    "source": "iana",
    "extensions": ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    "source": "iana",
    "extensions": ["pcx"]
  },
  "image/webp": {
    "source": "iana",
    "extensions": ["webp"]
  },
  "image/wmf": {
    "source": "iana",
    "extensions": ["wmf"]
  },
  "image/x-3ds": {
    "source": "apache",
    "extensions": ["3ds"]
  },
  "image/x-cmu-raster": {
    "source": "apache",
    "extensions": ["ras"]
  },
  "image/x-cmx": {
    "source": "apache",
    "extensions": ["cmx"]
  },
  "image/x-freehand": {
    "source": "apache",
    "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"]
  },
  "image/x-icon": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/x-jng": {
    "source": "nginx",
    "extensions": ["jng"]
  },
  "image/x-mrsid-image": {
    "source": "apache",
    "extensions": ["sid"]
  },
  "image/x-ms-bmp": {
    "source": "nginx",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/x-pcx": {
    "source": "apache",
    "extensions": ["pcx"]
  },
  "image/x-pict": {
    "source": "apache",
    "extensions": ["pic", "pct"]
  },
  "image/x-portable-anymap": {
    "source": "apache",
    "extensions": ["pnm"]
  },
  "image/x-portable-bitmap": {
    "source": "apache",
    "extensions": ["pbm"]
  },
  "image/x-portable-graymap": {
    "source": "apache",
    "extensions": ["pgm"]
  },
  "image/x-portable-pixmap": {
    "source": "apache",
    "extensions": ["ppm"]
  },
  "image/x-rgb": {
    "source": "apache",
    "extensions": ["rgb"]
  },
  "image/x-tga": {
    "source": "apache",
    "extensions": ["tga"]
  },
  "image/x-xbitmap": {
    "source": "apache",
    "extensions": ["xbm"]
  },
  "image/x-xcf": {
    "compressible": false
  },
  "image/x-xpixmap": {
    "source": "apache",
    "extensions": ["xpm"]
  },
  "image/x-xwindowdump": {
    "source": "apache",
    "extensions": ["xwd"]
  },
  "message/bhttp": {
    "source": "iana"
  },
  "message/cpim": {
    "source": "iana"
  },
  "message/delivery-status": {
    "source": "iana"
  },
  "message/disposition-notification": {
    "source": "iana",
    "extensions": [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    "source": "iana"
  },
  "message/feedback-report": {
    "source": "iana"
  },
  "message/global": {
    "source": "iana",
    "extensions": ["u8msg"]
  },
  "message/global-delivery-status": {
    "source": "iana",
    "extensions": ["u8dsn"]
  },
  "message/global-disposition-notification": {
    "source": "iana",
    "extensions": ["u8mdn"]
  },
  "message/global-headers": {
    "source": "iana",
    "extensions": ["u8hdr"]
  },
  "message/http": {
    "source": "iana",
    "compressible": false
  },
  "message/imdn+xml": {
    "source": "iana",
    "compressible": true
  },
  "message/news": {
    "source": "apache"
  },
  "message/partial": {
    "source": "iana",
    "compressible": false
  },
  "message/rfc822": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eml", "mime"]
  },
  "message/s-http": {
    "source": "apache"
  },
  "message/sip": {
    "source": "iana"
  },
  "message/sipfrag": {
    "source": "iana"
  },
  "message/tracking-status": {
    "source": "iana"
  },
  "message/vnd.si.simp": {
    "source": "apache"
  },
  "message/vnd.wfa.wsc": {
    "source": "iana",
    "extensions": ["wsc"]
  },
  "model/3mf": {
    "source": "iana",
    "extensions": ["3mf"]
  },
  "model/e57": {
    "source": "iana"
  },
  "model/gltf+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gltf"]
  },
  "model/gltf-binary": {
    "source": "iana",
    "compressible": true,
    "extensions": ["glb"]
  },
  "model/iges": {
    "source": "iana",
    "compressible": false,
    "extensions": ["igs", "iges"]
  },
  "model/jt": {
    "source": "iana",
    "extensions": ["jt"]
  },
  "model/mesh": {
    "source": "iana",
    "compressible": false,
    "extensions": ["msh", "mesh", "silo"]
  },
  "model/mtl": {
    "source": "iana",
    "extensions": ["mtl"]
  },
  "model/obj": {
    "source": "iana",
    "extensions": ["obj"]
  },
  "model/prc": {
    "source": "iana",
    "extensions": ["prc"]
  },
  "model/step": {
    "source": "iana"
  },
  "model/step+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["stpx"]
  },
  "model/step+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["stpz"]
  },
  "model/step-xml+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["stpxz"]
  },
  "model/stl": {
    "source": "iana",
    "extensions": ["stl"]
  },
  "model/u3d": {
    "source": "iana",
    "extensions": ["u3d"]
  },
  "model/vnd.cld": {
    "source": "iana",
    "extensions": ["cld"]
  },
  "model/vnd.collada+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dae"]
  },
  "model/vnd.dwf": {
    "source": "iana",
    "extensions": ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    "source": "iana"
  },
  "model/vnd.gdl": {
    "source": "iana",
    "extensions": ["gdl"]
  },
  "model/vnd.gs-gdl": {
    "source": "apache"
  },
  "model/vnd.gs.gdl": {
    "source": "iana"
  },
  "model/vnd.gtw": {
    "source": "iana",
    "extensions": ["gtw"]
  },
  "model/vnd.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "model/vnd.mts": {
    "source": "iana",
    "extensions": ["mts"]
  },
  "model/vnd.opengex": {
    "source": "iana",
    "extensions": ["ogex"]
  },
  "model/vnd.parasolid.transmit.binary": {
    "source": "iana",
    "extensions": ["x_b"]
  },
  "model/vnd.parasolid.transmit.text": {
    "source": "iana",
    "extensions": ["x_t"]
  },
  "model/vnd.pytha.pyox": {
    "source": "iana",
    "extensions": ["pyo", "pyox"]
  },
  "model/vnd.rosette.annotated-data-model": {
    "source": "iana"
  },
  "model/vnd.sap.vds": {
    "source": "iana",
    "extensions": ["vds"]
  },
  "model/vnd.usda": {
    "source": "iana",
    "extensions": ["usda"]
  },
  "model/vnd.usdz+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["usdz"]
  },
  "model/vnd.valve.source.compiled-map": {
    "source": "iana",
    "extensions": ["bsp"]
  },
  "model/vnd.vtu": {
    "source": "iana",
    "extensions": ["vtu"]
  },
  "model/vrml": {
    "source": "iana",
    "compressible": false,
    "extensions": ["wrl", "vrml"]
  },
  "model/x3d+binary": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3db", "x3dbz"]
  },
  "model/x3d+fastinfoset": {
    "source": "iana",
    "extensions": ["x3db"]
  },
  "model/x3d+vrml": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3dv", "x3dvz"]
  },
  "model/x3d+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["x3d", "x3dz"]
  },
  "model/x3d-vrml": {
    "source": "iana",
    "extensions": ["x3dv"]
  },
  "multipart/alternative": {
    "source": "iana",
    "compressible": false
  },
  "multipart/appledouble": {
    "source": "iana"
  },
  "multipart/byteranges": {
    "source": "iana"
  },
  "multipart/digest": {
    "source": "iana"
  },
  "multipart/encrypted": {
    "source": "iana",
    "compressible": false
  },
  "multipart/form-data": {
    "source": "iana",
    "compressible": false
  },
  "multipart/header-set": {
    "source": "iana"
  },
  "multipart/mixed": {
    "source": "iana"
  },
  "multipart/multilingual": {
    "source": "iana"
  },
  "multipart/parallel": {
    "source": "iana"
  },
  "multipart/related": {
    "source": "iana",
    "compressible": false
  },
  "multipart/report": {
    "source": "iana"
  },
  "multipart/signed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/vnd.bint.med-plus": {
    "source": "iana"
  },
  "multipart/voice-message": {
    "source": "iana"
  },
  "multipart/x-mixed-replace": {
    "source": "iana"
  },
  "text/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "text/cache-manifest": {
    "source": "iana",
    "compressible": true,
    "extensions": ["appcache", "manifest"]
  },
  "text/calendar": {
    "source": "iana",
    "extensions": ["ics", "ifb"]
  },
  "text/calender": {
    "compressible": true
  },
  "text/cmd": {
    "compressible": true
  },
  "text/coffeescript": {
    "extensions": ["coffee", "litcoffee"]
  },
  "text/cql": {
    "source": "iana"
  },
  "text/cql-expression": {
    "source": "iana"
  },
  "text/cql-identifier": {
    "source": "iana"
  },
  "text/css": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["css"]
  },
  "text/csv": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csv"]
  },
  "text/csv-schema": {
    "source": "iana"
  },
  "text/directory": {
    "source": "iana"
  },
  "text/dns": {
    "source": "iana"
  },
  "text/ecmascript": {
    "source": "apache"
  },
  "text/encaprtp": {
    "source": "iana"
  },
  "text/enriched": {
    "source": "iana"
  },
  "text/fhirpath": {
    "source": "iana"
  },
  "text/flexfec": {
    "source": "iana"
  },
  "text/fwdred": {
    "source": "iana"
  },
  "text/gff3": {
    "source": "iana"
  },
  "text/grammar-ref-list": {
    "source": "iana"
  },
  "text/hl7v2": {
    "source": "iana"
  },
  "text/html": {
    "source": "iana",
    "compressible": true,
    "extensions": ["html", "htm", "shtml"]
  },
  "text/jade": {
    "extensions": ["jade"]
  },
  "text/javascript": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js", "mjs"]
  },
  "text/jcr-cnd": {
    "source": "iana"
  },
  "text/jsx": {
    "compressible": true,
    "extensions": ["jsx"]
  },
  "text/less": {
    "compressible": true,
    "extensions": ["less"]
  },
  "text/markdown": {
    "source": "iana",
    "compressible": true,
    "extensions": ["md", "markdown"]
  },
  "text/mathml": {
    "source": "nginx",
    "extensions": ["mml"]
  },
  "text/mdx": {
    "compressible": true,
    "extensions": ["mdx"]
  },
  "text/mizar": {
    "source": "iana"
  },
  "text/n3": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["n3"]
  },
  "text/parameters": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/parityfec": {
    "source": "iana"
  },
  "text/plain": {
    "source": "iana",
    "compressible": true,
    "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
  },
  "text/provenance-notation": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    "source": "iana"
  },
  "text/prs.lines.tag": {
    "source": "iana",
    "extensions": ["dsc"]
  },
  "text/prs.prop.logic": {
    "source": "iana"
  },
  "text/raptorfec": {
    "source": "iana"
  },
  "text/red": {
    "source": "iana"
  },
  "text/rfc822-headers": {
    "source": "iana"
  },
  "text/richtext": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtx"]
  },
  "text/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    "source": "iana"
  },
  "text/rtploopback": {
    "source": "iana"
  },
  "text/rtx": {
    "source": "iana"
  },
  "text/sgml": {
    "source": "iana",
    "extensions": ["sgml", "sgm"]
  },
  "text/shaclc": {
    "source": "iana"
  },
  "text/shex": {
    "source": "iana",
    "extensions": ["shex"]
  },
  "text/slim": {
    "extensions": ["slim", "slm"]
  },
  "text/spdx": {
    "source": "iana",
    "extensions": ["spdx"]
  },
  "text/strings": {
    "source": "iana"
  },
  "text/stylus": {
    "extensions": ["stylus", "styl"]
  },
  "text/t140": {
    "source": "iana"
  },
  "text/tab-separated-values": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tsv"]
  },
  "text/troff": {
    "source": "iana",
    "extensions": ["t", "tr", "roff", "man", "me", "ms"]
  },
  "text/turtle": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["ttl"]
  },
  "text/ulpfec": {
    "source": "iana"
  },
  "text/uri-list": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uri", "uris", "urls"]
  },
  "text/vcard": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vcard"]
  },
  "text/vnd.a": {
    "source": "iana"
  },
  "text/vnd.abc": {
    "source": "iana"
  },
  "text/vnd.ascii-art": {
    "source": "iana"
  },
  "text/vnd.curl": {
    "source": "iana",
    "extensions": ["curl"]
  },
  "text/vnd.curl.dcurl": {
    "source": "apache",
    "extensions": ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    "source": "apache",
    "extensions": ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    "source": "apache",
    "extensions": ["scurl"]
  },
  "text/vnd.debian.copyright": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.dmclientscript": {
    "source": "iana"
  },
  "text/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.exchangeable": {
    "source": "iana"
  },
  "text/vnd.familysearch.gedcom": {
    "source": "iana",
    "extensions": ["ged"]
  },
  "text/vnd.ficlab.flt": {
    "source": "iana"
  },
  "text/vnd.fly": {
    "source": "iana",
    "extensions": ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    "source": "iana",
    "extensions": ["flx"]
  },
  "text/vnd.gml": {
    "source": "iana"
  },
  "text/vnd.graphviz": {
    "source": "iana",
    "extensions": ["gv"]
  },
  "text/vnd.hans": {
    "source": "iana"
  },
  "text/vnd.hgl": {
    "source": "iana"
  },
  "text/vnd.in3d.3dml": {
    "source": "iana",
    "extensions": ["3dml"]
  },
  "text/vnd.in3d.spot": {
    "source": "iana",
    "extensions": ["spot"]
  },
  "text/vnd.iptc.newsml": {
    "source": "iana"
  },
  "text/vnd.iptc.nitf": {
    "source": "iana"
  },
  "text/vnd.latex-z": {
    "source": "iana"
  },
  "text/vnd.motorola.reflex": {
    "source": "iana"
  },
  "text/vnd.ms-mediapackage": {
    "source": "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    "source": "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    "source": "iana"
  },
  "text/vnd.senx.warpscript": {
    "source": "iana"
  },
  "text/vnd.si.uricatalogue": {
    "source": "apache"
  },
  "text/vnd.sosi": {
    "source": "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.wap.si": {
    "source": "iana"
  },
  "text/vnd.wap.sl": {
    "source": "iana"
  },
  "text/vnd.wap.wml": {
    "source": "iana",
    "extensions": ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    "source": "iana",
    "extensions": ["wmls"]
  },
  "text/vtt": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["vtt"]
  },
  "text/wgsl": {
    "source": "iana",
    "extensions": ["wgsl"]
  },
  "text/x-asm": {
    "source": "apache",
    "extensions": ["s", "asm"]
  },
  "text/x-c": {
    "source": "apache",
    "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
  },
  "text/x-component": {
    "source": "nginx",
    "extensions": ["htc"]
  },
  "text/x-fortran": {
    "source": "apache",
    "extensions": ["f", "for", "f77", "f90"]
  },
  "text/x-gwt-rpc": {
    "compressible": true
  },
  "text/x-handlebars-template": {
    "extensions": ["hbs"]
  },
  "text/x-java-source": {
    "source": "apache",
    "extensions": ["java"]
  },
  "text/x-jquery-tmpl": {
    "compressible": true
  },
  "text/x-lua": {
    "extensions": ["lua"]
  },
  "text/x-markdown": {
    "compressible": true,
    "extensions": ["mkd"]
  },
  "text/x-nfo": {
    "source": "apache",
    "extensions": ["nfo"]
  },
  "text/x-opml": {
    "source": "apache",
    "extensions": ["opml"]
  },
  "text/x-org": {
    "compressible": true,
    "extensions": ["org"]
  },
  "text/x-pascal": {
    "source": "apache",
    "extensions": ["p", "pas"]
  },
  "text/x-processing": {
    "compressible": true,
    "extensions": ["pde"]
  },
  "text/x-sass": {
    "extensions": ["sass"]
  },
  "text/x-scss": {
    "extensions": ["scss"]
  },
  "text/x-setext": {
    "source": "apache",
    "extensions": ["etx"]
  },
  "text/x-sfv": {
    "source": "apache",
    "extensions": ["sfv"]
  },
  "text/x-suse-ymp": {
    "compressible": true,
    "extensions": ["ymp"]
  },
  "text/x-uuencode": {
    "source": "apache",
    "extensions": ["uu"]
  },
  "text/x-vcalendar": {
    "source": "apache",
    "extensions": ["vcs"]
  },
  "text/x-vcard": {
    "source": "apache",
    "extensions": ["vcf"]
  },
  "text/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml"]
  },
  "text/xml-external-parsed-entity": {
    "source": "iana"
  },
  "text/yaml": {
    "compressible": true,
    "extensions": ["yaml", "yml"]
  },
  "video/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "video/3gpp": {
    "source": "iana",
    "extensions": ["3gp", "3gpp"]
  },
  "video/3gpp-tt": {
    "source": "iana"
  },
  "video/3gpp2": {
    "source": "iana",
    "extensions": ["3g2"]
  },
  "video/av1": {
    "source": "iana"
  },
  "video/bmpeg": {
    "source": "iana"
  },
  "video/bt656": {
    "source": "iana"
  },
  "video/celb": {
    "source": "iana"
  },
  "video/dv": {
    "source": "iana"
  },
  "video/encaprtp": {
    "source": "iana"
  },
  "video/ffv1": {
    "source": "iana"
  },
  "video/flexfec": {
    "source": "iana"
  },
  "video/h261": {
    "source": "iana",
    "extensions": ["h261"]
  },
  "video/h263": {
    "source": "iana",
    "extensions": ["h263"]
  },
  "video/h263-1998": {
    "source": "iana"
  },
  "video/h263-2000": {
    "source": "iana"
  },
  "video/h264": {
    "source": "iana",
    "extensions": ["h264"]
  },
  "video/h264-rcdo": {
    "source": "iana"
  },
  "video/h264-svc": {
    "source": "iana"
  },
  "video/h265": {
    "source": "iana"
  },
  "video/h266": {
    "source": "iana"
  },
  "video/iso.segment": {
    "source": "iana",
    "extensions": ["m4s"]
  },
  "video/jpeg": {
    "source": "iana",
    "extensions": ["jpgv"]
  },
  "video/jpeg2000": {
    "source": "iana"
  },
  "video/jpm": {
    "source": "apache",
    "extensions": ["jpm", "jpgm"]
  },
  "video/jxsv": {
    "source": "iana"
  },
  "video/mj2": {
    "source": "iana",
    "extensions": ["mj2", "mjp2"]
  },
  "video/mp1s": {
    "source": "iana"
  },
  "video/mp2p": {
    "source": "iana"
  },
  "video/mp2t": {
    "source": "iana",
    "extensions": ["ts"]
  },
  "video/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mp4", "mp4v", "mpg4"]
  },
  "video/mp4v-es": {
    "source": "iana"
  },
  "video/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"]
  },
  "video/mpeg4-generic": {
    "source": "iana"
  },
  "video/mpv": {
    "source": "iana"
  },
  "video/nv": {
    "source": "iana"
  },
  "video/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogv"]
  },
  "video/parityfec": {
    "source": "iana"
  },
  "video/pointer": {
    "source": "iana"
  },
  "video/quicktime": {
    "source": "iana",
    "compressible": false,
    "extensions": ["qt", "mov"]
  },
  "video/raptorfec": {
    "source": "iana"
  },
  "video/raw": {
    "source": "iana"
  },
  "video/rtp-enc-aescm128": {
    "source": "iana"
  },
  "video/rtploopback": {
    "source": "iana"
  },
  "video/rtx": {
    "source": "iana"
  },
  "video/scip": {
    "source": "iana"
  },
  "video/smpte291": {
    "source": "iana"
  },
  "video/smpte292m": {
    "source": "iana"
  },
  "video/ulpfec": {
    "source": "iana"
  },
  "video/vc1": {
    "source": "iana"
  },
  "video/vc2": {
    "source": "iana"
  },
  "video/vnd.cctv": {
    "source": "iana"
  },
  "video/vnd.dece.hd": {
    "source": "iana",
    "extensions": ["uvh", "uvvh"]
  },
  "video/vnd.dece.mobile": {
    "source": "iana",
    "extensions": ["uvm", "uvvm"]
  },
  "video/vnd.dece.mp4": {
    "source": "iana"
  },
  "video/vnd.dece.pd": {
    "source": "iana",
    "extensions": ["uvp", "uvvp"]
  },
  "video/vnd.dece.sd": {
    "source": "iana",
    "extensions": ["uvs", "uvvs"]
  },
  "video/vnd.dece.video": {
    "source": "iana",
    "extensions": ["uvv", "uvvv"]
  },
  "video/vnd.directv.mpeg": {
    "source": "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dvb.file": {
    "source": "iana",
    "extensions": ["dvb"]
  },
  "video/vnd.fvt": {
    "source": "iana",
    "extensions": ["fvt"]
  },
  "video/vnd.hns.video": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    "source": "iana"
  },
  "video/vnd.motorola.video": {
    "source": "iana"
  },
  "video/vnd.motorola.videop": {
    "source": "iana"
  },
  "video/vnd.mpegurl": {
    "source": "iana",
    "extensions": ["mxu", "m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    "source": "iana",
    "extensions": ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    "source": "iana"
  },
  "video/vnd.nokia.mp4vr": {
    "source": "iana"
  },
  "video/vnd.nokia.videovoip": {
    "source": "iana"
  },
  "video/vnd.objectvideo": {
    "source": "iana"
  },
  "video/vnd.radgamettools.bink": {
    "source": "iana"
  },
  "video/vnd.radgamettools.smacker": {
    "source": "apache"
  },
  "video/vnd.sealed.mpeg1": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg4": {
    "source": "iana"
  },
  "video/vnd.sealed.swf": {
    "source": "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    "source": "iana"
  },
  "video/vnd.uvvu.mp4": {
    "source": "iana",
    "extensions": ["uvu", "uvvu"]
  },
  "video/vnd.vivo": {
    "source": "iana",
    "extensions": ["viv"]
  },
  "video/vnd.youtube.yt": {
    "source": "iana"
  },
  "video/vp8": {
    "source": "iana"
  },
  "video/vp9": {
    "source": "iana"
  },
  "video/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["webm"]
  },
  "video/x-f4v": {
    "source": "apache",
    "extensions": ["f4v"]
  },
  "video/x-fli": {
    "source": "apache",
    "extensions": ["fli"]
  },
  "video/x-flv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["flv"]
  },
  "video/x-m4v": {
    "source": "apache",
    "extensions": ["m4v"]
  },
  "video/x-matroska": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mkv", "mk3d", "mks"]
  },
  "video/x-mng": {
    "source": "apache",
    "extensions": ["mng"]
  },
  "video/x-ms-asf": {
    "source": "apache",
    "extensions": ["asf", "asx"]
  },
  "video/x-ms-vob": {
    "source": "apache",
    "extensions": ["vob"]
  },
  "video/x-ms-wm": {
    "source": "apache",
    "extensions": ["wm"]
  },
  "video/x-ms-wmv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["wmv"]
  },
  "video/x-ms-wmx": {
    "source": "apache",
    "extensions": ["wmx"]
  },
  "video/x-ms-wvx": {
    "source": "apache",
    "extensions": ["wvx"]
  },
  "video/x-msvideo": {
    "source": "apache",
    "extensions": ["avi"]
  },
  "video/x-sgi-movie": {
    "source": "apache",
    "extensions": ["movie"]
  },
  "video/x-smv": {
    "source": "apache",
    "extensions": ["smv"]
  },
  "x-conference/x-cooltalk": {
    "source": "apache",
    "extensions": ["ice"]
  },
  "x-shader/x-fragment": {
    "compressible": true
  },
  "x-shader/x-vertex": {
    "compressible": true
  }
};
var types = /* @__PURE__ */ new Map();
var extensions = /* @__PURE__ */ new Map();
var preference = ["nginx", "apache", void 0, "iana"];
for (const type2 of Object.keys(db_default)) {
  const mime = db_default[type2];
  const exts = mime.extensions;
  if (!exts || !exts.length) {
    continue;
  }
  extensions.set(type2, exts);
  for (const ext of exts) {
    const current = types.get(ext);
    if (current) {
      const from = preference.indexOf(db_default[current].source);
      const to = preference.indexOf(mime.source);
      if (current !== "application/octet-stream" && current !== "application/mp4" && (from > to || // @ts-ignore work around https://github.com/denoland/dnt/issues/148
      from === to && current.startsWith("application/"))) {
        continue;
      }
    }
    types.set(ext, type2);
  }
}
function getCharset(type2) {
  try {
    const [mediaType, params] = parseMediaType(type2);
    if (params?.charset) {
      return params.charset;
    }
    const entry = db_default[mediaType];
    if (entry?.charset) {
      return entry.charset;
    }
    if (mediaType.startsWith("text/")) {
      return "UTF-8";
    }
  } catch {
  }
  return void 0;
}
function formatMediaType(type2, param) {
  let serializedMediaType = "";
  const [major = "", sub] = type2.split("/");
  if (!sub) {
    if (!isToken(type2)) {
      return "";
    }
    serializedMediaType += type2.toLowerCase();
  } else {
    if (!isToken(major) || !isToken(sub)) {
      return "";
    }
    serializedMediaType += `${major.toLowerCase()}/${sub.toLowerCase()}`;
  }
  if (param) {
    param = isIterator(param) ? Object.fromEntries(param) : param;
    const attrs = Object.keys(param);
    attrs.sort();
    for (const attribute of attrs) {
      if (!isToken(attribute)) {
        return "";
      }
      const value = param[attribute];
      serializedMediaType += `; ${attribute.toLowerCase()}`;
      const needEnc = needsEncoding(value);
      if (needEnc) {
        serializedMediaType += "*";
      }
      serializedMediaType += "=";
      if (needEnc) {
        serializedMediaType += `utf-8''${encodeURIComponent(value)}`;
        continue;
      }
      if (isToken(value)) {
        serializedMediaType += value;
        continue;
      }
      serializedMediaType += `"${value.replace(/["\\]/gi, (m) => `\\${m}`)}"`;
    }
  }
  return serializedMediaType;
}
function typeByExtension(extension) {
  extension = extension.startsWith(".") ? extension.slice(1) : extension;
  return types.get(extension.toLowerCase());
}
function contentType(extensionOrType) {
  try {
    const [mediaType, params = {}] = extensionOrType.includes("/") ? parseMediaType(extensionOrType) : [typeByExtension(extensionOrType), void 0];
    if (!mediaType) {
      return void 0;
    }
    if (!("charset" in params)) {
      const charset = getCharset(mediaType);
      if (charset) {
        params.charset = charset;
      }
    }
    return formatMediaType(mediaType, params);
  } catch {
  }
  return void 0;
}
function extname(path) {
  assertPath(path);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path.length - 1; i >= 0; --i) {
    const code4 = path.charCodeAt(i);
    if (isPosixPathSeparator(code4)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code4 === CHAR_DOT) {
      if (startDot === -1) startDot = i;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function extname2(path) {
  assertPath(path);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path.length - 1; i >= start; --i) {
    const code4 = path.charCodeAt(i);
    if (isPathSeparator(code4)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code4 === CHAR_DOT) {
      if (startDot === -1) startDot = i;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function extname3(path) {
  return isWindows ? extname2(path) : extname(path);
}
function assertArgs2(from, to) {
  assertPath(from);
  assertPath(to);
  if (from === to) return "";
}
function relative(from, to) {
  assertArgs2(from, to);
  from = resolve(from);
  to = resolve(to);
  if (from === to) return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode) break;
    else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {
      if (out.length === 0) out += "..";
      else out += "/..";
    }
  }
  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
    return to.slice(toStart);
  }
}
function relative2(from, to) {
  assertArgs2(from, to);
  const fromOrig = resolve2(from);
  const toOrig = resolve2(to);
  if (fromOrig === toOrig) return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to) return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode) break;
    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1) lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0) out += "..";
      else out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function relative3(from, to) {
  return isWindows ? relative2(from, to) : relative(from, to);
}
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string) {
  return string.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}
function toFileUrl(path) {
  if (!isAbsolute(path)) {
    throw new TypeError(`Path must be absolute: received "${path}"`);
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(
    path.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}
function toFileUrl2(path) {
  if (!isAbsolute2(path)) {
    throw new TypeError(`Path must be absolute: received "${path}"`);
  }
  const [, hostname, pathname] = path.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname !== void 0 && hostname !== "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError(`Invalid hostname: "${url.hostname}"`);
    }
  }
  return url;
}
function toFileUrl3(path) {
  return isWindows ? toFileUrl2(path) : toFileUrl(path);
}
var { Deno: Deno4 } = globalThis;
var noColor3 = typeof Deno4?.noColor === "boolean" ? Deno4.noColor : false;
var enabled2 = !noColor3;
function code2(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run2(str, code4) {
  return enabled2 ? `${code4.open}${str.replace(code4.regexp, code4.open)}${code4.close}` : str;
}
function bold3(str) {
  return run2(str, code2([1], 22));
}
function italic(str) {
  return run2(str, code2([3], 23));
}
function red2(str) {
  return run2(str, code2([31], 39));
}
function green2(str) {
  return run2(str, code2([32], 39));
}
function yellow(str) {
  return run2(str, code2([33], 39));
}
function blue(str) {
  return run2(str, code2([34], 39));
}
function cyan(str) {
  return run2(str, code2([36], 39));
}
function white2(str) {
  return run2(str, code2([37], 39));
}
function gray3(str) {
  return brightBlack2(str);
}
function brightBlack2(str) {
  return run2(str, code2([90], 39));
}
var ANSI_PATTERN3 = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
var RealEnvironment = class {
  env(key) {
    return Deno.env.get(key);
  }
  stat(path) {
    return Deno.stat(path);
  }
  statSync(path) {
    return Deno.statSync(path);
  }
  get os() {
    return Deno.build.os;
  }
};
async function which(command, environment = new RealEnvironment()) {
  const systemInfo = getSystemInfo(command, environment);
  if (systemInfo == null) {
    return void 0;
  }
  for (const pathItem of systemInfo.pathItems) {
    const filePath = pathItem + command;
    if (systemInfo.pathExts) {
      environment.requestPermission?.(pathItem);
      for (const pathExt of systemInfo.pathExts) {
        const filePath2 = pathItem + command + pathExt;
        if (await pathMatches(environment, filePath2)) {
          return filePath2;
        }
      }
    } else if (await pathMatches(environment, filePath)) {
      return filePath;
    }
  }
  return void 0;
}
async function pathMatches(environment, path) {
  try {
    const result = await environment.stat(path);
    return result.isFile;
  } catch (err) {
    if (err instanceof Deno.errors.PermissionDenied) {
      throw err;
    }
    return false;
  }
}
function whichSync(command, environment = new RealEnvironment()) {
  const systemInfo = getSystemInfo(command, environment);
  if (systemInfo == null) {
    return void 0;
  }
  for (const pathItem of systemInfo.pathItems) {
    const filePath = pathItem + command;
    if (systemInfo.pathExts) {
      environment.requestPermission?.(pathItem);
      for (const pathExt of systemInfo.pathExts) {
        const filePath2 = pathItem + command + pathExt;
        if (pathMatchesSync(environment, filePath2)) {
          return filePath2;
        }
      }
    } else if (pathMatchesSync(environment, filePath)) {
      return filePath;
    }
  }
  return void 0;
}
function pathMatchesSync(environment, path) {
  try {
    const result = environment.statSync(path);
    return result.isFile;
  } catch (err) {
    if (err instanceof Deno.errors.PermissionDenied) {
      throw err;
    }
    return false;
  }
}
function getSystemInfo(command, environment) {
  const isWindows8 = environment.os === "windows";
  const envValueSeparator = isWindows8 ? ";" : ":";
  const path = environment.env("PATH");
  const pathSeparator = isWindows8 ? "\\" : "/";
  if (path == null) {
    return void 0;
  }
  return {
    pathItems: splitEnvValue(path).map((item) => normalizeDir(item)),
    pathExts: getPathExts(),
    isNameMatch: isWindows8 ? (a, b) => a.toLowerCase() === b.toLowerCase() : (a, b) => a === b
  };
  function getPathExts() {
    if (!isWindows8) {
      return void 0;
    }
    const pathExtText = environment.env("PATHEXT") ?? ".EXE;.CMD;.BAT;.COM";
    const pathExts = splitEnvValue(pathExtText);
    const lowerCaseCommand = command.toLowerCase();
    for (const pathExt of pathExts) {
      if (lowerCaseCommand.endsWith(pathExt.toLowerCase())) {
        return void 0;
      }
    }
    return pathExts;
  }
  function splitEnvValue(value) {
    return value.split(envValueSeparator).map((item) => item.trim()).filter((item) => item.length > 0);
  }
  function normalizeDir(dirPath) {
    if (!dirPath.endsWith(pathSeparator)) {
      dirPath += pathSeparator;
    }
    return dirPath;
  }
}
var Path = class _Path {
  #path;
  #knownResolved = false;
  /** This is a special symbol that allows different versions of
   * `Path` API to match on `instanceof` checks. Ideally
   * people shouldn't be mixing versions, but if it happens then
   * this will maybe reduce some bugs.
   * @internal
   */
  static instanceofSymbol = Symbol.for("@david/path.Path");
  /** Creates a new path from the provided string, URL, or another Path. */
  constructor(path) {
    if (path instanceof URL) {
      this.#path = fromFileUrl3(path);
    } else if (path instanceof _Path) {
      this.#path = path.toString();
    } else if (typeof path === "string") {
      if (path.startsWith("file://")) {
        this.#path = fromFileUrl3(path);
      } else {
        this.#path = path;
      }
    } else {
      throw new Error(
        `Invalid path argument: ${path}

Provide a URL, string, or another Path.`
      );
    }
  }
  /** @internal */
  static [Symbol.hasInstance](instance) {
    return instance?.constructor?.instanceofSymbol === _Path.instanceofSymbol;
  }
  /** @internal */
  [Symbol.for("Deno.customInspect")]() {
    return `Path("${this.#path}")`;
  }
  /** @internal */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Path("${this.#path}")`;
  }
  /** Gets the string representation of this path. */
  toString() {
    return this.#path;
  }
  /** Resolves the path and gets the file URL. */
  toFileUrl() {
    const resolvedPath = this.resolve();
    return toFileUrl3(resolvedPath.toString());
  }
  /** If this path reference is the same as another one. */
  equals(otherPath) {
    return this.resolve().toString() === otherPath.resolve().toString();
  }
  /** Follows symlinks and gets if this path is a directory. */
  isDirSync() {
    return this.statSync()?.isDirectory ?? false;
  }
  /** Follows symlinks and gets if this path is a file. */
  isFileSync() {
    return this.statSync()?.isFile ?? false;
  }
  /** Gets if this path is a symlink. */
  isSymlinkSync() {
    return this.lstatSync()?.isSymlink ?? false;
  }
  /** Gets if this path is an absolute path. */
  isAbsolute() {
    return isAbsolute3(this.#path);
  }
  /** Gets if this path is relative. */
  isRelative() {
    return !this.isAbsolute();
  }
  /** Joins the provided path segments onto this path. */
  join(...pathSegments) {
    return new _Path(join3(this.#path, ...pathSegments));
  }
  /** Resolves this path to an absolute path along with the provided path segments. */
  resolve(...pathSegments) {
    if (this.#knownResolved && pathSegments.length === 0) {
      return this;
    }
    const resolvedPath = resolve3(this.#path, ...pathSegments);
    if (pathSegments.length === 0 && resolvedPath === this.#path) {
      this.#knownResolved = true;
      return this;
    } else {
      const pathRef = new _Path(resolvedPath);
      pathRef.#knownResolved = true;
      return pathRef;
    }
  }
  /**
   * Normalizes the `path`, resolving `'..'` and `'.'` segments.
   * Note that resolving these segments does not necessarily mean that all will be eliminated.
   * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.
   */
  normalize() {
    return new _Path(normalize3(this.#path));
  }
  /** Resolves the `Deno.FileInfo` of this path following symlinks. */
  async stat() {
    try {
      return await Deno.stat(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /** Synchronously resolves the `Deno.FileInfo` of this
   * path following symlinks. */
  statSync() {
    try {
      return Deno.statSync(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /** Resolves the `Deno.FileInfo` of this path without
   * following symlinks. */
  async lstat() {
    try {
      return await Deno.lstat(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /** Synchronously resolves the `Deno.FileInfo` of this path
   * without following symlinks. */
  lstatSync() {
    try {
      return Deno.lstatSync(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /**
   * Gets the directory path. In most cases, it is recommended
   * to use `.parent()` instead since it will give you a `PathRef`.
   */
  dirname() {
    return dirname3(this.#path);
  }
  /** Gets the file or directory name of the path. */
  basename() {
    return basename3(this.#path);
  }
  /** Resolves the path getting all its ancestor directories in order. */
  *ancestors() {
    let ancestor = this.parent();
    while (ancestor != null) {
      yield ancestor;
      ancestor = ancestor.parent();
    }
  }
  /** Iterates over the components of a path. */
  *components() {
    const path = this.normalize();
    let last_index = 0;
    if (path.#path.startsWith("\\\\?\\")) {
      last_index = nextSlash(path.#path, 4);
      if (last_index === -1) {
        yield path.#path;
        return;
      } else {
        yield path.#path.substring(0, last_index);
        last_index += 1;
      }
    } else if (path.#path.startsWith("/")) {
      last_index += 1;
    }
    while (true) {
      const index = nextSlash(path.#path, last_index);
      if (index < 0) {
        const part = path.#path.substring(last_index);
        if (part.length > 0) {
          yield part;
        }
        return;
      }
      yield path.#path.substring(last_index, index);
      last_index = index + 1;
    }
    function nextSlash(path2, start) {
      for (let i = start; i < path2.length; i++) {
        const c = path2.charCodeAt(i);
        if (c === 47 || c === 92) {
          return i;
        }
      }
      return -1;
    }
  }
  // This is private because this doesn't handle stuff like `\\?\` at the start
  // so it's only used internally with #endsWith for perf. API consumers should
  // use .components()
  *#rcomponents() {
    const path = this.normalize();
    let last_index = void 0;
    while (last_index == null || last_index > 0) {
      const index = nextSlash(
        path.#path,
        last_index == null ? void 0 : last_index - 1
      );
      if (index < 0) {
        const part2 = path.#path.substring(0, last_index);
        if (part2.length > 0) {
          yield part2;
        }
        return;
      }
      const part = path.#path.substring(index + 1, last_index);
      if (last_index != null || part.length > 0) {
        yield part;
      }
      last_index = index;
    }
    function nextSlash(path2, start) {
      for (let i = start ?? path2.length - 1; i >= 0; i--) {
        const c = path2.charCodeAt(i);
        if (c === 47 || c === 92) {
          return i;
        }
      }
      return -1;
    }
  }
  /** Gets if the provided path starts with the specified Path, URL, or string.
   *
   * This verifies based on matching the components.
   *
   * ```
   * assert(new Path("/a/b/c").startsWith("/a/b"));
   * assert(!new Path("/example").endsWith("/exam"));
   * ```
   */
  startsWith(path) {
    const startsWithComponents = ensurePath(path).components();
    for (const component of this.components()) {
      const next = startsWithComponents.next();
      if (next.done) {
        return true;
      }
      if (next.value !== component) {
        return false;
      }
    }
    return startsWithComponents.next().done ?? true;
  }
  /** Gets if the provided path ends with the specified Path, URL, or string.
   *
   * This verifies based on matching the components.
   *
   * ```
   * assert(new Path("/a/b/c").endsWith("b/c"));
   * assert(!new Path("/a/b/example").endsWith("ple"));
   * ```
   */
  endsWith(path) {
    const endsWithComponents = ensurePath(path).#rcomponents();
    for (const component of this.#rcomponents()) {
      const next = endsWithComponents.next();
      if (next.done) {
        return true;
      }
      if (next.value !== component) {
        return false;
      }
    }
    return endsWithComponents.next().done ?? true;
  }
  /** Gets the parent directory or returns undefined if the parent is the root directory. */
  parent() {
    const resolvedPath = this.resolve();
    const dirname7 = resolvedPath.dirname();
    if (dirname7 === resolvedPath.#path) {
      return void 0;
    } else {
      return new _Path(dirname7);
    }
  }
  /** Gets the parent or throws if the current directory was the root. */
  parentOrThrow() {
    const parent = this.parent();
    if (parent == null) {
      throw new Error(`Cannot get the parent directory of '${this.#path}'.`);
    }
    return parent;
  }
  /**
   * Returns the extension of the path with leading period or undefined
   * if there is no extension.
   */
  extname() {
    const extName = extname3(this.#path);
    return extName.length === 0 ? void 0 : extName;
  }
  /** Gets a new path reference with the provided extension. */
  withExtname(ext) {
    const currentExt = this.extname();
    const hasLeadingPeriod = ext.charCodeAt(0) === /* period */
    46;
    if (!hasLeadingPeriod && ext.length !== 0) {
      ext = "." + ext;
    }
    return new _Path(
      this.#path.substring(0, this.#path.length - (currentExt?.length ?? 0)) + ext
    );
  }
  /** Gets a new path reference with the provided file or directory name. */
  withBasename(basename7) {
    const currentBaseName = this.basename();
    return new _Path(
      this.#path.substring(0, this.#path.length - currentBaseName.length) + basename7
    );
  }
  /** Gets the relative path from this path to the specified path. */
  relative(to) {
    const toPathRef = ensurePath(to);
    return relative3(this.resolve().#path, toPathRef.resolve().toString());
  }
  /** Gets if the path exists. Beware of TOCTOU issues. */
  exists() {
    return this.lstat().then((info) => info != null);
  }
  /** Synchronously gets if the path exists. Beware of TOCTOU issues. */
  existsSync() {
    return this.lstatSync() != null;
  }
  /** Resolves to the absolute normalized path, with symbolic links resolved. */
  realPath() {
    return Deno.realPath(this.#path).then((path) => new _Path(path));
  }
  /** Synchronously resolves to the absolute normalized path, with symbolic links resolved. */
  realPathSync() {
    return new _Path(Deno.realPathSync(this.#path));
  }
  /** Creates a directory at this path.
   * @remarks By default, this is recursive.
   */
  async mkdir(options) {
    await Deno.mkdir(this.#path, {
      recursive: true,
      ...options
    });
    return this;
  }
  /** Synchronously creates a directory at this path.
   * @remarks By default, this is recursive.
   */
  mkdirSync(options) {
    Deno.mkdirSync(this.#path, {
      recursive: true,
      ...options
    });
    return this;
  }
  async symlinkTo(target, opts) {
    await createSymlink(this.#resolveCreateSymlinkOpts(target, opts));
  }
  symlinkToSync(target, opts) {
    createSymlinkSync(this.#resolveCreateSymlinkOpts(target, opts));
  }
  #resolveCreateSymlinkOpts(target, opts) {
    if (opts?.kind == null) {
      if (typeof target === "string") {
        return {
          fromPath: this.resolve(),
          targetPath: ensurePath(target),
          text: target,
          type: opts?.type
        };
      } else {
        throw new Error(
          "Please specify if this symlink is absolute or relative. Otherwise provide the target text."
        );
      }
    }
    const targetPath = ensurePath(target).resolve();
    if (opts?.kind === "relative") {
      const fromPath = this.resolve();
      let relativePath;
      if (fromPath.dirname() === targetPath.dirname()) {
        relativePath = targetPath.basename();
      } else {
        relativePath = fromPath.relative(targetPath);
      }
      return {
        fromPath,
        targetPath,
        text: relativePath,
        type: opts?.type
      };
    } else {
      return {
        fromPath: this.resolve(),
        targetPath,
        text: targetPath.toString(),
        type: opts?.type
      };
    }
  }
  /**
   * Creates a hardlink to the provided target path.
   */
  async linkTo(targetPath) {
    const targetPathRef = ensurePath(targetPath).resolve();
    await Deno.link(targetPathRef.toString(), this.resolve().toString());
  }
  /**
   * Synchronously creates a hardlink to the provided target path.
   */
  linkToSync(targetPath) {
    const targetPathRef = ensurePath(targetPath).resolve();
    Deno.linkSync(targetPathRef.toString(), this.resolve().toString());
  }
  /** Reads the entries in the directory. */
  async *readDir() {
    const dir = this.resolve();
    for await (const entry of Deno.readDir(dir.#path)) {
      yield {
        ...entry,
        path: dir.join(entry.name)
      };
    }
  }
  /** Synchronously reads the entries in the directory. */
  *readDirSync() {
    const dir = this.resolve();
    for (const entry of Deno.readDirSync(dir.#path)) {
      yield {
        ...entry,
        path: dir.join(entry.name)
      };
    }
  }
  /** Reads only the directory file paths, not including symlinks. */
  async *readDirFilePaths() {
    const dir = this.resolve();
    for await (const entry of Deno.readDir(dir.#path)) {
      if (entry.isFile) {
        yield dir.join(entry.name);
      }
    }
  }
  /** Synchronously reads only the directory file paths, not including symlinks. */
  *readDirFilePathsSync() {
    const dir = this.resolve();
    for (const entry of Deno.readDirSync(dir.#path)) {
      if (entry.isFile) {
        yield dir.join(entry.name);
      }
    }
  }
  /** Reads the bytes from the file. */
  readBytes(options) {
    return Deno.readFile(this.#path, options);
  }
  /** Synchronously reads the bytes from the file. */
  readBytesSync() {
    return Deno.readFileSync(this.#path);
  }
  /** Calls `.readBytes()`, but returns undefined if the path doesn't exist. */
  readMaybeBytes(options) {
    return notFoundToUndefined(() => this.readBytes(options));
  }
  /** Calls `.readBytesSync()`, but returns undefined if the path doesn't exist. */
  readMaybeBytesSync() {
    return notFoundToUndefinedSync(() => this.readBytesSync());
  }
  /** Reads the text from the file. */
  readText(options) {
    return Deno.readTextFile(this.#path, options);
  }
  /** Synchronously reads the text from the file. */
  readTextSync() {
    return Deno.readTextFileSync(this.#path);
  }
  /** Calls `.readText()`, but returns undefined when the path doesn't exist.
   * @remarks This still errors for other kinds of errors reading a file.
   */
  readMaybeText(options) {
    return notFoundToUndefined(() => this.readText(options));
  }
  /** Calls `.readTextSync()`, but returns undefined when the path doesn't exist.
   * @remarks This still errors for other kinds of errors reading a file.
   */
  readMaybeTextSync() {
    return notFoundToUndefinedSync(() => this.readTextSync());
  }
  /** Reads and parses the file as JSON, throwing if it doesn't exist or is not valid JSON. */
  async readJson(options) {
    return this.#parseJson(await this.readText(options));
  }
  /** Synchronously reads and parses the file as JSON, throwing if it doesn't
   * exist or is not valid JSON. */
  readJsonSync() {
    return this.#parseJson(this.readTextSync());
  }
  #parseJson(text) {
    try {
      return JSON.parse(text);
    } catch (err) {
      throw new Error(`Failed parsing JSON in '${this.toString()}'.`, {
        cause: err
      });
    }
  }
  /**
   * Calls `.readJson()`, but returns undefined if the file doesn't exist.
   * @remarks This method will still throw if the file cannot be parsed as JSON.
   */
  readMaybeJson(options) {
    return notFoundToUndefined(() => this.readJson(options));
  }
  /**
   * Calls `.readJsonSync()`, but returns undefined if the file doesn't exist.
   * @remarks This method will still throw if the file cannot be parsed as JSON.
   */
  readMaybeJsonSync() {
    return notFoundToUndefinedSync(() => this.readJsonSync());
  }
  /** Writes out the provided bytes or text to the file. */
  async write(data, options) {
    await this.#withFileForWriting(options, (file) => {
      return writeAll(file, data);
    });
    return this;
  }
  /** Synchronously writes out the provided bytes or text to the file. */
  writeSync(data, options) {
    this.#withFileForWritingSync(options, (file) => {
      writeAllSync(file, data);
    });
    return this;
  }
  /** Writes the provided text to this file. */
  writeText(text, options) {
    return this.write(new TextEncoder().encode(text), options);
  }
  /** Synchronously writes the provided text to this file. */
  writeTextSync(text, options) {
    return this.writeSync(new TextEncoder().encode(text), options);
  }
  /** Writes out the provided object as compact JSON. */
  async writeJson(obj, options) {
    const text = JSON.stringify(obj);
    await this.writeText(text + "\n", options);
    return this;
  }
  /** Synchronously writes out the provided object as compact JSON. */
  writeJsonSync(obj, options) {
    const text = JSON.stringify(obj);
    this.writeTextSync(text + "\n", options);
    return this;
  }
  /** Writes out the provided object as formatted JSON. */
  async writeJsonPretty(obj, options) {
    const text = JSON.stringify(obj, void 0, 2);
    await this.writeText(text + "\n", options);
    return this;
  }
  /** Synchronously writes out the provided object as formatted JSON. */
  writeJsonPrettySync(obj, options) {
    const text = JSON.stringify(obj, void 0, 2);
    this.writeTextSync(text + "\n", options);
    return this;
  }
  /** Appends the provided bytes to the file. */
  async append(data, options) {
    await this.#withFileForAppending(options, (file) => writeAll(file, data));
    return this;
  }
  /** Synchronously appends the provided bytes to the file. */
  appendSync(data, options) {
    this.#withFileForAppendingSync(options, (file) => {
      writeAllSync(file, data);
    });
    return this;
  }
  /** Appends the provided text to the file. */
  async appendText(text, options) {
    await this.#withFileForAppending(
      options,
      (file) => writeAll(file, new TextEncoder().encode(text))
    );
    return this;
  }
  /** Synchronously appends the provided text to the file. */
  appendTextSync(text, options) {
    this.#withFileForAppendingSync(options, (file) => {
      writeAllSync(file, new TextEncoder().encode(text));
    });
    return this;
  }
  #withFileForAppending(options, action) {
    return this.#withFileForWriting({
      append: true,
      ...options
    }, action);
  }
  async #withFileForWriting(options, action) {
    const file = await this.#openFileMaybeCreatingDirectory({
      write: true,
      create: true,
      truncate: options?.append !== true,
      ...options
    });
    try {
      return await action(file);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
  }
  /** Opens a file, but handles if the directory does not exist. */
  async #openFileMaybeCreatingDirectory(options) {
    const resolvedPath = this.resolve();
    try {
      return await resolvedPath.open(options);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        const parent = resolvedPath.parent();
        if (parent != null) {
          try {
            await parent.mkdir();
          } catch {
            throw err;
          }
        }
        return await resolvedPath.open(options);
      } else {
        throw err;
      }
    }
  }
  #withFileForAppendingSync(options, action) {
    return this.#withFileForWritingSync({
      append: true,
      ...options
    }, action);
  }
  #withFileForWritingSync(options, action) {
    const file = this.#openFileForWritingSync(options);
    try {
      return action(file);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
  }
  /** Opens a file for writing, but handles if the directory does not exist. */
  #openFileForWritingSync(options) {
    return this.#openFileMaybeCreatingDirectorySync({
      write: true,
      create: true,
      truncate: options?.append !== true,
      ...options
    });
  }
  /** Opens a file for writing, but handles if the directory does not exist. */
  #openFileMaybeCreatingDirectorySync(options) {
    try {
      return this.openSync(options);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        const parent = this.resolve().parent();
        if (parent != null) {
          try {
            parent.mkdirSync();
          } catch {
            throw err;
          }
        }
        return this.openSync(options);
      } else {
        throw err;
      }
    }
  }
  /** Changes the permissions of the file or directory. */
  async chmod(mode) {
    await Deno.chmod(this.#path, mode);
    return this;
  }
  /** Synchronously changes the permissions of the file or directory. */
  chmodSync(mode) {
    Deno.chmodSync(this.#path, mode);
    return this;
  }
  /** Changes the ownership permissions of the file. */
  async chown(uid, gid) {
    await Deno.chown(this.#path, uid, gid);
    return this;
  }
  /** Synchronously changes the ownership permissions of the file. */
  chownSync(uid, gid) {
    Deno.chownSync(this.#path, uid, gid);
    return this;
  }
  /** Creates a new file or opens the existing one. */
  create() {
    return Deno.create(this.#path).then((file) => createFsFileWrapper(file));
  }
  /** Synchronously creates a new file or opens the existing one. */
  createSync() {
    return createFsFileWrapper(Deno.createSync(this.#path));
  }
  /** Creates a file throwing if a file previously existed. */
  createNew() {
    return this.open({
      createNew: true,
      read: true,
      write: true
    });
  }
  /** Synchronously creates a file throwing if a file previously existed. */
  createNewSync() {
    return this.openSync({
      createNew: true,
      read: true,
      write: true
    });
  }
  /** Opens a file. */
  open(options) {
    return Deno.open(this.#path, options).then((file) => createFsFileWrapper(file));
  }
  /** Opens a file synchronously. */
  openSync(options) {
    return createFsFileWrapper(Deno.openSync(this.#path, options));
  }
  /** Removes the file or directory from the file system. */
  async remove(options) {
    await Deno.remove(this.#path, options);
    return this;
  }
  /** Removes the file or directory from the file system synchronously. */
  removeSync(options) {
    Deno.removeSync(this.#path, options);
    return this;
  }
  /** Removes the file or directory from the file system, but doesn't throw
   * when the file doesn't exist.
   */
  async ensureRemove(options) {
    try {
      return await this.remove(options);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return this;
      } else {
        throw err;
      }
    }
  }
  /** Removes the file or directory from the file system, but doesn't throw
   * when the file doesn't exist.
   */
  ensureRemoveSync(options) {
    try {
      return this.removeSync(options);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return this;
      } else {
        throw err;
      }
    }
  }
  /**
   * Ensures that a directory is empty.
   * Deletes directory contents if the directory is not empty.
   * If the directory does not exist, it is created.
   * The directory itself is not deleted.
   */
  async emptyDir() {
    await emptyDir(this.toString());
    return this;
  }
  /** Synchronous version of `emptyDir()` */
  emptyDirSync() {
    emptyDirSync(this.toString());
    return this;
  }
  /** Ensures that the directory exists.
   * If the directory structure does not exist, it is created. Like mkdir -p.
   */
  async ensureDir() {
    await ensureDir(this.toString());
    return this;
  }
  /** Synchronously ensures that the directory exists.
   * If the directory structure does not exist, it is created. Like mkdir -p.
   */
  ensureDirSync() {
    ensureDirSync(this.toString());
    return this;
  }
  /**
   * Ensures that the file exists.
   * If the file that is requested to be created is in directories that do
   * not exist these directories are created. If the file already exists,
   * it is NOTMODIFIED.
   */
  async ensureFile() {
    await ensureFile(this.toString());
    return this;
  }
  /**
   * Synchronously ensures that the file exists.
   * If the file that is requested to be created is in directories that do
   * not exist these directories are created. If the file already exists,
   * it is NOTMODIFIED.
   */
  ensureFileSync() {
    ensureFileSync(this.toString());
    return this;
  }
  /** Copies a file or directory to the provided destination.
   * @returns The destination path.
   */
  async copy(destinationPath, options) {
    const pathRef = ensurePath(destinationPath);
    await copy(this.#path, pathRef.toString(), options);
    return pathRef;
  }
  /** Copies a file or directory to the provided destination synchronously.
   * @returns The destination path.
   */
  copySync(destinationPath, options) {
    const pathRef = ensurePath(destinationPath);
    copySync(this.#path, pathRef.toString(), options);
    return pathRef;
  }
  /**
   * Copies the file or directory to the specified directory.
   * @returns The destination path.
   */
  copyToDir(destinationDirPath, options) {
    const destinationPath = ensurePath(destinationDirPath).join(this.basename());
    return this.copy(destinationPath, options);
  }
  /**
   * Copies the file or directory to the specified directory synchronously.
   * @returns The destination path.
   */
  copyToDirSync(destinationDirPath, options) {
    const destinationPath = ensurePath(destinationDirPath).join(this.basename());
    return this.copySync(destinationPath, options);
  }
  /**
   * Copies the file to the specified destination path.
   * @returns The destination path.
   */
  copyFile(destinationPath) {
    const pathRef = ensurePath(destinationPath);
    return Deno.copyFile(this.#path, pathRef.toString()).then(() => pathRef);
  }
  /**
   * Copies the file to the destination path synchronously.
   * @returns The destination path.
   */
  copyFileSync(destinationPath) {
    const pathRef = ensurePath(destinationPath);
    Deno.copyFileSync(this.#path, pathRef.toString());
    return pathRef;
  }
  /**
   * Copies the file to the specified directory.
   * @returns The destination path.
   */
  copyFileToDir(destinationDirPath) {
    const destinationPath = ensurePath(destinationDirPath).join(this.basename());
    return this.copyFile(destinationPath);
  }
  /**
   * Copies the file to the specified directory synchronously.
   * @returns The destination path.
   */
  copyFileToDirSync(destinationDirPath) {
    const destinationPath = ensurePath(destinationDirPath).join(this.basename());
    return this.copyFileSync(destinationPath);
  }
  /**
   * Moves the file or directory returning a promise that resolves to
   * the renamed path.
   * @returns The destination path.
   */
  rename(newPath) {
    const pathRef = ensurePath(newPath);
    return Deno.rename(this.#path, pathRef.toString()).then(() => pathRef);
  }
  /**
   * Moves the file or directory returning the renamed path synchronously.
   * @returns The destination path.
   */
  renameSync(newPath) {
    const pathRef = ensurePath(newPath);
    Deno.renameSync(this.#path, pathRef.toString());
    return pathRef;
  }
  /**
   * Moves the file or directory to the specified directory.
   * @returns The destination path.
   */
  renameToDir(destinationDirPath) {
    const destinationPath = ensurePath(destinationDirPath).join(this.basename());
    return this.rename(destinationPath);
  }
  /**
   * Moves the file or directory to the specified directory synchronously.
   * @returns The destination path.
   */
  renameToDirSync(destinationDirPath) {
    const destinationPath = ensurePath(destinationDirPath).join(this.basename());
    return this.renameSync(destinationPath);
  }
  /** Opens the file and pipes it to the writable stream. */
  async pipeTo(dest, options) {
    const file = await Deno.open(this.#path, { read: true });
    try {
      await file.readable.pipeTo(dest, options);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
    return this;
  }
};
function ensurePath(path) {
  return path instanceof Path ? path : new Path(path);
}
function createFsFileWrapper(file) {
  Object.setPrototypeOf(file, FsFileWrapper.prototype);
  return file;
}
var FsFileWrapper = class extends Deno.FsFile {
  /** Writes the provided text to this file. */
  writeText(text) {
    return this.writeBytes(new TextEncoder().encode(text));
  }
  /** Synchronously writes the provided text to this file. */
  writeTextSync(text) {
    return this.writeBytesSync(new TextEncoder().encode(text));
  }
  /** Writes the provided bytes to the file. */
  async writeBytes(bytes) {
    await writeAll(this, bytes);
    return this;
  }
  /** Synchronously writes the provided bytes to the file. */
  writeBytesSync(bytes) {
    writeAllSync(this, bytes);
    return this;
  }
};
async function createSymlink(opts) {
  let kind = opts.type;
  if (kind == null && Deno.build.os === "windows") {
    const info = await opts.targetPath.lstat();
    if (info?.isDirectory) {
      kind = "dir";
    } else if (info?.isFile) {
      kind = "file";
    } else {
      throw new Deno.errors.NotFound(
        `The target path '${opts.targetPath}' did not exist or path kind could not be determined. When the path doesn't exist, you need to specify a symlink type on Windows.`
      );
    }
  }
  await Deno.symlink(
    opts.text,
    opts.fromPath.toString(),
    kind == null ? void 0 : {
      type: kind
    }
  );
}
function createSymlinkSync(opts) {
  let kind = opts.type;
  if (kind == null && Deno.build.os === "windows") {
    const info = opts.targetPath.lstatSync();
    if (info?.isDirectory) {
      kind = "dir";
    } else if (info?.isFile) {
      kind = "file";
    } else {
      throw new Deno.errors.NotFound(
        `The target path '${opts.targetPath}' did not exist or path kind could not be determined. When the path doesn't exist, you need to specify a symlink type on Windows.`
      );
    }
  }
  Deno.symlinkSync(
    opts.text,
    opts.fromPath.toString(),
    kind == null ? void 0 : {
      type: kind
    }
  );
}
async function notFoundToUndefined(action) {
  try {
    return await action();
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return void 0;
    } else {
      throw err;
    }
  }
}
function notFoundToUndefinedSync(action) {
  try {
    return action();
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return void 0;
    } else {
      throw err;
    }
  }
}
async function writeAll(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += await writer.write(data.subarray(nwritten));
  }
}
function writeAllSync(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += writer.writeSync(data.subarray(nwritten));
  }
}
var AssertionError2 = class extends Error {
  /** Constructs a new instance. */
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};
function assert2(expr, msg = "") {
  if (!expr) {
    throw new AssertionError2(msg);
  }
}
function copy2(src, dst, off = 0) {
  off = Math.max(0, Math.min(off, dst.byteLength));
  const dstBytesAvailable = dst.byteLength - off;
  if (src.byteLength > dstBytesAvailable) {
    src = src.subarray(0, dstBytesAvailable);
  }
  dst.set(src, off);
  return src.byteLength;
}
var MIN_READ = 32 * 1024;
var MAX_SIZE = 2 ** 32 - 2;
var Buffer = class {
  #buf;
  // contents are the bytes buf[off : len(buf)]
  #off = 0;
  // read at buf[off], write at buf[buf.byteLength]
  constructor(ab) {
    this.#buf = ab === void 0 ? new Uint8Array(0) : new Uint8Array(ab);
  }
  /** Returns a slice holding the unread portion of the buffer.
   *
   * The slice is valid for use only until the next buffer modification (that
   * is, only until the next call to a method like `read()`, `write()`,
   * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at
   * least until the next buffer modification, so immediate changes to the
   * slice will affect the result of future reads.
   * @param [options={ copy: true }]
   */
  bytes(options = { copy: true }) {
    if (options.copy === false) return this.#buf.subarray(this.#off);
    return this.#buf.slice(this.#off);
  }
  /** Returns whether the unread portion of the buffer is empty. */
  empty() {
    return this.#buf.byteLength <= this.#off;
  }
  /** A read only number of bytes of the unread portion of the buffer. */
  get length() {
    return this.#buf.byteLength - this.#off;
  }
  /** The read only capacity of the buffer's underlying byte slice, that is,
   * the total space allocated for the buffer's data. */
  get capacity() {
    return this.#buf.buffer.byteLength;
  }
  /** Discards all but the first `n` unread bytes from the buffer but
   * continues to use the same allocated storage. It throws if `n` is
   * negative or greater than the length of the buffer. */
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length) {
      throw Error("bytes.Buffer: truncation out of range");
    }
    this.#reslice(this.#off + n);
  }
  reset() {
    this.#reslice(0);
    this.#off = 0;
  }
  #tryGrowByReslice(n) {
    const l = this.#buf.byteLength;
    if (n <= this.capacity - l) {
      this.#reslice(l + n);
      return l;
    }
    return -1;
  }
  #reslice(len) {
    assert2(len <= this.#buf.buffer.byteLength);
    this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
  }
  /** Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Returns the number of bytes read. If the buffer has no data to
   * return, the return is EOF (`null`). */
  readSync(p) {
    if (this.empty()) {
      this.reset();
      if (p.byteLength === 0) {
        return 0;
      }
      return null;
    }
    const nread = copy2(this.#buf.subarray(this.#off), p);
    this.#off += nread;
    return nread;
  }
  /** Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Resolves to the number of bytes read. If the buffer has no
   * data to return, resolves to EOF (`null`).
   *
   * NOTE: This methods reads bytes synchronously; it's provided for
   * compatibility with `Reader` interfaces.
   */
  read(p) {
    const rr = this.readSync(p);
    return Promise.resolve(rr);
  }
  writeSync(p) {
    const m = this.#grow(p.byteLength);
    return copy2(p, this.#buf, m);
  }
  /** NOTE: This methods writes bytes synchronously; it's provided for
   * compatibility with `Writer` interface. */
  write(p) {
    const n = this.writeSync(p);
    return Promise.resolve(n);
  }
  #grow(n) {
    const m = this.length;
    if (m === 0 && this.#off !== 0) {
      this.reset();
    }
    const i = this.#tryGrowByReslice(n);
    if (i >= 0) {
      return i;
    }
    const c = this.capacity;
    if (n <= Math.floor(c / 2) - m) {
      copy2(this.#buf.subarray(this.#off), this.#buf);
    } else if (c + n > MAX_SIZE) {
      throw new Error("The buffer cannot be grown beyond the maximum size.");
    } else {
      const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
      copy2(this.#buf.subarray(this.#off), buf);
      this.#buf = buf;
    }
    this.#off = 0;
    this.#reslice(Math.min(m + n, MAX_SIZE));
    return m;
  }
  /** Grows the buffer's capacity, if necessary, to guarantee space for
   * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
   * the buffer without another allocation. If `n` is negative, `.grow()` will
   * throw. If the buffer can't grow it will throw an error.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.Grow | Buffer.Grow}. */
  grow(n) {
    if (n < 0) {
      throw Error("Buffer.grow: negative count");
    }
    const m = this.#grow(n);
    this.#reslice(m);
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It resolves to the number of bytes read.
   * If the buffer becomes too large, `.readFrom()` will reject with an error.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.ReadFrom | Buffer.ReadFrom}. */
  async readFrom(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ;
      const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = await r.read(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow) this.writeSync(buf.subarray(0, nread));
      else this.#reslice(this.length + nread);
      n += nread;
    }
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It returns the number of bytes read. If the
   * buffer becomes too large, `.readFromSync()` will throw an error.
   *
   * Based on Go Lang's
   * {@link https://golang.org/pkg/bytes/#Buffer.ReadFrom | Buffer.ReadFrom}. */
  readFromSync(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ;
      const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = r.readSync(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow) this.writeSync(buf.subarray(0, nread));
      else this.#reslice(this.length + nread);
      n += nread;
    }
  }
};
async function writeAll2(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += await writer.write(data.subarray(nwritten));
  }
}
function writeAllSync2(writer, data) {
  let nwritten = 0;
  while (nwritten < data.length) {
    nwritten += writer.writeSync(data.subarray(nwritten));
  }
}
function readerFromStreamReader(streamReader) {
  const buffer = new Buffer();
  return {
    async read(p) {
      if (buffer.empty()) {
        const res = await streamReader.read();
        if (res.done) {
          return null;
        }
        await writeAll2(buffer, res.value);
      }
      return buffer.read(p);
    }
  };
}
function readerFromStreamReader2(streamReader) {
  return readerFromStreamReader(streamReader);
}
function writerFromStreamWriter(streamWriter) {
  return {
    async write(p) {
      await streamWriter.ready;
      await streamWriter.write(p);
      return p.length;
    }
  };
}
var DEFAULT_BUF_SIZE = 4096;
var MIN_BUF_SIZE = 16;
var MAX_CONSECUTIVE_EMPTY_READS = 100;
var CR = "\r".charCodeAt(0);
var LF2 = "\n".charCodeAt(0);
var BufferFullError = class extends Error {
  constructor(partial) {
    super("Buffer full");
    this.partial = partial;
  }
  name = "BufferFullError";
};
var PartialReadError = class extends Error {
  name = "PartialReadError";
  partial;
  constructor() {
    super("Encountered UnexpectedEof, data only partially read");
  }
};
var BufReader = class _BufReader {
  #buf;
  #rd;
  // Reader provided by caller.
  #r = 0;
  // buf read position.
  #w = 0;
  // buf write position.
  #eof = false;
  // private lastByte: number;
  // private lastCharSize: number;
  /** return new BufReader unless r is BufReader */
  static create(r, size = DEFAULT_BUF_SIZE) {
    return r instanceof _BufReader ? r : new _BufReader(r, size);
  }
  constructor(rd, size = DEFAULT_BUF_SIZE) {
    if (size < MIN_BUF_SIZE) {
      size = MIN_BUF_SIZE;
    }
    this.#reset(new Uint8Array(size), rd);
  }
  /** Returns the size of the underlying buffer in bytes. */
  size() {
    return this.#buf.byteLength;
  }
  buffered() {
    return this.#w - this.#r;
  }
  // Reads a new chunk into the buffer.
  #fill = async () => {
    if (this.#r > 0) {
      this.#buf.copyWithin(0, this.#r, this.#w);
      this.#w -= this.#r;
      this.#r = 0;
    }
    if (this.#w >= this.#buf.byteLength) {
      throw Error("bufio: tried to fill full buffer");
    }
    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
      const rr = await this.#rd.read(this.#buf.subarray(this.#w));
      if (rr === null) {
        this.#eof = true;
        return;
      }
      assert2(rr >= 0, "negative read");
      this.#w += rr;
      if (rr > 0) {
        return;
      }
    }
    throw new Error(
      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`
    );
  };
  /** Discards any buffered data, resets all state, and switches
   * the buffered reader to read from r.
   */
  reset(r) {
    this.#reset(this.#buf, r);
  }
  #reset = (buf, rd) => {
    this.#buf = buf;
    this.#rd = rd;
    this.#eof = false;
  };
  /** reads data into p.
   * It returns the number of bytes read into p.
   * The bytes are taken from at most one Read on the underlying Reader,
   * hence n may be less than len(p).
   * To read exactly len(p) bytes, use io.ReadFull(b, p).
   */
  async read(p) {
    let rr = p.byteLength;
    if (p.byteLength === 0) return rr;
    if (this.#r === this.#w) {
      if (p.byteLength >= this.#buf.byteLength) {
        const rr2 = await this.#rd.read(p);
        const nread = rr2 ?? 0;
        assert2(nread >= 0, "negative read");
        return rr2;
      }
      this.#r = 0;
      this.#w = 0;
      rr = await this.#rd.read(this.#buf);
      if (rr === 0 || rr === null) return rr;
      assert2(rr >= 0, "negative read");
      this.#w += rr;
    }
    const copied = copy2(this.#buf.subarray(this.#r, this.#w), p, 0);
    this.#r += copied;
    return copied;
  }
  /** reads exactly `p.length` bytes into `p`.
   *
   * If successful, `p` is returned.
   *
   * If the end of the underlying stream has been reached, and there are no more
   * bytes available in the buffer, `readFull()` returns `null` instead.
   *
   * An error is thrown if some bytes could be read, but not enough to fill `p`
   * entirely before the underlying stream reported an error or EOF. Any error
   * thrown will have a `partial` property that indicates the slice of the
   * buffer that has been successfully filled with data.
   *
   * Ported from https://golang.org/pkg/io/#ReadFull
   */
  async readFull(p) {
    let bytesRead = 0;
    while (bytesRead < p.length) {
      try {
        const rr = await this.read(p.subarray(bytesRead));
        if (rr === null) {
          if (bytesRead === 0) {
            return null;
          } else {
            throw new PartialReadError();
          }
        }
        bytesRead += rr;
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = p.subarray(0, bytesRead);
        }
        throw err;
      }
    }
    return p;
  }
  /** Returns the next byte [0, 255] or `null`. */
  async readByte() {
    while (this.#r === this.#w) {
      if (this.#eof) return null;
      await this.#fill();
    }
    const c = this.#buf[this.#r];
    this.#r++;
    return c;
  }
  /** readString() reads until the first occurrence of delim in the input,
   * returning a string containing the data up to and including the delimiter.
   * If ReadString encounters an error before finding a delimiter,
   * it returns the data read before the error and the error itself
   * (often `null`).
   * ReadString returns err !== null if and only if the returned data does not end
   * in delim.
   * For simple uses, a Scanner may be more convenient.
   */
  async readString(delim) {
    if (delim.length !== 1) {
      throw new Error("Delimiter should be a single character");
    }
    const buffer = await this.readSlice(delim.charCodeAt(0));
    if (buffer === null) return null;
    return new TextDecoder().decode(buffer);
  }
  /** `readLine()` is a low-level line-reading primitive. Most callers should
   * use `readString('\n')` instead or use a Scanner.
   *
   * `readLine()` tries to return a single line, not including the end-of-line
   * bytes. If the line was too long for the buffer then `more` is set and the
   * beginning of the line is returned. The rest of the line will be returned
   * from future calls. `more` will be false when returning the last fragment
   * of the line. The returned buffer is only valid until the next call to
   * `readLine()`.
   *
   * The text returned from ReadLine does not include the line end ("\r\n" or
   * "\n").
   *
   * When the end of the underlying stream is reached, the final bytes in the
   * stream are returned. No indication or error is given if the input ends
   * without a final line end. When there are no more trailing bytes to read,
   * `readLine()` returns `null`.
   *
   * Calling `unreadByte()` after `readLine()` will always unread the last byte
   * read (possibly a character belonging to the line end) even if that byte is
   * not part of the line returned by `readLine()`.
   */
  async readLine() {
    let line = null;
    try {
      line = await this.readSlice(LF2);
    } catch (err) {
      let partial;
      if (err instanceof PartialReadError) {
        partial = err.partial;
        assert2(
          partial instanceof Uint8Array,
          "bufio: caught error from `readSlice()` without `partial` property"
        );
      }
      if (!(err instanceof BufferFullError)) {
        throw err;
      }
      partial = err.partial;
      if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
        assert2(this.#r > 0, "bufio: tried to rewind past start of buffer");
        this.#r--;
        partial = partial.subarray(0, partial.byteLength - 1);
      }
      if (partial) {
        return { line: partial, more: !this.#eof };
      }
    }
    if (line === null) {
      return null;
    }
    if (line.byteLength === 0) {
      return { line, more: false };
    }
    if (line[line.byteLength - 1] === LF2) {
      let drop = 1;
      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
        drop = 2;
      }
      line = line.subarray(0, line.byteLength - drop);
    }
    return { line, more: false };
  }
  /** `readSlice()` reads until the first occurrence of `delim` in the input,
   * returning a slice pointing at the bytes in the buffer. The bytes stop
   * being valid at the next read.
   *
   * If `readSlice()` encounters an error before finding a delimiter, or the
   * buffer fills without finding a delimiter, it throws an error with a
   * `partial` property that contains the entire buffer.
   *
   * If `readSlice()` encounters the end of the underlying stream and there are
   * any bytes left in the buffer, the rest of the buffer is returned. In other
   * words, EOF is always treated as a delimiter. Once the buffer is empty,
   * it returns `null`.
   *
   * Because the data returned from `readSlice()` will be overwritten by the
   * next I/O operation, most clients should use `readString()` instead.
   */
  async readSlice(delim) {
    let s = 0;
    let slice;
    while (true) {
      let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
      if (i >= 0) {
        i += s;
        slice = this.#buf.subarray(this.#r, this.#r + i + 1);
        this.#r += i + 1;
        break;
      }
      if (this.#eof) {
        if (this.#r === this.#w) {
          return null;
        }
        slice = this.#buf.subarray(this.#r, this.#w);
        this.#r = this.#w;
        break;
      }
      if (this.buffered() >= this.#buf.byteLength) {
        this.#r = this.#w;
        const oldbuf = this.#buf;
        const newbuf = this.#buf.slice(0);
        this.#buf = newbuf;
        throw new BufferFullError(oldbuf);
      }
      s = this.#w - this.#r;
      try {
        await this.#fill();
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = slice;
        }
        throw err;
      }
    }
    return slice;
  }
  /** `peek()` returns the next `n` bytes without advancing the reader. The
   * bytes stop being valid at the next read call.
   *
   * When the end of the underlying stream is reached, but there are unread
   * bytes left in the buffer, those bytes are returned. If there are no bytes
   * left in the buffer, it returns `null`.
   *
   * If an error is encountered before `n` bytes are available, `peek()` throws
   * an error with the `partial` property set to a slice of the buffer that
   * contains the bytes that were available before the error occurred.
   */
  async peek(n) {
    if (n < 0) {
      throw Error("negative count");
    }
    let avail = this.#w - this.#r;
    while (avail < n && avail < this.#buf.byteLength && !this.#eof) {
      try {
        await this.#fill();
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = this.#buf.subarray(this.#r, this.#w);
        }
        throw err;
      }
      avail = this.#w - this.#r;
    }
    if (avail === 0 && this.#eof) {
      return null;
    } else if (avail < n && this.#eof) {
      return this.#buf.subarray(this.#r, this.#r + avail);
    } else if (avail < n) {
      throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
    }
    return this.#buf.subarray(this.#r, this.#r + n);
  }
};
var wasm;
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedFloat64Memory0 = null;
function getFloat64Memory0() {
  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
  }
  return cachedFloat64Memory0;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
var WASM_VECTOR_LEN = 0;
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : {
  encode: () => {
    throw Error("TextEncoder not available");
  }
};
var encodeString = function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code4 = arg.charCodeAt(offset);
    if (code4 > 127) break;
    mem[ptr + offset] = code4;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : {
  decode: () => {
    throw Error("TextDecoder not available");
  }
};
if (typeof TextDecoder !== "undefined") cachedTextDecoder.decode();
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function dropObject(idx) {
  if (idx < 132) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var cachedBigInt64Memory0 = null;
function getBigInt64Memory0() {
  if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {
    cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);
  }
  return cachedBigInt64Memory0;
}
function debugString(val) {
  const type2 = typeof val;
  if (type2 == "number" || type2 == "boolean" || val == null) {
    return `${val}`;
  }
  if (type2 == "string") {
    return `"${val}"`;
  }
  if (type2 == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type2 == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function parse3(command) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(command, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.parse(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function static_text_render_text(items, cols, rows) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.static_text_render_text(retptr, addHeapObject(items), cols, rows);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    let v1;
    if (r0 !== 0) {
      v1 = getStringFromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 1, 1);
    }
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function static_text_clear_text(cols, rows) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.static_text_clear_text(retptr, cols, rows);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    let v1;
    if (r0 !== 0) {
      v1 = getStringFromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 1, 1);
    }
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function static_text_render_once(items, cols, rows) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.static_text_render_once(retptr, addHeapObject(items), cols, rows);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    let v1;
    if (r0 !== 0) {
      v1 = getStringFromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 1, 1);
    }
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function strip_ansi_codes(text) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.strip_ansi_codes(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    deferred2_0 = r0;
    deferred2_1 = r1;
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
  }
}
var imports = {
  __wbindgen_placeholder__: {
    __wbg_get_57245cc7d7c7619d: function(arg0, arg1) {
      const ret = getObject(arg0)[arg1 >>> 0];
      return addHeapObject(ret);
    },
    __wbindgen_jsval_loose_eq: function(arg0, arg1) {
      const ret = getObject(arg0) == getObject(arg1);
      return ret;
    },
    __wbg_instanceof_Uint8Array_971eeda69eb75003: function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof Uint8Array;
      } catch (_) {
        result = false;
      }
      const ret = result;
      return ret;
    },
    __wbg_instanceof_ArrayBuffer_e5e48f4762c5610b: function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof ArrayBuffer;
      } catch (_) {
        result = false;
      }
      const ret = result;
      return ret;
    },
    __wbg_new_8c3f0052272a457a: function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    },
    __wbindgen_boolean_get: function(arg0) {
      const v = getObject(arg0);
      const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
      return ret;
    },
    __wbindgen_number_get: function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "number" ? obj : void 0;
      getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
      getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
    },
    __wbindgen_string_get: function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    },
    __wbindgen_error_new: function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    },
    __wbindgen_string_new: function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    },
    __wbindgen_object_clone_ref: function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    },
    __wbg_set_9182712abebf82ef: function(arg0, arg1, arg2) {
      getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
    },
    __wbg_new_0b9bfdd97583284e: function() {
      const ret = new Object();
      return addHeapObject(ret);
    },
    __wbg_new_1d9a920c6bfc44a8: function() {
      const ret = new Array();
      return addHeapObject(ret);
    },
    __wbg_set_a68214f35c417fa9: function(arg0, arg1, arg2) {
      getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
    },
    __wbindgen_number_new: function(arg0) {
      const ret = arg0;
      return addHeapObject(ret);
    },
    __wbg_length_6e3bbe7c8bd4dbd8: function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    },
    __wbindgen_is_bigint: function(arg0) {
      const ret = typeof getObject(arg0) === "bigint";
      return ret;
    },
    __wbg_isSafeInteger_dfa0593e8d7ac35a: function(arg0) {
      const ret = Number.isSafeInteger(getObject(arg0));
      return ret;
    },
    __wbindgen_bigint_from_i64: function(arg0) {
      const ret = arg0;
      return addHeapObject(ret);
    },
    __wbindgen_is_object: function(arg0) {
      const val = getObject(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    },
    __wbg_iterator_6f9d4f28845f426c: function() {
      const ret = Symbol.iterator;
      return addHeapObject(ret);
    },
    __wbindgen_in: function(arg0, arg1) {
      const ret = getObject(arg0) in getObject(arg1);
      return ret;
    },
    __wbg_entries_65a76a413fc91037: function(arg0) {
      const ret = Object.entries(getObject(arg0));
      return addHeapObject(ret);
    },
    __wbindgen_bigint_from_u64: function(arg0) {
      const ret = BigInt.asUintN(64, arg0);
      return addHeapObject(ret);
    },
    __wbindgen_jsval_eq: function(arg0, arg1) {
      const ret = getObject(arg0) === getObject(arg1);
      return ret;
    },
    __wbg_new_abda76e883ba8a5f: function() {
      const ret = new Error();
      return addHeapObject(ret);
    },
    __wbg_stack_658279fe44541cf6: function(arg0, arg1) {
      const ret = getObject(arg1).stack;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    },
    __wbg_error_f851667af71bcfc6: function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
      } finally {
        wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
      }
    },
    __wbindgen_object_drop_ref: function(arg0) {
      takeObject(arg0);
    },
    __wbindgen_is_function: function(arg0) {
      const ret = typeof getObject(arg0) === "function";
      return ret;
    },
    __wbg_next_aaef7c8aa5e212ac: function() {
      return handleError(function(arg0) {
        const ret = getObject(arg0).next();
        return addHeapObject(ret);
      }, arguments);
    },
    __wbg_done_1b73b0672e15f234: function(arg0) {
      const ret = getObject(arg0).done;
      return ret;
    },
    __wbg_value_1ccc36bc03462d71: function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    },
    __wbg_get_765201544a2b6869: function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.get(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    },
    __wbg_call_97ae9d8645dc388b: function() {
      return handleError(function(arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    },
    __wbg_next_579e583d33566a86: function(arg0) {
      const ret = getObject(arg0).next;
      return addHeapObject(ret);
    },
    __wbg_isArray_27c46c67f498e15d: function(arg0) {
      const ret = Array.isArray(getObject(arg0));
      return ret;
    },
    __wbg_length_9e1ae1900cb0fbd5: function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    },
    __wbindgen_memory: function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    },
    __wbg_buffer_3f3d764d4747d564: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_set_83db9690f9353e79: function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    },
    __wbindgen_bigint_get_as_i64: function(arg0, arg1) {
      const v = getObject(arg1);
      const ret = typeof v === "bigint" ? v : void 0;
      getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? BigInt(0) : ret;
      getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
    },
    __wbindgen_debug_string: function(arg0, arg1) {
      const ret = debugString(getObject(arg1));
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    },
    __wbindgen_throw: function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    }
  }
};
function instantiate() {
  return instantiateWithInstance().exports;
}
var instanceWithExports;
function instantiateWithInstance() {
  if (instanceWithExports == null) {
    const instance = instantiateInstance();
    wasm = instance.exports;
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    instanceWithExports = {
      instance,
      exports: { parse: parse3, static_text_render_text, static_text_clear_text, static_text_render_once, strip_ansi_codes }
    };
  }
  return instanceWithExports;
}
function instantiateInstance() {
  const wasmBytes = base64decode(
    "AGFzbQEAAAAB7wEiYAAAYAABf2ABfwBgAX8Bf2ACf38AYAJ/fwF/YAN/f38AYAN/f38Bf2AEf39/fwBgBH9/f38Bf2AFf39/f38AYAV/f39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AHf39/f39/fwBgB39/f39/f38Bf2AJf39/f39/fn5+AGAEf39/fgBgA39/fgF/YAV/f35/fwBgBX9/fX9/AGAFf398f38AYAJ/fgBgBH9+f38AYAN/fn4AYAN/fn4Bf2AEf31/fwBgAn98AGADf3x/AX9gBH98f38AYAR/fH9/AX9gAX4Bf2ADfn9/AX9gAXwBfwL4Ei0YX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX2dldF81NzI0NWNjN2Q3Yzc2MTlkAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGV9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXEABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18sX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5Xzk3MWVlZGE2OWViNzUwMDMAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18tX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl9lNWU0OGY0NzYyYzU2MTBiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18VX193YmluZGdlbl9udW1iZXJfZ2V0AAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fc3RyaW5nX2dldAAEGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2Vycm9yX25ldwAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxVfX3diaW5kZ2VuX3N0cmluZ19uZXcABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18bX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85MTgyNzEyYWJlYmY4MmVmAAYYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld18wYjliZmRkOTc1ODMyODRlAAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF9hNjgyMTRmMzVjNDE3ZmE5AAYYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fbnVtYmVyX25ldwAhGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkOAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2lzX2JpZ2ludAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXyRfX3diZ19pc1NhZmVJbnRlZ2VyX2RmYTA1OTNlOGQ3YWMzNWEAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQAHxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18UX193YmluZGdlbl9pc19vYmplY3QAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18fX193YmdfaXRlcmF0b3JfNmY5ZDRmMjg4NDVmNDI2YwABGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXw1fX3diaW5kZ2VuX2luAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHl9fd2JnX2VudHJpZXNfNjVhNzZhNDEzZmM5MTAzNwADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diaW5kZ2VuX2JpZ2ludF9mcm9tX3U2NAAfGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxNfX3diaW5kZ2VuX2pzdmFsX2VxAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hYmRhNzZlODgzYmE4YTVmAAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHF9fd2JnX3N0YWNrXzY1ODI3OWZlNDQ1NDFjZjYABBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18cX193YmdfZXJyb3JfZjg1MTY2N2FmNzFiY2ZjNgAEGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZgACGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fG19fd2JnX25leHRfYWFlZjdjOGFhNWUyMTJhYwADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxtfX3diZ19kb25lXzFiNzNiMDY3MmUxNWYyMzQAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18cX193YmdfdmFsdWVfMWNjYzM2YmMwMzQ2MmQ3MQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diZ19nZXRfNzY1MjAxNTQ0YTJiNjg2OQAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxtfX3diZ19jYWxsXzk3YWU5ZDg2NDVkYzM4OGIABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18bX193YmdfbmV4dF81NzllNTgzZDMzNTY2YTg2AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHl9fd2JnX2lzQXJyYXlfMjdjNDZjNjdmNDk4ZTE1ZAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19sZW5ndGhfOWUxYWUxOTAwY2IwZmJkNQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxFfX3diaW5kZ2VuX21lbW9yeQABGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfM2YzZDc2NGQ0NzQ3ZDU2NAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diZ19zZXRfODNkYjk2OTBmOTM1M2U3OQAGGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxxfX3diaW5kZ2VuX2JpZ2ludF9nZXRfYXNfaTY0AAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nAAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABAPiA+ADHB4IBgMGBAYGBAcHDAYKBgYGCAoGBQUGAwYJBQkGCgIHBwQGCAoIBwYHCAcNBAcFBgIGBQYIBAYEBgUOBwYFAgQFEAwKBwgLDwUFBwggBgYGBQYFAgwFBAIFBQUIAwYLBQUFCgQECAgGBAQIAQQEBAQEBAQEBQYICAYIBAQKBgcIBQYFBAwEBQYEBgIGBQQEBgQEBAQEDAoEBAoKBAUSBAQHBwoEAAQDBgoECAYGBAQFBAsEBgYIBgUFAgYEBgQEBgYFAgICBAUACAYEBQICBAQEBAoEBAQECgcBBgYAChECBAQCAgQEAgICBAQEAgQHBgICBAMEBgQEFhYbDAIGBAYIBQQGAgULBgAEAwMHBQIFBQAEBgAEAgAGAwQFCQYCBAUCAgQJBAUEBAIFBAUFBQUFAgICBgIEBAQCBAQCAggFAgICDQQBCQkTCgoKCwsVFAIEGQUCGQgFAgICBwQFBgoKCgUKCAUFBQUFBQIFBQIDCAIDBAQFBAICAwIFBQYGAgICBAUCBAIFAgQCBAIFBQoFAgIEBgMEBAQFAgIGBAQEBAcGBQUGBAQEAgQFBAQEAgYCBwUHBwICBQcFAwUGAwcFBQIDBAUFBQcHBwcBAgQEBQUFBQICGAMAAgIGAgICBAUBcAF+fgUDAQARBgkBfwFBgIDAAAsH7AELBm1lbW9yeQIABXBhcnNlAD0Xc3RhdGljX3RleHRfcmVuZGVyX3RleHQAVxZzdGF0aWNfdGV4dF9jbGVhcl90ZXh0AHwXc3RhdGljX3RleHRfcmVuZGVyX29uY2UAUxBzdHJpcF9hbnNpX2NvZGVzAK8BEV9fd2JpbmRnZW5fbWFsbG9jALMCEl9fd2JpbmRnZW5fcmVhbGxvYwDSAh9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAOkDD19fd2JpbmRnZW5fZnJlZQDeAxRfX3diaW5kZ2VuX2V4bl9zdG9yZQDdAwn6AQEAQQELfbUDQoED6APtAr0ChwGqA7oB2QO+A9ID6gNrvAPhA7EDxwPmA90BgAHxAvsCsgH3AvoCiQOEA/gC+QL9AvwC9gLzA/QDqQP0AYcEmgOXA5UDlAOTA5gDxAPFA4gE5gLlAuQD4APKAdwCmwP7A84C3wPJAvUDlgOHAowEnAJ21AKLBOIDjQHuA4MEsAPOA4ADhAT/A6MD/QPNA8sDiQS7Av4DkwLMA5IC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hAEhB0EMEKcDIgQgFzcCBCAEIAU2AgAgAyAENgL0AiADKQL0AiEXQQAhBQwBCyADQfgCaiAXNwIAIANB9AJqIAQ2AgAgA0HwAmogBTYCACADIAY2AuwCIANBADYC6AIgBg0BIANBgAFqIAEgAhBBAkACQAJAAkACQAJAIAMoAoABDQAgA0GIAWoiBygCACEGIANBjAFqIggpAgAhGCADKAKEASEFIAMgA0GUAWoiBCgCADYCuAIgAyAYNwOwAiADQYABaiAFIAYQNCADKAKAAQ0BIAcoAgAhCSAIKQIAIRcgAygChAEhByADIAQoAgAiBjYCiAEgAyAXNwOAASAGDQQgA0GAAWoQlQJBACEGIAkhBUEAIQQMAgsgA0GUAWooAgAhBCADQYwBaikCACEXIANBiAFqKAIAIQUgAygChAEhBgwCCyAEKAIAIQQgCCkCACEXIAcoAgAhBSADKAKEASEGCyADQbACahCUAgtBACEHDAELIBinIQUgAyAGNgIYIAMgFzcDECADKQIUIRggF6chBCADKQK0AiEXIAkhBgsgA0HsAmoQiAMgB0UNAgsgAyAYNwKQASADIAQ2AowBIAMgFzcChAEgAyAFNgKAASADQegCaiAHIAYQtwECQCADKALoAkUNACADQfwCaigCACEEIANB9AJqKQIAIRcgA0HwAmooAgAhBSADKALsAiEGIANBgAFqEOACDAILIANB6AJqQQhqKAIAIQogAygC7AIhCyADIBg3AsACIAMgBDYCvAIgAyAXNwK0AiADIAU2ArACIANBADYCrAMgA0IENwKkAyADQYABakEUaiEMIANBgAFqQQxqIQ0gA0GAAWpBCGohCSADQegCakEMaiEOIANBEGpBDGohCCADQegCakEUaiEPQQQhEEEAIQYgCiEFIAshEQJAA0ACQAJAAkAgBQ0AQQAhBQwBCyADQgE3AugCIANBgAFqIANB6AJqEN4BIAMtAIABDQggAy0AgQENAQsgA0HYAmpBCGogA0GkA2pBCGooAgA2AgAgAyADKQKkAzcD2AIMBgsgA0HoAmogESAFEDUCQCADKALwAiISQQNGDQAgA0HQA2pBCGogD0EIaigCACIENgIAIAMgDykCACIXNwPQAyADKALsAiEHIAMoAugCIRMgAygC9AIhFCADKAL4AiEVIAhBCGoiFiAENgIAIAgg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A6gBIANBiAJqQQhqIgUoAgAhBiADKAKMAiEHIAUgBDYCACADIA83A4gCIAQNAiADQYgCahCUAkEAIQQMAQsgA0HIAGpBCGogA0GcAmooAgA2AgAgAyADQZQCaikCADcDSCADQYgCakEIaigCACEGIAMoAowCIQQLIANB5AJqIAMpA0g3AgAgA0HgAmogBjYCACADQQg2AtgCIANB7AJqIANByABqQQhqKAIANgIAIAMgBDYC3AIMAQsgA0H4AGpBCGogBSgCACIENgIAIAMgAykDiAIiDzcDeCADQcgAakEIaiAENgIAIAMgDzcDSCADQYgCaiAHIAYQNAJAAkAgAygCiAJFDQAgA0HQAmpBFGogA0GUAmopAgA3AgAgA0HsAmogA0GIAmpBFGooAgA2AgAgAyADKQKMAjcC3AIgA0EINgLYAgwBCyADQagBakEIaiADQZwCaigCACIGNgIAIAMgA0GUAmopAgAiDzcDqAEgA0GIAmpBCGoiBCgCACEFIAMoAowCIQcgBCAGNgIAIAMgDzcDiAICQCAGRQ0AIANCCDcC2AIgA0GIAmoQlQIMAQsCQAJAAkAgAygCUCIGQQFLDQAgBkUNAiADQeQCaiADKAJIIgRBCGopAgA3AgAgA0HsAmogBEEQaikCADcCACADIAQpAgA3AtwCIAQgBEEYaiAGQRhsQWhqEPgDGkEFIQggA0EFNgLYAiADIAU2AtQCIAMgBzYC0AIgAyAGQX9qNgJQDAELIANB0AJqIAEgAkH41cAAQc0AEI8DIAMoAtgCIQgLIANBiAJqEJUCIANByABqEJQCIAhBCEYNAiADQRBqQQhqIANB+AJqKQIANwMAIANBIGogA0GAA2opAgA3AwAgA0GSAWogA0GLA2otAAA6AAAgAyADKQLwAjcDECADIAMvAIkDOwGQASADKALsAiECIAMoAugCIQcgAygC5AIhBCADKALgAiEFIAMoAtwCIQYgAygC1AIhASADKALQAiEJIAMtAIgDIQoMAwsQ0gEACyADQcgAahCUAgsCQCADKALcAiIGRQ0AIANB7AJqKAIAIQIgA0HoAmooAgAhByADQeQCaigCACEEIANB4AJqKAIAIQUMAgsgA0EIakEBEOkBIAMoAgwhCSADKAIIIghBIToAACADQYgCaiAIQQEgASACENABAkACQAJAIAMoAogCDQAgA0GIAmpBEGoiBSgCACEHIANBiAJqQQxqIgsoAgAhBCADQYgCaiADKAKMAiADQYgCakEIaiIGKAIAEGQCQCADKAKIAkUNACADQZwCaigCACEKIAUoAgAhByALKAIAIQQgBigCACEFDAILIANBqAFqQRBqIAc2AgAgA0GoAWpBDGogBDYCACADQagBakEIaiAGKAIAIgU2AgAgAyADKAKMAiIGNgKsAUEAIQpBASELDAILIANBnAJqKAIAIQogA0GYAmooAgAhByADQZQCaigCACEEIANBkAJqKAIAIQULIAMoAowCIQYgA0G8AWogCjYCACADQbgBaiAHNgIAIANBtAFqIAQ2AgAgA0GwAWogBTYCACADIAY2AqwBQQEhCkEAIQsLIAMgCjYCqAEgCCAJELcDAkACQAJAAkACQCALRQ0AIAYhASAFIQIMAQsgBg0BIANBrAFqEIgDQQAhBAsgA0GIAmogASACEDACQCADKAKQAiIIQQVHDQAgA0GkAmooAgAhAiADQaACaigCACEHIANBnAJqKAIAIQQgA0GYAmooAgAhBSADKAKUAiEGDAILIANBGGogA0GwAmopAgA3AwAgA0EgaiADQbgCaikCADcDACADQZABakECaiADQcgAakECai0AADoAACADIAMpAqgCNwMQIAMgAy8ASDsBkAEgBEEARyEKIAMoAqQCIQIgAygCoAIhByADKAKcAiEEIAMoApgCIQUgAygClAIhBiADKAKMAiEBIAMoAogCIQkMAgsgA0G8AWooAgAhAgtBCCEICwJAIAMoAtgCQQhHDQAgA0HcAmoQiAMLIAhBCEYNAQsgA0HQAmpBKGogA0EQakEQaikDADcCACADQdACakEgaiADQRBqQQhqIgspAwA3AgAgA0GDA2ogA0GSAWotAAA6AAAgAyADKQMQNwLoAiADIAMvAZABOwCBAyADIAo6AIADIAMgAjYC5AIgAyAHNgLgAiADIAQ2AtwCIAMgBTYC2AIgAyAGNgLUAiADIAg2AtACIANBiAJqIAkgARC3ASADKAKIAkUNASADQZwCaigCACECIANBiAJqQRBqKAIAIQcgA0GUAmooAgAhBCADQYgCakEIaigCACEFIAMoAowCIQYgA0HQAmoQnwILIAAgBjYCDCAAQQg2AgggAEEcaiACNgIAIABBGGogBzYCACAAQRRqIAQ2AgAgAEEQaiAFNgIADAELIANBiAJqQQhqKAIAIQkgAygCjAIhCiADQegBakEIaiIMIANB0AJqQRhqIgFBCGopAgA3AwAgA0HoAWpBEGoiDSABQRBqKQIANwMAIANB6AFqQRhqIg4gAUEYaigCADYCACADIAEpAgA3A+gBIAMgAjYCJCADIAc2AiAgAyAENgIcIAMgBTYCGCADIAY2AhQgAyAINgIQIANBEGpBIGogDCkDADcCACADQRBqQShqIA0pAwA3AgAgA0HAAGogDigCADYCACADIAMpA+gBNwIoIANB+ABqIAogCRBqAkACQAJAAkAgAygCeCIFRQ0AAkAgAygCfA0AIANByABqIAtBLBD3AxoMAgsgAEEINgIIIAAgA0H8AGoiBikCADcCDCAAQRxqIAZBEGooAgA2AgAgAEEUaiAGQQhqKQIANwIADAMLIANBhAFqLQAAIQcgA0GIAmogAygCfCIGIANB+ABqQQhqKAIAIgQQMgJAAkAgAygCkAJBCEcNACADQdACaiAGIAQQMgJAAkACQCADKALYAiICQQhHDQACQCADKALcAiIBRQ0AIANB6AJqKAIAIQQgA0HgAmooAgAhAiADQewCaigCACEIIANB5AJqKAIAIQYgA0EsEOkBIAMoAgQhCSADKAIAQbzVwABBLBD3AyEKIANBLDYCzAIgAyAJNgLIAiADIAo2AsQCIANBxAJqQZDTwABBAhDiASADQcQCaiAGIAgQ4gEgA0G0AWogASACIANBxAJqENgBIANBCDYCsAEgBiAEELcDDAMLIANBqAFqIAYgBEG81cAAQSwQjwMgAkEIRw0BQQANAiADKALcAkUNAiADQeQCaigCACADQegCaigCABC3AwwCCyADQagBaiAGIARBvNXAAEEsEI8DCyADQdACahDwAgsgA0GIAmoQ8AIMAQsgA0GoAWogA0GIAmpBPBD3AxoLIAMoArABIgJBCEYNASADQZABakEIaiIGIANBvAFqKQIANwMAIANBkAFqQRBqIgQgA0HEAWooAgA2AgAgAyADKQK0ATcDkAEgAygCrAEhCSADKAKoASEKIANB6AJqIgEgA0HgAWooAgA2AgAgA0HQAmpBEGoiCCADQdgBaikCADcDACADQdACakEIaiILIANB0AFqKQIANwMAIAMgAykCyAE3A9ACIANBiAJqQRBqIgwgBCgCADYCACADQYgCakEIaiINIAYpAwA3AwAgAyADKQOQATcDiAJB7AAQpwMiBiADQRBqQTQQ9wMiBCACNgI0IAQgBzoAaCAEIAMpA4gCNwI4IARBwABqIA0pAwA3AgAgBEHIAGogDCgCADYCACAEIAMpA9ACNwJMIARB1ABqIAspAwA3AgAgBEHcAGogCCkDADcCACAEQeQAaiABKAIANgIAQQchCAsgACAGNgIMIAAgCDYCCCAAIAk2AgQgACAKNgIAIABBEGogA0HIAGpBLBD3AxogBUUNAiADQfwAahCIAwwCCyADQaABaiADQagBakEcaigCACIGNgIAIANBkAFqQQhqIANBqAFqQRRqKQIAIg83AwAgAyADKQK0ASIQNwOQASAAQRxqIAY2AgAgAEEUaiAPNwIAIAAgEDcCDCAAQQg2AggLIANBEGoQnwILIANBkANqJAALpRkDCn8BfgF8IwBBkAJrIgIkACACIAE2AoABAkACQAJAAkACQAJAIAEQoAMNAAJAIAEQBSIDQQFLDQAgAEEAOgAAIAAgA0EARzoAAQwECwJAAkACQAJAAkAgARARQQFGDQAgAkHwAGogARAGIAIoAnBFDQEgAisDeCENIAEQEg0CIAAgDTkDCCAAQQo6AAAMCAsgAiABNgKYASACQRhqIAEQwwIgAigCGEUNAyACIAIpAyAiDBATNgLQASACQZgBaiACQdABahC7AyEDIAIoAtABELYDIAIoApgBIQEgA0UNAyABELYDIAAgDDcDCCAAQQg6AAAMCQsgAkHoAGogARAHIAIoAmgiA0UNASACQeAAaiADIAIoAmwQqwIgAigCYCIERQ0BIAIoAmQhAyAAIAQ2AgQgAEEMOgAAIAAgAzYCDCAAIAM2AggMBgsgAEEIOgAAIA1EAAAAAAAA4MNmIQMCQAJAIA2ZRAAAAAAAAOBDY0UNACANsCEMDAELQoCAgICAgICAgH8hDAsgAEIAQv///////////wAgDEKAgICAgICAgIB/IAMbIA1E////////30NkGyANIA1iGzcDCAwFCwJAAkAgARDsAw0AIAJBhAFqIAJBgAFqEMABIAIoAoQBRQ0BIAJB2wFqIAJBhAFqQQhqKAIANgAAIABBDjoAACACIAIpAoQBNwDTASAAIAIpANABNwABIABBCGogAkHXAWopAAA3AAAMBgsgAiABNgKwAQJAIAJBsAFqEMMDIgFFDQBBCCEDIAJBgAJqQQhqIAEoAgAQEDYCACACQQA2AoQCIAJBADYCjAIgAiABNgKAAiACQThqIAJBgAJqEKwCAkAgAigCPCIBQYCABCABQYCABEkbQQAgAigCOBsiAUUNAEEIIAFBBHQQhQMiA0UNBQsgAkEANgL4ASACIAE2AvQBIAIgAzYC8AEgAkGYAWpBAXIhBCACQdABakEBciEFA0AgAkEwaiACQYACahCOAkEWIQECQCACKAIwRQ0AIAIoAjQhASACIAIoAowCQQFqNgKMAiACQdABaiABEDMgAi0A0AEiAUEWRg0HIAJBxAFqQQJqIAVBAmotAAA6AAAgAiAFLwAAOwHEASACKALUASEDIAIpA9gBIQwLIAQgAi8BxAE7AAAgBEECaiACQcQBakECai0AADoAACACIAw3A6ABIAIgAzYCnAEgAiABOgCYAQJAIAFBFkYNACACQfABaiACQZgBahD+AQwBCwsgAkGYAWoQrgMgAkHbAWogAkHwAWpBCGooAgA2AAAgAEEUOgAAIAIgAikC8AE3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAwHCyACQdABaiACKAKwARCaASACKALQASEBAkACQAJAIAItANQBIgNBfmoOAgIAAQsgAEEWOgAAIAAgATYCBAwICyACIAE2AvABIAIgA0EARzoA9AEgAkEANgKIAiACQgg3AoACIAJBmAFqQQFyIQMgAkHQAWpBAXIhBgJAAkACQAJAA0AgAkEoaiACQfABahC7ASACKAIsIQRBFiEBAkACQCACKAIoDgMABAEACyACQdABaiAEEDMgAi0A0AEiAUEWRg0CIAJBxAFqQQJqIAZBAmotAAA6AAAgAiAGLwAAOwHEASACKALUASEFIAIpA9gBIQwLIAMgAi8BxAE7AAAgA0ECaiACQcQBakECai0AADoAACACIAw3A6ABIAIgBTYCnAEgAiABOgCYASABQRZGDQMgAkGAAmogAkGYAWoQ/gEMAAsLIAIoAtQBIQQLIABBFjoAACAAIAQ2AgQgAkGAAmoQkAIMAQsgAkGYAWoQrgMgAkHbAWogAkGAAmpBCGooAgA2AAAgAEEUOgAAIAIgAikCgAI3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAsgAigC8AEQtgMMBwsgACACQbABahDRAgwGCwJAAkAgARAUQQFHDQAQFSIDIAEQFiEEIAMQtgMgBEEBRw0BCyAAIAJBgAFqENECIAIoAoABIQEMBQsgAiABNgKQASACQdABaiABEJoBIAIoAtABIQMCQAJAAkAgAi0A1AEiBEF+ag4CAgABCyAAQRY6AAAgACADNgIEDAYLIAJBvAFqIARBAEc6AAAgAiADNgK4ASACQQA2ArABIAJBADYCzAEgAkIINwLEASACQeABaiEFIAJB0AFqQQFyIQYgAkGAAmpBAXIhByACQZgBakEBciEIIAJBsAFqQQhqIQkCQANAIAJByABqIAkQuwEgAigCTCEKQQEhBEEWIQMCQAJAAkACQCACKAJIDgMAAQMACyACQcAAaiAKEOQCIAIoAkAhAyACKAJEIQQgAigCsAEgAigCtAEQxgMgAiAENgK0ASACQQE2ArABIAJBmAFqIAMQMwJAIAItAJgBIgNBFkcNACACKAKcASEKDAELIAcgCC8AADsAACAHQQJqIgogCEECai0AADoAACACIAIpA6ABIgw3A4gCIAIgAigCnAEiCzYChAIgAiADOgCAAiACQQA2ArABIAJBmAFqIAQQMyACLQCYAUEWRw0BIAIoApwBIQogAkGAAmoQ5wELIABBFjoAACAAIAo2AgQgAkHEAWoQkQIMAwsgAkHwAWpBCGogAkGYAWpBCGopAwA3AwAgAiACKQOYATcD8AEgAkGUAWpBAmogCi0AADoAACACIAcvAAA7AZQBQQAhBAsgBiACLwGUATsAACAFIAIpA/ABNwMAIAZBAmogAkGUAWpBAmotAAA6AAAgBUEIaiACQfABakEIaikDADcDACACIAw3A9gBIAIgCzYC1AEgAiADOgDQAQJAIAQNACACQcQBaiACQdABahDRAQwBCwsgAkHQAWoQrwMgAkHbAWogAkHEAWpBCGooAgA2AAAgAEEVOgAAIAIgAikCxAE3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAsgAigCuAEQtgMgAigCsAEgAigCtAEQxgMMBQsCQCABEBRBAUYNACAAIAJBkAFqENECIAIoApABIQEMBQsgAiABEBciAzYClAEgAkGYAWpBEGogAxAQIgM2AgAgAkGkAWpBADYCACACQQA2AqwBIAJBADYCmAEgAiACQZQBajYCoAFBCCEEAkAgA0GAgAIgA0GAgAJJGyIDRQ0AQQggA0EFdBCFAyIERQ0DCyACQZgBakEIaiEHIAJBADYCzAEgAiADNgLIASACIAQ2AsQBIAJB0AFqQRBqIQYgAkHQAWpBAXIhCiACQfABakEBciELIAJBlAFqIQUCQAJAAkACQANAQRYhAwJAIAVFDQAgAkHYAGogBxCbAkEWIQMgAigCWEUNACACQdAAaiACKAJcEOQCIAIgAigCrAFBAWo2AqwBIAIoAlQhAyACQYACaiACKAJQEDMgAi0AgAJBFkYNAiACQfABakEIaiACQYACakEIaiIEKQMANwMAIAIgAikDgAI3A/ABIAJBgAJqIAMQMwJAIAItAIACQRZHDQAgAigChAIhBCACQfABahDnAQwECyACQbABakEIaiAEKQMANwMAIAIgAikDgAI3A7ABIAJBwAFqQQJqIAtBAmotAAA6AAAgAiALLwAAOwHAASACKAL0ASEEIAItAPABIgNBF0YNAyACKQP4ASEMCyAKIAIvAcABOwAAIAYgAikDsAE3AwAgCkECaiACQcABakECai0AADoAACAGQQhqIAJBsAFqQQhqKQMANwMAIAIgDDcD2AEgAiAENgLUASACIAM6ANABIANBFkYNAyACQcQBaiACQdABahDRASACKAKgASEFDAALCyACKAKEAiEEIAMQtgMLIABBFjoAACAAIAQ2AgQgAkHEAWoQkQIMAQsgAkHQAWoQrwMgAkHbAWogAkHEAWpBCGooAgA2AAAgAEEVOgAAIAIgAikCxAE3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAsgAigCmAEgAigCnAEQxgMgAigClAEQtgMMBAsgAiABNgKYASACQQhqIAEQwwICQCACKAIIRQ0AIAIgAikDECIMEBg2AtABIAJBmAFqIAJB0AFqELsDIQMgAigC0AEQtgMgAigCmAEhASADRQ0AIAEQtgMgACAMNwMIIABBBDoAAAwGC0HricAAQc8AELABIQMgAEEWOgAAIAAgAzYCBAwDCyAAQRI6AAAMAgsACyACKALUASEBIABBFjoAACAAIAE2AgQgAkHwAWoQkAIMAQsgARC2AwwBCyACKAKwARC2AwsgAkGQAmokAAuUEgIUfwN+IwBBwAFrIgMkAEEAIQQgA0EANgIMIANCBDcCBCADQYgBakEMaiEFQQQhBiADQYgBakEEaiEHIANBoAFqQQxqIQggA0GIAWpBDWohCSADQaABakENaiEKIANB8ABqQQRqIQsgA0GgAWpBBGohDCADQcAAakEEaiENIANB2ABqQQRqIQ4gA0HwAGpBDWohD0EAIRACQAJAAkADQAJAAkAgAkUNACADQaABaiABIAIQaiADKAKoASERIAMoAqQBIRICQAJAAkACQCADKAKgAQ0AIAMgEjYCXAwBCyAPIAopAAA3AAAgD0EHaiAKQQdqIhMoAAA2AAAgAyADLQCsAToAfCADIBE2AnggAyASNgJ0IANBATYCcAJAAkACQCASDQAgA0GgAWogASACEH8CQAJAIAMoAqABDQAgByAMKQIANwIAIAdBCGogDEEIaikCADcCAAwBCwJAIAMoAqQBRQ0AIAcgDCkCADcCACAHQRBqIAxBEGooAgA2AgAgB0EIaiAMQQhqKQIANwIADAMLIANBiAFqIAEgAhC1AiAMEIgDIAMoAogBDQILIAMgAygCkAEiETYCYCADIAMoAowBIhI2AlxBACEUQQEhFQwCCyAOIAspAgA3AgAgDkEQaiALQRBqKAIANgIAIA5BCGogC0EIaikCADcCAEEBIRQgA0EBNgJYIAMoAlwhEgwDCyADIAMoApwBNgJsIAMgAykClAE3AmQgAyADKAKQASIRNgJgIAMgAygCjAEiEjYCXEEBIRRBACEVCyADIBQ2AlggCxCIAyAVRQ0BCyADIBE2AkggAyASNgJEIANBADYCQAwBCwJAAkACQCASDQAgA0GgAWogASACEDUCQCADKAKoASISQQNGDQAgA0GIAWpBCGogCEEIaikCACIXNwMAIANBiAFqQRBqIAhBEGooAgAiETYCACADIAgpAgAiGDcDiAEgAykCoAEhGSAMQRBqIBE2AgAgDEEIaiAXNwIAIAwgGDcCACADIBI2AqABIANBoAFqEKYDIAMgGTcCRCADQQA2AkAMAwsgA0GIAWpBEGogCEEQaigCACISNgIAIANBiAFqQQhqIAhBCGopAgAiFzcDACADIAgpAgAiGDcDiAEgC0EQaiIRIBI2AgAgC0EIaiISIBc3AgAgCyAYNwIAIANBATYCcCADKAJ0RQ0BIA0gCykCADcCACANQRBqIBEoAgA2AgAgDUEIaiASKQIANwIAIANBATYCQAwCCyANIA4pAgA3AgAgDUEQaiAOQRBqKAIANgIAIA1BCGogDkEIaikCADcCACADQQE2AkAMAgsgA0GgAWogASACEF8gAygCqAEhESADKAKkASESAkACQCADKAKgAQ0AIAMgETYCSCADIBI2AkQgA0EANgJADAELIAkgCikAADcAACAJQQdqIBMoAAA2AAAgAyADLQCsAToAlAEgAyARNgKQASADIBI2AowBIANBATYCiAECQAJAAkAgEg0AIANBoAFqQSkgASACEKcBIAMoAqABDQFBACESDAILIA0gBykCADcCACANQRBqIAdBEGooAgA2AgAgDUEIaiAHQQhqKQIANwIAIANBATYCQAwCCyADIAMpArABNwJQIAMgAygCrAE2AkxBASESCyADKAKkASERIAMgAygCqAE2AkggAyARNgJEIAMgEjYCQCAHEIgDCyALEIgDCyAURQ0AIA4QiAMLIANBKGogA0HAAGoQ3gEgAy0AKA0DIAMtACkNASACIQQLIAAgATYCBCAAQQA2AgAgAEEIaiAENgIAIABBDGogAykCBDcCACAAQRRqIANBBGpBCGooAgA2AgAMBAsgA0GgAWogASACEEogA0HwAGpBCGoiEyAIQQhqKAIANgIAIAMgCCkCADcDcCADKAKoASERIAMoAqQBIRICQAJAAkACQAJAAkACQCADKAKgAQ0AIANBoAFqQQhqIhQgEygCACITNgIAIAMgAykDcDcDoAECQCATDQAgA0GgAWoQnANBACESIBYhEQwCCyADQcAAakEIaiAUKAIAIhM2AgAgAyADKQOgASIXNwNAIANB2ABqQQhqIhYgEzYCACADIBc3A1ggA0GgAWogEiAREL0BIAMoAqgBIRMgAygCpAEhEiADKAKgAQ0CIANBoAFqIBIgExC3ASADKAKoASETIAMoAqQBIRIgAygCoAFFDQUgA0HwAGpBCGogCEEIaigCADYCACADIAgpAgA3A3AgEyERDAMLIANB2ABqQQhqIANB8ABqQQhqKAIANgIAIAMgAykDcDcDWAsgA0EoakEIaiADQdgAakEIaigCADYCACADIAMpA1g3AygMAgsgA0HwAGpBCGogCEEIaigCADYCACADIAgpAgA3A3AgEyERCyADQShqQQhqIANB8ABqQQhqKAIANgIAIAMgAykDcDcDKCADQdgAahCcAwsgA0EQakEIaiADQShqQQhqKAIAIhA2AgAgAyADKQMoIhc3AxAgBUEIaiAQNgIAIAUgFzcCACADIBE2ApABIAMgEjYCjAEgA0EBNgKIASASDQEgACABNgIEIABBADYCACAAQQhqIAI2AgAgAEEMaiADKQIENwIAIABBFGogA0EEakEIaigCADYCACAHEIgDDAULIANBEGpBCGogFigCACICNgIAIAMgAykDWCIXNwMQIBQgAjYCACADIBc3A6ABIAUgFzcCACAFQQhqIgEgAjYCACADIBI2AowBIAMgEzYCkAECQCAQIAMoAghHDQAgA0EEaiAQEJ4BIAMoAgQhBiADKAIMIRALIAEoAgAhAiAGIBBBDGxqIgEgBSkCADcCACABQQhqIAI2AgAgAyADKAIMQQFqIhA2AgwgESEWIBMhAiASIQEMAQsLIABBATYCACAAIAcpAgA3AgQgAEEUaiAHQRBqKAIANgIAIABBDGogB0EIaikCADcCAAwBCyADQSJqIANBKGpBFGooAgAiEjYBACADQRpqIANBKGpBDGopAgAiFzcBACADIAMpAiwiGDcBEiAAQRRqIBI2AQAgAEEMaiAXNwEAIAAgGDcBBCAAQQE2AgALIANBBGoQlQILIANBwAFqJAALmBACCn8BfiMAQeABayIDJAAgA0EYaiABIAIQqwECQAJAAkACQCADKAIYIgRFDQACQCADKAIcIgVFDQAgA0EgaikCACENIABBGGogA0EYakEQaikCADcCACAAQRBqIA03AgAgACAFNgIMIABBAzYCCAwECyADQRxqEIgDIANBGGpBJiABIAIQpwECQAJAIAMoAhgNACADQSRqKAIAIQYgA0EgaigCACECIAMoAhwhAQwBCyADKAIcIgUNAiADQRxqEIgDQYCAxAAhBgsMAgsgA0EkaigCACEHIANBIGooAgAhAiADKAIcIQFBgIDEACEGDAELIANBIGopAgAhDSAAQRhqIANBGGpBEGopAgA3AgAgAEEQaiANNwIAIAAgBTYCDCAAQQM2AggMAQsgA0EQakECEOkBIAMoAhQhCCADKAIQIgVBvvwAOwAAIANBCGpBARDpASADKAIMIQkgAygCCCIKQT46AAAgA0ECEOkBIAMoAgQhCyADKAIAIgxBvvgBOwAAIANBPGpBAjYCACADQThqIAg2AgAgAyAFNgI0IANBAjYCMCADIAs2AiwgAyAMNgIoIANBATYCJCADIAk2AiAgAyAKNgIcIANBPDYCGCADQagBaiAFQQIgASACENABAkACQAJAAkACQAJAAkAgAygCqAENACADQewAaiICQQE6AAAgA0GwAWooAgAhCCADKAKsASEFIAIoAgAhCQwBCyADQeAAakEQaiADQagBakEQaikCADcCACADQeAAakEMaiADQagBakEMaigCACIJNgIAIANB4ABqQQhqIANBqAFqQQhqKAIAIgg2AgAgAyADKAKsASIFNgJkIANBATYCYAJAAkACQCAFDQAgA0HkAGohCyADQagBaiAKQQEgASACENABAkACQCADKAKoAQ0AIANBkAFqQQxqIANBqAFqQQxqKQIANwIAIAMgAykCrAE3ApQBDAELIANBrAFqIQUCQCADKAKsAUUNACADQaQBaiAFQRBqKAIANgIAIANBnAFqIAVBCGopAgA3AgAgAyAFKQIANwKUAQwDCyADQZABaiAMQQIgASACENABIAUQiAMgAygCkAENAgtBACEKIANBhAFqIgJBADoAACADQfgAakEIaiADQZABakEIaigCACIINgIAIAMgAygClAEiBTYCfCACKAIAIglBCHYhAgwCCyAJQQh2IQIgAykCcCENDAMLIANB+ABqQRBqIANBkAFqQRBqKQIANwIAIANB+ABqQQxqIANBkAFqQQxqKAIAIgk2AgAgA0H4AGpBCGogA0GQAWpBCGooAgAiCDYCACADIAMoApQBIgU2AnxBASEKIANBATYCeAJAIAUNACADQfwAaiEMIANBqAFqQTwgASACEKcBAkACQCADKAKoAQ0AIANBsAFqKAIAIQggAygCrAEhBUEAIQpBAiEJDAELIANBtAFqKAIAIglBCHYhAiADQbgBaikCACENIANBqAFqQQhqKAIAIQggAygCrAEhBUEBIQoLIAwQiAMMAQsgCUEIdiECIAMpAogBIQ0LIAsQiAMgCg0BCyADQRhqEMwCIANBGGpBJiAFIAgQpwECQAJAIAMoAhgNACADQRhqIAMoAhwgA0EYakEIaiICKAIAEKsBIAMoAhhFDQMgA0EoaikCACENIANBJGooAgAhDCACKAIAIQEMAQsgA0EoaikCACENIANBJGooAgAhDCADQSBqKAIAIQELIAMoAhwhAiADQbgBaiANNwIAIANBtAFqIgogDDYCACADQagBakEIaiABNgIAIAMgAjYCrAEgA0EBNgKoASACDQMgA0GsAWohCiADQRhqIAUgCBC3AQJAAkACQAJAIAMoAhgNACADQRhqIAMoAhwgA0EYakEIaiICKAIAEEogAygCGEUNAiADQfgAakEIaiADQSxqKAIANgIAIAMgA0EkaikCADcDeCACKAIAIQEMAQsgA0H4AGpBCGogA0EsaigCADYCACADIANBJGopAgA3A3ggA0EYakEIaigCACEBCyADKAIcIQIgA0HQAGpBCGogA0H4AGpBCGooAgA2AgAgAyADKQN4NwNQQQAhBQwBCyADQcABakEIaiIFIANBLGooAgA2AgAgAyADQSRqKQIANwPAASACKAIAIQEgAygCHCECIANB0ABqQQhqIAUoAgA2AgAgAyADKQPAATcDUEEBIQULIAoQiAMgBQ0CDAQLIAAgAjsAFSAAIAU2AgwgAEEDNgIIIABBF2ogAkEQdjoAACAAQRhqIA03AgAgAEEUaiAJOgAAIABBEGogCDYCACADQRhqEMwCDAQLIANBqAFqQQxqIgFBADYCACADQbgBaiADQRhqQQxqKAIANgIAIANB0ABqQQhqIANBvAFqKAIANgIAIAMgASkCADcDUCACKAIAIQEgAygCHCECCyADQcAAakEIaiADQdAAakEIaigCACIFNgIAIAMgAykDUCINNwNAIANBGGpBCGogBTYCACADIA03AxggACAHNgIMIABBAkEBIAZBgIDEAEYbQQAgBBs2AgggACABNgIEIAAgAjYCACAAIA03AhAgAEEYaiAFNgIAIAAgCToAHAwCCyADQdAAakEIaiAKQQhqKAIANgIAIAMgCikCADcDUAsgA0HAAGpBCGogA0HQAGpBCGooAgAiBTYCACADIAMpA1AiDTcDQCAAQRxqIAU2AgAgAEEUaiANNwIAIABBEGogATYCACAAIAI2AgwgAEEDNgIICyADQeABaiQAC+wPAgh/An4jAEHQAGsiAiQAIAJBwABqIAEQMwJAAkACQAJAAkACQAJAAkACQAJAAkAgAi0AQCIBQRZGDQAgAiACLQBDOgATIAIgAi8AQTsAESACIAIpA0giCjcDGCACIAIoAkQiAzYCFCAC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IANByAFqIQcgA0HgAGpBBGohCCADQfgAakEEaiEJIANBJGpBBGohCgJAAkACQAJAAkACQAJAAkADQAJAAkACQAJAAkACQAJAAkAgAg0AQQAhAgwBCyADQgE3ArABIANBJGogA0GwAWoQ3gEgAy0AJA0CIAMtACUNAQsgAygCXCELIAMoAlghDCADKAJUIQ0MCAsgAyACNgI4IAMgATYCNCADQR42AjAgA0Gh2MAANgIsIANCp4CAgPAENwIkIANBsAFqQScgASACEKcBIAMoArgBIQwgAygCtAEhDQJAAkACQAJAIAMoArABDQAgA0EANgK4ASADIA02ArABIAMgDSAMajYCtAECQAJAA0AgA0EYaiADQbABahDJASADKAIcIgtBJ0YNASALQYCAxABHDQALQQAhC0Hwu8EAIQ4MAQsgA0EQaiANIAwgAygCGEGA08AAEIACIAMoAhQhCyADKAIQIQ4LIANBCGogDSAMIAwgC2tBtNPAABCLAiADKAIMIQ0gAygCCCEMIANBsAFqIAogDiALEGIgAygCsAFFDQIgAykCwAEhDyADKAK8ASELIAMoArgBIQwgAygCtAEhDQwBCyADKQLAASEPIAMoArwBIQsLIAMgCzYChAEgAyAMNgKAASADIA02AnwgA0EBNgJ4IAMgDz4CiAEgAyAPQiCIPgKMASANDQEgA0EAOgDIASADQqKAgICgBDcCsAEgAyACNgLEASADIAE2AsABIANBHjYCvAEgA0G/2MAANgK4ASADQSRqQSIgASACEKcBIAMoAiwhDSADKAIoIQsCQAJAAkAgAygCJA0AIANBJGogByALIA0QLyADQaABakEIaiIMIARBCGooAgA2AgAgAyAEKQIANwOgASADKAIsIQ0gAygCKCELIAMoAiQNASADQZABakEIaiIOIAwoAgA2AgAgAyADKQOgATcDkAEgA0EkaiAGIAsgDRBiIAMoAiwhDSADKAIoIQsgAygCJA0CIAUgAykDkAE3AgAgBUEIaiAOKAIANgIAIAMgDTYCaCADIAs2AmQgA0EANgJgQQEhDAwICyADIAMpAjQ3AnAgAyADKAIwNgJsDAULIAUgAykDoAE3AgAgBUEIaiAMKAIANgIADAQLIAMgAykCNDcCcCADIAMoAjA2AmwgAyANNgJoIAMgCzYCZCADQQE2AmAgA0GQAWoQnAMMBAsgAykCtAEhD0EQEKcDIQsgAyANEOkBIAMoAgQhAiADKAIAIAwgDRD3AyEBIAsgDTYCDCALIAI2AgggCyABNgIEIAtBADYCACADQoGAgIAQNwKIASADIAs2AoQBIAMgDzcCfCAIQRBqIAlBEGooAgA2AgAgCEEIaiAJQQhqKQIANwIAIAggCSkCADcCACADKAJoIQ0gAygCZCELDAULIAggCSkCADcCACAIQRBqIAlBEGooAgA2AgAgCEEIaiAJQQhqKQIANwIAIANBATYCYCADKAJkIQsMBgsgA0E4aigCACEBIANBNGooAgAhDCADQTBqKAIAIQ0gA0EsaigCACECIAMoAighCwwKCyADIA02AmggAyALNgJkIANBATYCYAtBACEMCyAJEIgDIAxFDQILIANB1ABqIAUQgQIgDSECIAshAQwACwsgCw0BIAMoAlwhCyADKAJYIQwgAygCVCENIAgQiAMLIAMgCzYCuAEgAyAMNgK0ASADIA02ArABAkAgCw0AIANBsAFqEJ8DQQAhC0EAIQEMBQtBACEFIANBADYCRCADQQA2AjQgAyANNgIsIAMgDDYCKCADIA02AiQgAyANIAtBDGxqNgIwIANBsAFqIANBJGoQqQFBBCELAkACQCADKAKwAUEERw0AIANBJGoQsgJBACENDAELIANB+ABqIANBJGoQxQEgAygCeEEBaiILQX8gCxsiC0EEIAtBBEsbIg1B////P0sNAiANQQR0IgtBf0wNAiALEJ0DIgtFDQMgCyADKQKwATcCACALQQhqIANBsAFqQQhqKQIANwIAIANBATYCaCADIA02AmQgAyALNgJgIANBsAFqIANBJGpBMBD3AxogA0HgAGogA0GwAWoQswEgAygCYCELIAMoAmQhDSADKAJoIQULIAAgATYCBCAAQRRqIAU2AgAgAEEQaiANNgIAIABBDGogCzYCACAAQQhqIAI2AgBBACELDAULIANB9ABqKAIAIQEgAygCcCEMIAMoAmwhDSADKAJoIQIMAgsQwgIACwALIANB1ABqEJ8DCyAAIAs2AgQgAEEUaiABNgIAIABBEGogDDYCACAAQQxqIA02AgAgAEEIaiACNgIAQQEhCwsgACALNgIAIANB4AFqJAALpw0CDX8DfiMAQYABayIFJAAgBCABEK8CIQYgBUEcaiABIAQQ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IANBATYC4AEgAQ0EIANBMGogEiAQELUCAkACQCADKAIwIhANAAwBCyADKAJEIRQgAygCQCEVCyADKAI8IRMgAygCOCECIAMoAjQhASAFEIgDIBANBAsgAyACNgK0ASADIAE2ArABIANBADYCrAEgA0GsAWoQqAMMAQsLIAMoAvwBIQogAygC+AEhCyADKAL0ASENIAMoAvABIQ4gAygC7AEhDwwDCyADQcQAaigCACEUIANBwABqKAIAIRUgA0E8aigCACETIBAhAiASIQELIANBwAFqIBQ2AgAgA0G8AWogFTYCACADQbgBaiIKIBM2AgAgAyACNgK0ASADIAE2ArABIANBATYCrAECQCABDQAgA0GsAWoQqAMMBAsgA0EYakEIaiAKQQhqKAIANgIAIAMgCikCADcDGAwCCyADKAL0ASEKIAMoAvABIQsgAygC7AEhDSADKALoASEOIANBrAFqEJ8CCyADIAo2AkwgAyALNgJIIAMgDTYCRCADIA42AkAgAyAPNgI8IANBCDYCOAJAIA8NACADQRhqQQhqIANBJGpBCGooAgA2AgAgAyADKQIkNwMYIAgQiAMgASEPIAIhDgwDCyADQRhqQQhqIAdBCGooAgA2AgAgAyAHKQIANwMYIA4hAiAPIQELIANBJGoQuAMgA0EIakEIaiADQRhqQQhqKAIAIgo2AgAgAyADKQMYIhs3AwggAEEUaiAKNgIAIABBDGogGzcCACAAQQhqIAI2AgAgACABNgIEIABBATYCAAwCCyADQRhqQQhqIANBJGpBCGooAgA2AgAgAyADKQIkNwMYCyADQQhqQQhqIANBGGpBCGooAgAiCjYCACADIAMpAxgiGzcDCCADQTBqQQhqIAo2AgAgAyAbNwMwIABBCGogDjYCACAAIA82AgQgAEEMaiAbNwIAIABBFGogCjYCACAAQQA2AgALIANBoAJqJAALogsBDn8jAEHwAGsiAyQAIANBIGogASACEKsCIAMoAiQhBCADKAIgIQUCQAJAAkACQAJAAkACQAJAAkACQEEALQCwvEEiAkEDRg0AAkAgAg4DAAMCAAtBAEECOgCwvEFBAEEBEJADIQECQAJAAkACQAJAQQAoAsC8QUH/////B3FFDQAQ+gNFDQELQQAoArS8QSECQQBBfzYCtLxBIAINCUEAKALAvEFB/////wdxDQFBACABNgK8vEEMAgsgA0HkAGpCADcCACADQQE2AlwgA0Gk58AANgJYIANB8LvBADYCYCADQdgAakHI58AAEMACAAsQ+gMhAkEAIAE2Ary8QSACRQ0BC0EAKALAvEFB/////wdxRQ0AEPoDDQBBAEEBOgC4vEELQQBBAzoAsLxBQQBBADYCtLxBCyADQSxqIAUgBBA8IAMoAiwNBSADQcAAaigCACEGIANBLGpBCGooAgAhByADKAIwIQggA0EANgJoIAMgCCAHajYCZCADIAg2AmAgAyAHNgJcIAMgCDYCWCADQdgAakEIaiEBIANBOGohCQNAIAMoAmQhCiADKAJgIQsgA0EYaiABEMkBIAMoAhwiAkGAgMQARg0DIAMoAhghDCACEKECDQALIAogC2sgDGogAygCYCINaiADKAJkIgJrIQ4MAwsgA0HkAGpCADcCACADQQE2AlwgA0HchsAANgJYIANB8LvBADYCYCADQdgAakHghcAAEMACAAsgA0HkAGpCADcCACADQQE2AlwgA0GchsAANgJYIANB8LvBADYCYCADQdgAakHghcAAEMACAAtBACEMIAMoAmQhAiADKAJgIQ1BACEOCwJAA0AgDSACIgFGDQECQCABQX9qIgItAAAiCsAiC0F/Sg0AAkACQCABQX5qIgItAAAiCsAiD0FASA0AIApBH3EhCgwBCwJAAkAgAUF9aiICLQAAIgrAIhBBQEgNACAKQQ9xIQoMAQsgAUF8aiICLQAAQQdxQQZ0IBBBP3FyIQoLIApBBnQgD0E/cXIhCgsgCkEGdCALQT9xciIKQYCAxABGDQILIAoQoQINAAsgASANayADKAJoaiEOCwJAAkACQCAOIAxGDQAgA0HEAGogCCAHEMIDIANB2ABqIANBxABqEGMgAygCWA0BIANB5ABqKAIAIQYgA0HgAGooAgAhASADKAJcIQIMAgsCQCAGRQ0AIANBPGooAgAhASADKAI4IQIMBQsgA0EIakEEQQwQ4gIgAygCCCIBRQ0CIAFBDjYCCCABQdTUwAA2AgQgAUHEj8AANgIAIAkQuAMMBQtBACECIANB2ABqELkCIQELIAkQuAMMAgsACwJAAkAgAygCMEUNACADQdgAaiADQTBqEGMCQCADKAJYDQAgA0HkAGooAgAhBiADQeAAaigCACEBIAMoAlwhAgwD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A0HSAGogA0HoAGpBFGooAgAiDTYBACADQcoAaiADQegAakEMaikCACIRNwEAIAMgAykCbCISNwFCIABBFGogDTYBACAAQQxqIBE3AQAgACASNwEEIABBATYCAAsgA0EUahCUAgsgA0GAAWokAAuYCgEBfyMAQTBrIgIkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAtAAAOEgABAgMEBQYHCAkKCwwNDg8QEQALIAIgAC0AAToACCACQSRqQgE3AgAgAkECNgIcIAJBlOLAADYCGCACQQM2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDBELIAIgACkDCDcDCCACQSRqQgE3AgAgAkECNgIcIAJBsOLAADYCGCACQQQ2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDBALIAIgACkDCDcDCCACQSRqQgE3AgAgAkECNgIcIAJBsOLAADYCGCACQQU2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDA8LIAIgACsDCDkDCCACQSRqQgE3AgAgAkECNgIcIAJB0OLAADYCGCACQQY2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDA4LIAIgACgCBDYCCCACQSRqQgE3AgAgAkECNgIcIAJB7OLAADYCGCACQQc2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDA0LIAIgACkCBDcCCCACQSRqQgE3AgAgAkEBNgIcIAJBhOPAADYCGCACQQg2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDAwLIAJBJGpCADcCACACQQE2AhwgAkGM48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAsLIAJBJGpCADcCACACQQE2AhwgAkGg48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAoLIAJBJGpCADcCACACQQE2AhwgAkG048AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAkLIAJBJGpCADcCACACQQE2AhwgAkHM48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAgLIAJBJGpCADcCACACQQE2AhwgAkHc48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAcLIAJBJGpCADcCACACQQE2AhwgAkHo48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAYLIAJBJGpCADcCACACQQE2AhwgAkH048AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAULIAJBJGpCADcCACACQQE2AhwgAkGI5MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAQLIAJBJGpCADcCACACQQE2AhwgAkGg5MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAMLIAJBJGpCADcCACACQQE2AhwgAkG45MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAILIAJBJGpCADcCACACQQE2AhwgAkHQ5MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAELIAEoAhQgACgCBCAAQQhqKAIAIAFBGGooAgAoAgwRBwAhAQsgAkEwaiQAIAELqAgBB38CQAJAIAFB/wlLDQAgAUEFdiECAkACQAJAIAAoAqABIgNFDQAgA0F/aiEEIANBAnQgAGpBfGohBSADIAJqQQJ0IABqQXxqIQYgA0EpSSEDA0AgA0UNAiACIARqIgdBKE8NAyAGIAUoAgA2AgAgBkF8aiEGIAVBfGohBSAEQX9qIgRBf0cNAAsLIAFBIEkNAyAAQQA2AgAgAUHAAEkNAyAAQQA2AgQgAkEBIAJBAUsbIgRBAkYNAyAAQQA2AgggBEEDRg0DIABBADYCDCAEQQRGDQMgAEEANgIQIARBBUYNAyAAQQA2AhQgBEEGRg0DIABBADYCGCAEQQdGDQMgAEEANgIcIARBCEYNAyAAQQA2AiAgBEEJRg0DIABBADYCJCAEQQpGDQMgAEEANgIoIARBC0YNAyAAQQA2AiwgBEEMRg0DIABBADYCMCAEQQ1GDQMgAEEANgI0IARBDkYNAyAAQQA2AjggBEEPRg0DIABBADYCPCAEQRBGDQMgAEEANgJAIARBEUYNAyAAQQA2AkQgBEESRg0DIABBADYCSCAEQRNGDQMgAEEANgJMIARBFEYNAyAAQQA2AlAgBEEVRg0DIABBADYCVCAEQRZGDQMgAEEANgJYIARBF0YNAyAAQQA2AlwgBEEYRg0DIABBADYCYCAEQRlGDQMgAEEANgJkIARBGkYNAyAAQQA2AmggBEEbRg0DIABBADYCbCAEQRxGDQMgAEEANgJwIARBHUYNAyAAQQA2AnQgBEEeRg0DIABBADYCeCAEQR9GDQMgAEEANgJ8IARBIEYNAyAAQQA2AoABIARBIUYNAyAAQQA2AoQBIARBIkYNAyAAQQA2AogBIARBI0YNAyAAQQA2AowBIARBJEYNAyAAQQA2ApABIARBJUYNAyAAQQA2ApQBIARBJkYNAyAAQQA2ApgBIARBJ0YNAyAAQQA2ApwBIARBKEYNA0EoQShBlMrAABDqAQALIARBKEGUysAAEOoBAAsgB0EoQZTKwAAQ6gEAC0G+ysAAQR1BlMrAABCjAgALIAAoAqABIAJqIQUCQCABQR9xIgMNACAAIAU2AqABIAAPCwJAAkAgBUF/aiIEQSdLDQAgBSEIIAAgBEECdGooAgAiBkEAIAFrIgF2IgRFDQECQCAFQSdLDQAgACAFQQJ0aiAENgIAIAVBAWohCAwCCyAFQShBlMrAABDqAQALIARBKEGUysAAEOoBAAsCQAJAIAJBAWoiByAFTw0AIAFBH3EhASAFQQJ0IABqQXhqIQQDQCAFQX5qQShPDQIgBEEEaiAGIAN0IAQoAgAiBiABdnI2AgAgBEF8aiEEIAcgBUF/aiIFSQ0ACwsgACACQQJ0aiIEIAQoAgAgA3Q2AgAgACAINgKgASAADwtBf0EoQZTKwAAQ6gEAC4MJAgd/An4jAEHwAGsiAyQAIANByABqIAEgAhA6AkACQCADKAJIDQAgA0EwakEIaiADQcgAakEUaigCACICNgIAIAMgA0HIAGpBDGopAgAiCjcDMCADKQJMIQsgA0HIAGpBCGoiASACNgIAIAMgCjcDSEEQEKcDIgJBAzYCACACIAMpA0g3AgQgAkEMaiABKAIANgIAIANBDGpBEGpCgYCAgBA3AgAgA0EMakEMaiIBIAI2AgAgACALNwIEIABBDGogASkCADcCACAAQRRqQQE2AgAgAEEANgIAIAMgCzcCEAwBCyADQQxqQQxqIANByABqQQxqKQIANwIAIANBDGpBFGogA0HIAGpBFGooAgA2AgAgA0EMakEIaiADQcgAakEIaigCADYCACADIAMoAkwiBDYCECADQQE2AgwgA0EQaiEFAkAgBEUNACAAQQE2AgAgACAFKQIANwIEIABBFGogBUEQaigCADYCACAAQQxqIAVBCGopAgA3AgAMAQsgA0EaNgIoIANBh9jAADYCJCADQQE6ACwgA0EwaiADQSRqQQhqIgYgASACEC9BAiEEAkAgAygCMA0AQQEhBCADQcQAaigCAEEBRw0AIANBMGpBDGooAgAiBygCAA0AQQAhBCAHKAIEIgggB0EMaigCACIHQYjawABBAhD0Ag0AIAggB0GK2sAAQQQQ9AINACAIIAdBjtrAAEEEEPQCDQAgCCAHQZLawABBBBD0Ag0AIAggB0GW2sAAQQIQ9AINACAIIAdBmNrAAEECEPQCDQAgCCAHQZrawABBBBD0Ag0AIAggB0Ge2sAAQQQQ9AINACAIIAdBotrAAEEEEPQCDQAgCCAHQabawABBBRD0Ag0AIAggB0Gr2sAAQQUQ9AINACAIIAdBsNrAAEEDEPQCDQAgCCAHQbPawABBAhD0AkEBcyEECwJAAkACQCAEQQJGDQAgBEEBcQ0AIANByABqIAYgASACEC8CQAJAIAMoAkgiBEUNAAJAIAMoAkwiBkUNACADQcgAakEQaigCACEEIANByABqQQhqKAIAIQcgA0HcAGooAgAhCCADQdQAaigCACEBIANBGhDpASADKAIEIQkgAygCACICQQApAIfYQDcAACACQRhqQQAvAJ/YQDsAACACQRBqQQApAJfYQDcAACACQQhqQQApAI/YQDcAACADQRo2AmwgAyAJNgJoIAMgAjYCZCADQeQAakGQ08AAQQIQ4gEgA0HkAGogASAIEOIBIABBBGogBiAHIANB5ABqENgBIABBATYCACABIAQQtwMMBAsgAEEEaiABIAJBh9jAAEEaEMQBIABBATYCACAERQ0BQQANAyADKAJMRQ0DIANB1ABqKAIAIANB2ABqKAIAELcDDAMLIABBBGogASACQYfYwABBGhDEASAAQQE2AgALIANByABqEIIDDAELIAAgAykCMDcCACAAQRBqIANBMGpBEGopAgA3AgAgAEEIaiAD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ACABQcAAahBWDQACQCAAKAIMIgJFDQAgAUE0akHssMAAQQIQ4wMNASABQdgAakEQaiACQRBqKQIANwMAIAFB2ABqQQhqIAJBCGopAgA3AwAgASACKQIANwNYIAFBNGpB/JDAACABQdgAahBWDQEMAgsgAUEgaiAAKAIAIgIgACgCBCgCDBEEACABKQMgQsH3+ejMk7LRQYUgAUEoaikDAELk3seFkNCF3n2FhFBFDQEgAUE0akHssMAAQQIQ4wMNACABQTRqIAIoAgAgAigCBBDjA0UNAQtBlJHAAEE3IAFB2ABqQcyRwABBqJLAABDWAQALIAFBwABqQQhqIgAgAUE0akEIaigCADYCACABIAEpAjQ3A0AgAUHAAGpB0JLAAEHaksAAENoBIAFBGGoQGiICEBsgAUEQaiABKAIYIAEoAhwQqwIgAUHAAGogASgCECIDIAEoAhQiBBDQAyABQcAAakGQ08AAQZLTwAAQ2gEgAUHYAGpBCGogACgCADYCACABIAEpA0A3A1ggAUEIaiABQdgAahDXASABKAIIIAEoAgwQHCADIAQQtwMCQCACQYQBSQ0AIAIQHQsgAUHwAGokAAumBAIHfwF+IwBBwABrIgMkACADQQhqQQIQ6QEgAygCDCEEIAMoAggiBUH8zAA7AAAgA0EoaiAFQQIgASACENABAkACQAJAAkACQCADKAIoDQAgA0EcaiIGQQE6AAAgA0EwaigCACEHIAMoAiwhCCAGKAIAIQYMAQsgA0EQakEQaiADQShqQRBqKQIANwIAIANBEGpBDGogA0EoakEMaigCACIGNgIAIANBEGpBCGogA0EoakEIaigCACIHNgIAIAMgAygCLCIINgIUIANBATYCECAIDQEgA0EUaiEJIANBKGpB/AAgASACEKcBAkACQCADKAIoIgENACADQTBqKAIAIQcgAygCLCEIQQAhBgwBCyADQTRqKAIAIgZBCHYhAiADQThqKQIAIQogA0EoakEIaigCACEHIAMoAiwhCAsgCRCIAyABDQILIANBKGpB4tfAAEECIAggBxBxAkAgAygCKEUNACADLwA1IANBN2otAABBEHRyIQIgA0EoakEQaikCACEKIANBNGotAAAhBiADQTBqKAIAIQcgAygCLCEIDAILIAAgAykCLDcCBEEAIQggAEEMaiAGQf8BcUEARzoA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f2oiCiAFTw0IIAogDGoiESADTw0GIAQgCmotAAAgAiARai0AAEYNAAsgASAIIAxqIgw2AhQgBg0EIAkhCgwICyAMIApqIhIgA08NBSAQIApqIREgBCAKaiETIApBAWohCiATLQAAIBEtAABGDQALIBIgC2tBAWohDAwBCyAMIAVqIQwLIAEgDDYCFCAGDQALQQAhCgwDCyARIANBuNLAABDqAQALIBIgA0HI0sAAEOoBAAsgCiAFQajSwAAQ6gEACyABIAo2AhwMAQsLIAAgDDYCBCAAQQhqIAo2AgBBASEKCyAAIAo2AgAL0wMCB38BfCMAQeAAayIDJAACQAJAAkAgACgCACIEEKADRQ0AQQchBUEAIQZBACEADAELQQAhBgJAQQFBAiAEEAUiB0EBRhtBACAHGyIHQQJGDQBBACEAQQAhBQwCCyADQRhqIAQQBgJAIAMoAhhFDQAgAysDICEKQQMhBUEAIQZBACEADAELIANBEGogBBAHAkACQCADKAIQIgRFDQAgA0EIaiAEIAMoAhQQqwIgAygCCCIERQ0AIAMoAgwhByADIAQ2AiggAyAHNgIwIAMgBzYCLEEFIQVBASEAQQAhBgwBCyADQTRqIAAQwAECQAJAIAMoAjQiCEUNAEEGIQUgAygCPCEHIAMoAjghCSAIIQQMAQsgA0HMAGpCATcCACADQQE2AkQgA0Gg38AANgJAIANBCTYCXCADIAA2AlggAyADQdgAajYCSCADQShqIANBwABqEL8BQREhBSADKAIoIQQgAygCMCEHCyAIQQBHIQYgCEUhAAsgB62/IQoLCyADIAo5A0ggAyAENgJEIAMgBzoAQSADIAU6AEAgA0HAAGogASACEM4BIQcCQCAGRQ0AIAggCRC3AwsCQCAARQ0AIAQgAygCLBC3AwsgA0HgAGokACAHC9wDAgN/An4jAEHgAGsiAyQAIANBCGpB0NTAAEECENUBIANByABqQdLUwABBAhDVASADQSxqIANByABqQRBqIgQoAgA2AgAgA0EkaiADQcgAakEIaiIFKQMANwIAIAMgAykDSDcCHCADQcgAaiADQQhqIAEgAhCJAQJAAkAgAygCSA0AIANBMGpBDGoiAkEAOgAAIAAgAykCTCIGNwIEIABBADYCACAAQQxqIAIoAgA2AgAgAyAGNwI0DAELIANBMGpBEGog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AyQAIAMgATYCCCADIAEgAmo2AgwCQAJAIANBCGoQxwIiBEGAgMQARg0AQQEhBQJAIARBgAFJDQBBAiEFIARBgBBJDQBBA0EEIARBgIAESRshBQsgAyABIAIgBUGE4MAAEIUCIAMpAwAhBiAAQQxqIAQ2AgAgACAGNwIEQQAhAQwBCyAAQQA2AgRBASEBCyAAIAE2AgAgA0EQaiQAC6MBAQJ/IwBBEGsiAiQAAkACQAJAIAEoAgBFDQACQCABKAIIIgMgASgCDEYNACABIANBEGo2AgggAkEIaiADQQxqKAIANgIAIAIgAykCBDcDACADKAIAIgNBBEcNAgsgARC/AyABQQA2AgBBBCEDDAELIABBBDYCAAwBCyAAIAM2AgAgACACKQMANwIEIABBDGogAkEIaigCADYCAAsgAkEQaiQAC50BAQF/IwBBIGsiAyQAIANBCGogASACEGQCQAJAAkACQCADKAIIDQAgA0EQaigCACECIAMoAgwhAQwBCyADKAIMDQELIAAgATYCBCAAQQhqIAI2AgBBACECDAELIAAgA0EMaiICKQIANwIEIABBFGogAkEQaigCADYCACAAQQxqIAJBCGopAgA3AgBBASECCyAAIAI2AgAgA0EgaiQAC7QBAQN/IwBBEGsiASQAIAAoAgAiAkEMaigCACEDAkACQAJAAkAgAigCBA4CAAEDCyADDQJB8LvBACECQQAhAwwBCyADDQEgAigCACICKAIEIQMgAigCACECCyABIAM2AgQgASACNgIAIAFBiOjAACAAKAIEIgIoAgwgACgCCCACLQAQEKoBAAsgAUEANgIEIAEgAjYCACABQZzowAAgACgCBCICKAIMIAAoAgggAi0AEBCqAQALowEAAkACQAJAAkAgAkF8ag4DAAIBAgsgAS0AAEH0AEcNASABLQABQeUARw0BIAEtAAJB+ABHDQFBACECIAEtAANB9ABHDQEMAgsgAS0AAEHpAEcNACABLQABQe4ARw0AIAEtAAJB5ABHDQAgAS0AA0HlAEcNACABLQAEQe4ARw0AQQEhAiABLQAFQfQARg0BC0ECIQILIABBADoAACAAIAI6AAELnwEBAX8jAEHAAGsiAiQAIAJCADcDOCACQThqIAAoAgAQKyACQRhqQgE3AgAgAiACKAI8IgA2AjQgAiAANgIwIAIgAigCODYC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IAJBMGokACABC2QBAX8jAEEwayICJAAgAiABNgIMIAIgADYCCCACQRxqQgE3AgAgAkECNgIUIAJBnInAADYCECACQRI2AiwgAiACQShqNgIYIAIgAkEIajYCKCACQRBqELgCIQEgAkEwaiQAIAELeQACQAJAAkACQAJAAkACQCAALQAADhUBAQEBAQEBAQEBAQECAQMBAQQBBQYACyAAQQRqEJECCw8LIAAoAgQgAEEIaigCABC3Aw8LIAAoAgQgAEEIaigCABC3Aw8LIABBBGoQyAMPCyAAQQRqEMgDDwsgAEEEahCQAgtkAQF/IwBBEGsiAyQAAkAgASgCAA0AIAAgASgCBDYCACAAIAFBCGotAAA6AAQgA0EQaiQADwsgAyABKAIENgIIIAMgAUEIai0AADoADEH7lsAAQSsgA0EIakHAiMAAIAIQ1gEAC1sBAn8jAEEQayICJAACQAJAAkACQCABDQBBASEDDAELIAFBf0wNASACQQhqQQEgARDiAiACKAIIIgNFDQILIAAgATYCBCAAIAM2AgAgAkEQaiQADwsQwgIACwALXgEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBLGpBEDYCACADQRA2AiQgAyADNgIoIAMgA0EEajYCICADQQhqQbSxwABBAiADQSBqQQIQxwEgA0EIaiACEMACAAthAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEsakEQNgIAIAJBEDYCJCACIAI2AiggAiACQQRqNgIgIAJBCGpBlLjAAEEDIAJBIGpBAhDHASACQQhqQciYwAAQwAIAC2IBA38CQCAAKAIMIgIgACgCECIDTw0AAkAgACgCCCIEIAAoAgRHDQAgACAEEJ4BIAAoAgghBAsgACAEQQFqNgIIIAAoAgAgBEEMbGoiACABOgAIIAAgAzYCBCAAIAI2AgALC14BAX8jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQSxqQRA2AgAgA0EQNgIkIAMgA0EEajYCKCADIAM2AiAgA0EIakGQt8AAQQIgA0EgakECEMcBIANBCGogAhDAAgALXgEBfyMAQTBrIgMkACADIAA2AgAgAyABNgIEIANBLGpBEDYCACADQRA2AiQgAyADQQRqNgIoIAMgAzYCICADQQhqQcS3wABBAiADQSBqQQIQxwEgA0EI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AgwBCyABQf///z9LDQEgAUEEdCICQX9MDQFBBCACEIUDIgJFDQILIAAgATYCBCAAIAI2AgAPCxDCAgALAAtRAQJ/IwBBEGsiAiQAAkACQCABKAIADQBBACEBQQAhAwwBCyACQQhqIAEQjwIgAigCDCEBIAIoAgghAwsgACABNgIEIAAgAzYCACACQRBqJAALSwACQAJAAkAgAiADSw0AIAIgA0cNAQwCCyABIANqLAAAQb9/Sg0BCyABIAIgAyACIAQQvQMACyAAIAIgA2s2AgQgACABIANqNgIAC0oBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASAAQQFqIQAgAUEBaiEBIAJBf2oiAkUNAgwACwsgBCAFayEDCyADC1wBAn9BAEEBEJADIQBBLEEEEJADIgFBAToAKCABQQA2ASQgAUIENwEcIAFBwITAADYBGCABIAA2ARQgAUEAOwEQIAFBADsBDCABQQA7AQggAUKBgICAEDcCACABC04BAX8jAEEgayIDJAAgA0EQaiACNgIAIAMgATYCDCADQQU6AAggA0EIaiADQR9qQdCJwAAQzgEhAiAAQQI7AQAgACACNgIEIANBIGokAAtOAQF/IwBBIGsiAyQAIANBEGogAjYCACADIAE2AgwgA0EGOgAIIANBCGogA0EfakHQicAAEM4BIQIgAEECOwEAIAAgAjYCBCADQSBqJAALUwEBfyMAQTBrIgAkACAAQTU2AgwgAEG4l8AANgIIIABBDDYCLCAAIABBCGo2AiggAEEQakGg38AAQQEgAEEoakEBEMcBIABBEGpBuJjAABDAAgALSgACQCADRQ0AAkACQCADIAJJDQAgAyACRw0BDAILIAEgA2osAABBv39KDQELIAEgAkEAIAMgBBC9AwALIAAgAzYCBCAAIAE2AgALRwEEfyABIAEgAiADEMsBIgRqIgUtAAAhBiAFIAOnQRl2Igc6AAAgBEF4aiACcSABakEIaiAHOgAAIAAgBjoABCAAIAQ2AgALSwEDfyAAKAIIIQEgACgCACICIQMCQANAIAFFDQEgAUF/aiEBIAMQugMgA0EQaiEDDAALCwJAIAAoAgQiAUUNACACIAFBBHQQwQMLC00BAn8jAEEQayICJAACQAJAIAEoAgANAEEAIQEMAQsgAkEIaiABEJsCIAIoAgwh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QgEBfwJAAkACQCACQYCAxABGDQBBASEFIAAgAiABKAIQEQUADQELIAMNAUEAIQULIAUPCyAAIAMgBCABKAIMEQcACz4BAX8jAEEgayIDJAAgA0EMakHh18AAQQEQ1QEgACADQQxqIAEgAhCJASADKAIMIAMoAhAQtwMgA0EgaiQAC0EBAn9BACEAAkBBACgC2L1BIgFFDQBBACEAA0AgAEEBaiEAIAEoAggiAQ0ACwtBACAAQf8fIABB/x9LGzYCkMBBC0UBAn9BAC0ApMBBGiABKAIEIQIgASgCACEDAkBBCBAxIgENAAALIAEgAjYCBCABIAM2AgAgAEH458AANgIEIAAgATYCAAs6AQJ/IwBBEGsiASQAIAFBBGogABC/ASABKAIEIgAgASgCDBAIIQIgACABKAIIELcDIAFBEGokACACCz8BAX9BHBCnAyIBQbzUwAA2AgAgASAAKQIANwIEIAFBDGogAEEIaikCADcCACABQRRqIABBEGopAgA3AgAgAQs8AQF/IwBBEGsiAyQAAkAgAA0AIANBEGokACABDwsgAyABNgIMQfuWwABBKyADQQxqQbCIwAAgAhDWAQALPAEBfyMAQRBrIgIkACACQQhqIAAgACgCACgCBBEEACACKAIIIAEgAigCDCgCEBEFACEAIAJBEGokACAAC0IBAn8gACgCBCEBIABB8LvBADYCBCAAKAIAIQIgAEHwu8EANgIAAkAgASACRg0AIAIgASACa0EEdhDVAgsgABDxAQs7AgF/AXwgASgCHEEBcSECIAArAwAhAwJAIAEoAghFDQAgASADIAIgAUEMaigCABAuDwsgASADIAIQLQs8AQF/IwBBEGsiAiQAIAJBCGogACAAKAIAKAIEEQQAIAIoAgggASACKAIMKAIQEQUAIQAgAkEQaiQAIAALQAEBfyMAQSBrIgAkACAAQRRqQgA3AgAgAEEBNgIMIABB6NrAADYCCCAAQfC7wQA2AhAgAEEIakHE28AAEMACAAs/AQF/IwBBIGsiAiQAIAIgADYCGCACQfCwwAA2AhAgAkHwu8EANgIMIAJBAToAHCACIAE2AhQgAkEMahCqAgALNwEBfyMAQRBrIgMkACADQQhqIAEgAhB9IAMoAgwhAiAAIAMoAgg2AgAgACACNgIEIANBEGokAAtAAQF/IwBBIGsiACQAIABBFGpCADcCACAAQQE2AgwgAEHojcAANgIIIABB8LvBADYCECAAQQhqQfCNwAAQwAIACzYBAX8jAEEQayICJAAgAiABECogAigCACEBIAAgAikDCDcDCCAAIAFBAEetNwMAIAJBEGokAAs/AAJAIAAtABgNACAAQQAQ7AEgAEEBOgAYIAAgACgCEDYCDAsgACAAKAIUNgIQIABBARDsASAAIAAoAhQ2AgwLQAEBfyMAQSBrIgAkACAAQRRqQgA3AgAgAEEBNgIMIABB/OXAADYCCCAAQfC7wQA2AhAgAEEIakGE5sAAEMACAAs3AQF/IwBBEGsiAyQAIANBCGogASACEKsDIAMoAgwhAiAAQe2BwABBBBBnIAIQ6wMgA0EQaiQACzYBAn8jAEEQayIBJAAgAUEIaiAAEJYBIAEoAgghACABKAIMIQIgAUEQaiQAIAJBgIDEACAAGws9AQF/IwBBEGsiAiQAIAJB5IbAADYCDCACIAA2AgggAkEIakHQiMAAIAJBDGpB0IjAACABQfiHwAAQggEACz0BAn9BASECAkAgASgCFCIDQeCJwABBCyABQRhqKAIAKAIMIgERBwANACADQZazwABBByABEQcAIQILIAILMAAgAUH//wNxIANB//8DcUYgAiAAckH//wNxRSIDIAJB//8DcRsgAyAAQf//A3EbCzoBAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCADQQhqQcSxwAAgA0EMakHEscAAIAJBmJ7AABCCAQALNQAgACgCHCAAQSBqKAIAELcDIAAoAgQgAEEIaigCABC3AyAAQRBqKAIAIABBFGooAgAQtwMLPQEBfyMAQRBrIgIkACACQfDgwAA2AgwgAiAANgIIIAJBCGpB4ODAACACQQxqQeDgwAAgAUHo4cAAEIIBAAsyAQF/IwBBEGsiAiQAIAIgADYCDCABQfbKwABBBSACQQxqQQ0QjAEhACACQRBqJAAgAAsyAQF/IAAoAgghASAAKAIAIQACQANAIAFFDQEgAUF/aiEBIAAQnwIgAEE4aiEADAALCwswAQF/IABBDGoQmgICQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQTAsLMgEBfyMAQRBrIgIkACABIAJBD2pBsITAABBpIQEgAEEWOgAAIAAgATYCBCACQRBqJAALLwACQAJA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ACIAEOcBIAAQTAsPACAAEOcBIABBEGoQ5wELDgAgACABIAEgAmoQ2QELEwAgAEEoNgIEIABB2NLAADYCAAsgACAAQpuomM3bgtTUfDcDCCAAQpa3iIC6l+SpEjcDAAsiACAAQubG5dbLj/f/5AA3AwggAELznNq2t8OlnY9/NwMACxMAIABBpJDAADYCBCAAIAE2AgALEAAgACgCACABIAIQ0ANBAAsOACAAIAEgASACahDaAQsPACAAKAIAIAEQiAEaQQALEAAgASAAKAIAIAAoAgQQOAsQACAAIAIQ+AEgAUEMOgAACyAAIABCq/3xnKmDxYRkNwMIIABC+P3H/oOGtog5NwMACyEAIABCzOOog7P46rB0NwMIIABC/ZCAh5Cx88TRADcDAAsgACAAQraSm5Smo42H8AA3AwggAEKMibeF4+rZTzcDAAsOACAAQQRqEOMCIAAQTAsTACAAQZDUwAA2AgQgACABNgIACxAAIAEgACgCACAAKAIIEDgLIQAgAELCw5vOrZDA3qZ/NwMIIABC0oKx+Pqs5712NwMACxMAIABB+OfAADYCBCAAIAE2AgALIAAgAELk3seFkNCF3n03AwggAELB9/nozJOy0UE3AwALFABBACAANgKswEFBAEEBOgCowEELDgACQCABRQ0AIAAQTAsLDwAgACgCACAALQAEEPICCw0AIAAgASACEOIBQQALDQAgADUCAEEBIAEQegsNACAAKAIAIAEgAhBYCw0AIAAgASACENADQQALDwAgACgCACAAKAIEELcDCw8AIAAoAgAgACgCBBCkAwsNACAAKAIAGgN/DAALCw0AIAAoAgAgASACEFsLDQAgACkDAEEBIAEQegsLACAAIwBqJAAjAAsMACAAKAIAIAEQugELCgAgACABIAIQCwsJACAAECVBAEcLCgAgACABIAIQVgsMACAAKAIAIAEQ2wILDAAgACgCACABENwCCwoAIABBBGoQ4wILCQAgABAeQQFGCwkAIAAgARAsAAsMACAAKAIAIAEQqQMLDAAgACgCACABENkDCwwAIAAoAgAgARCBAwsLACAAIAEgAhCsAQsKACAAIAEgAhB4CwoAIAAgASACEE0LCwAgACABIAIQhgILCgBBACgClMBBRQsKACAAKAIAELYDCwkAIAAgARDVAgsJACAAQQA2AgALCAAgACABEGALCQAgACABEMcDCwgAIAAgARBgCwgAIAAgARAACwgAIAAQuAEACwYAIAAQTAsGACAAEEwLBgAgABAmCwMAAAsCAAsCAAsCAAsCAAsCAAsCAAsLq7wBAgBBgIDAAAuMvAEmAAAAAAAAAAEAAAAnAAAAaW52YWxpZCB0eXBlOiAAABAAEAAOAAAAbwQQAAsAAAD//////////0M6XFVzZXJzXGRhdmlkXC5jYXJnb1xyZWdpc3RyeVxzcmNcaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWZcc2VyZGUtd2FzbS1iaW5kZ2VuLTAuNi4zXHNyY1xsaWIucnMAOAAQAGcAAAA1AAAADgAAACYAAAAAAAAAAQAAACgAAAAmAAAAAAAAAAEAAAApAAAAJgAAAAAAAAABAAAAKgAAAG5hbWV2YWx1ZXdvcmRraW5kZmRDb21tYW5kaW5uZXJyZWRpcmVjdFBpcGVsaW5lbmVnYXRlZG1heWJlRmRvcGlvRmlsZVNlcXVlbmNlU2hlbGxWYXJzaGVsbFZhcnBpcGVsaW5lQm9vbGVhbkxpc3Rib29sZWFuTGlzdHRleHR2YXJpYWJsZWNvbW1hbmRxdW90ZWRzdGRvdXRTdGRlcnJpbnB1dG91dHB1dGN1cnJlbnRuZXh0Q29tbWFuZElubmVyU2ltcGxlc2ltcGxlU3Vic2hlbGxzdWJzaGVsbFBpcGVTZXF1ZW5jZVBpcGVsaW5lSW5uZXJwaXBlU2VxdWVuY2VlbnZWYXJzYXJnc2l0ZW1zb3ZlcndyaXRlYXBwZW5kaXNBc3luY2FuZG9yc3Rkb3V0YSBzZXF1ZW5jZQAAJgAAAAAAAAABAAAAKwAAACYAAAAAAAAAAQAAACwAAAAmAAAAAAAAAAEAAAAtAAAALgAAAC4AAAAvAAAACAAAAAQAAAAwAAAAMQAAADEAAABDOlxVc2Vyc1xkYXZpZFwuY2FyZ29ccmVnaXN0cnlcc3JjXGluZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmXGNvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuN1xzcmNcbGliLnJzAAAAcAIQAG0AAACVAAAADgAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAA8AIQACoAAABvbmUtdGltZSBpbml0aWFsaXphdGlvbiBtYXkgbm90IGJlIHBlcmZvcm1lZCByZWN1cnNpdmVseSQDEAA4AAAAAGNhbm5vdCByZWN1cnNpdmVseSBhY3F1aXJlIG11dGV4AAAAZQMQACAAAAAvcnVzdGMvY2M2NmFkNDY4OTU1NzE3YWI5MjYwMGM3NzBkYThjMTYwMWE0ZmYzMy9saWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbG9ja3MvbXV0ZXgucnMAAJADEABmAAAAFAAAAAkAAAAyAAAADAAAAAQAAAAzAAAANAAAADUAAAAmAAAAAAAAAAEAAAA2AAAANwAAAAQAAAAEAAAAOAAAADkAAAAIAAAABAAAADoAAAAvAAAABAAAAAQAAAA7AAAAaW52YWxpZCB2YWx1ZTogLCBleHBlY3RlZCAAAGAEEAAPAAAAbwQQAAsAAABtaXNzaW5nIGZpZWxkIGAAjAQQAA8AAAATMRAAAQAAAGR1cGxpY2F0ZSBmaWVsZCBgAAAArAQQABEAAAATMRAAAQAAACYAAAAAAAAAAQAAADwAAABQb2lzb25FcnJvckNvdWxkbid0IGRlc2VyaWFsaXplIGk2NCBvciB1NjQgZnJvbSBhIEJpZ0ludCBvdXRzaWRlIGk2NDo6TUlOLi51NjQ6Ok1BWCBib3VuZHNMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ6BRAAKgAAAEM6XFVzZXJzXGRhdmlkXC5jYXJnb1xyZWdpc3RyeVxzcmNcaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWZcb25jZV9jZWxsLTEuMTYuMFxzcmNcbGliLnJzAGwFEABfAAAA9gQAABkAAABzcmNccnNfbGliXHNyY1xsaWIucnMAAADcBRAAFQAAABEAAAA4AAAAZGF0YSBkaWQgbm90IG1hdGNoIGFueSB2YXJpYW50IG9mIHVudGFnZ2VkIGVudW0gV2FzbVRleHRJdGVtZmllbGQgaWRlbnRpZmllcmluZGVudHN0cnVjdCB2YXJpYW50IFdhc21UZXh0SXRlbTo6SGFuZ2luZ1RleHQAANwFEAAVAAAAOAAAABkAAADcBRAAFQAAAEUAAAAGAAAAPgAAAAQAAAAEAAAAPwAAAEAAAABBAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA1AYQABEAAAC4BhAAHAAAABYCAAAFAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yAEIAAAAAAAAAAQAAADYAAABsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnNEBxAAGAAAAGICAAAgAAAAKSBzaG91bGQgYmUgPCBsZW4gKGlzIHJlbW92YWwgaW5kZXggKGlzIIIHEAASAAAAbAcQABYAAAD4XRAAAQAAAC8AAAAEAAAABAAAAEMAAABEAAAARQAAAEYAAABHAAAASAAAAEkAAABKAAAALwAAAAgAAAAEAAAASwAAAC8AAAAIAAAABAAAAEwAAABLAAAA2AcQAE0AAABOAAAATwAAAE0AAABQAAAALwAAAAwAAAAEAAAAUQAAAC8AAAAMAAAABAAAAFIAAABRAAAAFAgQAFMAAABUAAAATwAAAFUAAABQAAAAXBkQAAIAAAAKCkNhdXNlZCBieTpYCBAADAAAAM8OEAABAAAAICAgICAgIAAyAAAADAAAAAQAAABWAAAAVwAAADUAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5ACYAAAAAAAAAAQAAADYAAAAvcnVzdGMvY2M2NmFkNDY4OTU1NzE3YWI5MjYwMGM3NzBkYThjMTYwMWE0ZmYzMy9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMA3AgQAEsAAACcCQAADgAAAC8AAAAEAAAABAAAAFgAAABZAAAAWgAAAAoKU3RhY2s6CgpDOlxVc2Vyc1xkYXZpZFwuY2FyZ29ccmVnaXN0cnlcc3JjXGluZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmXHVuaWNvZGUtd2lkdGgtMC4xLjExXHNyY1x0YWJsZXMucnNaCRAAZgAAACcAAAAZAAAAWgkQAGYAAAAtAAAAHQAAAEM6XFVzZXJzXGRhdmlkXC5jYXJnb1xyZWdpc3RyeVxzcmNcaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWZcdnRlLTAuMTMuMFxzcmNcbGliLnJzAAAA4AkQAFkAAADlAAAAIQAAAOAJEABZAAAA4AAAADQAAADgCRAAWQAAAHkAAAAcAAAA4AkQAFkAAABOAQAAFQAAAOAJEABZAAAAMAEAACQAAADgCRAAWQAAADIBAAAZAAAA4AkQAFkAAAAVAQAAKAAAAOAJEABZAAAAFwEAAB0AAABDOlxVc2Vyc1xkYXZpZFwuY2FyZ29ccmVnaXN0cnlcc3JjXGluZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmXHZ0ZS0wLjEzLjBcc3JjXHBhcmFtcy5yc7wKEABcAAAAPgAAAAkAAAC8ChAAXAAAAD8AAAAJAAAAvAoQAFwAAABHAAAACQAAALwKEABcAAAASAAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKWNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAFsAAAABAAAAAQAAAFwAAABhdHRlbXB0IHRvIGpvaW4gaW50byBjb2xsZWN0aW9uIHdpdGggbGVuID4gdXNpemU6Ok1BWC9ydXN0Yy9jYzY2YWQ0Njg5NTU3MTdhYjkyNjAwYzc3MGRhOGMxNjAxYTRmZjMzL2xpYnJhcnkvYWxsb2Mvc3JjL3N0ci5ycwAAAO0LEABIAAAAmQAAAAoAAADtCxAASAAAALAAAAAWAAAAQ2FwYWNpdHlFcnJvcjogAFgMEAAPAAAAaW5zdWZmaWNpZW50IGNhcGFjaXR5AAAAcAwQABUAAADXKBAATwAAALgBAAA3AAAAQzpcVXNlcnNcZGF2aWRcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxhcnJheXZlYy0wLjcuMlxzcmNcYXJyYXl2ZWNfaW1wbC5ycwCgDBAAZwAAACcAAAAgAAAAQzpcVXNlcnNcZGF2aWRcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxjb25zb2xlX3N0YXRpY190ZXh0LTAuOC4yXHNyY1xhbnNpLnJzAAAAGA0QAGkAAAATAAAAHQAAABtbMUNDOlxVc2Vyc1xkYXZpZFwuY2FyZ29c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AABmAAAAZQAAABgAAAAEAAAAZwAAAGYAAADEKRAATQAAAGgAAABPAAAATQAAAFAAAABpAAAAHAAAAAQAAABqAAAAaQAAABwAAAAEAAAAawAAAGoAAAAAKhAAbAAAAG0AAABPAAAAbgAAAFAAAABvAAAAcAAAAHEAAAByAAAASgAAACYmfHxFbXB0eSBjb21tYW5kLkM6XFVzZXJzXGRhdmlkXC5jYXJnb1xnaXRcY2hlY2tvdXRzXGRlbm9fdGFza19zaGVsbC0yYjA3MDlmYzcxZjcxY2QzXGVkM2Q0ZDBcc3JjXHBhcnNlci5yc0V4cGVjdGVkIGNvbW1hbmQgZm9sbG93aW5nIGJvb2xlYW4gb3BlcmF0b3IuYioQAFoAAACVAQAAOQAAAENhbm5vdCBzZXQgbXVsdGlwbGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdoZW4gdGhlcmUgaXMgbm8gZm9sbG93aW5nIGNvbW1hbmQuRXhwZWN0ZWQgY29tbWFuZCBmb2xsb3dpbmcgcGlwZWxpbmUgb3BlcmF0b3IuUmVkaXJlY3RzIGluIHBpcGUgc2VxdWVuY2UgY29tbWFuZHMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLk11bHRpcGxlIHJlZGlyZWN0cyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJnwmSW52YWxpZCBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZS5VbnN1cHBvcnRlZCByZXNlcnZlZCB3b3JkLkV4cGVjdGVkIGNsb3Npbmcgc2luZ2xlIHF1b3RlLkV4cGVjdGVkIGNsb3NpbmcgZG91YmxlIHF1b3RlLiQ/IyokIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLgAAYSwQAAEAAABiLBAAHAAAAEJhY2sgdGlja3MgaW4gc3RyaW5ncyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5+KCl7fTw+fCY7IidFeHBlY3RlZCBjbG9zaW5nIHBhcmVudGhlc2lzIG9uIHN1YnNoZWxsLgAAYioQAFoAAABkAwAADQAAAGlmdGhlbmVsc2VlbGlmZmlkb2RvbmVjYXNlZXNhY3doaWxldW50aWxmb3JpblVuZXhwZWN0ZWQgY2hhcmFjdGVyLkhhc2ggdGFi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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O4gGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgZdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dOzs7Ozs7OzuJBgYGBgYGBgYGBgaKiwYBcYwGjQYGBgYGBgaOBgYGjwaQBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgaRBgaSBgYGBgYGBgaTBgYGBgaUlQaWlwaYmZqbnJ2en6AuBqEsogYGo6SlpgYGp6ipqqsGrAYGBq0GBgaurwawsbKzBgYGBga0BrUGtre4BgYGBrm6uwYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgZHvAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBga9vgYGBgYGBgYGBgYGBgYGBga/wME7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O8I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7w8QGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgbFOzs7O8bHOzs7OzvIBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgbJBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBsrLBgYGBgYGBszNBgbOBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGz9DRBgYGBgYGBgYGBgYGBgYGBgYGBgYG0ga/Br4GBgYGBtPUBgYGBgYGBtQGBgYGBgYGBgYGBgYGBgbVBtYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBtcGBtjZ2tsG3N0GBt7f4OHi4zvk5ebn6DvpO+oGBgbrBgYGBuztOzsG7u/wBgYGBgYGBgYGBgYGBgYGBgYGBgY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs75fEKBgYKCgoLBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1d8gAAAAAAAAAAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVAAAAAAAAAABd13d1//d//1V1VVVX1Vf1X3V/X/fVf3ddVVVV3VXVVVX11VX9VVfVf1f/XfVVVVVV9dVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV1d3d3V1VVVVVVVVVVVVVVVV1VVVVdVVVVVVVVVVXX/V1XVf/dVVVVVVVVVVUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVVVVVVVVVVX9////3/9fVf3////f/19VVVVVVVVVVVVVVVVVXVVVVf////////////////////9dVVVVVVVVVVVVVVUVAFBVVVVVVVVVVVVVVVVVVVVVVQEAAAAAAAAAAAAAEEEQVVVVVVVVVVVVVVVVVVUAUFVVAABAVFVVVVVVVVVVVVUVAAAAAABVVVVVVFVVVVVVVVVVBQAQABQEUFVVVVVVVVUVUVVVVVVVVVUAAAAAAABAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQUAAFRVVVVVVVVVVVVVVVVVFQAAVVVRVVVVVVUFEAAAAQFQVVVVVVVVVVVVVQFVVVVVVVVVVVVVVVVVUFUAAFVVVVVVVVVVVVUFAAAAAAAAAAAAAAAAAEBVVVVVVVVVVVVVVVVVRVQBAFRRAQBVVQVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVAFUVVFVVVVVBVVVVVVVVUVBVVVVVVVVVVVVVVVVVVVUQRUUUFFVVVVVVVVVUFFVVQEQVFFVVVVVBVVVVVVVBQBRVVVVVVVVVVVVVVVVVVUUAVRVUVVBVVUFVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVUVVVRVVVVVVVVVVVVVVVVVFRVVVVVVVVVVVVVVVVVBFQFBFBVQVVVBVVVVVVVVVVVRVVQVVVVVQVVVVVVVVVVUFVVVVVVVVVVVVVVVVUVVAFUVVFVVVVVBVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVVVFVQVEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVEAQFVVFQBAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUQAAVFVVAEBVVVVVVVVVVVVVVVVVVVVVVVVQVVVVVVVVEVFVVVVVVVVVVVVVVVVVAQAAQAAEVQEAAAEAAAAAAAAAAFRVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUBBABBQVVVVVVVVVAFVFVVVQFUVVVFQVVRVVVVUVVVVVVVVVVVqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqAAAAAAAAAABVVVVVVVVVAVVVVVVVVVVVVVVVVQVUVVVVVVVVBVVVVVVVVVUFVVVVVVVVVQVVVVVVVVVVVVVVVVVVVVVVEABQVUUBAABVVVFVVVVVVVVVVVVVFQBVVVVVVVVVVVVVVVVVQVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVAFVRVRVUBVVVVVVVVFRRVVVVVVVVVVVVVVVVVVUUAQEQBAFQVAAAUVVVVVVVVVVVVVVVVAAAAAAAAAEBVVVVVVVVVVVVVVVUAVVVVVVVVVVVVVVVVBEBURVVVVVVVVVVVVRUAAFVVVVBVVVVVVVVVBVAQUFVVVVVVVVVVVVVVVVVFUBFQVVVVVVVVVVVVVVVVVVUAAAVVVVVVVVVAAAAABABUUVVUUFVVVRUA139fX3//BUD3XdV1VVVVVVVVVVUABAAAVVdV1f1XVVVVVVVVVVVVV1VVVVVVVVVVAAAAAAAAAABUVVVV1V1dVdV1VVV9ddVVVVVVVVVVVVXVV9V/////Vf//X1VVVV1V//9fVVVVVVVVVV9VVVVVVXVXVVVV1VVVVVVVVffV19VdXXX9193/d1X/VV9VVVdXdVVVVV//9fVVVVVV9fVVVVVdXVVVXVVVVVVV1VVVVVV1VaVVVVVpVVVVVVVVVVVVVVVVVVVVqVaWVVVVVVVVVVVVVVX/////////////////////////////////////////////3///////////Vf///////////1VVVf/////1X1VV3/9fVfX1VV9f9df1X1VVVfVfVdVVVVVpVX1d9VVaVXdVVVVVVVVVVXdVqqqqVVVV399/31VVVZVVVVVVlVVV9VlVpVVVVVXpVfr/7//+///fVe//r/vv+1VZpVVVVVVVVVVWVVVVVV1VVVVmlZpVVVVVVVVV9f//VVVVVVWpVVVVVVVVVlVVlVVVVVVVVZVWVVVVVVVVVVVVVVVVVvlfVVVVVVVVVVVVVVVVVVVVVVVVVVUVUFVVVVVVVVVVVVVVAAAAAAAAAACqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqlVVVaqqqqqqWlVVVVVVVaqqqqqqqqqqqqqqqqqqCqCqqqpqqaqqqqqqqqqqqqqqqqqqqqqqqqqqaoGqqqqqqqqqqqpVqaqqqqqqqqqqqqqpqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqlVVlaqqqqqqqqqqqqqqaqqqqqqqqqqqqqr//6qqqqqqqqqqqqqqqqqqqlaqqqqqqqqqqqqqqqqqalVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVQAAAUFVVVVVVVVUFVVVVVVVVVVVVVVVVVVVVVVVVVVVQVVVVRUUVVVVVVVVVQVVUVVVVVVVQVVVVVVVVAAAAAFBVVRVVVVVVVVVVVVUFAFBVVVVVVRUAAFBVVVWqqqqqqqqqVkBVVVVVVVVVVVVVVRUFUFBVVVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVQFAQUFVVRVVVVRVVVVVVVVVVVVVVVRVVVVVVVVVVVVVVVUEFFQFUVVVVVVVVVVVVVVQVUVVVVVVVVVVVVVVVVFUUVVVVVWqqqqqqqqqqqpVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVQAAAACqqlpVAAAAAKqqqqqqqqqqaqqqqqpqqlVVVVVVqqqqqqqqqqpWVVVVVVVVVVVVVVVVVVVVqmpVVVVVAV1VVVVVVVVVVVVVVVVVVVVRVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVUFQFUBQVUAVVVVVVVVVVVVVUAVVVVVVVVVVVVVQVVVVVVVVVVVVVVVVVVVVQBVVVVVVVVVVVVVVVVVVVVVFVRVVVVVVVVVVVVVVVVVVVVVVVVVAVUFAABUVVVVVVVVVVVVVVUFUFVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVUAAABAVVVVVVVVVVVVVRRUVRVQVVVVVVVVVVVVVVUVQEFRRVVVUVVVVVVVVVVVVVVVVUBVVVVVVVVVVRUAAQBUVVVVVVVVVVVVVVVVVVUVVVVVUFVVVVVVVVVVVVVVVQUAQFVVARRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQBFVFVVVVVVVVVRUVAEBVVVVVVVRVVVVVVVVVVQUAVABUVVVVVVVVVVVVVVVVVVVVVQAABURVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVVRUARBUEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBVBVEFRVVVVVVVVQVVVVVVVVVVVVVVVVVVVVVVVVVVUVAEARVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVUQAQVVVVVVVVVVVVAQUQAFVVVVVVVVVVVVVVVVVVVVUVAABBVVVVVVVVVVVVVVVVVVVVFUQVVVVVVVVVVVVVVVVVVVVVVVVVVVUABVVUVVVVVVVVVQEAQFVVVVVVVVVVVRUAFEBVFVVVAUABVVVVVVVVVVVVVVUFAABAUFVVVVVVVVVVVVVVVVVVVVVVVVVVVQBAABBVVVVVBQAAAAAABQAEQVVVVVVVVVVVVVVVVVVVAUBFEAAQVVVVVVVVVVVVVVVVVVVVVVVVUBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVRVVVBVVVVVVVVVVVVVVVUFQFVEVVVVVVVVVVVVVVVVVVVVVBUAAABQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQBUVVVVVVVVVVVVVVVVVVUAQFVVVVVVFVVVVVVVVVVVVVVVVVVVVRVAVVVVVVVVVVVVVVVVVVVVVVVVVapUVVVaVVVVqqqqqqqqqqqqqqqqqqpVVaqqqqqqWlVVVVVVVVVVVVWqqlZVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVqqmqaaqqqqqqqqqqalVVVWVVVVVVVVVVallVVVWqVVWqqqqqqqqqqqqqqqqqqqqqqqqqVVVVVVVVVVVBAFVVVVVVVVUAAAAAAAAAAAAAAFAAAAAAAEBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQVRUAAABAAQBVVVVVVVVVBVBVVVVVBVRVVVVVVVVVVVVVVVVVVQAAAAAAAAAAAAAAAABAFQAAAAAAAAAAAAAAAFRVUVVVVVRVVVVVFQABAAAAVVVVVQBAAAAAABQAEARAVVVVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVUAVVVVVVVVVVUAQFVVVVVVVVVVVVVVAEBVVVVVVVVVVVVVVVVVVVZVVVVVVVVVVVVVVVVVVVVVVZVVVVVVVVVVVVVVVVX//39V/////////1///////////////////19V/////////++rqur/////V1VVVVVqVVVVqqqqqqqqqqqqqqpVqqpWVVpVVVWqWlVVVVVVVaqqqqqqqqqqVlVVqaqaqqqqqqqqqqqqqqqqqqqqqqqmqqqqqqpVVVWqqqqqqqqqqqqqapWqVVVVqqqqqlZWqqqqqqqqqqqqqqqqqqqqqqpqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpaqqqqqqqqqqqqqqqqqqqpaVVWVaqqqqqqqqlVVVVVlVVVVVVVVaVVVVVZVVVVVVVVVVVVVVVVVVVVVVVVVVZWqqqqqqlVVVVVVVVVVVVVVVapaVVZqqVWqVVWVVlWqqlZVVVVVVVVVVaqqqlVWVVVVVVVVqqqqqqqqqqqqqqpqqqqaqqqqqqqqqqqqqqqqqqpVVVVVVVVVVVVVVVWqqqpWqqpWVaqqqqqqqqqqqqqqmqpaVaWqqqpVqqpWVaqqVlVRVVVVVVVVVQAAAAAAAAAA////////////////////XwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAXAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUAAAUFBQUCMjIyMjIyMjIyMjIyMjIyO0tLS0tLS0tLS0tLQkJCQkPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAAFBQUFBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAABQUFBQICAgICAgICAgICAgICAgIAICAgICAgICAgICAgICAgI8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUAAAUFBQUCMjIyMjIyMjIyMjIyMjIyOwsLCwsLCwsLCwsLACAgICPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHAAAHBwcHAnJycnJycnJycnJycnJycnuLi4uLi4uLi4uLi4KCgoKAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcAAAcHBwcCAgICAgICAgICAgICAgICAGBgYGBgYGBgYGBgYGBgYGCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHAAAHBwcHAnJycnJycnJycnJycnJycnsLCwsLCwsLCwsLCwBgYGBgkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ADQAADQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUAAAUFBQUCsrKysrKysrKysrKysrKytMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAVMTExMTExMDkxMAUwNDg5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAAFBQUFAgICAgICAgICAgICAgICAgTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAABQUFBQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAUFBQUFBQUFBQUFBQUFBQUABQUFBQUFBQUFBQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////////////////////////////////////////////////////////AAAAAAAAAAAAAABwcHBwcHBwDHBwcHBwcHBwcHBwcHBwcHAAcAAAcHBwcJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKc1ZhbHVlKCkAAADwXRAACAAAAPhdEAABAAAAAEGMvMEACwwAAAAAAAAAAD0AAAAAqaMCBG5hbWUBoKMCjQQAQWpzX3N5czo6QXJyYXk6OmdldDo6X193YmdfZ2V0XzU3MjQ1Y2M3ZDdjNzYxOWQ6Omg4MmE0ZGFhNDA3NjU3NTUzATp3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXE6Omg2YjYyNTI1ZWQ0OGRkOTc0ApABanNfc3lzOjpfOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNhc3Q6OkpzQ2FzdCBmb3IganNfc3lzOjpVaW50OEFycmF5Pjo6aW5zdGFuY2VvZjo6X193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5Xzk3MWVlZGE2OWViNzUwMDM6OmhmYTA5N2I3YWEzOGUxNjliA5IBanNfc3lzOjpfOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNhc3Q6OkpzQ2FzdCBmb3IganNfc3lzOjpBcnJheUJ1ZmZlcj46Omluc3RhbmNlb2Y6Ol9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfZTVlNDhmNDc2MmM1NjEwYjo6aDk2ZGViYTA5MmFjN2M5ZGEERmpzX3N5czo6VWludDhBcnJheTo6bmV3OjpfX3diZ19uZXdfOGMzZjAwNTIyNzJhNDU3YTo6aGIzMDI1NzBjYWQ4NTY4ODYFN3dhc21fYmluZGdlbjo6X193YmluZGdlbl9ib29sZWFuX2dldDo6aDE2NDhmMWFiNjRjZjk1NTIGNndhc21fYmluZGdlbjo6X193YmluZGdlbl9udW1iZXJfZ2V0OjpoNjMxZTg0MDYzZjBjYjE2Ngc2d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3N0cmluZ19nZXQ6OmgxZjM1ZDA1ZTIyYjQ5ZDRhCDV3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fZXJyb3JfbmV3OjpoZTA3OTNjNTU5MTE4MWE0Ngk2d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3N0cmluZ19uZXc6OmgxNGU0MmZjOTZkMjFmOTUzCjx3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZjo6aDVkOTNkZTUxMDFmZThjYTcLUXNlcmRlX3dhc21fYmluZGdlbjo6T2JqZWN0RXh0OjpzZXQ6Ol9fd2JnX3NldF85MTgyNzEyYWJlYmY4MmVmOjpoZmM4MGQ5OTAyZGZhNThmNQxCanNfc3lzOjpPYmplY3Q6Om5ldzo6X193YmdfbmV3XzBiOWJmZGQ5NzU4MzI4NGU6OmhiMzZmYzllZDJmMDc0ZDRjDUFqc19zeXM6OkFycmF5OjpuZXc6Ol9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4OjpoYzE0YTk5MGIzOGE0ZjJmMQ5BanNfc3lzOjpBcnJheTo6c2V0OjpfX3diZ19zZXRfYTY4MjE0ZjM1YzQxN2ZhOTo6aGU0MmJhZmJkYzNlYTFhNGUPNndhc21fYmluZGdlbjo6X193YmluZGdlbl9udW1iZXJfbmV3OjpoZjE3NjI1ZDU1Y2FiNWU3YxBHanNfc3lzOjpBcnJheTo6bGVuZ3RoOjpfX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkODo6aGUxMTFiYjM5NjM5MjBjYTgRNXdhc21fYmluZGdlbjo6X193YmluZGdlbl9pc19iaWdpbnQ6OmhhNzUyNzY0NDZjZGY1OTE2Elhqc19zeXM6Ok51bWJlcjo6aXNfc2FmZV9pbnRlZ2VyOjpfX3diZ19pc1NhZmVJbnRlZ2VyX2RmYTA1OTNlOGQ3YWMzNWE6OmhjZjg2YWQ4N2Q4ZjE2NzRkEzt3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fYmlnaW50X2Zyb21faTY0OjpoNTZhZWY5MjE4N2E1YzIxZhQ1d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2lzX29iamVjdDo6aDI1NmMxNTYwZGVkNDY2ZjEVTGpzX3N5czo6U3ltYm9sOjppdGVyYXRvcjo6X193YmdfaXRlcmF0b3JfNmY5ZDRmMjg4NDVmNDI2Yzo6aDkyNTgwY2M5ZDM0NWQ1MTIWLndhc21fYmluZGdlbjo6X193YmluZGdlbl9pbjo6aGM2Y2VmZTJiNjFhMjIyMjkXSmpzX3N5czo6T2JqZWN0OjplbnRyaWVzOjpfX3diZ19lbnRyaWVzXzY1YTc2YTQxM2ZjOTEwMzc6OmhjM2VjODkyZjFhYmE2NzQwGDt3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fYmlnaW50X2Zyb21fdTY0OjpoMWFhNDU4MmRhNjM2NGIxOBk0d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2pzdmFsX2VxOjpoOGY5ZTU3Y2E5ZTc4M2MxNxpTY29uc29sZV9lcnJvcl9wYW5pY19ob29rOjpFcnJvcjo6bmV3OjpfX3diZ19uZXdfYWJkYTc2ZTg4M2JhOGE1Zjo6aDRhNjdmNzI0ZDU4MmNmZGEbV2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vazo6RXJyb3I6OnN0YWNrOjpfX3diZ19zdGFja182NTgyNzlmZTQ0NTQxY2Y2OjpoYWE1NjU3ZmQ3OGQ0YzNmNhxQY29uc29sZV9lcnJvcl9wYW5pY19ob29rOjplcnJvcjo6X193YmdfZXJyb3JfZjg1MTY2N2FmNzFiY2ZjNjo6aDBiNzFiMjEyMjU1MDNiYzEdO3dhc21fYmluZGdlbjo6X193YmluZGdlbl9vYmplY3RfZHJvcF9yZWY6Omg0Mjg2MmM3OGVkMWI2NjFhHjd3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5faXNfZnVuY3Rpb246Omg3Zjk4ZjQ5ZGExN2ZlYTNjH0Zqc19zeXM6Okl0ZXJhdG9yOjpuZXh0OjpfX3diZ19uZXh0X2FhZWY3YzhhYTVlMjEyYWM6OmgwMzU2MDJhMTk1M2VhMmQwIEpqc19zeXM6Okl0ZXJhdG9yTmV4dDo6ZG9uZTo6X193YmdfZG9uZV8xYjczYjA2NzJlMTVmMjM0OjpoNTk0MmQwOTY2NDI3NzU1NCFManNfc3lzOjpJdGVyYXRvck5leHQ6OnZhbHVlOjpfX3diZ192YWx1ZV8xY2NjMzZiYzAzNDYyZDcxOjpoOWExMzNjNDIzNjU3ZmQyNiJDanNfc3lzOjpSZWZsZWN0OjpnZXQ6Ol9fd2JnX2dldF83NjUyMDE1NDRhMmI2ODY5OjpoNjk0YjYyZDgwMjBmY2VlNSNHanNfc3lzOjpGdW5jdGlvbjo6Y2FsbDA6Ol9fd2JnX2NhbGxfOTdhZTlkODY0NWRjMzg4Yjo6aDJmYzg2OGU1NjAwNjg2NGIkampzX3N5czo6SXRlcmF0b3I6Omxvb2tzX2xpa2VfaXRlcmF0b3I6Ok1heWJlSXRlcmF0b3I6Om5leHQ6Ol9fd2JnX25leHRfNTc5ZTU4M2QzMzU2NmE4Njo6aGQ2OTE5M2Q0YzQzMzViOGUlSmpzX3N5czo6QXJyYXk6OmlzX2FycmF5OjpfX3diZ19pc0FycmF5XzI3YzQ2YzY3ZjQ5OGUxNWQ6Omg0MjhhYWI0OTMwZmNmODNiJkxqc19zeXM6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzllMWFlMTkwMGNiMGZiZDU6OmgwYWQ1ZTVjYjNhMzE3ZTA3JzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoZTQ4NzUwM2IxZTEyMTk2ZihVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl8zZjNkNzY0ZDQ3NDdkNTY0OjpoYzMzZGVhYWZiM2RmZDQ0ZilGanNfc3lzOjpVaW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF84M2RiOTY5MGY5MzUzZTc5OjpoZTFiODBiZmE1N2UzMjMyOCo9d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2JpZ2ludF9nZXRfYXNfaTY0OjpoYTBiMTkyYmQ3ZGYwNDVlZCs4d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2RlYnVnX3N0cmluZzo6aGQ5MTQzYTM5YzczZjUzNDEsMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDAxZDY5Mjk2Y2IxM2ZkMjMtRWNvcmU6OmZtdDo6ZmxvYXQ6OmZsb2F0X3RvX2RlY2ltYWxfY29tbW9uX3Nob3J0ZXN0OjpoNmU3OGFiNTJhMjc2NWJiOC5CY29yZTo6Zm10OjpmbG9hdDo6ZmxvYXRfdG9fZGVjaW1hbF9jb21tb25fZXhhY3Q6OmgwMmRmYjJhODYyNjIxMjllL0lkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2Vfd29yZF9wYXJ0czo6e3tjbG9zdXJlfX06OmgxYjdkZTcyNTUzOWI1OGZkMEBkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfcGlwZWxpbmVfaW5uZXI6OmgzZDY2YmFjYjdiNjcyMWE3MTpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmhmODI3YmQ2MGNkOGFkYTczMjpkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2Vfc2VxdWVuY2U6Omg0NjQ4M2U3ZjAzY2NlNmEwM2U8c2VyZGVfd2FzbV9iaW5kZ2VuOjpkZTo6RGVzZXJpYWxpemVyIGFzIHNlcmRlOjpkZTo6RGVzZXJpYWxpemVyPjo6ZGVzZXJpYWxpemVfYW55OjpoMDUwMGZiYjAwYmRjY2MyZDQ+ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX2NvbW1hbmRfYXJnczo6aGE3MDk3MmE3NWJlYjA2NjQ1OmRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV9yZWRpcmVjdDo6aGE0NGEwYzM3MTFmMjA3YWY2XDxjb3JlOjptYXJrZXI6OlBoYW50b21EYXRhPFQ+IGFzIHNlcmRlOjpkZTo6RGVzZXJpYWxpemVTZWVkPjo6ZGVzZXJpYWxpemU6OmhkYTJiMGVhZTRiMjc4ZDZmNzJjb3JlOjpzdHI6OjxpbXBsIHN0cj46OmNvbnRhaW5zOjpoZmIwYzNhM2I4NDdkYWRjNTgsY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDgzZjkzM2UwODU2YzBiMjQ5PGNvbnNvbGVfc3RhdGljX3RleHQ6OnJlbmRlcl90ZXh0X3RvX2xpbmVzOjpoOWY5YTgzYmRmNTQ2OTU4NTo/ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3F1b3RlZF9zdHJpbmc6Omg1NzYzN2ViZDhjOWQyMGFmO1Fjb25zb2xlX3N0YXRpY190ZXh0OjpDb25zb2xlU3RhdGljVGV4dDo6cmVuZGVyX2l0ZW1zX3dpdGhfc2l6ZTo6aDBhODEyZTgwNTZkZjcyOGQ8QWRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV9zZXF1ZW50aWFsX2xpc3Q6Omg1MmJmOGZhN2VhMDQ5MWY5PQVwYXJzZT5FY29yZTo6Y2hhcjo6bWV0aG9kczo6PGltcGwgY2hhcj46OmVzY2FwZV9kZWJ1Z19leHQ6Omg0YTQ3ZDA2NzI3ZjQ4ZDUwPzF2dGU6OlBhcnNlcjxfPjo6cGVyZm9ybV9hY3Rpb246OmhhZWVhMzcyNGJiNTkzZWFhQDFjb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWxfcnQ6Omg2M2VlNjdhMmY2ZTc0MDg2QTpkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfZW52X3ZhcnM6OmgzMTQ5YjU1ZTliY2NkOGQ0QkU8c2VyZGU6OmRlOjpVbmV4cGVjdGVkIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGRkZDc5ZjZkOThjMjY1OTBDOGNvcmU6Om51bTo6YmlnbnVtOjpCaWczMng0MDo6bXVsX3BvdzI6OmgxZjhlZjExNmNiYjg5MWNiRCltb25jaDo6b3I6Ont7Y2xvc3VyZX19OjpoNGQ0MjhlM2YxY2JhYzk1ZUVAaGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlPFQsQT46OnJlc2VydmVfcmVoYXNoOjpoZjE4ZTEzMTc2ZmZiYzk1MkZJY29uc29sZV9zdGF0aWNfdGV4dDo6Q29uc29sZVN0YXRpY1RleHQ6OmdldF9sYXN0X2xpbmVzOjpoYTdlMGZjMjgzNTE0OWI0N0cxPHN0ciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNmFmYjE3OGQ1MjAzYzEzNEhCY29yZTo6bnVtOjpmbHQyZGVjOjpzdHJhdGVneTo6ZHJhZ29uOjptdWxfcG93MTA6Omg0NzhkNmUwOTBjOGQ5YzZkSQ5fX3J1c3RfcmVhbGxvY0o2ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3dvcmQ6OmhiN2FlMjY3OGE4ODJkOWY4S248c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoZTdkNzhmMTliZjhhNDc3ZEw4ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZnJlZTo6aDRhNjAwOWJmY2Y3NjBlODFNMmNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbW1vdmU6OmhmZDIzOWQ5NGU0NWI5M2I0Tjpjb3JlOjpudW06OmJpZ251bTo6QmlnMzJ4NDA6Om11bF9kaWdpdHM6Omg5MmZkZDlmOGMzNDdkN2RhTzFzZXJkZV93YXNtX2JpbmRnZW46OmZyb21fdmFsdWU6OmhiMTRjZWNhMTgxZWFmYmViUFc8c2VyZGU6OmRlOjppbXBsczo6U3RyaW5nVmlzaXRvciBhcyBzZXJkZTo6ZGU6OlZpc2l0b3I+Ojp2aXNpdF9ieXRlczo6aGI2Y2M0MzJjNWE3ZWFlNGRRPWNvbnNvbGVfc3RhdGljX3RleHQ6OnJhd19yZW5kZXJfbGFzdF9pdGVtczo6aDYwOTM5NGY1Yzc2MGYzYTdSbjxzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6T2JqZWN0U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVTdHJ1Y3Q+OjpzZXJpYWxpemVfZmllbGQ6Omg1YjVlN2IwNmQyODJhMTBhUxdzdGF0aWNfdGV4dF9yZW5kZXJfb25jZVQ+Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OndyaXRlX2Zvcm1hdHRlZF9wYXJ0czo6aGNkMmE0OWRkYTY5M2I1YTRVbjxzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6T2JqZWN0U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVTdHJ1Y3Q+OjpzZXJpYWxpemVfZmllbGQ6OmhmZjQzYjUyODgwOWRhNDMzViNjb3JlOjpmbXQ6OndyaXRlOjpoNzFmYWEyNTE5Y2JiOTg3NVcXc3RhdGljX3RleHRfcmVuZGVyX3RleHRYTDxhbnlob3c6OmZtdDo6SW5kZW50ZWQ8VD4gYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGFiNGNhOWFlNjIxMzNhODlZNWNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6Omg1OTBjNTRmZmUyYzNhYTUyWkFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3NlX2NodW5rOjpoYzExOTVlNmNiZmNlMDBmNVtTPGNvcmU6OmZtdDo6YnVpbGRlcnM6OlBhZEFkYXB0ZXIgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDBmMjY1Y2I4MDc2ZTVkNWRcPGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfZm9ybWF0dGVkX3BhcnRzOjpoYzJiMDc3NTI5Zjc0ZDE5ZV0vdnRlOjpQYXJzZXI8Xz46OnByb2Nlc3NfdXRmODo6aDZlNjZmNzc1NWM2NDI4MDZeMWNvbnNvbGVfZXJyb3JfcGFuaWNfaG9vazo6aG9vazo6aGRjNGM1OGUzMjk0ZjI1NGFfQmRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV9waXBlX3NlcXVlbmNlX29wOjpoZmFlZmQzY2I2MTNhZmUxYmBGYW55aG93OjpmbXQ6OjxpbXBsIGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbD46OmRlYnVnOjpoOTg5Yzk4NDkzZDFjY2FiYmE2Y29uc29sZV9zdGF0aWNfdGV4dDo6YW5zaTo6dG9rZW5pemU6Omg2YjczZWFhMzY0NDBkZWRmYjltb25jaDo6d2l0aF9mYWlsdXJlX2lucHV0Ojp7e2Nsb3N1cmV9fTo6aDIyOTQ2NWIwNjRkZThlMTVjN21vbmNoOjpQYXJzZUVycm9yRmFpbHVyZTo6aW50b19lcnJvcjo6aDY4ZDMwMTljMjcyN2M1ZDlkJG1vbmNoOjp3aGl0ZXNwYWNlOjpoMjI3MmJhYjBjMzYwYmE5YmVePGNvcmU6OnN0cjo6aXRlcjo6U3BsaXQ8UD4gYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoOThkZmIwY2FlNTlmNzMwZmZuPHNlcmRlX3dhc21fYmluZGdlbjo6c2VyOjpPYmplY3RTZXJpYWxpemVyIGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZVN0cnVjdD46OnNlcmlhbGl6ZV9maWVsZDo6aGEwOWJmNWVmODVkYjVlYzdnN3NlcmRlX3dhc21fYmluZGdlbjo6c3RhdGljX3N0cl90b19qczo6aDNkYTE4NzQxZTBkZGRiMThoO2NvcmU6OnN0cjo6cGF0dGVybjo6VHdvV2F5U2VhcmNoZXI6Om5leHQ6OmgxNWY2OTc3NzIzMTY2OTU2aUZzZXJkZV93YXNtX2JpbmRnZW46OmRlOjpEZXNlcmlhbGl6ZXI6OmludmFsaWRfdHlwZV86OmgyMDdkMDRhZmU4MzBiMjNiakFkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfYm9vbGVhbl9saXN0X29wOjpoZmM0MzQyNGVmY2NmZjMwOWtSYW55aG93OjplcnJvcjo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciBhbnlob3c6OkVycm9yPjo6Zm10OjpoZTYyMWYwNGFmOTdjOWEzMmw1b25jZV9jZWxsOjppbXA6OmluaXRpYWxpemVfb3Jfd2FpdDo6aDBmZTk1YmIwMGE2ZTBlMmVtM2FsbG9jOjpmbXQ6OmZvcm1hdDo6Zm9ybWF0X2lubmVyOjpoYzk0NGFlOGJjYmEyYWI1OW48ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWVtYWxpZ246OmhhZjQ1Zjk5MmIzMWVmNzZib1hjb3JlOjpudW06OmZsdDJkZWM6OnN0cmF0ZWd5OjpncmlzdTo6Zm9ybWF0X2V4YWN0X29wdDo6cG9zc2libHlfcm91bmQ6OmhiMDlmZDU3MDg2ODg2MmQxcDhjb3JlOjpudW06OmZsdDJkZWM6OmRpZ2l0c190b19kZWNfc3RyOjpoMjA0NWFkN2RhOGY5ZDBlZHEqbW9uY2g6Om1hcDo6e3tjbG9zdXJlfX06OmhjZTVlYjM1OTU2ZWQ3ZWNhcllzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudFJlZkRlc2VyaWFsaXplcjxFPjo6aW52YWxpZF90eXBlOjpoMzdmMzYzODE3MjUyNzAzZHM9Y29uc29sZV9zdGF0aWNfdGV4dDo6dHJ1bmNhdGVfbGluZXNfaGVpZ2h0OjpoYzFjYmQ2OTUzZjViNWMzZnQ6Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdTdHJ1Y3Q6OmZpZWxkOjpoODczZWRmNWZiMWNkMThiMnUyY29yZTo6dW5pY29kZTo6cHJpbnRhYmxlOjpjaGVjazo6aGQyODkwMmJmNDIzMzFkYjF2OzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg1YjM5MGNmZDRkN2E5ZDdidzs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoMTViZmMxMWY2YTU2MGZjZHgxY29tcGlsZXJfYnVpbHRpbnM6Om1lbTo6bWVtY3B5OjpoMGNmNDc0OTU5MDFkMDY4NHk2Y29yZTo6c2xpY2U6Om1lbWNocjo6bWVtY2hyX2FsaWduZWQ6OmhkZjJlNDBmYzFjYzA3MjZiei9jb3JlOjpmbXQ6Om51bTo6aW1wOjpmbXRfdTY0OjpoZTVmN2NmNWU5ZTAyZGE0MHs+Y29uc29sZV9zdGF0aWNfdGV4dDo6YW5zaTo6c3RyaXBfYW5zaV9jb2Rlczo6aGIyNmE5ZWY5NWI1Y2YwZTJ8FnN0YXRpY190ZXh0X2NsZWFyX3RleHR9ZHNlcmRlOjpzZXI6OmltcGxzOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGFsbG9jOjp2ZWM6OlZlYzxUPj46OnNlcmlhbGl6ZTo6aDM0NjcxMjQxMjRiMGU3YjJ+MDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMDBlNjNiNjIyYzM3NjlhYn8wY29yZTo6b3BzOjpmdW5jdGlvbjo6Rm46OmNhbGw6OmhjMDBlZGUyMjE2NzE5ODBlgAEyPGNoYXIgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDA4MDc0NDVjNWRmZWZkZWGBAUZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojp1bmxpbmtfbGFyZ2VfY2h1bms6OmgxYjg3OTllNDEzMTI3NGU3ggE3Y29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkX2lubmVyOjpoZWY4YWE5MTQwZWQzYjE1Y4MBMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMjAyMmM5NTgxYTBmMjFiZYQBRmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46Omluc2VydF9sYXJnZV9jaHVuazo6aDZkZjg3ODczZGJiYTQ2NDaFAekBY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGNvcmU6OmNlbGw6OlJlZkNlbGw8c3RkOjpjb2xsZWN0aW9uczo6aGFzaDo6bWFwOjpIYXNoTWFwPCpjb25zdCBzdHIsanNfc3lzOjpKc1N0cmluZyxjb3JlOjpoYXNoOjpCdWlsZEhhc2hlckRlZmF1bHQ8c2VyZGVfd2FzbV9iaW5kZ2VuOjpzdGF0aWNfc3RyX3RvX2pzOjpQdHJIYXNoZXI+Pj4+Pjo6aGJlZmEyNGY1MGYxNzZiYTaGAUdjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpEZWJ1ZyBmb3IgdTMyPjo6Zm10OjpoNDRlZmU5OTJhYzZhYmE4Y4cBNDxjaGFyIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDYxNDlmOGIxODUxZGMwMzOIAU08YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoODIzMThkOThhZjhhNTcyMS40NokBKm1vbmNoOjptYXA6Ont7Y2xvc3VyZX19OjpoNDZlNDljMDc1ZDY4NmE0NooBR3NlcmRlX3dhc21fYmluZGdlbjo6c3RhdGljX3N0cl90b19qczo6Q0FDSEU6Ol9fZ2V0aXQ6Omg1YjJlYWZhMGQ3OTc1YzRmiwE+ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX2Vudl92YXJfbmFtZTo6aGQxOWY3NGVjNTM1MGNlMjOMAUJjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfdHVwbGVfZmllbGQxX2ZpbmlzaDo6aDQ3ZGI3ZmI2NTRjZjdmZDmNATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoNzUwM2NmMmU0MzNmMjViMI4BOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6OmgzNzIzODI3OGEyZDI1NDVmjwEvY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfY2hhcjo6aDE5OGY1MTg3NjY3N2I5ZDOQASptb25jaDo6bWFwOjp7e2Nsb3N1cmV9fTo6aDQ4NWI4NjJjYjU1NTA3ZjeRAWg8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMzQ5MWU3MGMwZjA2MDI3MpIBMGFsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZXNlcnZlOjpoN2RiOWYzZTljYjFlOGM1MJMBLmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aDZmYzBhY2JhZDMxYzdjOGSUAS5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmgzNzJmNDExOWUwZjhjNTM3lQE3Y29yZTo6Y2hhcjo6bWV0aG9kczo6ZW5jb2RlX3V0ZjhfcmF3OjpoY2E2NTg3MTZlMzhhYzMwOZYBOmNvcmU6OnN0cjo6dmFsaWRhdGlvbnM6Om5leHRfY29kZV9wb2ludDo6aDMyODc3NjNjNTVkNzM4MGGXATp1bmljb2RlX3dpZHRoOjp0YWJsZXM6OmNoYXJ3aWR0aDo6d2lkdGg6OmhhYTBmODA4NTVmY2E5ZGFkmAE+YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+Ojpncm93X2Ftb3J0aXplZDo6aDQ2ZmVlMTE5ZmJjY2FiMDWZAT9zdGQ6OnN5c19jb21tb246OnRocmVhZF9pbmZvOjpjdXJyZW50X3RocmVhZDo6aDhhYTEyM2U4ZmJjMjdkNTeaASNqc19zeXM6OnRyeV9pdGVyOjpoYmI3MTRhYWJjMDJlNWVjZZsBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDQ0NWU2N2UzZDVkYTFhMTicAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6Omg3NGIyNDQwNGZkNWRmNmQ0nQFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoYWQxM2IyMTAxNTE5YjMyNZ4BQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDRmNGI5ZmM2ZmMxN2NmY2KfAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmgyMDkzYjliYTNjZWQ2NWQ3oAFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoODkwNjllNjQ3Y2FhNTNiZKEBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDUzMjg4MDViODg1MzJkOGGiAUs8bW9uY2g6OlBhcnNlRXJyb3JGYWlsdXJlRXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGRmMjU3ZTc1YzhiOTc0M2OjAW48c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoOWNhZTZkZjVjOWI1ZTRkY6QBPmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6Z3Jvd19hbW9ydGl6ZWQ6OmgwNzU0NzEwNDhmYTNkYjhmpQE+YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+Ojpncm93X2Ftb3J0aXplZDo6aDIzOTllMjc3MWE0MDk0NGGmAU5hbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmU6OmRvX3Jlc2VydmVfYW5kX2hhbmRsZTo6aDA4ODA0MjU3YWU5NWI5NzSnAS5tb25jaDo6aWZfdHJ1ZTo6e3tjbG9zdXJlfX06Omg4ZTQ1M2VkYjBiNmJjODQwqAFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoMWIxZTYyYzcyOTMyMDcyYakBbjxjb3JlOjppdGVyOjphZGFwdGVyczo6ZmxhdHRlbjo6RmxhdHRlbjxJPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmhmYTkyZmFlOTVkY2YyN2RkqgE3c3RkOjpwYW5pY2tpbmc6OnJ1c3RfcGFuaWNfd2l0aF9ob29rOjpoM2FhMDU0ZDM1YTA4MTdkN6sBMGNvcmU6Om9wczo6ZnVuY3Rpb246OkZuOjpjYWxsOjpoY2Q2OTMwZWRjOGNkYjA2MqwBMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbXNldDo6aDNlZjQyM2I5MmRjZmRmYjetAS5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmgwOGMxM2Q0YjFkNWY5ZGY4rgFNPG1vbmNoOjpQYXJzZUVycm9yRmFpbHVyZUVycm9yIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDg3NjE3YmVhMDU1MGEzOGSvARBzdHJpcF9hbnNpX2NvZGVzsAFRPHNlcmRlX3dhc21fYmluZGdlbjo6ZXJyb3I6OkVycm9yIGFzIHNlcmRlOjpkZTo6RXJyb3I+OjpjdXN0b206OmhmNjZlZjQxMDFlZmI0NjA4sQExYWxsb2M6OnN0cjo6PGltcGwgc3RyPjo6cmVwZWF0OjpoNjI3ZGY3MWUxNzcxZjZjNLIBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZDdhMTc3MGU5ODU1NWU1YbMBOWFsbG9jOjp2ZWM6OlZlYzxULEE+OjpleHRlbmRfZGVzdWdhcmVkOjpoODMxNWQ0ODVkZDdjNjJmZLQBR29uY2VfY2VsbDo6aW1wOjpPbmNlQ2VsbDxUPjo6aW5pdGlhbGl6ZTo6e3tjbG9zdXJlfX06Omg1MmI1ODBkODNlYmRkOWQ3tQEjbW9uY2g6Om5leHRfY2hhcjo6aGVhMmE1ZTExZWQ0OTQ0YjW2AUNjb3JlOjppdGVyOjphZGFwdGVyczo6ZmxhdHRlbjo6YW5kX3RoZW5fb3JfY2xlYXI6OmgxMjFmOGFmNmQ5OGEzNWQxtwEpbW9uY2g6OnNraXBfd2hpdGVzcGFjZTo6aGM3YzE3ZDJiZWMxMzdiNjK4AUNzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6e3tjbG9zdXJlfX06OmgyZjczZTRjZjZjZDYzMTlhuQGWATxyc19saWI6Ol86OjxpbXBsIHNlcmRlOjpkZTo6RGVzZXJpYWxpemUgZm9yIHJzX2xpYjo6V2FzbVRleHRJdGVtPjo6ZGVzZXJpYWxpemU6Ol9fRmllbGRWaXNpdG9yIGFzIHNlcmRlOjpkZTo6VmlzaXRvcj46OnZpc2l0X2J5dGVzOjpoMzhhNDgyNGQ5N2FjYTViZroBQzx3YXNtX2JpbmRnZW46OkpzVmFsdWUgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJkMzljMDU4MTc5N2I4ODa7AVU8anNfc3lzOjpJbnRvSXRlciBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmgxMTZiZDM5ZTkzZTRlZjZlvAFpc2VyZGU6OmRlOjppbXBsczo6PGltcGwgc2VyZGU6OmRlOjpEZXNlcmlhbGl6ZSBmb3IgYWxsb2M6OnN0cmluZzo6U3RyaW5nPjo6ZGVzZXJpYWxpemU6OmgxZDYxNzY5YjUyNWVjZGM1vQEwY29yZTo6b3BzOjpmdW5jdGlvbjo6Rm46OmNhbGw6OmhlMzAwZDdmMjQxZDY3Yjk2vgFjPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+OjpnZXQ6Omg1M2UzZDk4YzUzMTk3Yjk2vwElYWxsb2M6OmZtdDo6Zm9ybWF0OjpoNDIxNjgxNmM1YTExNWM1M8ABQXNlcmRlX3dhc21fYmluZGdlbjo6ZGU6OkRlc2VyaWFsaXplcjo6YXNfYnl0ZXM6OmgxMDQ1OTY5NDlmZmQwODg5wQEoYWxsb2M6OmZtdDo6Zm9ybWF0OjpoNDIxNjgxNmM1YTExNWM1My42NsIBZ2FueWhvdzo6Y2hhaW46OjxpbXBsIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yIGZvciBhbnlob3c6OkNoYWluPjo6bmV4dDo6aGMzZGI5NDJlNzU1MTE1ZTDDAVZjb3JlOjpzdHI6OnRyYWl0czo6PGltcGwgY29yZTo6b3BzOjppbmRleDo6SW5kZXg8ST4gZm9yIHN0cj46OmluZGV4OjpoYmI4MzhkYjljNGRhMjBjZcQBMG1vbmNoOjpQYXJzZUVycm9yRmFpbHVyZTo6bmV3OjpoYWU0YTNjNmRjZWM0NDdjNsUBczxjb3JlOjppdGVyOjphZGFwdGVyczo6ZmxhdHRlbjo6RmxhdHRlbjxJPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OnNpemVfaGludDo6aGQ0OWRhY2UwNjlkYThiMjHGAURoYXNoYnJvd246OnJhdzo6VGFibGVMYXlvdXQ6OmNhbGN1bGF0ZV9sYXlvdXRfZm9yOjpoZWE5NDU5MzE4NDA4OWI5YccBMmNvcmU6OmZtdDo6QXJndW1lbnRzOjpuZXdfdjE6OmhkNTVkZWY0NjRmOGQyMWU3Ljc5yAEzY29yZTo6Zm10OjpBcmd1bWVudHM6Om5ld192MTo6aGQ1NWRlZjQ2NGY4ZDIxZTcuMzI0yQFhPGNvcmU6OnN0cjo6aXRlcjo6Q2hhckluZGljZXMgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoZjMzZmZkZmI1YzFkOWEzN8oBSjxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg4MjMxOGQ5OGFmOGE1NzIxywFFaGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlSW5uZXI8QT46OmZpbmRfaW5zZXJ0X3Nsb3Q6OmhiMTNlNjA5Yjk4ODg5Y2IyzAEzc3RkOjpzeW5jOjptdXRleDo6TXV0ZXg8VD46OmxvY2s6OmhlOTk4Mzg0Y2VmNzEwMTg5zQExYWxsb2M6OnN0cmluZzo6U3RyaW5nOjpwdXNoOjpoYTY1YzIyOTQxNWFmZjEyNC42NM4BMXNlcmRlOjpkZTo6RXJyb3I6OmludmFsaWRfdHlwZTo6aDQyN2E3ZTE4NjljZWQ3MmXPATJzZXJkZTo6ZGU6OkVycm9yOjppbnZhbGlkX3ZhbHVlOjpoZjllZTlmOTI1MGJjMGE2Y9ABKm1vbmNoOjp0YWc6Ont7Y2xvc3VyZX19OjpoZDg4YTBjNDY5Y2JlMjExY9EBLWFsbG9jOjp2ZWM6OlZlYzxULEE+OjpwdXNoOjpoZDdlNDQwYzQ1MDQ5ODhlONIBPmFsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZW1vdmU6OmFzc2VydF9mYWlsZWQ6Omg0MjVhZDczNDlkODgxZjMz0wEsdnRlOjpwYXJhbXM6OlBhcmFtczo6cHVzaDo6aDdiMjgyMTlkZTdiM2E5MGLUAUNjb3JlOjp1bmljb2RlOjp1bmljb2RlX2RhdGE6OndoaXRlX3NwYWNlOjpsb29rdXA6OmgzODZjZTAxMjE3NDllYzg01QE4ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX29wX3N0cjo6aDU1NDdmNzI1NjNhYzQ0M2PWAS5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6Omg4YjNkYjBmMTExNzFiNTdi1wE5YWxsb2M6OnZlYzo6VmVjPFQsQT46OmludG9fYm94ZWRfc2xpY2U6OmgyZmJhNmExOTczNzZmZmY42AEwbW9uY2g6OlBhcnNlRXJyb3JGYWlsdXJlOjpuZXc6Omg1MjFjM2E5ODNlMGM1ZDM52QF8PGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGFsbG9jOjp2ZWM6OnNwZWNfZXh0ZW5kOjpTcGVjRXh0ZW5kPCZULGNvcmU6OnNsaWNlOjppdGVyOjpJdGVyPFQ+Pj46OnNwZWNfZXh0ZW5kOjpoYmYzOTM1NGZlMzQzMWRkMtoBfDxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBhbGxvYzo6dmVjOjpzcGVjX2V4dGVuZDo6U3BlY0V4dGVuZDwmVCxjb3JlOjpzbGljZTo6aXRlcjo6SXRlcjxUPj4+OjpzcGVjX2V4dGVuZDo6aGVkODdkYzU0NmJiOTA0OTXbATFjb25zb2xlX3N0YXRpY190ZXh0OjpMaW5lOjpuZXc6OmhiYWMxNTIwNmYyZWEyODRl3AFbPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6Y29sbGVjdDo6RXh0ZW5kPFQ+Pjo6ZXh0ZW5kOjpoYzU3OTUwZmFiYjNhYjA4MN0BSjxjb3JlOjpvcHM6OnJhbmdlOjpSYW5nZTxJZHg+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhjMTc2ZjkyMzliMzVhMzJm3gEmbW9uY2g6OmlzX2JhY2t0cmFjZTo6aGViMGNhMDA4NjdkY2I3NmLfAUs8YWxsb2M6OmFsbG9jOjpHbG9iYWwgYXMgY29yZTo6YWxsb2M6OkFsbG9jYXRvcj46OnNocmluazo6aGFhYTM4YjFjZGQ5N2ZjZGTgAS1qc19zeXM6OlVpbnQ4QXJyYXk6OnRvX3ZlYzo6aDU4MTRmZWFkZDFkMjc5YWbhAWs8c2VyZGU6Ol9fcHJpdmF0ZTo6c2VyOjpUYWdnZWRTZXJpYWxpemVyPFM+IGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZXI+OjpzZXJpYWxpemVfc3RydWN0OjpoYmU2NGJkMjg1ODQyYmJjNuIBOmFsbG9jOjp2ZWM6OlZlYzxULEE+OjpleHRlbmRfZnJvbV9zbGljZTo6aDg4ZjE2MDEwMjQzNmFjMTXjAXxjb3JlOjpzdHI6OnRyYWl0czo6PGltcGwgY29yZTo6c2xpY2U6OmluZGV4OjpTbGljZUluZGV4PHN0cj4gZm9yIGNvcmU6Om9wczo6cmFuZ2U6OlJhbmdlRnJvbTx1c2l6ZT4+OjpnZXQ6OmhiNTVjNDZhODlkOTI2NDEx5AGCAWRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpfOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpTZXF1ZW50aWFsTGlzdD46OnNlcmlhbGl6ZTo6aGIzY2VjOWMwM2I1NmQ3ZGLlATRzZXJkZTo6ZGU6OkVycm9yOjpkdXBsaWNhdGVfZmllbGQ6Omg4Y2JiYWZmZjUwZDM0OTFh5gEyc2VyZGU6OmRlOjpFcnJvcjo6bWlzc2luZ19maWVsZDo6aGE4MzJiNmJkNTE0YzI2M2bnAVNjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGU6Ol9fcHJpdmF0ZTo6ZGU6OmNvbnRlbnQ6OkNvbnRlbnQ+OjpoOTQ0MjkxYjY2YjUyNjA1ZegBNGNvcmU6OnJlc3VsdDo6UmVzdWx0PFQsRT46OnVud3JhcDo6aDQxZDc3OTViMTU1OTgzZDLpATthbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OmFsbG9jYXRlX2luOjpoMDk3Njg2YzQ4OGE0ZDE0MOoBNmNvcmU6OnBhbmlja2luZzo6cGFuaWNfYm91bmRzX2NoZWNrOjpoOTI0NWQ0YTgyNWNjNTEwN+sBTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRjaF9mYWlsOjpoMjYzOGZjYjVhZWJkZTRlNewBQWNvbnNvbGVfc3RhdGljX3RleHQ6OmFuc2k6OlBlcmZvcm1lcjo6ZmluYWxpemU6Omg4OTZlOWNkZWUzODJlOWE07QE/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6Omg4OGZhYjU5ZjM1OWMzYjgz7gE9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoMTM0YWI2MWM5ODBhZjYzNu8BQTxzdHIgYXMgdW5pY29kZV93aWR0aDo6VW5pY29kZVdpZHRoU3RyPjo6d2lkdGg6OmgzZDMzNzczMjI2ZmFlZmZj8AFBY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aGY3ZmMyMDI1MzY5MDQxMmTxAYIBPDxhbGxvYzo6dmVjOjpkcmFpbjo6RHJhaW48VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpEcm9wR3VhcmQ8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoMTdmZWQwZGFkMjJhMmNiNfIBW2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8Y29uc29sZV9zdGF0aWNfdGV4dDo6VGV4dEl0ZW0+Pjo6aDliYzA3Y2U3NTcwYTk3ZTPzATNjb25zb2xlX3N0YXRpY190ZXh0Ojp2dHNfbW92ZV91cDo6aGVmNGM1YWNlZjFiM2YxZjP0ATA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGUwMTBjOWNlMDU4MGNkMjH1AVE8b25jZV9jZWxsOjpzeW5jOjpMYXp5PFQsRj4gYXMgY29yZTo6b3BzOjpkZXJlZjo6RGVyZWY+OjpkZXJlZjo6aDFkMWJlMmU1ZDc5MTVkOTX2ATRjb3JlOjpzbGljZTo6bWVtY2hyOjptZW1jaHJfbmFpdmU6Omg1MmNkMWQ0OWNiNzQ2Yzll9wFuPHNlcmRlX3dhc21fYmluZGdlbjo6c2VyOjpPYmplY3RTZXJpYWxpemVyIGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZVN0cnVjdD46OnNlcmlhbGl6ZV9maWVsZDo6aGU0NThhNGQ5Mzg3NWI0NDH4AUJjb25zb2xlX3N0YXRpY190ZXh0OjphbnNpOjpQZXJmb3JtZXI6Om1hcmtfY2hhcjo6aDgyNjM0Y2E5NmYwMWFmZGT5AVA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMzkxYjM4MzYzMzcxMTdjNvoBM2FsbG9jOjpzeW5jOjpBcmM8VCxBPjo6ZHJvcF9zbG93OjpoZTQzZmNiM2M4ZTk4OTFhOPsBM2FsbG9jOjpzeW5jOjpBcmM8VCxBPjo6ZHJvcF9zbG93OjpoNWQ2MzU4ZTE4MzlkNzUxY/wBjgF3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmltcGxzOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OnRyYWl0czo6UmV0dXJuV2FzbUFiaSBmb3IgY29yZTo6cmVzdWx0OjpSZXN1bHQ8VCxFPj46OnJldHVybl9hYmk6Omg5Nzg0OTkwMzNlZWQxMGI5/QEtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg2ZTA5Mzc5MThmNjBkODlm/gEtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg1OGE3ZThhYTI2YjM1Nzk0/wEtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6OmgxOTdkMTBmYjEyODZlZTAxgAJWY29yZTo6c3RyOjp0cmFpdHM6OjxpbXBsIGNvcmU6Om9wczo6aW5kZXg6OkluZGV4PEk+IGZvciBzdHI+OjppbmRleDo6aGU1Y2VmYTc5YzNmMWNmOGGBAi1hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cHVzaDo6aDNmMGQ2NDg1ZGNjYzE4NDKCAi1hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cHVzaDo6aDM5ODA3NzEwNWE0YmY0NTaDAjthbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OmFsbG9jYXRlX2luOjpoNTY1ZTY2OWUzNDFiNWQ0YoQCiAF3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmltcGxzOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OnRyYWl0czo6SW50b1dhc21BYmkgZm9yIGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+Pjo6aW50b19hYmk6OmhlZTI1ZTU2MWNhMWVjYjNihQJWY29yZTo6c3RyOjp0cmFpdHM6OjxpbXBsIGNvcmU6Om9wczo6aW5kZXg6OkluZGV4PEk+IGZvciBzdHI+OjppbmRleDo6aGIxYThjOTBjY2VmMTBkYTGGAjFjb21waWxlcl9idWlsdGluczo6bWVtOjptZW1jbXA6OmgxNDc2OWRiY2RkNTRlODc1hwI5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6Omg1OTI2NGI2ZjEzOTFhMDA3iAIwc2VyZGU6OmRlOjpWaXNpdG9yOjp2aXNpdF9zdHI6Omg4MjQwM2Y3OGNlNGQyMmY4iQIyc2VyZGU6OmRlOjpWaXNpdG9yOjp2aXNpdF9ieXRlczo6aDQyNDIzMTVjNWRkOWY5YWKKAi5jb3JlOjpvcHRpb246OmV4cGVjdF9mYWlsZWQ6OmhlYTIyY2YxMzVhZDY0ZTk4iwJWY29yZTo6c3RyOjp0cmFpdHM6OjxpbXBsIGNvcmU6Om9wczo6aW5kZXg6OkluZGV4PEk+IGZvciBzdHI+OjppbmRleDo6aDVkMzhhNTgyYmQ2ZWUzZDGMAkhoYXNoYnJvd246OnJhdzo6UmF3VGFibGVJbm5lcjxBPjo6cHJlcGFyZV9pbnNlcnRfc2xvdDo6aDg4OGM3MDJmNjNkNjU2NjONAlJjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPHJzX2xpYjo6V2FzbVRleHRJdGVtPj46OmgwMTk4OThhZTU3NjdhOGEwjgJoPGNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpmdXNlOjpGdXNlPEk+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6bmV4dDo6aDYyNzI5MWRjYTg3MmZhZjePAocBd2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpzbGljZXM6OjxpbXBsIHdhc21fYmluZGdlbjo6Y29udmVydDo6dHJhaXRzOjpJbnRvV2FzbUFiaSBmb3IgYWxsb2M6OnN0cmluZzo6U3RyaW5nPjo6aW50b19hYmk6OmgzOGJkMGQyYjM1MTYzYjE3kAJkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjp2ZWM6OlZlYzxzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudD4+OjpoMzVkODc2ZTU0ZDA5ZTkwYZECjQFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPChzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCxzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCk+Pjo6aDBjMWM2Y2I1NzBjOTY0OTmSAixjb3JlOjplcnJvcjo6RXJyb3I6OmNhdXNlOjpoZmNiMzIyZTcyYTI0ZDc0Y5MCTjxhbnlob3c6OmVycm9yOjpFcnJvckltcGw8RT4gYXMgY29yZTo6ZXJyb3I6OkVycm9yPjo6c291cmNlOjpoZmUyZWM4NmJlMDJjODQ2ZpQCXWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OkVudlZhcj4+OjpoN2RmNDAyZTJiMmVkYTUyY5UCW2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmQ+Pjo6aGRlNGZiYThhMWE1YTFhZTGWAl9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpSZWRpcmVjdD4+OjpoNDg2NzAwZmE0N2RhZmIyOJcCLGNvcmU6OmVycm9yOjpFcnJvcjo6Y2F1c2U6OmhjOTBkYzliN2FlMWVmYzRmmAJOPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxFPiBhcyBjb3JlOjplcnJvcjo6RXJyb3I+Ojpzb3VyY2U6OmhjZmJhMWU2ZjczMDFhZjllmQI8ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6aW5pdF90b3A6Omg1Y2NlNjI5NmExODMyYmFhmgJTY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvbnNvbGVfc3RhdGljX3RleHQ6OkNvbnNvbGVTdGF0aWNUZXh0Pjo6aDc0MDgzMTI5YWZmOWE0ODmbAlY8anNfc3lzOjpBcnJheUl0ZXIgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoNzAyMzRiZjZkNDIwYTU1NJwCOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDdiMTNjZDc5YTk2YjRmNTSdAlU8c2VyZGU6OmRlOjppbXBsczo6U3RyaW5nVmlzaXRvciBhcyBzZXJkZTo6ZGU6OlZpc2l0b3I+Ojp2aXNpdF9zdHI6OmhjOWQyYjBiMTY3M2JhZDQxngJOY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD46Omg2YzZhZDczNmU5NWZlZGU2nwJOY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpTZXF1ZW5jZT46OmhjZTA1NzVlZTk4M2U5NDAyoAI7YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjphbGxvY2F0ZV9pbjo6aGFmZTA0NDAxNTM2MjJhZWGhAkJjb3JlOjpjaGFyOjptZXRob2RzOjo8aW1wbCBjaGFyPjo6aXNfd2hpdGVzcGFjZTo6aDBhZTczZDkzYWRjOWZiYTOiAjBhbGxvYzo6dmVjOjpWZWM8VCxBPjo6cmVzZXJ2ZTo6aGM0ZWQyYzkwM2RiOTNlNzOjAiljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoMGYwYzA1YjIwZGE5M2RkN6QCMGFsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZXNlcnZlOjpoYTBiZjgxZTc3NzUxMGIyOKUCaTxoYXNoYnJvd246OnJhdzo6Yml0bWFzazo6Qml0TWFza0l0ZXIgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoMDA0MmMzMGJiZjQwZjQwYqYCMHNlcmRlOjpkZTo6VmlzaXRvcjo6dmlzaXRfdTY0OjpoZDNlOTc5NTk5YzE0NzAzNqcCMHNlcmRlOjpkZTo6VmlzaXRvcjo6dmlzaXRfaTY0OjpoOTBlYzVmN2Y3ZjYyMDQ2N6gCMHNlcmRlOjpkZTo6VmlzaXRvcjo6dmlzaXRfZjY0OjpoYmJhOGQyMzI4MjlmOTJjMKkCYTxjb3JlOjpvcHM6OnJhbmdlOjpSYW5nZTx1c2l6ZT4gYXMgY29yZTo6c2xpY2U6OmluZGV4OjpTbGljZUluZGV4PFtUXT4+OjppbmRleDo6aDU3NWNmNDg5ZGRhODRkOGaqAhFydXN0X2JlZ2luX3Vud2luZKsCiAF3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OnNsaWNlczo6PGltcGwgd2FzbV9iaW5kZ2VuOjpjb252ZXJ0Ojp0cmFpdHM6OkZyb21XYXNtQWJpIGZvciBhbGxvYzo6Ym94ZWQ6OkJveDxbVF0+Pjo6ZnJvbV9hYmk6OmgxMzg2OGVmYmVkMzQ3MDM5rAJePHNlcmRlOjpkZTo6dmFsdWU6OlNlcURlc2VyaWFsaXplcjxJLEU+IGFzIHNlcmRlOjpkZTo6U2VxQWNjZXNzPjo6c2l6ZV9oaW50OjpoNWQ5NjE4MWFjZjY1ZmFhNq0ClAE8cnNfbGliOjpfOjo8aW1wbCBzZXJkZTo6ZGU6OkRlc2VyaWFsaXplIGZvciByc19saWI6Oldhc21UZXh0SXRlbT46OmRlc2VyaWFsaXplOjpfX0ZpZWxkVmlzaXRvciBhcyBzZXJkZTo6ZGU6OlZpc2l0b3I+Ojp2aXNpdF9zdHI6OmhkOWNjMmQzMzU2Mzk1Y2JkrgI4Y29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OnNwbGl0X2F0X211dDo6aDg3NTJlNmQ2MDc4N2E0MjCvAlE8Y29uc29sZV9zdGF0aWNfdGV4dDo6Q29uc29sZVNpemUgYXMgY29yZTo6Y21wOjpQYXJ0aWFsRXE+OjplcTo6aDNiMzMyMjRjNmFkYjNkZDOwAnJjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8W2Rlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV93b3JkX3BhcnRzOjp7e2Nsb3N1cmV9fTo6UGVuZGluZ1BhcnRdPjo6aDE5N2M1ZjJiZTdiNGIzYWOxAkRoYXNoYnJvd246OnJhdzo6UmF3VGFibGVJbm5lcjxBPjo6YWxsb2NhdGlvbl9pbmZvOjpoOWNiMWIxY2IzYjM5NTJkOLICqAFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6aXRlcjo6YWRhcHRlcnM6OmZsYXR0ZW46OkZsYXR0ZW48YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0Pj4+Pjo6aGQwZWY4ODAzNDgxOTJjZDCzAhFfX3diaW5kZ2VuX21hbGxvY7QCQ2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OndyaXRlX3ByZWZpeDo6aDhiNDQ3ZDFkNzIzOTVhZDO1AjBjb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbjo6Y2FsbDo6aDhlMzIxNGE3NTYzZGZjNGW2AktkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpyZWxlYXNlX3VudXNlZF9zZWdtZW50czo6aDcwYWJlNmJmMThjMzZiZGG3Ams8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoNTcyNjFmMzcyZTk4Yzg2NLgCOHNlcmRlX3dhc21fYmluZGdlbjo6ZXJyb3I6OkVycm9yOjpuZXc6OmgzYjM4OTFmZTM2M2U4NzQzuQJAYW55aG93OjplcnJvcjo6PGltcGwgYW55aG93OjpFcnJvcj46OmZyb21fc3RkOjpoYTI4MmE0OGIxNmQxYzZmM7oCNGNvcmU6OnJlc3VsdDo6UmVzdWx0PFQsRT46OnVud3JhcDo6aDA0ZTY4NWU4YmZkYWU3NWK7Aks8YW55aG93OjplcnJvcjo6RXJyb3JJbXBsPEU+IGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDgyMjk5ZTAyZmZhM2VmMzK8AlE8YWxsb2M6OnZlYzo6ZHJhaW46OkRyYWluPFQsQT4gYXMgY29yZTo6b3BzOjpkcm9wOjpEcm9wPjo6ZHJvcDo6aDMyNTgzNDM4ZTVmYTA2N2K9Aktjb3JlOjpmbXQ6OmZsb2F0Ojo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIGY2ND46OmZtdDo6aGI3OGJiMThmZGUwNjE5NWG+Aks8YW55aG93OjplcnJvcjo6RXJyb3JJbXBsPEU+IGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGJmMWEyYzIxYjY3ZDJlODC/AkFoYXNoYnJvd246OnJhdzo6RmFsbGliaWxpdHk6OmNhcGFjaXR5X292ZXJmbG93OjpoMTE0ODBmNGE2YjdkYWQxNcACLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm10OjpoM2UxZGQzZDA4Mjg4NTY5ZcECeGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpfOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkPjo6c2VyaWFsaXplOjpoOTZhNzc2MmI5MjhlN2RiN8ICNGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDk1NmViZTZiZjA0YjljNzPDAjJ3YXNtX2JpbmRnZW46OmJpZ2ludF9nZXRfYXNfaTY0OjpoOTdhNzkzNjcyYTg3N2FmMsQCRGNvbnNvbGVfc3RhdGljX3RleHQ6OmFuc2k6OlBlcmZvcm1lcjo6bWFya19lc2NhcGU6Omg2OWYxYjY3N2EyNTdiYzBjxQI4c3RkOjp0aHJlYWQ6OlRocmVhZElkOjpuZXc6OmV4aGF1c3RlZDo6aDQyODYyODIzNWRhNDQ4MmTGAm48c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoODlkYTI0ODM4MzAyNGNkMMcCWzxjb3JlOjpzdHI6Oml0ZXI6OkNoYXJzIGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6bmV4dDo6aDYzZWE3N2U5MDlhYTgxNTjIAjFjb3JlOjpwYW5pY2tpbmc6OmFzc2VydF9mYWlsZWQ6Omg3OGU2NDhkYTU5YTE1YzdkyQJPPHN0ZDo6c3luYzo6cG9pc29uOjpQb2lzb25FcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZTRkZTZhZDQ0MWE3NjFlY8oCSDxjb3JlOjpvcHRpb246Ok9wdGlvbjxUPiBhcyBjb3JlOjpjbXA6OlBhcnRpYWxFcT46OmVxOjpoYWJmMzcyZDFmYTM0MjdlMcsCMWNvcmU6OnBhbmlja2luZzo6YXNzZXJ0X2ZhaWxlZDo6aDhiN2E3MzE1N2ZhYjg5NjXMAsoFY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPG1vbmNoOjpvcjxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UmVkaXJlY3RPcCxtb25jaDo6bWFwPCZzdHIsZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlJlZGlyZWN0T3AsbW9uY2g6OnRhZzwmc3RyPjo6e3tjbG9zdXJlfX0sZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3JlZGlyZWN0Ojp7e2Nsb3N1cmV9fT46Ont7Y2xvc3VyZX19LG1vbmNoOjpvcjxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UmVkaXJlY3RPcCxtb25jaDo6bWFwPCZzdHIsZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlJlZGlyZWN0T3AsbW9uY2g6Om9yPCZzdHIsbW9uY2g6OnRhZzwmc3RyPjo6e3tjbG9zdXJlfX0sbW9uY2g6OnRhZzwmc3RyPjo6e3tjbG9zdXJlfX0+Ojp7e2Nsb3N1cmV9fSxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfcmVkaXJlY3Q6Ont7Y2xvc3VyZX19Pjo6e3tjbG9zdXJlfX0sbW9uY2g6Om1hcDxjaGFyLGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpSZWRpcmVjdE9wLG1vbmNoOjppZl90cnVlPGNoYXIsbW9uY2g6Om5leHRfY2hhcixtb25jaDo6Y2g6Ont7Y2xvc3VyZX19Pjo6e3tjbG9zdXJlfX0sZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3JlZGlyZWN0Ojp7e2Nsb3N1cmV9fT46Ont7Y2xvc3VyZX19Pjo6e3tjbG9zdXJlfX0+Ojp7e2Nsb3N1cmV9fT46Omg2MzQyNDdhODU0ZTRjMjMwzQIxY29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkOjpoYmI2YzgwY2RjNTA2NTBhN84CTjxzZXJkZV93YXNtX2JpbmRnZW46OmVycm9yOjpFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNDdkZDI5ODQ0YzA5YmVkY88CSDxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoNmQzOWFiYTE2YmJiZTlhOdACM2FsbG9jOjpzeW5jOjpBcmM8VCxBPjo6ZHJvcF9zbG93OjpoZjIyMTZjNGMwZjA3MTBhZdECRXNlcmRlX3dhc21fYmluZGdlbjo6ZGU6OkRlc2VyaWFsaXplcjo6aW52YWxpZF90eXBlOjpoNjEzY2RlN2Y1NDFmZWYzMtICEl9fd2JpbmRnZW5fcmVhbGxvY9MCQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDNiYmJhMWE2N2VmZTE0ZGPUAjo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6OmhlNDgxNjMxM2YyNGNlM2Qy1QJIY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPFtjb25zb2xlX3N0YXRpY190ZXh0OjpMaW5lXT46Omg2ZDQ0ZTM0NjYxMjcyNDc11gJAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoNWUzYjAzMzJiNGEwNmY4ZtcCMHZ0ZTo6UGFyc2VyPF8+OjppbnRlcm1lZGlhdGVzOjpoZTFiMjQ5MDk1OGVkNDA0MtgCOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aDUwZWIyZGEyMTE1Yjg3OTTZAkBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmhkMzQ1YTk0YmY3NWNjOTll2gI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoOGMwMWEyZTFjNDc0MDUzMNsCLmNvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2ZtdDo6aDRiNWZhYjExNmEwODM5OGbcAi5jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9mbXQ6OmhlM2MyZGI3ODA0N2IwMGEy3QIuY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfZm10OjpoODU1NjcxM2E4ZDMzZTk3M94CZ3NlcmRlOjpzZXI6OmltcGxzOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OnNlcmlhbGl6ZTo6aDYxMTFhY2JkZjI1YzFlNzDfAlNjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlBpcGVsaW5lSW5uZXI+OjpoZDk1NDE0YjZkNzc4NGQ3ZOACUmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6Q29tbWFuZElubmVyPjo6aGE3NWJiMzc3YzViNGQ4MTHhAjp3YXNtX2JpbmRnZW46Ol9fcnQ6OnRha2VfbGFzdF9leGNlcHRpb246OmhmZWNjM2U0ZTE2MjQyYTgw4gI2YWxsb2M6OmFsbG9jOjpHbG9iYWw6OmFsbG9jX2ltcGw6OmhmZjJmNWE4ODkzODYyMjRkLjE54wJKY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPG1vbmNoOjpQYXJzZUVycm9yRmFpbHVyZUVycm9yPjo6aGI0YzY3MmUyNDExMzhhNjbkAjdzZXJkZV93YXNtX2JpbmRnZW46OmRlOjpjb252ZXJ0X3BhaXI6Omg4NWU1OTcxMDFkOTU3YzE25QI/cnNfbGliOjpzdGF0aWNfdGV4dF9yZW5kZXJfb25jZTo6e3tjbG9zdXJlfX06Omg3NzM2YjAxZDVhMDUyZjU45gJIY29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2V7e3Z0YWJsZS5zaGltfX06OmgxMjM5NGFhMzg4NTU2NGZl5wJGY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFueWhvdzo6Y2hhaW46OkNoYWluU3RhdGU+OjpoYzZjZDEzNTBmMTUyYzMyNOgCYWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxbYWxsb2M6OnZlYzo6VmVjPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD5dPjo6aDM2NDg2OGU1ZDgwN2IxYWbpAlBjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8W2Rlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydF0+OjpoM2IwYTkxODdiMTU0Y2E0N+oCQGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdGQ6OnRocmVhZDo6VGhyZWFkPjo6aDcxYTRlOTU2NTdhYWVhNzbrAlg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg4Nzk4YTYxZTQ0M2JkOGMz7AI7Y29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6aDY3ODc5ZWRkMTA5NDk0YzftAk5jb3JlOjpmbXQ6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIGk2ND46OmZtdDo6aGE5ZTQzZGI0YjQ5NjdlYzPuAlg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmhhNGIxMWY3MDA2OGMwYjRh7wKCAWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpyZXN1bHQ6OlJlc3VsdDwoJnN0cixkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UGlwZWxpbmVJbm5lciksbW9uY2g6OlBhcnNlRXJyb3I+Pjo6aGEwYWVjZGQ1ZjEwYWM3NDXwAn1jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6cmVzdWx0OjpSZXN1bHQ8KCZzdHIsZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlNlcXVlbmNlKSxtb25jaDo6UGFyc2VFcnJvcj4+OjpoNWRiOGJlMmZiNTU2ZjBhOfECP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoY2I1ODg5Zjc3Y2FmNWRkZfICcWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdGQ6OnN5bmM6Om11dGV4OjpNdXRleEd1YXJkPGNvbnNvbGVfc3RhdGljX3RleHQ6OkNvbnNvbGVTdGF0aWNUZXh0Pj46OmhhMjc5MTE2ODYxNzcyZTk38wIsc3RkOjpwYW5pY2tpbmc6OnBhbmlja2luZzo6aDBjMjNlY2Y4NDk0OTJlZGP0AkY8W0FdIGFzIGNvcmU6OnNsaWNlOjpjbXA6OlNsaWNlUGFydGlhbEVxPEI+Pjo6ZXF1YWw6OmgwYzhkOTI4MTExYjhlNjNl9QI1Y29yZTo6c3RyOjo8aW1wbCBzdHI+OjpzdGFydHNfd2l0aDo6aGNmYWQ4N2Q4YWY0NjRjYjH2Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDEwNWUxYjUzMjAyZDRkOTL3Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDE1Mzc0ZTQxZjk5MjJkOGX4Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDE4YTg3M2I4ZjBmZmE3ODb5Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDFiNjM2ZDhlNTY5ZDdkYTj6Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDI0ZGE3ZWEzN2Y3ZTkxM2T7Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDNhMzM0NjhhZTk1MjE0Yzn8Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGI0YzlkNzc1ZTlkY2RhZTf9Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGY1M2Q3YzcyOTBkOGQ2ZjT+Al5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlBhbmljUGF5bG9hZD46OmgzMDlhYTViMTlmYzJmODcz/wIxYWxsb2M6OnJhd192ZWM6OmhhbmRsZV9yZXNlcnZlOjpoNWUyMGI1MGMxMGM4YTJlOYADMWFueWhvdzo6ZXJyb3I6Om9iamVjdF9kb3duY2FzdDo6aDIwZTYzNGRhMTRmYzk0Y2OBAzQ8Ym9vbCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyOTY2YWYyODdhZjBlY2Q5ggOOAWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpyZXN1bHQ6OlJlc3VsdDwoJnN0cixhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0PiksbW9uY2g6OlBhcnNlRXJyb3I+Pjo6aGI1MzJhYzgzZDcyOGViNTGDAzFhbnlob3c6OmVycm9yOjpvYmplY3RfZG93bmNhc3Q6OmhiM2NmYTI4MzViN2M2MTkwhAM/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMl9tdXQ6OmgzNDVmM2EzZTM1MzBmMzdjhQMzYWxsb2M6OmFsbG9jOjpHbG9iYWw6OmFsbG9jX2ltcGw6OmhmZjJmNWE4ODkzODYyMjRkhgN4Y29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6OnJlc3VsdDo6UmVzdWx0PHJzX2xpYjo6V2FzbVRleHRJdGVtLHNlcmRlX3dhc21fYmluZGdlbjo6ZXJyb3I6OkVycm9yPj46Omg1YjMyY2NhNDhmNTg4MjM5hwNNY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpDb21tYW5kPjo6aDEzODJjYjMzZDBlOTFjNTKIAz5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8bW9uY2g6OlBhcnNlRXJyb3I+OjpoMDZlMjFiZmM1NTE5M2Q1YokDP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTFfbXV0OjpoMzk1Yzg5ZTIwMjUyNmIyZooDN2FsbG9jOjphbGxvYzo6R2xvYmFsOjphbGxvY19pbXBsOjpoZmYyZjVhODg5Mzg2MjI0ZC4zMTSLAwxfX3J1c3RfYWxsb2OMA248c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoOTQ5NjExNTcxZTEzYzM5MY0DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoZGZhNTkwZGRiZjY3NTRhOI4DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoYTIzOWZmZTM1ZmI3YjE4OI8DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoYzFhNTNjMWUyZjFhZmRlNJADMGFsbG9jOjphbGxvYzo6ZXhjaGFuZ2VfbWFsbG9jOjpoMGVkZDRjOTFlMWU1NmQ4OZEDbjxzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6T2JqZWN0U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVTdHJ1Y3Q+OjpzZXJpYWxpemVfZmllbGQ6OmgxY2YyZmFkZDFkZGQ1ZWNlkgNuPHNlcmRlX3dhc21fYmluZGdlbjo6c2VyOjpPYmplY3RTZXJpYWxpemVyIGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZVN0cnVjdD46OnNlcmlhbGl6ZV9maWVsZDo6aGQ1Y2E1ZWQzNDQ2MjUwZjiTAzI8VCBhcyBzZXJkZTo6ZGU6OkV4cGVjdGVkPjo6Zm10OjpoMzMyYWU1OWFlNTY5NDU1OJQDMjxUIGFzIHNlcmRlOjpkZTo6RXhwZWN0ZWQ+OjpmbXQ6Omg5YmU3ZWEwNjhhYTBlZjc1lQMyPFQgYXMgc2VyZGU6OmRlOjpFeHBlY3RlZD46OmZtdDo6aGM3MzYzMjFlODY4NGM0MmKWAzI8VCBhcyBzZXJkZTo6ZGU6OkV4cGVjdGVkPjo6Zm10OjpoNTVmZTc0ZDMxZmYwOTVkZpcDMjxUIGFzIHNlcmRlOjpkZTo6RXhwZWN0ZWQ+OjpmbXQ6OmgxZGQwYWY2MWI5NmY2ODUzmAMyPFQgYXMgc2VyZGU6OmRlOjpFeHBlY3RlZD46OmZtdDo6aGFiYTk1MGQ4MDhmN2Q5NmWZA1djb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPGNvbnNvbGVfc3RhdGljX3RleHQ6OkxpbmU+Pjo6aDViNDhmODFiZjgwNTI5YzGaA0g8Y29yZTo6Y2VsbDo6Qm9ycm93TXV0RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDQ1YWU2ODgyZTkyNTk3NmGbAz48Y29yZTo6Zm10OjpFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWIyNWU4Y2I0MDliM2Y4YpwDX2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0Pj46Omg1YjA3YzQ0ODJlOWNiNTg5nQM3YWxsb2M6OmFsbG9jOjpHbG9iYWw6OmFsbG9jX2ltcGw6OmhmZjJmNWE4ODkzODYyMjRkLjIyOJ4DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoNjcxNzY4NTdmNDE5NWY1ZJ8DcGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8YWxsb2M6OnZlYzo6VmVjPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD4+Pjo6aDZhMmNkZWIwNjRjZDNkYzegA0NzZXJkZV93YXNtX2JpbmRnZW46OmRlOjpEZXNlcmlhbGl6ZXI6OmlzX251bGxpc2g6OmhlZDlhZDA5NDQ1MjRiODJmoQNPPGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoNzM0ZjYwNGY2MzJkZWI4NaIDTzxhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT4gYXMgY29yZTo6b3BzOjpkcm9wOjpEcm9wPjo6ZHJvcDo6aDVmMTAyNWU3NzRjYWRlOGKjA048YW55aG93Ojp3cmFwcGVyOjpNZXNzYWdlRXJyb3I8TT4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGZjYTQzZWQ5YzNhZTNiOGakA088YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg2YmRiMmJjNWJmNmEzMWNmpQNMY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpFbnZWYXI+OjpoZDgyN2I5MzdhYjQ2NWFiYaYDTmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UmVkaXJlY3Q+OjpoNzAzYjdhNWUzYjY4ZTRjMKcDNGFsbG9jOjphbGxvYzo6ZXhjaGFuZ2VfbWFsbG9jOjpoMGVkZDRjOTFlMWU1NmQ4OS4yMzCoA2Bjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6cmVzdWx0OjpSZXN1bHQ8KCZzdHIsY2hhciksbW9uY2g6OlBhcnNlRXJyb3I+Pjo6aDRhNDMwNDY0NDMyMzI0N2GpA0c8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhMGM4YWNkYTZiYWFmNDVmLjMxNqoDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMWNkODQzMDE0ZTQwNTY0OasDazwmc2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6OlNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplcj46OnNlcmlhbGl6ZV91bml0X3ZhcmlhbnQ6OmhlZjVhNjI4NzJhY2U5ZDE3rANiPCZzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVyPjo6c2VyaWFsaXplX3N0cjo6aDZkMTA2MWRlNmI4YTMzYzKtA1djb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248cnNfbGliOjpXYXNtVGV4dEl0ZW0+Pjo6aDQyZjg2NDhmMjMzZTVjZjWuA2ljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248c2VyZGU6Ol9fcHJpdmF0ZTo6ZGU6OmNvbnRlbnQ6OkNvbnRlbnQ+Pjo6aDY3ODYwZGQ1MWQ5Mzk5YjevA5IBY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPChzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCxzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCk+Pjo6aDc4Njg0ZjhkZTY5NWM1NjiwAyxhbnlob3c6OmVycm9yOjpvYmplY3RfcmVmOjpoNDlhNzVhOTYyNmQ3MzIyN7EDRDxjb3JlOjpmbXQ6OkFyZ3VtZW50cyBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyMDAyYTFlMDllZjk3ZDk4sgNkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD4+OjpoZDU4OGJhMGZkZjRhM2RlZLMDLGFueWhvdzo6ZXJyb3I6Om9iamVjdF9yZWY6OmhhMTM0NzIzYmU0NDhmNDVjtANCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OmhmY2Y2YmVmMjg1MGFmOTE2tQMyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGZhMzQwMThmNWRhMjNjYTO2A0Jjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8d2FzbV9iaW5kZ2VuOjpKc1ZhbHVlPjo6aDZhNTNkYTRkY2YzNTJkYzS3A088YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmgwN2ZkOWFmMDA3MGJjYjdjuANpY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjp2ZWM6OlZlYzxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6U2VxdWVudGlhbExpc3RJdGVtPj46OmgzODNkMGM5ZDQ1ZmE4OTMzuQNEY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpib3Jyb3c6OkNvdzxzdHI+Pjo6aGE4MGQxNjc2OTQ5NmRiZWO6A0Fjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8cnNfbGliOjpXYXNtVGV4dEl0ZW0+OjpoN2VkY2NkMTM3OTc1NzkzNbsDT2NvcmU6OmNtcDo6aW1wbHM6OjxpbXBsIGNvcmU6OmNtcDo6UGFydGlhbEVxPCZCPiBmb3IgJkE+OjplcTo6aDIzODM2Mzk0MWFkNzY1ODK8AzI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoMTE0MTkxMTdkOWQ0MTdmML0DLmNvcmU6OnN0cjo6c2xpY2VfZXJyb3JfZmFpbDo6aGExZTNlMDI5MzVjYzEwNGS+AzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDMxMDc5MzliZGVmMjI3MWO/A4UBY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGFsbG9jOjp2ZWM6OmludG9faXRlcjo6SW50b0l0ZXI8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0Pj4+OjpoZjQ1NWJiMjc5MzQxZWJiMcADQ2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxvbmNlX2NlbGw6OmltcDo6V2FpdGVyPjo6aGM0Y2I4YjQ0M2JjMDZiODXBA088YWxsb2M6OmFsbG9jOjpHbG9iYWwgYXMgY29yZTo6YWxsb2M6OkFsbG9jYXRvcj46OmRlYWxsb2NhdGU6OmgxYzQzNjY5OGFjNzZjNjVjwgNDZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OmZhaWxfZm9yX3RyYWlsaW5nX2lucHV0OjpoYTFmMTAyMzNlMmNlZjgwOMMDNndhc21fYmluZGdlbjo6Y2FzdDo6SnNDYXN0OjpkeW5fcmVmOjpoY2Q5ZTY4Njg1YTJhOTIzMsQDSGNvcmU6Om9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNle3t2dGFibGUuc2hpbX19OjpoZTM4YTc2NjViNDNjMGY0OMUDQHJzX2xpYjo6U1RBVElDX1RFWFQ6Ont7Y2xvc3VyZX19Ojp7e2Nsb3N1cmV9fTo6aDAwMGRlMjJlNzQ2MWVlYTDGA2djb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248c2VyZGVfd2FzbV9iaW5kZ2VuOjpkZTo6RGVzZXJpYWxpemVyPj46Omg2NWFmMzYwNjViMTQ0MmRmxwMyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDg4OTAxMzBjMmJmNjYwMDDIA2Zjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OmJveGVkOjpCb3g8c2VyZGU6Ol9fcHJpdmF0ZTo6ZGU6OmNvbnRlbnQ6OkNvbnRlbnQ+Pjo6aGM2NDY0OWI3MTE0MzU2MmXJA3xjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8KHNlcmRlOjpfX3ByaXZhdGU6OmRlOjpjb250ZW50OjpDb250ZW50LHNlcmRlOjpfX3ByaXZhdGU6OmRlOjpjb250ZW50OjpDb250ZW50KT46OmhjYjlmZTJlMjkwNWYxMzliygM6YWxsb2M6OnZlYzo6VmVjPFQsQT46OmV4dGVuZF9mcm9tX3NsaWNlOjpoOTcyZTc5NjMwNTg5YTQ1YssDMmNvcmU6OmVycm9yOjpFcnJvcjo6ZGVzY3JpcHRpb246Omg0NzZiZDJkNWUyMGY3NGZjzAMuY29yZTo6ZXJyb3I6OkVycm9yOjp0eXBlX2lkOjpoMTdkMWEwNTQ0ZjQzNGJjNs0DLmNvcmU6OmVycm9yOjpFcnJvcjo6dHlwZV9pZDo6aGE3YjQ2ODQ1MjViZjVlMDTOAy5hbnlob3c6OmVycm9yOjpvYmplY3RfYm94ZWQ6OmhlODI0ZDhlZTZkMTZiNzQ5zwM6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoYjg0YWJhNzg1ZjJjMGE4ZtADOmFsbG9jOjp2ZWM6OlZlYzxULEE+OjpleHRlbmRfZnJvbV9zbGljZTo6aGU4ODMxMzczZTRkZTYxNDTRAzs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoNWY2NDhiZmViZjc3OGRjYdIDMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhlOGE2MzVkYzc2OGFiMzZl0wNNPHZ0ZTo6VnRVdGY4UmVjZWl2ZXI8UD4gYXMgdXRmOHBhcnNlOjpSZWNlaXZlcj46OmNvZGVwb2ludDo6aDBjM2IyNmU4YmNkOGNjMWTUAzE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6OmgzNTA5OWNjMDRlMzMxMDlk1QMuY29yZTo6ZXJyb3I6OkVycm9yOjp0eXBlX2lkOjpoNDFlMjliNWE3YmQ3ZGE0OdYDLmNvcmU6OmVycm9yOjpFcnJvcjo6dHlwZV9pZDo6aGY3ODcwZTY0NmVhMzYwYzDXAy1hbnlob3c6OmVycm9yOjpvYmplY3RfZHJvcDo6aDI2N2IwM2RjNzc0Mjc3OTPYAy5hbnlob3c6OmVycm9yOjpvYmplY3RfYm94ZWQ6Omg0ODQ5ZDJjNTNiOWMyYmQ22QNFPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg2ZjNkMzQwYTViZWE3NmUx2gMxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYWU0MTkzNzUwYTE2NzE1NdsDZjxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6U3RyUGFuaWNQYXlsb2FkIGFzIGNvcmU6OnBhbmljOjpCb3hNZVVwPjo6Z2V0OjpoOWVhZjUzZWE5YTUyOWFhONwDMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGJiYmVmYjBkMDExYTlkZjXdAxRfX3diaW5kZ2VuX2V4bl9zdG9yZd4DD19fd2JpbmRnZW5fZnJlZd8DkQFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjpzeW5jOjpwb2lzb246OlBvaXNvbkVycm9yPHN0ZDo6c3luYzo6bXV0ZXg6Ok11dGV4R3VhcmQ8Y29uc29sZV9zdGF0aWNfdGV4dDo6Q29uc29sZVN0YXRpY1RleHQ+Pj46OmgxNTk5N2JiNmRjM2E2YWRk4ANJPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNTRlZGE3NWM3YWJlM2UyNOEDTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoN2Y1MjZhNGIyZjMyZjc0M+IDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGRiMDU2YTQ5YWQwZmRjZjDjA0w8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9zdHI6Omg1NGVkYTc1YzdhYmUzZTI0LjQ55ANCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OmgyNTk4ODU4NmM3YjFjOTdm5QNYPGFsbG9jOjp2ZWM6OmludG9faXRlcjo6SW50b0l0ZXI8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoMmI0MzMyMjdlNDNiODRhNOYDOWNvcmU6Om9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNlOjpoNzc3NDg3NzA4MGYzZjlmNecDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDhmMDAxOTM5MzE4YTcwZTboA05jb3JlOjpmbXQ6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIHU2ND46OmZtdDo6aGMxNjI4MThkMDBhNjcxYzbpAx9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVy6gMwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg0Mzk5ZDg1MDFmMmQzZmIz6wM1c2VyZGVfd2FzbV9iaW5kZ2VuOjpPYmplY3RFeHQ6OnNldDo6aGNlYzAxYmQ0NTBhNmMwOGTsAypqc19zeXM6OkFycmF5Ojppc19hcnJheTo6aGNkZjIwMjAxZGJmNDcyYmTtAzJjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6d3JpdGVfZm10OjpoZDlkZDE0ZDZkYzgwMjkzOO4DOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aGZlYWZlNTU2YzE2OTE2MTnvAzo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6Omg5OTMwNTI4OTg1Zjc3MmYx8ANkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxtb25jaDo6UGFyc2VFcnJvckZhaWx1cmVFcnJvcj4+OjpoNThlMDNiNjYxYjA4Yjc4OPEDNXdhc21fYmluZGdlbjo6SnNWYWx1ZTo6aXNfZnVuY3Rpb246Omg1OTg2OTMxNjgwZjUxZTQ08gMqd2FzbV9iaW5kZ2VuOjp0aHJvd19zdHI6Omg5NDg4MDQyMDM2ZDM2Y2Qw8wMwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmZGZlNGFjMmY5ZGI4NGJh9AMyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDgzMmUxMTYzZDM4M2NiZDf1AzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGE4NGFjZDQwZTE4MmRjZGL2AwZtZW1zZXT3AwZtZW1jcHn4AwdtZW1tb3Zl+QMGbWVtY21w+gNBc3RkOjpwYW5pY2tpbmc6OnBhbmljX2NvdW50Ojppc196ZXJvX3Nsb3dfcGF0aDo6aDljMTM3MzM0ZTZiYmVmOWb7A01jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGVfd2FzbV9iaW5kZ2VuOjplcnJvcjo6RXJyb3I+OjpoZmUzN2UzYzI2M2Q1ZWYyNvwDSDxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoNmQ1MDM5ZTc5MTM4NjNkYv0DLGNvcmU6OmVycm9yOjpFcnJvcjo6Y2F1c2U6Omg2NGQwMzc1YWQ4YWQzYmRk/gNJPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxFPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNzIxYjNiN2YwNzM5MTEyM/8DUDxhbnlob3c6OndyYXBwZXI6Ok1lc3NhZ2VFcnJvcjxNPiBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhiZTExM2UwODk2MWRhMjkzgARJPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxFPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNmExOWIyYWZlNGJlZmVmYYEEJWpzX3N5czo6QXJyYXk6OmdldDo6aGMwZjgyNzczN2ZmYWJlM2KCBElzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg5OGFjNjFhNmFiYmZmN2U5gwQtYW55aG93OjplcnJvcjo6b2JqZWN0X2Ryb3A6Omg0NjBiZTQ5YTQzMzE1MDRjhAQzYW55aG93OjplcnJvcjo6b2JqZWN0X2Ryb3BfZnJvbnQ6OmgxYjlhYjFjMWUyYTM1N2Y1hQQtanNfc3lzOjpVaW50OEFycmF5OjpsZW5ndGg6Omg0NWFkZDcxZjdiY2U5ZmMzhgQKcnVzdF9wYW5pY4cEgwFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGU6OmRlOjppbXBsczo6PGltcGwgc2VyZGU6OmRlOjpEZXNlcmlhbGl6ZSBmb3IgdTE2Pjo6ZGVzZXJpYWxpemU6OlByaW1pdGl2ZVZpc2l0b3I+OjpoNDRhODRhODliNjA0ZDhkNIgEMmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmYm9vbD46Omg5ZGNjMjM4YmIwNzczMmFiiQQuY29yZTo6ZXJyb3I6OkVycm9yOjpwcm92aWRlOjpoNTJiOGViZGYwODNiODFhN4oEUGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhcnJheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPHU4Pj46Omg5ZDgwOGM5Mzc3NTE0ZjAyiwQvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCgpPjo6aDhiMjEwZjViNjljMzM4MjiMBGljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm11dCBzdGQ6OmlvOjpXcml0ZTo6d3JpdGVfZm10OjpBZGFwdGVyPGFsbG9jOjp2ZWM6OlZlYzx1OD4+Pjo6aGU3MDZhMTE5NjAwZDVjYTgAbwlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNzMuMCAoY2M2NmFkNDY4IDIwMjMtMTAtMDMpBndhbHJ1cwYwLjIwLjMMd2FzbS1iaW5kZ2VuBjAuMi45MAAsD3RhcmdldF9mZWF0dXJlcwIrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQ=    "
  );
  const wasmModule = new WebAssembly.Module(wasmBytes);
  return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
var wasmInstance = instantiate();
var refreshItems = {
  [
    0
    /* ProgressBars */
  ]: void 0,
  [
    1
    /* Selection */
  ]: void 0
};
function setItems(kind, items, size) {
  refreshItems[kind] = items;
  refresh(size);
}
function refresh(size) {
  if (!isOutputTty) {
    return;
  }
  const items = Object.values(refreshItems).flatMap((items2) => items2 ?? []);
  staticText.set(items, size);
}
function logAboveStaticText(inner, providedSize) {
  if (!isOutputTty) {
    inner();
    return;
  }
  const size = providedSize ?? safeConsoleSize();
  if (size != null) {
    staticText.clear(size);
  }
  inner();
  refresh(size);
}
function logOnce(items, size) {
  logAboveStaticText(() => {
    staticText.outputItems(items, size);
  }, size);
}
var logger = {
  setItems,
  logOnce,
  logAboveStaticText
};
var encoder2 = new TextEncoder();
var decoder = new TextDecoder();
async function* readKeys() {
  const { strip_ansi_codes: strip_ansi_codes3 } = wasmInstance;
  while (true) {
    const buf = new Uint8Array(8);
    const byteCount = await Deno.stdin.read(buf);
    if (byteCount == null) {
      break;
    }
    if (byteCount === 3) {
      if (buf[0] === 27 && buf[1] === 91) {
        if (buf[2] === 65) {
          yield 0;
          continue;
        } else if (buf[2] === 66) {
          yield 1;
          continue;
        } else if (buf[2] === 67) {
          yield 3;
          continue;
        } else if (buf[2] === 68) {
          yield 2;
          continue;
        }
      }
    } else if (byteCount === 1) {
      if (buf[0] === 3) {
        break;
      } else if (buf[0] === 13) {
        yield 4;
        continue;
      } else if (buf[0] === 32) {
        yield 5;
        continue;
      } else if (buf[0] === 127) {
        yield 6;
        continue;
      }
    }
    const text = strip_ansi_codes3(decoder.decode(buf.slice(0, byteCount ?? 0)));
    if (text.length > 0) {
      yield text;
    }
  }
}
function hideCursor() {
  Deno.stderr.writeSync(encoder2.encode("\x1B[?25l"));
}
function showCursor() {
  Deno.stderr.writeSync(encoder2.encode("\x1B[?25h"));
}
var isOutputTty = safeConsoleSize() != null && isTerminal(Deno.stderr);
function isTerminal(pipe) {
  if (typeof pipe.isTerminal === "function") {
    return pipe.isTerminal();
  } else if (pipe.rid != null && typeof Deno.isatty === "function") {
    return Deno.isatty(pipe.rid);
  } else {
    throw new Error("Unsupported pipe.");
  }
}
function resultOrExit(result) {
  if (result == null) {
    Deno.exit(130);
  } else {
    return result;
  }
}
function createSelection(options) {
  if (!isOutputTty || !isTerminal(Deno.stdin)) {
    throw new Error(`Cannot prompt when not a tty. (Prompt: '${options.message}')`);
  }
  if (safeConsoleSize() == null) {
    throw new Error(`Cannot prompt when can't get console size. (Prompt: '${options.message}')`);
  }
  return ensureSingleSelection(async () => {
    logger.setItems(1, options.render());
    for await (const key of readKeys()) {
      const keyResult = options.onKey(key);
      if (keyResult != null) {
        const size = Deno.consoleSize();
        logger.setItems(1, [], size);
        if (options.noClear) {
          logger.logOnce(options.render(), size);
        }
        return keyResult;
      }
      logger.setItems(1, options.render());
    }
    logger.setItems(1, []);
    return void 0;
  });
}
var lastPromise = Promise.resolve();
function ensureSingleSelection(action) {
  const currentLastPromise = lastPromise;
  const currentPromise = (async () => {
    try {
      await currentLastPromise;
    } catch {
    }
    hideCursor();
    try {
      Deno.stdin.setRaw(true);
      try {
        return await action();
      } finally {
        Deno.stdin.setRaw(false);
      }
    } finally {
      showCursor();
    }
  })();
  lastPromise = currentPromise;
  return currentPromise;
}
function safeConsoleSize() {
  try {
    return Deno.consoleSize();
  } catch {
    return void 0;
  }
}
var staticText = {
  set(items, size) {
    if (items.length === 0) {
      return this.clear(size);
    }
    const { columns, rows } = size ?? Deno.consoleSize();
    const newText = wasmInstance.static_text_render_text(items, columns, rows);
    if (newText != null) {
      Deno.stderr.writeSync(encoder2.encode(newText));
    }
  },
  outputItems(items, size) {
    const { columns, rows } = size ?? Deno.consoleSize();
    const newText = wasmInstance.static_text_render_once(items, columns, rows);
    if (newText != null) {
      Deno.stderr.writeSync(encoder2.encode(newText + "\n"));
    }
  },
  clear(size) {
    const { columns, rows } = size ?? Deno.consoleSize();
    const newText = wasmInstance.static_text_clear_text(columns, rows);
    if (newText != null) {
      Deno.stderr.writeSync(encoder2.encode(newText));
    }
  }
};
function confirm(optsOrMessage, options) {
  return maybeConfirm(optsOrMessage, options).then(resultOrExit);
}
function maybeConfirm(optsOrMessage, options) {
  const opts = typeof optsOrMessage === "string" ? { message: optsOrMessage, ...options } : optsOrMessage;
  return createSelection({
    message: opts.message,
    noClear: opts.noClear,
    ...innerConfirm(opts)
  });
}
function innerConfirm(opts) {
  const drawState = {
    title: opts.message,
    default: opts.default,
    inputText: "",
    hasCompleted: false
  };
  return {
    render: () => render(drawState),
    onKey: (key) => {
      switch (key) {
        case "Y":
        case "y":
          drawState.inputText = "Y";
          break;
        case "N":
        case "n":
          drawState.inputText = "N";
          break;
        case 6:
          drawState.inputText = "";
          break;
        case 4:
          if (drawState.inputText.length === 0) {
            if (drawState.default == null) {
              return void 0;
            }
            drawState.inputText = drawState.default ? "Y" : "N";
          }
          drawState.hasCompleted = true;
          return drawState.inputText === "Y" ? true : drawState.inputText === "N" ? false : drawState.default;
      }
    }
  };
}
function render(state) {
  return [
    bold3(blue(state.title)) + " " + (state.hasCompleted ? "" : state.default == null ? "(Y/N) " : state.default ? "(Y/n) " : "(y/N) ") + state.inputText + (state.hasCompleted ? "" : "\u2588")
    // (block character)
  ];
}
function multiSelect(opts) {
  return maybeMultiSelect(opts).then(resultOrExit);
}
function maybeMultiSelect(opts) {
  if (opts.options.length === 0) {
    throw new Error(`You must provide at least one option. (Prompt: '${opts.message}')`);
  }
  return createSelection({
    message: opts.message,
    noClear: opts.noClear,
    ...innerMultiSelect(opts)
  });
}
function innerMultiSelect(opts) {
  const drawState = {
    title: opts.message,
    activeIndex: 0,
    items: opts.options.map((option) => {
      if (typeof option === "string") {
        option = {
          text: option
        };
      }
      return {
        selected: option.selected ?? false,
        text: option.text
      };
    }),
    hasCompleted: false
  };
  return {
    render: () => render2(drawState),
    onKey: (key) => {
      switch (key) {
        case 0:
          if (drawState.activeIndex === 0) {
            drawState.activeIndex = drawState.items.length - 1;
          } else {
            drawState.activeIndex--;
          }
          break;
        case 1:
          drawState.activeIndex = (drawState.activeIndex + 1) % drawState.items.length;
          break;
        case 5: {
          const item = drawState.items[drawState.activeIndex];
          item.selected = !item.selected;
          break;
        }
        case 4:
          drawState.hasCompleted = true;
          return drawState.items.map((value, index) => [value, index]).filter(([value]) => value.selected).map(([, index]) => index);
      }
      return void 0;
    }
  };
}
function render2(state) {
  const items = [];
  items.push(bold3(blue(state.title)));
  if (state.hasCompleted) {
    if (state.items.some((i) => i.selected)) {
      for (const item of state.items) {
        if (item.selected) {
          items.push({
            text: ` - ${item.text}`,
            indent: 3
          });
        }
      }
    } else {
      items.push(italic(" <None>"));
    }
  } else {
    for (const [i, item] of state.items.entries()) {
      const prefix = i === state.activeIndex ? "> " : "  ";
      items.push({
        text: `${prefix}[${item.selected ? "x" : " "}] ${item.text}`,
        indent: 6
      });
    }
  }
  return items;
}
var units = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
function humanDownloadSize(byteCount, totalBytes) {
  const exponent = Math.min(units.length - 1, Math.floor(Math.log(totalBytes) / Math.log(1024)));
  const unit = units[exponent];
  const prettyBytes = (Math.floor(byteCount / Math.pow(1024, exponent) * 100) / 100).toFixed(exponent === 0 ? 0 : 2);
  return `${prettyBytes} ${unit}`;
}
var intervalMs = 60;
var progressBars = [];
var renderIntervalId;
function addProgressBar(render9) {
  const pb = {
    render: render9
  };
  progressBars.push(pb);
  if (renderIntervalId == null && isOutputTty) {
    renderIntervalId = setInterval(forceRender, intervalMs);
  }
  return pb;
}
function removeProgressBar(pb) {
  const index = progressBars.indexOf(pb);
  if (index === -1) {
    return false;
  }
  progressBars.splice(index, 1);
  if (progressBars.length === 0) {
    clearInterval(renderIntervalId);
    logger.setItems(0, []);
    renderIntervalId = void 0;
  }
  return true;
}
function forceRender() {
  if (!isShowingProgressBars()) {
    return;
  }
  const size = Deno.consoleSize();
  const items = progressBars.map((p) => p.render(size)).flat();
  logger.setItems(0, items, size);
}
function isShowingProgressBars() {
  return isOutputTty && progressBars.length > 0;
}
var ProgressBar = class {
  #state;
  #pb;
  #withCount = 0;
  #onLog;
  #noClear;
  /** @internal */
  constructor(onLog, opts) {
    if (arguments.length !== 2) {
      throw new Error("Invalid usage. Create the progress bar via `$.progress`.");
    }
    this.#onLog = onLog;
    this.#state = {
      message: opts.message,
      prefix: opts.prefix,
      length: opts.length,
      currentPos: 0,
      tickCount: 0,
      hasCompleted: false,
      kind: "raw"
    };
    this.#pb = addProgressBar((size) => {
      this.#state.tickCount++;
      return renderProgressBar(this.#state, size);
    });
    this.#noClear = opts.noClear ?? false;
    this.#logIfNonInteractive();
  }
  /** Sets the prefix message/word, which will be displayed in green. */
  prefix(prefix) {
    this.#state.prefix = prefix;
    if (prefix != null && prefix.length > 0) {
      this.#logIfNonInteractive();
    }
    return this;
  }
  /** Sets the message the progress bar will display after the prefix in white. */
  message(message) {
    this.#state.message = message;
    if (message != null && message.length > 0) {
      this.#logIfNonInteractive();
    }
    return this;
  }
  /** Sets how to format the length values. */
  kind(kind) {
    this.#state.kind = kind;
    return this;
  }
  #logIfNonInteractive() {
    if (isOutputTty) {
      return;
    }
    let text = this.#state.prefix ?? "";
    if (text.length > 0) {
      text += " ";
    }
    text += this.#state.message ?? "";
    if (text.length > 0) {
      this.#onLog(text);
    }
  }
  /** Sets the current position of the progress bar. */
  position(position) {
    this.#state.currentPos = position;
    return this;
  }
  /** Increments the position of the progress bar. */
  increment(inc = 1) {
    this.#state.currentPos += inc;
    return this;
  }
  /** Sets the total length of the progress bar. */
  length(size) {
    this.#state.length = size;
    return this;
  }
  /** Whether the progress bar should output a summary when finished. */
  noClear(value = true) {
    this.#noClear = value;
    return this;
  }
  /** Forces a render to the console. */
  forceRender() {
    return forceRender();
  }
  /** Finish showing the progress bar. */
  finish() {
    if (removeProgressBar(this.#pb)) {
      this.#state.hasCompleted = true;
      if (this.#noClear) {
        const text = renderProgressBar(this.#state, safeConsoleSize()).map((item) => typeof item === "string" ? item : item.text).join("\n");
        this.#onLog(text);
      }
    }
  }
  with(action) {
    this.#withCount++;
    let wasAsync = false;
    try {
      const result = action();
      if (result instanceof Promise) {
        wasAsync = true;
        return result.finally(() => {
          this.#decrementWith();
        });
      } else {
        return result;
      }
    } finally {
      if (!wasAsync) {
        this.#decrementWith();
      }
    }
  }
  #decrementWith() {
    this.#withCount--;
    if (this.#withCount === 0) {
      this.finish();
    }
  }
};
var tickStrings = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
function renderProgressBar(state, size) {
  if (state.hasCompleted) {
    let text = "";
    if (state.prefix != null) {
      text += green2(state.prefix);
    }
    if (state.message != null) {
      if (text.length > 0) {
        text += " ";
      }
      text += state.message;
    }
    return text.length > 0 ? [text] : [];
  } else if (state.length == null || state.length === 0) {
    let text = green2(tickStrings[Math.abs(state.tickCount) % tickStrings.length]);
    if (state.prefix != null) {
      text += ` ${green2(state.prefix)}`;
    }
    if (state.message != null) {
      text += ` ${state.message}`;
    }
    return [text];
  } else {
    let firstLine = "";
    if (state.prefix != null) {
      firstLine += green2(state.prefix);
    }
    if (state.message != null) {
      if (firstLine.length > 0) {
        firstLine += " ";
      }
      firstLine += state.message;
    }
    const percent = Math.min(state.currentPos / state.length, 1);
    const currentPosText = state.kind === "bytes" ? humanDownloadSize(state.currentPos, state.length) : state.currentPos.toString();
    const lengthText = state.kind === "bytes" ? humanDownloadSize(state.length, state.length) : state.length.toString();
    const maxWidth = size == null ? 75 : Math.max(10, Math.min(75, size.columns - 5));
    const sameLineTextWidth = 6 + lengthText.length * 2 + state.length.toString().length * 2;
    const totalBars = Math.max(1, maxWidth - sameLineTextWidth);
    const completedBars = Math.floor(totalBars * percent);
    let secondLine = "";
    secondLine += "[";
    if (completedBars != totalBars) {
      if (completedBars > 0) {
        secondLine += cyan("#".repeat(completedBars - 1) + ">");
      }
      secondLine += blue("-".repeat(totalBars - completedBars));
    } else {
      secondLine += cyan("#".repeat(completedBars));
    }
    secondLine += `] (${currentPosText}/${lengthText})`;
    const result = [];
    if (firstLine.length > 0) {
      result.push(firstLine);
    }
    result.push(secondLine);
    return result;
  }
}
var defaultMask = { char: "*", lastVisible: false };
function prompt(optsOrMessage, options) {
  return maybePrompt(optsOrMessage, options).then(resultOrExit);
}
function maybePrompt(optsOrMessage, options) {
  const opts = typeof optsOrMessage === "string" ? {
    message: optsOrMessage,
    ...options
  } : optsOrMessage;
  return createSelection({
    message: opts.message,
    noClear: opts.noClear,
    ...innerPrompt(opts)
  });
}
function innerPrompt(opts) {
  let mask = opts.mask ?? false;
  if (mask && typeof mask === "boolean") {
    mask = defaultMask;
  }
  const drawState = {
    title: opts.message,
    inputText: opts.default ?? "",
    mask,
    hasCompleted: false
  };
  return {
    render: () => render3(drawState),
    onKey: (key) => {
      if (typeof key === "string") {
        drawState.inputText += key;
      } else {
        switch (key) {
          case 5:
            drawState.inputText += " ";
            break;
          case 6:
            drawState.inputText = drawState.inputText.slice(0, -1);
            break;
          case 4:
            drawState.hasCompleted = true;
            return drawState.inputText;
        }
      }
      return void 0;
    }
  };
}
function render3(state) {
  let { inputText } = state;
  if (state.mask) {
    const char = state.mask.char ?? defaultMask.char;
    const lastVisible = state.mask.lastVisible ?? defaultMask.lastVisible;
    const shouldShowLast = lastVisible && !state.hasCompleted;
    const safeLengthMinusOne = Math.max(0, inputText.length - 1);
    const masked = char.repeat(shouldShowLast ? safeLengthMinusOne : inputText.length);
    const unmasked = shouldShowLast ? inputText.slice(safeLengthMinusOne) : "";
    inputText = `${masked}${unmasked}`;
  }
  return [
    bold3(blue(state.title)) + " " + inputText + (state.hasCompleted ? "" : "\u2588")
    // (block character)
  ];
}
function select(opts) {
  return maybeSelect(opts).then(resultOrExit);
}
function maybeSelect(opts) {
  if (opts.options.length <= 1) {
    throw new Error(`You must provide at least two options. (Prompt: '${opts.message}')`);
  }
  return createSelection({
    message: opts.message,
    noClear: opts.noClear,
    ...innerSelect(opts)
  });
}
function innerSelect(opts) {
  const drawState = {
    title: opts.message,
    activeIndex: (opts.initialIndex ?? 0) % opts.options.length,
    items: opts.options,
    hasCompleted: false
  };
  return {
    render: () => render4(drawState),
    onKey: (key) => {
      switch (key) {
        case 0:
          if (drawState.activeIndex === 0) {
            drawState.activeIndex = drawState.items.length - 1;
          } else {
            drawState.activeIndex--;
          }
          break;
        case 1:
          drawState.activeIndex = (drawState.activeIndex + 1) % drawState.items.length;
          break;
        case 4:
          drawState.hasCompleted = true;
          return drawState.activeIndex;
      }
    }
  };
}
function render4(state) {
  const items = [];
  items.push(bold3(blue(state.title)));
  if (state.hasCompleted) {
    items.push({
      text: ` - ${state.items[state.activeIndex]}`,
      indent: 3
    });
  } else {
    for (const [i, text] of state.items.entries()) {
      const prefix = i === state.activeIndex ? "> " : "  ";
      items.push({
        text: `${prefix}${text}`,
        indent: 4
      });
    }
  }
  return items;
}
var symbols = {
  writable: Symbol.for("dax.writableStream"),
  readable: Symbol.for("dax.readableStream")
};
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
  }
  get name() {
    return "TimeoutError";
  }
};
function formatMillis(ms) {
  if (ms < 1e3) {
    return `${formatValue(ms)} millisecond${ms === 1 ? "" : "s"}`;
  } else if (ms < 60 * 1e3) {
    const s = ms / 1e3;
    return `${formatValue(s)} ${pluralize("second", s)}`;
  } else {
    const mins = ms / 60 / 1e3;
    return `${formatValue(mins)} ${pluralize("minute", mins)}`;
  }
  function formatValue(value) {
    const text = value.toFixed(2);
    if (text.endsWith(".00")) {
      return value.toFixed(0);
    } else if (text.endsWith("0")) {
      return value.toFixed(1);
    } else {
      return text;
    }
  }
  function pluralize(text, value) {
    const suffix = value === 1 ? "" : "s";
    return text + suffix;
  }
}
function delayToIterator(delay) {
  if (typeof delay !== "number" && typeof delay !== "string") {
    return delay;
  }
  const ms = delayToMs(delay);
  return {
    next() {
      return ms;
    }
  };
}
function delayToMs(delay) {
  if (typeof delay === "number") {
    return delay;
  } else if (typeof delay === "string") {
    const msMatch = delay.match(/^([0-9]+)ms$/);
    if (msMatch != null) {
      return parseInt(msMatch[1], 10);
    }
    const secondsMatch = delay.match(/^([0-9]+\.?[0-9]*)s$/);
    if (secondsMatch != null) {
      return Math.round(parseFloat(secondsMatch[1]) * 1e3);
    }
    const minutesMatch = delay.match(/^([0-9]+\.?[0-9]*)m$/);
    if (minutesMatch != null) {
      return Math.round(parseFloat(minutesMatch[1]) * 1e3 * 60);
    }
    const minutesSecondsMatch = delay.match(/^([0-9]+\.?[0-9]*)m([0-9]+\.?[0-9]*)s$/);
    if (minutesSecondsMatch != null) {
      return Math.round(
        parseFloat(minutesSecondsMatch[1]) * 1e3 * 60 + parseFloat(minutesSecondsMatch[2]) * 1e3
      );
    }
    const hoursMatch = delay.match(/^([0-9]+\.?[0-9]*)h$/);
    if (hoursMatch != null) {
      return Math.round(parseFloat(hoursMatch[1]) * 1e3 * 60 * 60);
    }
    const hoursMinutesMatch = delay.match(/^([0-9]+\.?[0-9]*)h([0-9]+\.?[0-9]*)m$/);
    if (hoursMinutesMatch != null) {
      return Math.round(
        parseFloat(hoursMinutesMatch[1]) * 1e3 * 60 * 60 + parseFloat(hoursMinutesMatch[2]) * 1e3 * 60
      );
    }
    const hoursMinutesSecondsMatch = delay.match(/^([0-9]+\.?[0-9]*)h([0-9]+\.?[0-9]*)m([0-9]+\.?[0-9]*)s$/);
    if (hoursMinutesSecondsMatch != null) {
      return Math.round(
        parseFloat(hoursMinutesSecondsMatch[1]) * 1e3 * 60 * 60 + parseFloat(hoursMinutesSecondsMatch[2]) * 1e3 * 60 + parseFloat(hoursMinutesSecondsMatch[3]) * 1e3
      );
    }
  }
  throw new Error(`Unknown delay value: ${delay}`);
}
function filterEmptyRecordValues(record) {
  const result = {};
  for (const [key, value] of Object.entries(record)) {
    if (value != null) {
      result[key] = value;
    }
  }
  return result;
}
function resolvePath(cwd, arg) {
  return resolve3(isAbsolute3(arg) ? arg : join3(cwd, arg));
}
var Box = class {
  constructor(value) {
    this.value = value;
  }
};
var TreeBox = class _TreeBox {
  #value;
  constructor(value) {
    this.#value = value;
  }
  getValue() {
    let tree = this;
    while (tree.#value instanceof _TreeBox) {
      tree = tree.#value;
    }
    return tree.#value;
  }
  setValue(value) {
    this.#value = value;
  }
  createChild() {
    return new _TreeBox(this);
  }
};
var LoggerTreeBox = class extends TreeBox {
  getValue() {
    const innerValue = super.getValue();
    return (...args) => {
      return logger.logAboveStaticText(() => {
        innerValue(...args);
      });
    };
  }
};
async function safeLstat(path) {
  try {
    return await Deno.lstat(path);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return void 0;
    } else {
      throw err;
    }
  }
}
function getFileNameFromUrl(url) {
  const parsedUrl = url instanceof URL ? url : new URL(url);
  const fileName = parsedUrl.pathname.split("/").at(-1);
  return fileName?.length === 0 ? void 0 : fileName;
}
async function getExecutableShebangFromPath(path) {
  try {
    const file = await Deno.open(path, { read: true });
    try {
      return await getExecutableShebang(file);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}
var decoder2 = new TextDecoder();
async function getExecutableShebang(reader) {
  const text = "#!/usr/bin/env ";
  const buffer = new Uint8Array(text.length);
  const bytesReadCount = await reader.read(buffer);
  if (bytesReadCount !== text.length || decoder2.decode(buffer) !== text) {
    return void 0;
  }
  const bufReader = new BufReader(reader);
  const line = await bufReader.readLine();
  if (line == null) {
    return void 0;
  }
  const result = decoder2.decode(line.line).trim();
  const dashS = "-S ";
  if (result.startsWith(dashS)) {
    return {
      stringSplit: true,
      command: result.slice(dashS.length)
    };
  } else {
    return {
      stringSplit: false,
      command: result
    };
  }
}
var nodeENotEmpty = "ENOTEMPTY: ";
var nodeENOENT = "ENOENT: ";
function errorToString(err) {
  let message;
  if (err instanceof Error) {
    message = err.message;
  } else {
    message = String(err);
  }
  if (message.startsWith(nodeENotEmpty)) {
    return message.slice(nodeENotEmpty.length);
  } else if (message.startsWith(nodeENOENT)) {
    return message.slice(nodeENOENT.length);
  } else {
    return message;
  }
}
function parseArgKinds(flags) {
  const result = [];
  let had_dash_dash = false;
  for (const arg of flags) {
    if (had_dash_dash) {
      result.push({ arg, kind: "Arg" });
    } else if (arg == "-") {
      result.push({ arg: "-", kind: "Arg" });
    } else if (arg == "--") {
      had_dash_dash = true;
    } else if (arg.startsWith("--")) {
      result.push({ arg: arg.replace(/^--/, ""), kind: "LongFlag" });
    } else if (arg.startsWith("-")) {
      const flags2 = arg.replace(/^-/, "");
      if (!isNaN(parseFloat(flags2))) {
        result.push({ arg, kind: "Arg" });
      } else {
        for (const c of flags2) {
          result.push({ arg: c, kind: "ShortFlag" });
        }
      }
    } else {
      result.push({ arg, kind: "Arg" });
    }
  }
  return result;
}
function bailUnsupported(arg) {
  switch (arg.kind) {
    case "Arg":
      throw Error(`unsupported argument: ${arg.arg}`);
    case "ShortFlag":
      throw Error(`unsupported flag: -${arg.arg}`);
    case "LongFlag":
      throw Error(`unsupported flag: --${arg.arg}`);
  }
}
async function catCommand(context) {
  try {
    const code4 = await executeCat(context);
    return { code: code4 };
  } catch (err) {
    return context.error(`cat: ${errorToString(err)}`);
  }
}
async function executeCat(context) {
  const flags = parseCatArgs(context.args);
  let exitCode = 0;
  const buf = new Uint8Array(1024);
  for (const path of flags.paths) {
    if (path === "-") {
      if (typeof context.stdin === "object") {
        while (!context.signal.aborted) {
          const size = await context.stdin.read(buf);
          if (!size || size === 0) {
            break;
          } else {
            const maybePromise = context.stdout.write(buf.slice(0, size));
            if (maybePromise instanceof Promise) {
              await maybePromise;
            }
          }
        }
        exitCode = context.signal.abortedExitCode ?? 0;
      } else {
        const _assertValue = context.stdin;
        throw new Error(`not supported. stdin was '${context.stdin}'`);
      }
    } else {
      let file;
      try {
        file = await Deno.open(resolvePath(context.cwd, path), { read: true });
        while (!context.signal.aborted) {
          const size = file.readSync(buf);
          if (!size || size === 0) {
            break;
          } else {
            const maybePromise = context.stdout.write(buf.slice(0, size));
            if (maybePromise instanceof Promise) {
              await maybePromise;
            }
          }
        }
        exitCode = context.signal.abortedExitCode ?? 0;
      } catch (err) {
        const maybePromise = context.stderr.writeLine(`cat ${path}: ${errorToString(err)}`);
        if (maybePromise instanceof Promise) {
          await maybePromise;
        }
        exitCode = 1;
      } finally {
        file?.close();
      }
    }
  }
  return exitCode;
}
function parseCatArgs(args) {
  const paths = [];
  for (const arg of parseArgKinds(args)) {
    if (arg.kind === "Arg") {
      paths.push(arg.arg);
    } else {
      bailUnsupported(arg);
    }
  }
  if (paths.length === 0) {
    paths.push("-");
  }
  return { paths };
}
async function cdCommand(context) {
  try {
    const dir = await executeCd(context.cwd, context.args);
    return {
      code: 0,
      changes: [{
        kind: "cd",
        dir
      }]
    };
  } catch (err) {
    return context.error(`cd: ${errorToString(err)}`);
  }
}
async function executeCd(cwd, args) {
  const arg = parseArgs3(args);
  const result = resolvePath(cwd, arg);
  if (!await isDirectory(result)) {
    throw new Error(`${result}: Not a directory`);
  }
  return result;
}
async function isDirectory(path) {
  try {
    const info = await Deno.stat(path);
    return info.isDirectory;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    } else {
      throw err;
    }
  }
}
function parseArgs3(args) {
  if (args.length === 0) {
    throw new Error("expected at least 1 argument");
  } else if (args.length > 1) {
    throw new Error("too many arguments");
  } else {
    return args[0];
  }
}
async function cpCommand(context) {
  try {
    await executeCp(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`cp: ${errorToString(err)}`);
  }
}
async function executeCp(cwd, args) {
  const flags = await parseCpArgs(cwd, args);
  for (const { from, to } of flags.operations) {
    await doCopyOperation(flags, from, to);
  }
}
async function parseCpArgs(cwd, args) {
  const paths = [];
  let recursive = false;
  for (const arg of parseArgKinds(args)) {
    if (arg.kind === "Arg") paths.push(arg.arg);
    else if (arg.arg === "recursive" && arg.kind === "LongFlag" || arg.arg === "r" && arg.kind == "ShortFlag" || arg.arg === "R" && arg.kind === "ShortFlag") {
      recursive = true;
    } else bailUnsupported(arg);
  }
  if (paths.length === 0) throw Error("missing file operand");
  else if (paths.length === 1) throw Error(`missing destination file operand after '${paths[0]}'`);
  return { recursive, operations: await getCopyAndMoveOperations(cwd, paths) };
}
async function doCopyOperation(flags, from, to) {
  const fromInfo = await safeLstat(from.path);
  if (fromInfo?.isDirectory) {
    if (flags.recursive) {
      const toInfo = await safeLstat(to.path);
      if (toInfo?.isFile) {
        throw Error("destination was a file");
      } else if (toInfo?.isSymlink) {
        throw Error("no support for copying to symlinks");
      } else if (fromInfo.isSymlink) {
        throw Error("no support for copying from symlinks");
      } else {
        await copyDirRecursively(from.path, to.path);
      }
    } else {
      throw Error("source was a directory; maybe specify -r");
    }
  } else {
    await Deno.copyFile(from.path, to.path);
  }
}
async function copyDirRecursively(from, to) {
  await Deno.mkdir(to, { recursive: true });
  const readDir = Deno.readDir(from);
  for await (const entry of readDir) {
    const newFrom = join3(from, basename3(entry.name));
    const newTo = join3(to, basename3(entry.name));
    if (entry.isDirectory) {
      await copyDirRecursively(newFrom, newTo);
    } else if (entry.isFile) {
      await Deno.copyFile(newFrom, newTo);
    }
  }
}
async function mvCommand(context) {
  try {
    await executeMove(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`mv: ${errorToString(err)}`);
  }
}
async function executeMove(cwd, args) {
  const flags = await parseMvArgs(cwd, args);
  for (const { from, to } of flags.operations) {
    await Deno.rename(from.path, to.path);
  }
}
async function parseMvArgs(cwd, args) {
  const paths = [];
  for (const arg of parseArgKinds(args)) {
    if (arg.kind === "Arg") paths.push(arg.arg);
    else bailUnsupported(arg);
  }
  if (paths.length === 0) throw Error("missing operand");
  else if (paths.length === 1) throw Error(`missing destination file operand after '${paths[0]}'`);
  return { operations: await getCopyAndMoveOperations(cwd, paths) };
}
async function getCopyAndMoveOperations(cwd, paths) {
  const specified_destination = paths.splice(paths.length - 1, 1)[0];
  const destination = resolvePath(cwd, specified_destination);
  const fromArgs = paths;
  const operations = [];
  if (fromArgs.length > 1) {
    if (!await safeLstat(destination).then((p) => p?.isDirectory)) {
      throw Error(`target '${specified_destination}' is not a directory`);
    }
    for (const from of fromArgs) {
      const fromPath = resolvePath(cwd, from);
      const toPath = join3(destination, basename3(fromPath));
      operations.push(
        {
          from: {
            specified: from,
            path: fromPath
          },
          to: {
            specified: specified_destination,
            path: toPath
          }
        }
      );
    }
  } else {
    const fromPath = resolvePath(cwd, fromArgs[0]);
    const toPath = await safeLstat(destination).then((p) => p?.isDirectory) ? calculateDestinationPath(destination, fromPath) : destination;
    operations.push({
      from: {
        specified: fromArgs[0],
        path: fromPath
      },
      to: {
        specified: specified_destination,
        path: toPath
      }
    });
  }
  return operations;
}
function calculateDestinationPath(destination, from) {
  return join3(destination, basename3(from));
}
function echoCommand(context) {
  try {
    const maybePromise = context.stdout.writeLine(context.args.join(" "));
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => ({ code: 0 })).catch((err) => handleFailure(context, err));
    } else {
      return { code: 0 };
    }
  } catch (err) {
    return handleFailure(context, err);
  }
}
function handleFailure(context, err) {
  return context.error(`echo: ${errorToString(err)}`);
}
function exitCommand(context) {
  try {
    const code4 = parseArgs4(context.args);
    return {
      kind: "exit",
      code: code4
    };
  } catch (err) {
    return context.error(2, `exit: ${errorToString(err)}`);
  }
}
function parseArgs4(args) {
  if (args.length === 0) return 1;
  if (args.length > 1) throw new Error("too many arguments");
  const exitCode = parseInt(args[0], 10);
  if (isNaN(exitCode)) throw new Error("numeric argument required.");
  if (exitCode < 0) {
    const code4 = -exitCode % 256;
    return 256 - code4;
  }
  return exitCode % 256;
}
function exportCommand(context) {
  const changes = [];
  for (const arg of context.args) {
    const equalsIndex = arg.indexOf("=");
    if (equalsIndex >= 0) {
      changes.push({
        kind: "envvar",
        name: arg.substring(0, equalsIndex),
        value: arg.substring(equalsIndex + 1)
      });
    }
  }
  return {
    code: 0,
    changes
  };
}
async function mkdirCommand(context) {
  try {
    await executeMkdir(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`mkdir: ${errorToString(err)}`);
  }
}
async function executeMkdir(cwd, args) {
  const flags = parseArgs5(args);
  for (const specifiedPath of flags.paths) {
    const path = resolvePath(cwd, specifiedPath);
    const info = await safeLstat(path);
    if (info?.isFile || !flags.parents && info?.isDirectory) {
      throw Error(`cannot create directory '${specifiedPath}': File exists`);
    }
    if (flags.parents) {
      await Deno.mkdir(path, { recursive: true });
    } else {
      await Deno.mkdir(path);
    }
  }
}
function parseArgs5(args) {
  const result = {
    parents: false,
    paths: []
  };
  for (const arg of parseArgKinds(args)) {
    if (arg.arg === "parents" && arg.kind === "LongFlag" || arg.arg === "p" && arg.kind == "ShortFlag") {
      result.parents = true;
    } else {
      if (arg.kind !== "Arg") bailUnsupported(arg);
      result.paths.push(arg.arg.trim());
    }
  }
  if (result.paths.length === 0) {
    throw Error("missing operand");
  }
  return result;
}
function printEnvCommand(context) {
  let args;
  if (Deno.build.os === "windows") {
    args = context.args.map((arg) => arg.toUpperCase());
  } else {
    args = context.args;
  }
  try {
    const result = executePrintEnv(context.env, args);
    const code4 = args.some((arg) => context.env[arg] === void 0) ? 1 : 0;
    const maybePromise = context.stdout.writeLine(result);
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => ({ code: code4 })).catch((err) => handleError2(context, err));
    } else {
      return { code: code4 };
    }
  } catch (err) {
    return handleError2(context, err);
  }
}
function handleError2(context, err) {
  return context.error(`printenv: ${errorToString(err)}`);
}
function executePrintEnv(env, args) {
  const isWindows8 = Deno.build.os === "windows";
  if (args.length === 0) {
    return Object.entries(env).map(([key, val]) => `${isWindows8 ? key.toUpperCase() : key}=${val}`).join("\n");
  } else {
    if (isWindows8) {
      args = args.map((arg) => arg.toUpperCase());
    }
    return Object.entries(env).filter(([key]) => args.includes(key)).map(([_key, val]) => val).join("\n");
  }
}
function pwdCommand(context) {
  try {
    const output = executePwd(context.cwd, context.args);
    const maybePromise = context.stdout.writeLine(output);
    const result = { code: 0 };
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => result).catch((err) => handleError3(context, err));
    } else {
      return result;
    }
  } catch (err) {
    return handleError3(context, err);
  }
}
function handleError3(context, err) {
  return context.error(`pwd: ${errorToString(err)}`);
}
function executePwd(cwd, args) {
  const flags = parseArgs6(args);
  if (flags.logical) {
    return resolve3(cwd);
  } else {
    return cwd;
  }
}
function parseArgs6(args) {
  let logical = false;
  for (const arg of parseArgKinds(args)) {
    if (arg.arg === "L" && arg.kind === "ShortFlag") {
      logical = true;
    } else if (arg.arg === "P" && arg.kind == "ShortFlag") {
    } else if (arg.kind === "Arg") {
    } else {
      bailUnsupported(arg);
    }
  }
  return { logical };
}
async function rmCommand(context) {
  try {
    await executeRemove(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`rm: ${errorToString(err)}`);
  }
}
async function executeRemove(cwd, args) {
  const flags = parseArgs7(args);
  await Promise.all(flags.paths.map((specifiedPath) => {
    if (specifiedPath.length === 0) {
      throw new Error("Bug in dax. Specified path should have not been empty.");
    }
    const path = resolvePath(cwd, specifiedPath);
    if (path === "/") {
      throw new Error("Cannot delete root directory. Maybe bug in dax? Please report this.");
    }
    return Deno.remove(path, { recursive: flags.recursive }).catch((err) => {
      if (flags.force && err instanceof Deno.errors.NotFound) {
        return Promise.resolve();
      } else {
        return Promise.reject(err);
      }
    });
  }));
}
function parseArgs7(args) {
  const result = {
    recursive: false,
    force: false,
    dir: false,
    paths: []
  };
  for (const arg of parseArgKinds(args)) {
    if (arg.arg === "recursive" && arg.kind === "LongFlag" || arg.arg === "r" && arg.kind == "ShortFlag" || arg.arg === "R" && arg.kind === "ShortFlag") {
      result.recursive = true;
    } else if (arg.arg == "dir" && arg.kind === "LongFlag" || arg.arg == "d" && arg.kind === "ShortFlag") {
      result.dir = true;
    } else if (arg.arg == "force" && arg.kind === "LongFlag" || arg.arg == "f" && arg.kind === "ShortFlag") {
      result.force = true;
    } else {
      if (arg.kind !== "Arg") bailUnsupported2(arg);
      result.paths.push(arg.arg.trim());
    }
  }
  if (result.paths.length === 0) {
    throw Error("missing operand");
  }
  return result;
}
function bailUnsupported2(arg) {
  switch (arg.kind) {
    case "Arg":
      throw Error(`unsupported argument: ${arg.arg}`);
    case "ShortFlag":
      throw Error(`unsupported flag: -${arg.arg}`);
    case "LongFlag":
      throw Error(`unsupported flag: --${arg.arg}`);
  }
}
function getAbortedResult() {
  return {
    kind: "exit",
    code: 124
    // same as timeout command
  };
}
async function sleepCommand(context) {
  try {
    const ms = parseArgs8(context.args);
    await new Promise((resolve7) => {
      const timeoutId = setTimeout(finish, ms);
      context.signal.addListener(signalListener);
      function signalListener(_signal) {
        if (context.signal.aborted) {
          finish();
        }
      }
      function finish() {
        resolve7();
        clearInterval(timeoutId);
        context.signal.removeListener(signalListener);
      }
    });
    if (context.signal.aborted) {
      return getAbortedResult();
    }
    return { code: 0 };
  } catch (err) {
    return context.error(`sleep: ${errorToString(err)}`);
  }
}
function parseArgs8(args) {
  let totalTimeMs = 0;
  if (args.length === 0) {
    throw new Error("missing operand");
  }
  for (const arg of args) {
    if (arg.startsWith("-")) {
      throw new Error(`unsupported: ${arg}`);
    }
    const value = parseFloat(arg);
    if (isNaN(value)) {
      throw new Error(`error parsing argument '${arg}' to number.`);
    }
    totalTimeMs = value * 1e3;
  }
  return totalTimeMs;
}
async function testCommand(context) {
  try {
    const [testFlag, testPath] = parseArgs9(context.cwd, context.args);
    let result;
    switch (testFlag) {
      case "-f":
        result = (await safeLstat(testPath))?.isFile ?? false;
        break;
      case "-d":
        result = (await safeLstat(testPath))?.isDirectory ?? false;
        break;
      case "-e":
        result = await exists(testPath);
        break;
      case "-s":
        result = ((await safeLstat(testPath))?.size ?? 0) > 0;
        break;
      case "-L":
        result = (await safeLstat(testPath))?.isSymlink ?? false;
        break;
      default:
        throw new Error("unsupported test type");
    }
    return { code: result ? 0 : 1 };
  } catch (err) {
    return context.error(2, `test: ${errorToString(err)}`);
  }
}
function parseArgs9(cwd, args) {
  if (args.length !== 2) {
    throw new Error("expected 2 arguments");
  }
  if (args[0] == null || !args[0].startsWith("-")) {
    throw new Error("missing test type flag");
  }
  return [args[0], resolvePath(cwd, args[1])];
}
async function touchCommand(context) {
  try {
    await executetouch(context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`touch: ${errorToString(err)}`);
  }
}
async function executetouch(args) {
  const flags = parseArgs10(args);
  for (const path of flags.paths) {
    const f = await Deno.create(path);
    f.close();
  }
}
function parseArgs10(args) {
  const paths = [];
  for (const arg of parseArgKinds(args)) {
    if (arg.kind === "Arg") paths.push(arg.arg);
    else bailUnsupported(arg);
  }
  if (paths.length === 0) throw Error("missing file operand");
  return { paths };
}
function unsetCommand(context) {
  try {
    return {
      code: 0,
      changes: parseNames(context.args).map((name) => ({ kind: "unsetvar", name }))
    };
  } catch (err) {
    return context.error(`unset: ${errorToString(err)}`);
  }
}
function parseNames(args) {
  if (args[0] === "-f") {
    throw Error(`unsupported flag: -f`);
  } else if (args[0] === "-v") {
    return args.slice(1);
  } else {
    return args;
  }
}
var encoder3 = new TextEncoder();
var NullPipeReader = class {
  read(_p) {
    return Promise.resolve(null);
  }
};
var NullPipeWriter = class {
  writeSync(p) {
    return p.length;
  }
};
var ShellPipeWriter = class {
  #kind;
  #inner;
  constructor(kind, inner) {
    this.#kind = kind;
    this.#inner = inner;
  }
  get kind() {
    return this.#kind;
  }
  get inner() {
    return this.#inner;
  }
  write(p) {
    if ("write" in this.#inner) {
      return this.#inner.write(p);
    } else {
      return this.#inner.writeSync(p);
    }
  }
  writeAll(data) {
    if ("write" in this.#inner) {
      return writeAll2(this.#inner, data);
    } else {
      return writeAllSync2(this.#inner, data);
    }
  }
  writeText(text) {
    return this.writeAll(encoder3.encode(text));
  }
  writeLine(text) {
    return this.writeText(text + "\n");
  }
};
var CapturingBufferWriter = class {
  #buffer;
  #innerWriter;
  constructor(innerWriter, buffer) {
    this.#innerWriter = innerWriter;
    this.#buffer = buffer;
  }
  getBuffer() {
    return this.#buffer;
  }
  async write(p) {
    const nWritten = await this.#innerWriter.write(p);
    this.#buffer.writeSync(p.slice(0, nWritten));
    return nWritten;
  }
};
var CapturingBufferWriterSync = class {
  #buffer;
  #innerWriter;
  constructor(innerWriter, buffer) {
    this.#innerWriter = innerWriter;
    this.#buffer = buffer;
  }
  getBuffer() {
    return this.#buffer;
  }
  writeSync(p) {
    const nWritten = this.#innerWriter.writeSync(p);
    this.#buffer.writeSync(p.slice(0, nWritten));
    return nWritten;
  }
};
var lineFeedCharCode = "\n".charCodeAt(0);
var InheritStaticTextBypassWriter = class {
  #buffer;
  #innerWriter;
  constructor(innerWriter) {
    this.#innerWriter = innerWriter;
    this.#buffer = new Buffer();
  }
  writeSync(p) {
    const index = p.findLastIndex((v) => v === lineFeedCharCode);
    if (index === -1) {
      this.#buffer.writeSync(p);
    } else {
      this.#buffer.writeSync(p.slice(0, index + 1));
      this.flush();
      this.#buffer.writeSync(p.slice(index + 1));
    }
    return p.byteLength;
  }
  flush() {
    const bytes = this.#buffer.bytes({ copy: false });
    logger.logAboveStaticText(() => {
      writeAllSync2(this.#innerWriter, bytes);
    });
    this.#buffer.reset();
  }
};
var PipedBuffer = class {
  #inner;
  #hasSet = false;
  constructor() {
    this.#inner = new Buffer();
  }
  getBuffer() {
    if (this.#inner instanceof Buffer) {
      return this.#inner;
    } else {
      return void 0;
    }
  }
  setError(err) {
    if ("setError" in this.#inner) {
      this.#inner.setError(err);
    }
  }
  close() {
    if ("close" in this.#inner) {
      this.#inner.close();
    }
  }
  writeSync(p) {
    return this.#inner.writeSync(p);
  }
  setListener(listener) {
    if (this.#hasSet) {
      throw new Error("Piping to multiple outputs is currently not supported.");
    }
    if (this.#inner instanceof Buffer) {
      writeAllSync2(listener, this.#inner.bytes({ copy: false }));
    }
    this.#inner = listener;
    this.#hasSet = true;
  }
};
var PipeSequencePipe = class {
  #inner = new Buffer();
  #readListener;
  #closed = false;
  close() {
    this.#readListener?.();
    this.#closed = true;
  }
  writeSync(p) {
    const value = this.#inner.writeSync(p);
    if (this.#readListener !== void 0) {
      const listener = this.#readListener;
      this.#readListener = void 0;
      listener();
    }
    return value;
  }
  read(p) {
    if (this.#readListener !== void 0) {
      throw new Error("Misuse of PipeSequencePipe");
    }
    if (this.#inner.length === 0) {
      if (this.#closed) {
        return Promise.resolve(null);
      } else {
        return new Promise((resolve7) => {
          this.#readListener = () => {
            resolve7(this.#inner.readSync(p));
          };
        });
      }
    } else {
      return Promise.resolve(this.#inner.readSync(p));
    }
  }
};
async function pipeReadableToWriterSync(readable, writer, signal) {
  const reader = readable.getReader();
  while (!signal.aborted) {
    const result = await reader.read();
    if (result.done) {
      break;
    }
    const maybePromise = writer.writeAll(result.value);
    if (maybePromise) {
      await maybePromise;
    }
  }
}
var spawnCommand = (path, options) => {
  const child = new Deno.Command(path, options).spawn();
  child.status;
  return {
    stdin() {
      return child.stdin;
    },
    kill(signo) {
      child.kill(signo);
    },
    waitExitCode() {
      return child.status.then((status) => status.code);
    },
    stdout() {
      return child.stdout;
    },
    stderr() {
      return child.stderr;
    }
  };
};
var neverAbortedSignal = new AbortController().signal;
var RealEnv = class {
  setCwd(cwd) {
    Deno.chdir(cwd);
  }
  getCwd() {
    return Deno.cwd();
  }
  setEnvVar(key, value) {
    if (value == null) {
      Deno.env.delete(key);
    } else {
      Deno.env.set(key, value);
    }
  }
  getEnvVar(key) {
    return Deno.env.get(key);
  }
  getEnvVars() {
    return Deno.env.toObject();
  }
  clone() {
    return cloneEnv(this);
  }
};
var ShellEnv = class {
  #cwd;
  #envVars = {};
  setCwd(cwd) {
    this.#cwd = cwd;
  }
  getCwd() {
    if (this.#cwd == null) {
      throw new Error("The cwd must be initialized.");
    }
    return this.#cwd;
  }
  setEnvVar(key, value) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (value == null) {
      delete this.#envVars[key];
    } else {
      this.#envVars[key] = value;
    }
  }
  getEnvVar(key) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    return this.#envVars[key];
  }
  getEnvVars() {
    return { ...this.#envVars };
  }
  clone() {
    return cloneEnv(this);
  }
};
var RealEnvWriteOnly = class {
  real = new RealEnv();
  shell = new ShellEnv();
  setCwd(cwd) {
    this.real.setCwd(cwd);
    this.shell.setCwd(cwd);
  }
  getCwd() {
    return this.shell.getCwd();
  }
  setEnvVar(key, value) {
    this.real.setEnvVar(key, value);
    this.shell.setEnvVar(key, value);
  }
  getEnvVar(key) {
    return this.shell.getEnvVar(key);
  }
  getEnvVars() {
    return this.shell.getEnvVars();
  }
  clone() {
    return cloneEnv(this);
  }
};
function initializeEnv(env, opts) {
  env.setCwd(opts.cwd);
  for (const [key, value] of Object.entries(opts.env)) {
    env.setEnvVar(key, value);
  }
}
function cloneEnv(env) {
  const result = new ShellEnv();
  initializeEnv(result, {
    cwd: env.getCwd(),
    env: env.getEnvVars()
  });
  return result;
}
var StreamFds = class {
  #readers = /* @__PURE__ */ new Map();
  #writers = /* @__PURE__ */ new Map();
  insertReader(fd, stream) {
    this.#readers.set(fd, stream);
  }
  insertWriter(fd, stream) {
    this.#writers.set(fd, stream);
  }
  getReader(fd) {
    return this.#readers.get(fd)?.();
  }
  getWriter(fd) {
    return this.#writers.get(fd)?.();
  }
};
var Context = class _Context {
  stdin;
  stdout;
  stderr;
  #env;
  #shellVars;
  #static;
  constructor(opts) {
    this.stdin = opts.stdin;
    this.stdout = opts.stdout;
    this.stderr = opts.stderr;
    this.#env = opts.env;
    this.#shellVars = opts.shellVars;
    this.#static = opts.static;
  }
  get signal() {
    return this.#static.signal;
  }
  applyChanges(changes) {
    if (changes == null) {
      return;
    }
    for (const change of changes) {
      switch (change.kind) {
        case "cd":
          this.#env.setCwd(change.dir);
          break;
        case "envvar":
          this.setEnvVar(change.name, change.value);
          break;
        case "shellvar":
          this.setShellVar(change.name, change.value);
          break;
        case "unsetvar":
          this.setShellVar(change.name, void 0);
          this.setEnvVar(change.name, void 0);
          break;
        default: {
          const _assertNever = change;
          throw new Error(`Not implemented env change: ${change}`);
        }
      }
    }
  }
  setEnvVar(key, value) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (key === "PWD") {
      if (value != null && isAbsolute3(value)) {
        this.#env.setCwd(resolve3(value));
      }
    } else {
      delete this.#shellVars[key];
      this.#env.setEnvVar(key, value);
    }
  }
  setShellVar(key, value) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (this.#env.getEnvVar(key) != null || key === "PWD") {
      this.setEnvVar(key, value);
    } else if (value == null) {
      delete this.#shellVars[key];
    } else {
      this.#shellVars[key] = value;
    }
  }
  getEnvVars() {
    return this.#env.getEnvVars();
  }
  getCwd() {
    return this.#env.getCwd();
  }
  getVar(key) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (key === "PWD") {
      return this.#env.getCwd();
    }
    return this.#env.getEnvVar(key) ?? this.#shellVars[key];
  }
  getCommand(command) {
    return this.#static.commands[command] ?? null;
  }
  getFdReader(fd) {
    return this.#static.fds?.getReader(fd);
  }
  getFdWriter(fd) {
    return this.#static.fds?.getWriter(fd);
  }
  asCommandContext(args) {
    const context = this;
    return {
      get args() {
        return args;
      },
      get cwd() {
        return context.getCwd();
      },
      get env() {
        return context.getEnvVars();
      },
      get stdin() {
        return context.stdin;
      },
      get stdout() {
        return context.stdout;
      },
      get stderr() {
        return context.stderr;
      },
      get signal() {
        return context.signal;
      },
      error(codeOrText, maybeText) {
        return context.error(codeOrText, maybeText);
      }
    };
  }
  error(codeOrText, maybeText) {
    let code4;
    let text;
    if (typeof codeOrText === "number") {
      code4 = codeOrText;
      text = maybeText;
    } else {
      code4 = 1;
      text = codeOrText;
    }
    const maybePromise = this.stderr.writeLine(text);
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => ({ code: code4 }));
    } else {
      return { code: code4 };
    }
  }
  withInner(opts) {
    return new _Context({
      stdin: opts.stdin ?? this.stdin,
      stdout: opts.stdout ?? this.stdout,
      stderr: opts.stderr ?? this.stderr,
      env: this.#env.clone(),
      shellVars: { ...this.#shellVars },
      static: this.#static
    });
  }
  clone() {
    return new _Context({
      stdin: this.stdin,
      stdout: this.stdout,
      stderr: this.stderr,
      env: this.#env.clone(),
      shellVars: { ...this.#shellVars },
      static: this.#static
    });
  }
};
function parseCommand(command) {
  return wasmInstance.parse(command);
}
async function spawn(list, opts) {
  const env = opts.exportEnv ? opts.clearedEnv ? new RealEnvWriteOnly() : new RealEnv() : new ShellEnv();
  initializeEnv(env, opts);
  const context = new Context({
    env,
    stdin: opts.stdin,
    stdout: opts.stdout,
    stderr: opts.stderr,
    shellVars: {},
    static: {
      commands: opts.commands,
      fds: opts.fds,
      signal: opts.signal
    }
  });
  const result = await executeSequentialList(list, context);
  return result.code;
}
async function executeSequentialList(list, context) {
  let finalExitCode = 0;
  const finalChanges = [];
  for (const item of list.items) {
    if (item.isAsync) {
      throw new Error("Async commands are not supported. Run a command concurrently in the JS code instead.");
    }
    const result = await executeSequence(item.sequence, context);
    switch (result.kind) {
      case void 0:
        if (result.changes) {
          context.applyChanges(result.changes);
          finalChanges.push(...result.changes);
        }
        finalExitCode = result.code;
        break;
      case "exit":
        return result;
      default: {
        const _assertNever = result;
      }
    }
  }
  return {
    code: finalExitCode,
    changes: finalChanges
  };
}
function executeSequence(sequence, context) {
  if (context.signal.aborted) {
    return Promise.resolve(getAbortedResult());
  }
  switch (sequence.kind) {
    case "pipeline":
      return executePipeline(sequence, context);
    case "booleanList":
      return executeBooleanList(sequence, context);
    case "shellVar":
      return executeShellVar(sequence, context);
    default: {
      const _assertNever = sequence;
      throw new Error(`Not implemented: ${sequence}`);
    }
  }
}
function executePipeline(pipeline, context) {
  if (pipeline.negated) {
    throw new Error("Negated pipelines are not implemented.");
  }
  return executePipelineInner(pipeline.inner, context);
}
async function executeBooleanList(list, context) {
  const changes = [];
  const firstResult = await executeSequence(
    list.current,
    context.clone()
  );
  let exitCode = 0;
  switch (firstResult.kind) {
    case "exit":
      return firstResult;
    case void 0:
      if (firstResult.changes) {
        context.applyChanges(firstResult.changes);
        changes.push(...firstResult.changes);
      }
      exitCode = firstResult.code;
      break;
    default: {
      const _assertNever = firstResult;
      throw new Error("Not handled.");
    }
  }
  const next = findNextSequence(list, exitCode);
  if (next == null) {
    return {
      code: exitCode,
      changes
    };
  } else {
    const nextResult = await executeSequence(
      next,
      context.clone()
    );
    switch (nextResult.kind) {
      case "exit":
        return nextResult;
      case void 0:
        if (nextResult.changes) {
          changes.push(...nextResult.changes);
        }
        return {
          code: nextResult.code,
          changes
        };
      default: {
        const _assertNever = nextResult;
        throw new Error("Not Implemented");
      }
    }
  }
  function findNextSequence(current, exitCode2) {
    if (opMovesNextForExitCode(current.op, exitCode2)) {
      return current.next;
    } else {
      let next2 = current.next;
      while (next2.kind === "booleanList") {
        if (opMovesNextForExitCode(next2.op, exitCode2)) {
          return next2.next;
        } else {
          next2 = next2.next;
        }
      }
      return void 0;
    }
  }
  function opMovesNextForExitCode(op, exitCode2) {
    switch (op) {
      case "or":
        return exitCode2 !== 0;
      case "and":
        return exitCode2 === 0;
    }
  }
}
async function executeShellVar(sequence, context) {
  const value = await evaluateWord(sequence.value, context);
  return {
    code: 0,
    changes: [{
      kind: "shellvar",
      name: sequence.name,
      value
    }]
  };
}
function executePipelineInner(inner, context) {
  switch (inner.kind) {
    case "command":
      return executeCommand(inner, context);
    case "pipeSequence":
      return executePipeSequence(inner, context);
    default: {
      const _assertNever = inner;
      throw new Error(`Not implemented: ${inner.kind}`);
    }
  }
}
async function executeCommand(command, context) {
  if (command.redirect != null) {
    const redirectResult = await resolveRedirectPipe(command.redirect, context);
    let redirectPipe;
    if (redirectResult.kind === "input") {
      const { pipe } = redirectResult;
      context = context.withInner({
        stdin: pipe
      });
      redirectPipe = pipe;
    } else if (redirectResult.kind === "output") {
      const { pipe, toFd } = redirectResult;
      const writer = new ShellPipeWriter("piped", pipe);
      redirectPipe = pipe;
      if (toFd === 1) {
        context = context.withInner({
          stdout: writer
        });
      } else if (toFd === 2) {
        context = context.withInner({
          stderr: writer
        });
      } else {
        const _assertNever = toFd;
        throw new Error(`Not handled fd: ${toFd}`);
      }
    } else {
      return redirectResult;
    }
    const result = await executeCommandInner(command.inner, context);
    try {
      if (isAsyncDisposable(redirectPipe)) {
        await redirectPipe[Symbol.asyncDispose]();
      } else if (isDisposable(redirectPipe)) {
        redirectPipe[Symbol.dispose]();
      }
    } catch (err) {
      if (result.code === 0) {
        return context.error(`failed disposing redirected pipe. ${errorToString(err)}`);
      }
    }
    return result;
  } else {
    return executeCommandInner(command.inner, context);
  }
}
async function resolveRedirectPipe(redirect, context) {
  function handleFileOpenError(outputPath, err) {
    return context.error(`failed opening file for redirect (${outputPath}). ${errorToString(err)}`);
  }
  const toFd = resolveRedirectToFd(redirect, context);
  if (typeof toFd !== "number") {
    return toFd;
  }
  const { ioFile } = redirect;
  if (ioFile.kind === "fd") {
    switch (redirect.op.kind) {
      case "input": {
        if (ioFile.value === 0) {
          return {
            kind: "input",
            pipe: getStdinReader(context.stdin)
          };
        } else if (ioFile.value === 1 || ioFile.value === 2) {
          return context.error(`redirecting stdout or stderr to a command input is not supported`);
        } else {
          const pipe = context.getFdReader(ioFile.value);
          if (pipe == null) {
            return context.error(`could not find fd reader: ${ioFile.value}`);
          } else {
            return {
              kind: "input",
              pipe
            };
          }
        }
      }
      case "output": {
        if (ioFile.value === 0) {
          return context.error(`redirecting output to stdin is not supported`);
        } else if (ioFile.value === 1) {
          return {
            kind: "output",
            pipe: context.stdout.inner,
            toFd
          };
        } else if (ioFile.value === 2) {
          return {
            kind: "output",
            pipe: context.stderr.inner,
            toFd
          };
        } else {
          const pipe = context.getFdWriter(ioFile.value);
          if (pipe == null) {
            return context.error(`could not find fd: ${ioFile.value}`);
          } else {
            return {
              kind: "output",
              pipe,
              toFd
            };
          }
        }
      }
      default: {
        const _assertNever = redirect.op;
        throw new Error("not implemented redirect op.");
      }
    }
  } else if (ioFile.kind === "word") {
    const words = await evaluateWordParts(ioFile.value, context);
    if (words.length === 0) {
      return context.error("redirect path must be 1 argument, but found 0");
    } else if (words.length > 1) {
      return context.error(
        `redirect path must be 1 argument, but found ${words.length} (${words.join(" ")}). Did you mean to quote it (ex. "${words.join(" ")}")?`
      );
    }
    switch (redirect.op.kind) {
      case "input": {
        const outputPath = isAbsolute3(words[0]) ? words[0] : join3(context.getCwd(), words[0]);
        try {
          const file = await Deno.open(outputPath, {
            read: true
          });
          return {
            kind: "input",
            pipe: file
          };
        } catch (err) {
          return handleFileOpenError(outputPath, err);
        }
      }
      case "output": {
        if (words[0] === "/dev/null") {
          return {
            kind: "output",
            pipe: new NullPipeWriter(),
            toFd
          };
        }
        const outputPath = isAbsolute3(words[0]) ? words[0] : join3(context.getCwd(), words[0]);
        try {
          const file = await Deno.open(outputPath, {
            write: true,
            create: true,
            append: redirect.op.value === "append",
            truncate: redirect.op.value !== "append"
          });
          return {
            kind: "output",
            pipe: file,
            toFd
          };
        } catch (err) {
          return handleFileOpenError(outputPath, err);
        }
      }
      default: {
        const _assertNever = redirect.op;
        throw new Error("not implemented redirect op.");
      }
    }
  } else {
    const _assertNever = ioFile;
    throw new Error("not implemented redirect io file.");
  }
}
function getStdinReader(stdin) {
  if (stdin === "inherit") {
    return Deno.stdin;
  } else if (stdin === "null") {
    return new NullPipeReader();
  } else {
    return stdin;
  }
}
function resolveRedirectToFd(redirect, context) {
  const maybeFd = redirect.maybeFd;
  if (maybeFd == null) {
    return 1;
  }
  if (maybeFd.kind === "stdoutStderr") {
    return context.error("redirecting to both stdout and stderr is not implemented");
  }
  if (maybeFd.fd !== 1 && maybeFd.fd !== 2) {
    return context.error(`only redirecting to stdout (1) and stderr (2) is supported`);
  } else {
    return maybeFd.fd;
  }
}
function executeCommandInner(command, context) {
  switch (command.kind) {
    case "simple":
      return executeSimpleCommand(command, context);
    case "subshell":
      return executeSubshell(command, context);
    default: {
      const _assertNever = command;
      throw new Error(`Not implemented: ${command.kind}`);
    }
  }
}
async function executeSimpleCommand(command, parentContext) {
  const context = parentContext.clone();
  for (const envVar of command.envVars) {
    context.setEnvVar(envVar.name, await evaluateWord(envVar.value, context));
  }
  const commandArgs = await evaluateArgs(command.args, context);
  return await executeCommandArgs(commandArgs, context);
}
function checkMapCwdNotExistsError(cwd, err) {
  if (err.code === "ENOENT" && !existsSync(cwd)) {
    throw new Error(`Failed to launch command because the cwd does not exist (${cwd}).`, {
      cause: err
    });
  } else {
    throw err;
  }
}
function executeCommandArgs(commandArgs, context) {
  const commandName = commandArgs.shift();
  const command = context.getCommand(commandName);
  if (command != null) {
    return Promise.resolve(command(context.asCommandContext(commandArgs)));
  }
  const unresolvedCommand = {
    name: commandName,
    baseDir: context.getCwd()
  };
  return executeUnresolvedCommand(unresolvedCommand, commandArgs, context);
}
async function executeUnresolvedCommand(unresolvedCommand, commandArgs, context) {
  const resolvedCommand = await resolveCommand(unresolvedCommand, context);
  if (resolvedCommand === false) {
    context.stderr.writeLine(`dax: ${unresolvedCommand.name}: command not found`);
    return { code: 127 };
  }
  if (resolvedCommand.kind === "shebang") {
    return executeUnresolvedCommand(resolvedCommand.command, [...resolvedCommand.args, ...commandArgs], context);
  }
  const _assertIsPath = resolvedCommand.kind;
  return executeCommandAtPath(resolvedCommand.path, commandArgs, context);
}
async function executeCommandAtPath(commandPath, commandArgs, context) {
  const pipeStringVals = {
    stdin: getStdioStringValue(context.stdin),
    stdout: getStdioStringValue(context.stdout.kind),
    stderr: getStdioStringValue(context.stderr.kind)
  };
  let p;
  const cwd = context.getCwd();
  try {
    p = spawnCommand(commandPath, {
      args: commandArgs,
      cwd,
      env: context.getEnvVars(),
      clearEnv: true,
      ...pipeStringVals
    });
  } catch (err) {
    throw checkMapCwdNotExistsError(cwd, err);
  }
  const listener = (signal) => p.kill(signal);
  context.signal.addListener(listener);
  const completeController = new AbortController();
  const completeSignal = completeController.signal;
  let stdinError;
  const stdinPromise = writeStdin(context.stdin, p, completeSignal).catch(async (err) => {
    if (completeSignal.aborted) {
      return;
    }
    const maybePromise = context.stderr.writeLine(`stdin pipe broken. ${errorToString(err)}`);
    if (maybePromise != null) {
      await maybePromise;
    }
    stdinError = err;
    try {
      p.kill("SIGKILL");
    } catch (err2) {
      if (!(err2 instanceof Deno.errors.PermissionDenied || err2 instanceof Deno.errors.NotFound)) {
        throw err2;
      }
    }
  });
  try {
    const readStdoutTask = pipeStringVals.stdout === "piped" ? readStdOutOrErr(p.stdout(), context.stdout) : Promise.resolve();
    const readStderrTask = pipeStringVals.stderr === "piped" ? readStdOutOrErr(p.stderr(), context.stderr) : Promise.resolve();
    const [exitCode] = await Promise.all([
      p.waitExitCode().catch((err) => Promise.reject(checkMapCwdNotExistsError(cwd, err))),
      readStdoutTask,
      readStderrTask
    ]);
    if (stdinError != null) {
      return {
        code: 1,
        kind: "exit"
      };
    } else {
      return { code: exitCode };
    }
  } finally {
    completeController.abort();
    context.signal.removeListener(listener);
    await stdinPromise;
  }
  async function writeStdin(stdin, p2, signal) {
    if (typeof stdin === "string") {
      return;
    }
    const processStdin = p2.stdin();
    await pipeReaderToWritable(stdin, processStdin, signal);
    try {
      await processStdin.close();
    } catch {
    }
  }
  async function readStdOutOrErr(readable, writer) {
    if (typeof writer === "string") {
      return;
    }
    await pipeReadableToWriterSync(readable, writer, neverAbortedSignal);
  }
  function getStdioStringValue(value) {
    if (value === "inheritPiped") {
      return "piped";
    } else if (value === "inherit" || value === "null" || value === "piped") {
      return value;
    } else {
      return "piped";
    }
  }
}
async function executeSubshell(subshell, context) {
  const result = await executeSequentialList(subshell, context);
  return { code: result.code };
}
async function pipeReaderToWritable(reader, writable, signal) {
  const abortedPromise = new Promise((resolve7) => {
    signal.addEventListener("abort", listener);
    function listener() {
      signal.removeEventListener("abort", listener);
      resolve7();
    }
  });
  const writer = writable.getWriter();
  try {
    while (!signal.aborted) {
      const buffer = new Uint8Array(1024);
      const length = await Promise.race([abortedPromise, reader.read(buffer)]);
      if (length === 0 || length == null) {
        break;
      }
      await writer.write(buffer.subarray(0, length));
    }
  } finally {
    await writer.close();
  }
}
async function pipeReaderToWriterSync(reader, writer, signal) {
  const buffer = new Uint8Array(1024);
  while (!signal.aborted) {
    const bytesRead = await reader.read(buffer);
    if (bytesRead == null || bytesRead === 0) {
      break;
    }
    const maybePromise = writer.writeAll(buffer.slice(0, bytesRead));
    if (maybePromise) {
      await maybePromise;
    }
  }
}
function pipeCommandPipeReaderToWriterSync(reader, writer, signal) {
  switch (reader) {
    case "inherit":
      return pipeReadableToWriterSync(Deno.stdin.readable, writer, signal);
    case "null":
      return Promise.resolve();
    default: {
      return pipeReaderToWriterSync(reader, writer, signal);
    }
  }
}
async function resolveCommand(unresolvedCommand, context) {
  if (unresolvedCommand.name.includes("/") || Deno.build.os === "windows" && unresolvedCommand.name.includes("\\")) {
    const commandPath2 = isAbsolute3(unresolvedCommand.name) ? unresolvedCommand.name : resolve3(unresolvedCommand.baseDir, unresolvedCommand.name);
    const result = await getExecutableShebangFromPath(commandPath2);
    if (result === false) {
      return false;
    } else if (result != null) {
      const args = await parseShebangArgs(result, context);
      const name = args.shift();
      args.push(commandPath2);
      return {
        kind: "shebang",
        command: {
          name,
          baseDir: dirname3(commandPath2)
        },
        args
      };
    } else {
      const _assertUndefined = result;
      return {
        kind: "path",
        path: commandPath2
      };
    }
  }
  const commandPath = await whichFromContext(unresolvedCommand.name, context);
  if (commandPath == null) {
    return false;
  }
  return {
    kind: "path",
    path: commandPath
  };
}
var WhichEnv = class extends RealEnvironment {
  requestPermission(folderPath) {
    Deno.permissions.requestSync({
      name: "read",
      path: folderPath
    });
  }
};
var denoWhichRealEnv = new WhichEnv();
async function whichFromContext(commandName, context) {
  if (commandName.toUpperCase() === "DENO") {
    return Deno.execPath();
  }
  return await which(commandName, {
    os: Deno.build.os,
    stat: denoWhichRealEnv.stat,
    env(key) {
      return context.getVar(key);
    },
    requestPermission: denoWhichRealEnv.requestPermission
  });
}
async function executePipeSequence(sequence, context) {
  const waitTasks = [];
  let lastOutput = context.stdin;
  let nextInner = sequence;
  while (nextInner != null) {
    let innerCommand;
    switch (nextInner.kind) {
      case "pipeSequence":
        switch (nextInner.op) {
          case "stdout": {
            innerCommand = nextInner.current;
            break;
          }
          case "stdoutstderr": {
            return context.error(`piping to both stdout and stderr is not implemented (ex. |&)`);
          }
          default: {
            const _assertNever = nextInner.op;
            return context.error(`not implemented pipe sequence op: ${nextInner.op}`);
          }
        }
        nextInner = nextInner.next;
        break;
      case "command":
        innerCommand = nextInner;
        nextInner = void 0;
        break;
    }
    const buffer = new PipeSequencePipe();
    const newContext = context.withInner({
      stdout: new ShellPipeWriter("piped", buffer),
      stdin: lastOutput
    });
    const commandPromise = executeCommand(innerCommand, newContext);
    waitTasks.push(commandPromise);
    commandPromise.finally(() => {
      buffer.close();
    });
    lastOutput = buffer;
  }
  waitTasks.push(
    pipeCommandPipeReaderToWriterSync(lastOutput, context.stdout, context.signal).then(() => ({ code: 0 }))
  );
  const results = await Promise.all(waitTasks);
  const secondLastResult = results[results.length - 2];
  return secondLastResult;
}
async function parseShebangArgs(info, context) {
  function throwUnsupported() {
    throw new Error("Unsupported shebang. Please report this as a bug.");
  }
  if (!info.stringSplit) {
    return [info.command];
  }
  const command = parseCommand(info.command);
  if (command.items.length !== 1) {
    throwUnsupported();
  }
  const item = command.items[0];
  if (item.sequence.kind !== "pipeline" || item.isAsync) {
    throwUnsupported();
  }
  const sequence = item.sequence;
  if (sequence.negated) {
    throwUnsupported();
  }
  if (sequence.inner.kind !== "command" || sequence.inner.redirect != null) {
    throwUnsupported();
  }
  const innerCommand = sequence.inner.inner;
  if (innerCommand.kind !== "simple") {
    throwUnsupported();
  }
  if (innerCommand.envVars.length > 0) {
    throwUnsupported();
  }
  return await evaluateArgs(innerCommand.args, context);
}
async function evaluateArgs(args, context) {
  const result = [];
  for (const arg of args) {
    result.push(...await evaluateWordParts(arg, context));
  }
  return result;
}
async function evaluateWord(word, context) {
  const result = await evaluateWordParts(word, context);
  return result.join(" ");
}
async function evaluateWordParts(wordParts, context, quoted = false) {
  const result = [];
  let currentText = "";
  let hasQuoted = false;
  for (const stringPart of wordParts) {
    let evaluationResult = void 0;
    switch (stringPart.kind) {
      case "text":
        currentText += stringPart.value;
        break;
      case "variable":
        evaluationResult = context.getVar(stringPart.value);
        break;
      case "quoted": {
        const text = (await evaluateWordParts(stringPart.value, context, true)).join("");
        currentText += text;
        hasQuoted = true;
        continue;
      }
      case "command":
      default:
        throw new Error(`Not implemented: ${stringPart.kind}`);
    }
    if (evaluationResult != null) {
      if (quoted) {
        currentText += evaluationResult;
      } else {
        const parts = evaluationResult.split(" ").map((t) => t.trim()).filter((t) => t.length > 0);
        if (parts.length > 0) {
          currentText += parts[0];
          result.push(currentText);
          result.push(...parts.slice(1));
          currentText = result.pop();
        }
      }
    }
  }
  if (hasQuoted || currentText.length !== 0) {
    result.push(currentText);
  }
  return result;
}
function isDisposable(value) {
  return value != null && typeof value[Symbol.dispose] === "function";
}
function isAsyncDisposable(value) {
  return value != null && typeof value[Symbol.asyncDispose] === "function";
}
async function whichCommand(context) {
  try {
    return await executeWhich(context);
  } catch (err) {
    return context.error(`which: ${errorToString(err)}`);
  }
}
async function executeWhich(context) {
  let flags;
  try {
    flags = parseArgs11(context.args);
  } catch (err) {
    return await context.error(2, `which: ${errorToString(err)}`);
  }
  if (flags.commandName == null) {
    return { code: 1 };
  }
  const path = await whichFromContext(flags.commandName, {
    getVar(key) {
      return context.env[key];
    }
  });
  if (path != null) {
    await context.stdout.writeLine(path);
    return { code: 0 };
  } else {
    return { code: 1 };
  }
}
function parseArgs11(args) {
  let commandName;
  for (const arg of parseArgKinds(args)) {
    if (arg.kind === "Arg") {
      if (commandName != null) {
        throw Error("unsupported too many arguments");
      }
      commandName = arg.arg;
    } else {
      bailUnsupported3(arg);
    }
  }
  return {
    commandName
  };
}
function bailUnsupported3(arg) {
  switch (arg.kind) {
    case "Arg":
      throw Error(`unsupported argument: ${arg.arg}`);
    case "ShortFlag":
      throw Error(`unsupported flag: -${arg.arg}`);
    case "LongFlag":
      throw Error(`unsupported flag: --${arg.arg}`);
  }
}
var withProgressBarFactorySymbol = Symbol();
var RequestBuilder = class _RequestBuilder {
  #state = void 0;
  #getClonedState() {
    const state = this.#state;
    if (state == null) {
      return this.#getDefaultState();
    }
    return {
      // be explicit here in order to force evaluation
      // of each property on a case by case basis
      noThrow: typeof state.noThrow === "boolean" ? state.noThrow : [...state.noThrow],
      url: state.url,
      body: state.body,
      cache: state.cache,
      headers: state.headers,
      integrity: state.integrity,
      keepalive: state.keepalive,
      method: state.method,
      mode: state.mode,
      redirect: state.redirect,
      referrer: state.referrer,
      referrerPolicy: state.referrerPolicy,
      progressBarFactory: state.progressBarFactory,
      progressOptions: state.progressOptions == null ? void 0 : {
        ...state.progressOptions
      },
      timeout: state.timeout
    };
  }
  #getDefaultState() {
    return {
      noThrow: false,
      url: void 0,
      body: void 0,
      cache: void 0,
      headers: {},
      integrity: void 0,
      keepalive: void 0,
      method: void 0,
      mode: void 0,
      redirect: void 0,
      referrer: void 0,
      referrerPolicy: void 0,
      progressBarFactory: void 0,
      progressOptions: void 0,
      timeout: void 0
    };
  }
  #newWithState(action) {
    const builder = new _RequestBuilder();
    const state = this.#getClonedState();
    action(state);
    builder.#state = state;
    return builder;
  }
  [symbols.readable]() {
    const self = this;
    let streamReader;
    let response;
    let wasCancelled = false;
    let cancelledReason;
    return new ReadableStream({
      async start() {
        response = await self.fetch();
        const readable = response.readable;
        if (wasCancelled) {
          readable.cancel(cancelledReason);
        } else {
          streamReader = readable.getReader();
        }
      },
      async pull(controller) {
        const { done, value } = await streamReader.read();
        if (done || value == null) {
          if (response?.signal?.aborted) {
            controller.error(response?.signal?.reason);
          } else {
            controller.close();
          }
        } else {
          controller.enqueue(value);
        }
      },
      cancel(reason) {
        streamReader?.cancel(reason);
        wasCancelled = true;
        cancelledReason = reason;
      }
    });
  }
  then(onfulfilled, onrejected) {
    return this.fetch().then(onfulfilled).catch(onrejected);
  }
  /** Fetches and gets the response. */
  fetch() {
    return makeRequest(this.#getClonedState()).catch((err) => {
      if (err instanceof TimeoutError) {
        Error.captureStackTrace(err, TimeoutError);
      }
      return Promise.reject(err);
    });
  }
  /** Specifies the URL to send the request to. */
  url(value) {
    return this.#newWithState((state) => {
      state.url = value;
    });
  }
  header(nameOrItems, value) {
    return this.#newWithState((state) => {
      if (typeof nameOrItems === "string") {
        setHeader(state, nameOrItems, value);
      } else {
        for (const [name, value2] of Object.entries(nameOrItems)) {
          setHeader(state, name, value2);
        }
      }
    });
    function setHeader(state, name, value2) {
      name = name.toUpperCase();
      state.headers[name] = value2;
    }
  }
  noThrow(value, ...additional) {
    return this.#newWithState((state) => {
      if (typeof value === "boolean" || value == null) {
        state.noThrow = value ?? true;
      } else {
        state.noThrow = [value, ...additional];
      }
    });
  }
  body(value) {
    return this.#newWithState((state) => {
      state.body = value;
    });
  }
  cache(value) {
    return this.#newWithState((state) => {
      state.cache = value;
    });
  }
  integrity(value) {
    return this.#newWithState((state) => {
      state.integrity = value;
    });
  }
  keepalive(value) {
    return this.#newWithState((state) => {
      state.keepalive = value;
    });
  }
  method(value) {
    return this.#newWithState((state) => {
      state.method = value;
    });
  }
  mode(value) {
    return this.#newWithState((state) => {
      state.mode = value;
    });
  }
  /** @internal */
  [withProgressBarFactorySymbol](factory) {
    return this.#newWithState((state) => {
      state.progressBarFactory = factory;
    });
  }
  redirect(value) {
    return this.#newWithState((state) => {
      state.redirect = value;
    });
  }
  referrer(value) {
    return this.#newWithState((state) => {
      state.referrer = value;
    });
  }
  referrerPolicy(value) {
    return this.#newWithState((state) => {
      state.referrerPolicy = value;
    });
  }
  showProgress(value) {
    return this.#newWithState((state) => {
      if (value === true || value == null) {
        state.progressOptions = { noClear: false };
      } else if (value === false) {
        state.progressOptions = void 0;
      } else {
        state.progressOptions = {
          noClear: value.noClear ?? false
        };
      }
    });
  }
  /** Timeout the request after the specified delay throwing a `TimeoutError`. */
  timeout(delay) {
    return this.#newWithState((state) => {
      state.timeout = delay == null ? void 0 : delayToMs(delay);
    });
  }
  /** Fetches and gets the response as an array buffer. */
  async arrayBuffer() {
    const response = await this.fetch();
    return response.arrayBuffer();
  }
  /** Fetches and gets the response as a blob. */
  async blob() {
    const response = await this.fetch();
    return response.blob();
  }
  /** Fetches and gets the response as form data. */
  async formData() {
    const response = await this.fetch();
    return response.formData();
  }
  /** Fetches and gets the response as JSON additionally setting
   * a JSON accept header if not set. */
  async json() {
    let builder = this;
    const acceptHeaderName = "ACCEPT";
    if (builder.#state == null || !Object.hasOwn(builder.#state.headers, acceptHeaderName)) {
      builder = builder.header(acceptHeaderName, "application/json");
    }
    const response = await builder.fetch();
    return response.json();
  }
  /** Fetches and gets the response as text. */
  async text() {
    const response = await this.fetch();
    return response.text();
  }
  /** Pipes the response body to the provided writable stream. */
  async pipeTo(dest, options) {
    const response = await this.fetch();
    return await response.pipeTo(dest, options);
  }
  async pipeToPath(filePathOrOptions, maybeOptions) {
    const { filePath, options } = resolvePipeToPathParams(filePathOrOptions, maybeOptions, this.#state?.url);
    const response = await this.fetch();
    return await response.pipeToPath(filePath, options);
  }
  /** Pipes the response body through the provided transform. */
  async pipeThrough(transform) {
    const response = await this.fetch();
    return response.pipeThrough(transform);
  }
};
var RequestResponse = class {
  #response;
  #downloadResponse;
  #originalUrl;
  #abortController;
  /** @internal */
  constructor(opts) {
    this.#originalUrl = opts.originalUrl;
    this.#response = opts.response;
    this.#abortController = opts.abortController;
    if (opts.response.body == null) {
      opts.abortController.clearTimeout();
    }
    if (opts.progressBar != null) {
      const pb = opts.progressBar;
      this.#downloadResponse = new Response(
        new ReadableStream({
          async start(controller) {
            const reader = opts.response.body?.getReader();
            if (reader == null) {
              return;
            }
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done || value == null) {
                  break;
                }
                pb.increment(value.byteLength);
                controller.enqueue(value);
              }
              const signal = opts.abortController.controller.signal;
              if (signal.aborted) {
                controller.error(signal.reason);
              } else {
                controller.close();
              }
            } finally {
              reader.releaseLock();
              pb.finish();
            }
          }
        })
      );
    } else {
      this.#downloadResponse = opts.response;
    }
  }
  /** Raw response. */
  get response() {
    return this.#response;
  }
  /** Response headers. */
  get headers() {
    return this.#response.headers;
  }
  /** If the response had a 2xx code. */
  get ok() {
    return this.#response.ok;
  }
  /** If the response is the result of a redirect. */
  get redirected() {
    return this.#response.redirected;
  }
  /** The underlying `AbortSignal` used to abort the request body
   * when a timeout is reached or when the `.abort()` method is called. */
  get signal() {
    return this.#abortController.controller.signal;
  }
  /** Status code of the response. */
  get status() {
    return this.#response.status;
  }
  /** Status text of the response. */
  get statusText() {
    return this.#response.statusText;
  }
  /** URL of the response. */
  get url() {
    return this.#response.url;
  }
  /** Aborts  */
  abort(reason) {
    this.#abortController?.controller.abort(reason);
  }
  /**
   * Throws if the response doesn't have a 2xx code.
   *
   * This might be useful if the request was built with `.noThrow()`, but
   * otherwise this is called automatically for any non-2xx response codes.
   */
  throwIfNotOk() {
    if (!this.ok) {
      this.#response.body?.cancel().catch(() => {
      });
      throw new Error(`Error making request to ${this.#originalUrl}: ${this.statusText}`);
    }
  }
  /**
   * Respose body as an array buffer.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  arrayBuffer() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return this.#downloadResponse.arrayBuffer();
    });
  }
  /**
   * Response body as a blog.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  blob() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.blob();
    });
  }
  /**
   * Response body as a form data.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  formData() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.formData();
    });
  }
  /**
   * Respose body as JSON.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  json() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.json();
    });
  }
  /**
   * Respose body as text.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  text() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.text();
    });
  }
  /** Pipes the response body to the provided writable stream. */
  pipeTo(dest, options) {
    return this.#withReturnHandling(() => this.readable.pipeTo(dest, options));
  }
  async pipeToPath(filePathOrOptions, maybeOptions) {
    const { filePath, options } = resolvePipeToPathParams(filePathOrOptions, maybeOptions, this.#originalUrl);
    const body = this.readable;
    try {
      const file = await filePath.open({
        write: true,
        create: true,
        ...options ?? {}
      });
      try {
        await body.pipeTo(file.writable, {
          preventClose: true
        });
        await file.writable.close();
      } finally {
        try {
          file.close();
        } catch {
        }
        this.#abortController?.clearTimeout();
      }
    } catch (err) {
      await this.#response.body?.cancel();
      throw err;
    }
    return filePath;
  }
  /** Pipes the response body through the provided transform. */
  pipeThrough(transform) {
    return this.readable.pipeThrough(transform);
  }
  get readable() {
    const body = this.#downloadResponse.body;
    if (body == null) {
      throw new Error("Response had no body.");
    }
    return body;
  }
  async #withReturnHandling(action) {
    try {
      return await action();
    } catch (err) {
      if (err instanceof TimeoutError) {
        Error.captureStackTrace(err);
      }
      throw err;
    } finally {
      this.#abortController.clearTimeout();
    }
  }
};
async function makeRequest(state) {
  if (state.url == null) {
    throw new Error("You must specify a URL before fetching.");
  }
  const abortController = getTimeoutAbortController() ?? {
    controller: new AbortController(),
    clearTimeout() {
    }
  };
  const response = await fetch(state.url, {
    body: state.body,
    // @ts-ignore not supported in Node.js yet?
    cache: state.cache,
    headers: filterEmptyRecordValues(state.headers),
    integrity: state.integrity,
    keepalive: state.keepalive,
    method: state.method,
    mode: state.mode,
    redirect: state.redirect,
    referrer: state.referrer,
    referrerPolicy: state.referrerPolicy,
    signal: abortController.controller.signal
  });
  const result = new RequestResponse({
    response,
    originalUrl: state.url.toString(),
    progressBar: getProgressBar(),
    abortController
  });
  if (!state.noThrow) {
    result.throwIfNotOk();
  } else if (state.noThrow instanceof Array) {
    if (!state.noThrow.includes(response.status)) {
      result.throwIfNotOk();
    }
  }
  return result;
  function getProgressBar() {
    if (state.progressOptions == null || state.progressBarFactory == null) {
      return void 0;
    }
    return state.progressBarFactory(`Download ${state.url}`).noClear(state.progressOptions.noClear).kind("bytes").length(getContentLength());
    function getContentLength() {
      const contentLength = response.headers.get("content-length");
      if (contentLength == null) {
        return void 0;
      }
      const length = parseInt(contentLength, 10);
      return isNaN(length) ? void 0 : length;
    }
  }
  function getTimeoutAbortController() {
    if (state.timeout == null) {
      return void 0;
    }
    const timeout = state.timeout;
    const controller = new AbortController();
    const timeoutId = setTimeout(
      () => controller.abort(new TimeoutError(`Request timed out after ${formatMillis(timeout)}.`)),
      timeout
    );
    return {
      controller,
      clearTimeout() {
        clearTimeout(timeoutId);
      }
    };
  }
}
function resolvePipeToPathParams(pathOrOptions, maybeOptions, originalUrl) {
  let filePath;
  let options;
  if (typeof pathOrOptions === "string" || pathOrOptions instanceof URL) {
    filePath = new Path(pathOrOptions).resolve();
    options = maybeOptions;
  } else if (pathOrOptions instanceof Path) {
    filePath = pathOrOptions.resolve();
    options = maybeOptions;
  } else if (typeof pathOrOptions === "object") {
    options = pathOrOptions;
  } else if (pathOrOptions === void 0) {
    options = maybeOptions;
  }
  if (filePath === void 0) {
    filePath = new Path(getFileNameFromUrlOrThrow(originalUrl));
  } else if (filePath.isDirSync()) {
    filePath = filePath.join(getFileNameFromUrlOrThrow(originalUrl));
  }
  filePath = filePath.resolve();
  return {
    filePath,
    options
  };
  function getFileNameFromUrlOrThrow(url) {
    const fileName = url == null ? void 0 : getFileNameFromUrl(url);
    if (fileName == null) {
      throw new Error(
        "Could not derive the path from the request URL. Please explicitly provide a path."
      );
    }
    return fileName;
  }
}
var Deferred = class {
  #create;
  constructor(create) {
    this.#create = create;
  }
  create() {
    return this.#create();
  }
};
var textDecoder2 = new TextDecoder();
var builtInCommands = {
  cd: cdCommand,
  printenv: printEnvCommand,
  echo: echoCommand,
  cat: catCommand,
  exit: exitCommand,
  export: exportCommand,
  sleep: sleepCommand,
  test: testCommand,
  rm: rmCommand,
  mkdir: mkdirCommand,
  cp: cpCommand,
  mv: mvCommand,
  pwd: pwdCommand,
  touch: touchCommand,
  unset: unsetCommand,
  which: whichCommand
};
var getRegisteredCommandNamesSymbol = Symbol();
var setCommandTextStateSymbol = Symbol();
var CommandBuilder = class _CommandBuilder {
  #state = {
    command: void 0,
    combinedStdoutStderr: false,
    stdin: "inherit",
    stdout: {
      kind: "inherit"
    },
    stderr: {
      kind: "inherit"
    },
    noThrow: false,
    env: {},
    cwd: void 0,
    commands: { ...builtInCommands },
    clearEnv: false,
    exportEnv: false,
    printCommand: false,
    printCommandLogger: new LoggerTreeBox(
      // deno-lint-ignore no-console
      (cmd) => console.error(white2(">"), blue(cmd))
    ),
    timeout: void 0,
    signal: void 0
  };
  #getClonedState() {
    const state = this.#state;
    return {
      // be explicit here in order to evaluate each property on a case by case basis
      command: state.command,
      combinedStdoutStderr: state.combinedStdoutStderr,
      stdin: state.stdin,
      stdout: {
        kind: state.stdout.kind,
        options: state.stdout.options
      },
      stderr: {
        kind: state.stderr.kind,
        options: state.stderr.options
      },
      noThrow: state.noThrow instanceof Array ? [...state.noThrow] : state.noThrow,
      env: { ...state.env },
      cwd: state.cwd,
      commands: { ...state.commands },
      clearEnv: state.clearEnv,
      exportEnv: state.exportEnv,
      printCommand: state.printCommand,
      printCommandLogger: state.printCommandLogger.createChild(),
      timeout: state.timeout,
      signal: state.signal
    };
  }
  #newWithState(action) {
    const builder = new _CommandBuilder();
    const state = this.#getClonedState();
    action(state);
    builder.#state = state;
    return builder;
  }
  then(onfulfilled, onrejected) {
    return this.spawn().then(onfulfilled).catch(onrejected);
  }
  /**
   * Explicit way to spawn a command.
   *
   * This is an alias for awaiting the command builder or calling `.then(...)`
   */
  spawn() {
    return parseAndSpawnCommand(this.#getClonedState());
  }
  /**
   * Register a command.
   */
  registerCommand(command, handleFn) {
    validateCommandName(command);
    return this.#newWithState((state) => {
      state.commands[command] = handleFn;
    });
  }
  /**
   * Register multilple commands.
   */
  registerCommands(commands) {
    let command = this;
    for (const [key, value] of Object.entries(commands)) {
      command = command.registerCommand(key, value);
    }
    return command;
  }
  /**
   * Unregister a command.
   */
  unregisterCommand(command) {
    return this.#newWithState((state) => {
      delete state.commands[command];
    });
  }
  /** Sets the raw command to execute. */
  command(command) {
    return this.#newWithState((state) => {
      if (command instanceof Array) {
        command = command.map(escapeArg).join(" ");
      }
      state.command = {
        text: command,
        fds: void 0
      };
    });
  }
  noThrow(value, ...additional) {
    return this.#newWithState((state) => {
      if (typeof value === "boolean" || value == null) {
        state.noThrow = value ?? true;
      } else {
        state.noThrow = [value, ...additional];
      }
    });
  }
  /** Sets the command signal that will be passed to all commands
   * created with this command builder.
   */
  signal(killSignal) {
    return this.#newWithState((state) => {
      if (state.signal != null) {
        state.signal.linkChild(killSignal);
      }
      state.signal = killSignal;
    });
  }
  /**
   * Whether to capture a combined buffer of both stdout and stderr.
   *
   * This will set both stdout and stderr to "piped" if not already "piped"
   * or "inheritPiped".
   */
  captureCombined(value = true) {
    return this.#newWithState((state) => {
      state.combinedStdoutStderr = value;
      if (value) {
        if (state.stdout.kind !== "piped" && state.stdout.kind !== "inheritPiped") {
          state.stdout.kind = "piped";
        }
        if (state.stderr.kind !== "piped" && state.stderr.kind !== "inheritPiped") {
          state.stderr.kind = "piped";
        }
      }
    });
  }
  /**
   * Sets the stdin to use for the command.
   *
   * @remarks If multiple launches of a command occurs, then stdin will only be
   * read from the first consumed reader or readable stream and error otherwise.
   * For this reason, if you are setting stdin to something other than "inherit" or
   * "null", then it's recommended to set this each time you spawn a command.
   */
  stdin(reader) {
    return this.#newWithState((state) => {
      if (reader === "inherit" || reader === "null") {
        state.stdin = reader;
      } else if (reader instanceof Uint8Array) {
        state.stdin = new Deferred(() => new Buffer(reader));
      } else if (reader instanceof Path) {
        state.stdin = new Deferred(async () => {
          const file = await reader.open();
          return file.readable;
        });
      } else if (reader instanceof RequestBuilder) {
        state.stdin = new Deferred(async () => {
          const body = await reader;
          return body.readable;
        });
      } else if (reader instanceof _CommandBuilder) {
        state.stdin = new Deferred(() => {
          return reader.stdout("piped").spawn().stdout();
        });
      } else {
        state.stdin = new Box(reader);
      }
    });
  }
  /**
   * Sets the stdin string to use for a command.
   *
   * @remarks See the remarks on stdin. The same applies here.
   */
  stdinText(text) {
    return this.stdin(new TextEncoder().encode(text));
  }
  stdout(kind, options) {
    return this.#newWithState((state) => {
      if (state.combinedStdoutStderr && kind !== "piped" && kind !== "inheritPiped") {
        throw new Error(
          "Cannot set stdout's kind to anything but 'piped' or 'inheritPiped' when combined is true."
        );
      }
      if (options?.signal != null) {
        throw new Error("Setting a signal for a stdout WritableStream is not yet supported.");
      }
      state.stdout = {
        kind,
        options
      };
    });
  }
  stderr(kind, options) {
    return this.#newWithState((state) => {
      if (state.combinedStdoutStderr && kind !== "piped" && kind !== "inheritPiped") {
        throw new Error(
          "Cannot set stderr's kind to anything but 'piped' or 'inheritPiped' when combined is true."
        );
      }
      if (options?.signal != null) {
        throw new Error("Setting a signal for a stderr WritableStream is not yet supported.");
      }
      state.stderr = {
        kind,
        options
      };
    });
  }
  /** Pipes the current command to the provided command returning the
   * provided command builder. When chaining, it's important to call this
   * after you are done configuring the current command or else you will
   * start modifying the provided command instead.
   *
   * @example
   * ```ts
   * const lineCount = await $`echo 1 && echo 2`
   *  .pipe($`wc -l`)
   *  .text();
   * ```
   */
  pipe(builder) {
    return builder.stdin(this.stdout("piped"));
  }
  env(nameOrItems, value) {
    return this.#newWithState((state) => {
      if (typeof nameOrItems === "string") {
        setEnv(state, nameOrItems, value);
      } else {
        for (const [key, value2] of Object.entries(nameOrItems)) {
          setEnv(state, key, value2);
        }
      }
    });
    function setEnv(state, key, value2) {
      if (Deno.build.os === "windows") {
        key = key.toUpperCase();
      }
      state.env[key] = value2;
    }
  }
  /** Sets the current working directory to use when executing this command. */
  cwd(dirPath) {
    return this.#newWithState((state) => {
      state.cwd = dirPath instanceof URL ? fromFileUrl3(dirPath) : dirPath instanceof Path ? dirPath.resolve().toString() : resolve3(dirPath);
    });
  }
  /**
   * Exports the environment of the command to the executing process.
   *
   * So for example, changing the directory in a command or exporting
   * an environment variable will actually change the environment
   * of the executing process.
   *
   * ```ts
   * await $`cd src && export SOME_VALUE=5`;
   * console.log(Deno.env.get("SOME_VALUE")); // 5
   * console.log(Deno.cwd()); // will be in the src directory
   * ```
   */
  exportEnv(value = true) {
    return this.#newWithState((state) => {
      state.exportEnv = value;
    });
  }
  /**
   * Clear environmental variables from parent process.
   *
   * Doesn't guarantee that only `env` variables are present, as the OS may
   * set environmental variables for processes.
   */
  clearEnv(value = true) {
    return this.#newWithState((state) => {
      state.clearEnv = value;
    });
  }
  /**
   * Prints the command text before executing the command.
   *
   * For example:
   *
   * ```ts
   * const text = "example";
   * await $`echo ${text}`.printCommand();
   * ```
   *
   * Outputs:
   *
   * ```
   * > echo example
   * example
   * ```
   */
  printCommand(value = true) {
    return this.#newWithState((state) => {
      state.printCommand = value;
    });
  }
  /**
   * Mutates the command builder to change the logger used
   * for `printCommand()`.
   */
  setPrintCommandLogger(logger3) {
    this.#state.printCommandLogger.setValue(logger3);
  }
  /**
   * Ensures stdout and stderr are piped if they have the default behaviour or are inherited.
   *
   * ```ts
   * // ensure both stdout and stderr is not logged to the console
   * await $`echo 1`.quiet();
   * // ensure stdout is not logged to the console
   * await $`echo 1`.quiet("stdout");
   * // ensure stderr is not logged to the console
   * await $`echo 1`.quiet("stderr");
   * ```
   */
  quiet(kind = "combined") {
    kind = kind === "both" ? "combined" : kind;
    return this.#newWithState((state) => {
      if (kind === "combined" || kind === "stdout") {
        state.stdout.kind = getQuietKind(state.stdout.kind);
      }
      if (kind === "combined" || kind === "stderr") {
        state.stderr.kind = getQuietKind(state.stderr.kind);
      }
    });
    function getQuietKind(kind2) {
      if (typeof kind2 === "object") {
        return kind2;
      }
      switch (kind2) {
        case "inheritPiped":
        case "inherit":
          return "piped";
        case "null":
        case "piped":
          return kind2;
        default: {
          const _assertNever = kind2;
          throw new Error(`Unhandled kind ${kind2}.`);
        }
      }
    }
  }
  /**
   * Specifies a timeout for the command. The command will exit with
   * exit code `124` (timeout) if it times out.
   *
   * Note that when using `.noThrow()` this won't cause an error to
   * be thrown when timing out.
   */
  timeout(delay) {
    return this.#newWithState((state) => {
      state.timeout = delay == null ? void 0 : delayToMs(delay);
    });
  }
  /**
   * Sets stdout as quiet, spawns the command, and gets stdout as a Uint8Array.
   *
   * Shorthand for:
   *
   * ```ts
   * const data = (await $`command`.quiet("stdout")).stdoutBytes;
   * ```
   */
  async bytes(kind = "stdout") {
    const command = kind === "combined" ? this.quiet(kind).captureCombined() : this.quiet(kind);
    return (await command)[`${kind}Bytes`];
  }
  /**
   * Sets the provided stream (stdout by default) as quiet, spawns the command, and gets the stream as a string without the last newline.
   * Can be used to get stdout, stderr, or both.
   *
   * Shorthand for:
   *
   * ```ts
   * const data = (await $`command`.quiet("stdout")).stdout.replace(/\r?\n$/, "");
   * ```
   */
  async text(kind = "stdout") {
    const command = kind === "combined" ? this.quiet(kind).captureCombined() : this.quiet(kind);
    return (await command)[kind].replace(/\r?\n$/, "");
  }
  /** Gets the text as an array of lines. */
  async lines(kind = "stdout") {
    const text = await this.text(kind);
    return text.split(/\r?\n/g);
  }
  /**
   * Sets stream (stdout by default) as quiet, spawns the command, and gets stream as JSON.
   *
   * Shorthand for:
   *
   * ```ts
   * const data = (await $`command`.quiet("stdout")).stdoutJson;
   * ```
   */
  async json(kind = "stdout") {
    return (await this.quiet(kind))[`${kind}Json`];
  }
  /** @internal */
  [getRegisteredCommandNamesSymbol]() {
    return Object.keys(this.#state.commands);
  }
  /** @internal */
  [setCommandTextStateSymbol](textState) {
    return this.#newWithState((state) => {
      state.command = textState;
    });
  }
};
var CommandChild = class extends Promise {
  #pipedStdoutBuffer;
  #pipedStderrBuffer;
  #killSignalController;
  /** @internal */
  constructor(executor, options = { pipedStderrBuffer: void 0, pipedStdoutBuffer: void 0, killSignalController: void 0 }) {
    super(executor);
    this.#pipedStdoutBuffer = options.pipedStdoutBuffer;
    this.#pipedStderrBuffer = options.pipedStderrBuffer;
    this.#killSignalController = options.killSignalController;
  }
  /** Send a signal to the executing command's child process. Note that SIGTERM,
   * SIGKILL, SIGABRT, SIGQUIT, SIGINT, or SIGSTOP will cause the entire command
   * to be considered "aborted" and if part of a command runs after this has occurred
   * it will return a 124 exit code. Other signals will just be forwarded to the command.
   *
   * Defaults to "SIGTERM".
   */
  kill(signal) {
    this.#killSignalController?.kill(signal);
  }
  stdout() {
    const buffer = this.#pipedStdoutBuffer;
    this.#assertBufferStreamable("stdout", buffer);
    this.#pipedStdoutBuffer = "consumed";
    this.catch(() => {
    });
    return this.#bufferToStream(buffer);
  }
  stderr() {
    const buffer = this.#pipedStderrBuffer;
    this.#assertBufferStreamable("stderr", buffer);
    this.#pipedStderrBuffer = "consumed";
    this.catch(() => {
    });
    return this.#bufferToStream(buffer);
  }
  #assertBufferStreamable(name, buffer) {
    if (buffer == null) {
      throw new Error(
        `No pipe available. Ensure ${name} is "piped" (not "inheritPiped") and combinedOutput is not enabled.`
      );
    }
    if (buffer === "consumed") {
      throw new Error(`Streamable ${name} was already consumed. Use the previously acquired stream instead.`);
    }
  }
  #bufferToStream(buffer) {
    const self = this;
    return new ReadableStream({
      start(controller) {
        buffer.setListener({
          writeSync(data) {
            controller.enqueue(data);
            return data.length;
          },
          setError(err) {
            controller.error(err);
          },
          close() {
            controller.close();
          }
        });
      },
      cancel(_reason) {
        self.kill();
      }
    });
  }
};
function parseAndSpawnCommand(state) {
  if (state.command == null) {
    throw new Error("A command must be set before it can be spawned.");
  }
  if (state.printCommand) {
    state.printCommandLogger.getValue()(state.command.text);
  }
  const disposables = [];
  const asyncDisposables = [];
  const parentSignal = state.signal;
  const killSignalController = new KillSignalController();
  if (parentSignal != null) {
    const parentSignalListener = (signal2) => {
      killSignalController.kill(signal2);
    };
    parentSignal.addListener(parentSignalListener);
    disposables.push({
      [Symbol.dispose]() {
        parentSignal.removeListener(parentSignalListener);
      }
    });
  }
  let timedOut = false;
  if (state.timeout != null) {
    const timeoutId = setTimeout(() => {
      timedOut = true;
      killSignalController.kill();
    }, state.timeout);
    disposables.push({
      [Symbol.dispose]() {
        clearTimeout(timeoutId);
      }
    });
  }
  const [stdoutBuffer, stderrBuffer, combinedBuffer] = getBuffers();
  const stdout = new ShellPipeWriter(
    state.stdout.kind,
    stdoutBuffer === "null" ? new NullPipeWriter() : stdoutBuffer === "inherit" ? Deno.stdout : stdoutBuffer
  );
  const stderr = new ShellPipeWriter(
    state.stderr.kind,
    stderrBuffer === "null" ? new NullPipeWriter() : stderrBuffer === "inherit" ? Deno.stderr : stderrBuffer
  );
  const { text: commandText, fds } = state.command;
  const signal = killSignalController.signal;
  return new CommandChild(async (resolve7, reject) => {
    try {
      const list = parseCommand(commandText);
      const stdin = await takeStdin();
      let code4 = await spawn(list, {
        stdin: stdin instanceof ReadableStream ? readerFromStreamReader2(stdin.getReader()) : stdin,
        stdout,
        stderr,
        env: buildEnv(state.env, state.clearEnv),
        commands: state.commands,
        cwd: state.cwd ?? Deno.cwd(),
        exportEnv: state.exportEnv,
        clearedEnv: state.clearEnv,
        signal,
        fds
      });
      if (code4 !== 0) {
        if (timedOut) {
          code4 = 124;
        }
        const noThrow = state.noThrow instanceof Array ? state.noThrow.includes(code4) : state.noThrow;
        if (!noThrow) {
          if (stdin instanceof ReadableStream) {
            if (!stdin.locked) {
              stdin.cancel();
            }
          }
          if (timedOut) {
            throw new Error(`Timed out with exit code: ${code4}`);
          } else if (signal.aborted) {
            throw new Error(`${timedOut ? "Timed out" : "Aborted"} with exit code: ${code4}`);
          } else {
            throw new Error(`Exited with code: ${code4}`);
          }
        }
      }
      const result = new CommandResult(
        code4,
        finalizeCommandResultBuffer(stdoutBuffer),
        finalizeCommandResultBuffer(stderrBuffer),
        combinedBuffer instanceof Buffer ? combinedBuffer : void 0
      );
      const maybeError = await cleanupDisposablesAndMaybeGetError(void 0);
      if (maybeError) {
        reject(maybeError);
      } else {
        resolve7(result);
      }
    } catch (err) {
      finalizeCommandResultBufferForError(stdoutBuffer, err);
      finalizeCommandResultBufferForError(stderrBuffer, err);
      reject(await cleanupDisposablesAndMaybeGetError(err));
    }
  }, {
    pipedStdoutBuffer: stdoutBuffer instanceof PipedBuffer ? stdoutBuffer : void 0,
    pipedStderrBuffer: stderrBuffer instanceof PipedBuffer ? stderrBuffer : void 0,
    killSignalController
  });
  async function cleanupDisposablesAndMaybeGetError(maybeError) {
    const errors = [];
    if (maybeError) {
      errors.push(maybeError);
    }
    for (const disposable of disposables) {
      try {
        disposable[Symbol.dispose]();
      } catch (err) {
        errors.push(err);
      }
    }
    if (asyncDisposables.length > 0) {
      await Promise.all(asyncDisposables.map(async (d) => {
        try {
          await d[Symbol.asyncDispose]();
        } catch (err) {
          errors.push(err);
        }
      }));
    }
    if (errors.length === 1) {
      return errors[0];
    } else if (errors.length > 1) {
      return new AggregateError(errors);
    } else {
      return void 0;
    }
  }
  async function takeStdin() {
    if (state.stdin instanceof Box) {
      const stdin = state.stdin.value;
      if (stdin === "consumed") {
        throw new Error(
          "Cannot spawn command. Stdin was already consumed when a previous command using the same stdin was spawned. You need to call `.stdin(...)` again with a new value before spawning."
        );
      }
      state.stdin.value = "consumed";
      return stdin;
    } else if (state.stdin instanceof Deferred) {
      const stdin = await state.stdin.create();
      if (stdin instanceof ReadableStream) {
        asyncDisposables.push({
          async [Symbol.asyncDispose]() {
            if (!stdin.locked) {
              await stdin.cancel();
            }
          }
        });
      }
      return stdin;
    } else {
      return state.stdin;
    }
  }
  function getBuffers() {
    const hasProgressBars = isShowingProgressBars();
    const stdoutBuffer2 = getOutputBuffer(Deno.stdout, state.stdout);
    const stderrBuffer2 = getOutputBuffer(Deno.stderr, state.stderr);
    if (state.combinedStdoutStderr) {
      if (typeof stdoutBuffer2 === "string" || typeof stderrBuffer2 === "string") {
        throw new Error("Internal programming error. Expected writers for stdout and stderr.");
      }
      const combinedBuffer2 = new Buffer();
      return [
        getCapturingBuffer(stdoutBuffer2, combinedBuffer2),
        getCapturingBuffer(stderrBuffer2, combinedBuffer2),
        combinedBuffer2
      ];
    }
    return [stdoutBuffer2, stderrBuffer2, void 0];
    function getCapturingBuffer(buffer, combinedBuffer2) {
      if ("write" in buffer) {
        return new CapturingBufferWriter(buffer, combinedBuffer2);
      } else {
        return new CapturingBufferWriterSync(buffer, combinedBuffer2);
      }
    }
    function getOutputBuffer(inheritWriter, { kind, options }) {
      if (typeof kind === "object") {
        if (kind instanceof Path) {
          const file = kind.openSync({ write: true, truncate: true, create: true });
          disposables.push(file);
          return file;
        } else if (kind instanceof WritableStream) {
          const streamWriter = kind.getWriter();
          asyncDisposables.push({
            async [Symbol.asyncDispose]() {
              streamWriter.releaseLock();
              if (!options?.preventClose) {
                try {
                  await kind.close();
                } catch {
                }
              }
            }
          });
          return writerFromStreamWriter(streamWriter);
        } else {
          return kind;
        }
      }
      switch (kind) {
        case "inherit":
          if (hasProgressBars) {
            return new InheritStaticTextBypassWriter(inheritWriter);
          } else {
            return "inherit";
          }
        case "piped":
          return new PipedBuffer();
        case "inheritPiped":
          return new CapturingBufferWriterSync(inheritWriter, new Buffer());
        case "null":
          return "null";
        default: {
          const _assertNever = kind;
          throw new Error("Unhandled.");
        }
      }
    }
  }
  function finalizeCommandResultBuffer(buffer) {
    if (buffer instanceof CapturingBufferWriterSync || buffer instanceof CapturingBufferWriter) {
      return buffer.getBuffer();
    } else if (buffer instanceof InheritStaticTextBypassWriter) {
      buffer.flush();
      return "inherit";
    } else if (buffer instanceof PipedBuffer) {
      buffer.close();
      return buffer.getBuffer() ?? "streamed";
    } else if (typeof buffer === "object") {
      return "streamed";
    } else {
      return buffer;
    }
  }
  function finalizeCommandResultBufferForError(buffer, error) {
    if (buffer instanceof InheritStaticTextBypassWriter) {
      buffer.flush();
    } else if (buffer instanceof PipedBuffer) {
      buffer.setError(error);
    }
  }
}
var CommandResult = class {
  #stdout;
  #stderr;
  #combined;
  /** The exit code. */
  code;
  /** @internal */
  constructor(code4, stdout, stderr, combined) {
    this.code = code4;
    this.#stdout = stdout;
    this.#stderr = stderr;
    this.#combined = combined;
  }
  #memoizedStdout;
  /** Raw decoded stdout text. */
  get stdout() {
    if (!this.#memoizedStdout) {
      this.#memoizedStdout = textDecoder2.decode(this.stdoutBytes);
    }
    return this.#memoizedStdout;
  }
  #memoizedStdoutJson;
  /**
   * Stdout text as JSON.
   *
   * @remarks Will throw if it can't be parsed as JSON.
   */
  get stdoutJson() {
    if (this.#memoizedStdoutJson == null) {
      this.#memoizedStdoutJson = JSON.parse(this.stdout);
    }
    return this.#memoizedStdoutJson;
  }
  /** Raw stdout bytes. */
  get stdoutBytes() {
    if (this.#stdout === "streamed") {
      throw new Error(
        `Stdout was streamed to another source and is no longer available.`
      );
    }
    if (typeof this.#stdout === "string") {
      throw new Error(
        `Stdout was not piped (was ${this.#stdout}). Call .stdout("piped") or .stdout("inheritPiped") when building the command.`
      );
    }
    return this.#stdout.bytes({ copy: false });
  }
  #memoizedStderr;
  /** Raw decoded stdout text. */
  get stderr() {
    if (!this.#memoizedStderr) {
      this.#memoizedStderr = textDecoder2.decode(this.stderrBytes);
    }
    return this.#memoizedStderr;
  }
  #memoizedStderrJson;
  /**
   * Stderr text as JSON.
   *
   * @remarks Will throw if it can't be parsed as JSON.
   */
  get stderrJson() {
    if (this.#memoizedStderrJson == null) {
      this.#memoizedStderrJson = JSON.parse(this.stderr);
    }
    return this.#memoizedStderrJson;
  }
  /** Raw stderr bytes. */
  get stderrBytes() {
    if (this.#stderr === "streamed") {
      throw new Error(
        `Stderr was streamed to another source and is no longer available.`
      );
    }
    if (typeof this.#stderr === "string") {
      throw new Error(
        `Stderr was not piped (was ${this.#stderr}). Call .stderr("piped") or .stderr("inheritPiped") when building the command.`
      );
    }
    return this.#stderr.bytes({ copy: false });
  }
  #memoizedCombined;
  /** Raw combined stdout and stderr text. */
  get combined() {
    if (!this.#memoizedCombined) {
      this.#memoizedCombined = textDecoder2.decode(this.combinedBytes);
    }
    return this.#memoizedCombined;
  }
  /** Raw combined stdout and stderr bytes. */
  get combinedBytes() {
    if (this.#combined == null) {
      throw new Error("Stdout and stderr were not combined. Call .captureCombined() when building the command.");
    }
    return this.#combined.bytes({ copy: false });
  }
};
function buildEnv(env, clearEnv) {
  const result = clearEnv ? {} : Deno.env.toObject();
  for (const [key, value] of Object.entries(env)) {
    if (value == null) {
      delete result[key];
    } else {
      result[key] = value;
    }
  }
  return result;
}
function escapeArg(arg) {
  if (/^[A-Za-z0-9]+$/.test(arg)) {
    return arg;
  } else {
    return `'${arg.replaceAll("'", `'"'"'`)}'`;
  }
}
function validateCommandName(command) {
  if (command.match(/^[a-zA-Z0-9-_]+$/) == null) {
    throw new Error("Invalid command name");
  }
}
var SHELL_SIGNAL_CTOR_SYMBOL = Symbol();
var KillSignalController = class {
  #state;
  #killSignal;
  constructor() {
    this.#state = {
      abortedCode: void 0,
      listeners: []
    };
    this.#killSignal = new KillSignal(SHELL_SIGNAL_CTOR_SYMBOL, this.#state);
  }
  get signal() {
    return this.#killSignal;
  }
  /** Send a signal to the downstream child process. Note that SIGTERM,
   * SIGKILL, SIGABRT, SIGQUIT, SIGINT, or SIGSTOP will cause all the commands
   * to be considered "aborted" and will return a 124 exit code, while other
   * signals will just be forwarded to the commands.
   */
  kill(signal = "SIGTERM") {
    sendSignalToState(this.#state, signal);
  }
};
var KillSignal = class {
  #state;
  /** @internal */
  constructor(symbol, state) {
    if (symbol !== SHELL_SIGNAL_CTOR_SYMBOL) {
      throw new Error("Constructing instances of KillSignal is not permitted.");
    }
    this.#state = state;
  }
  /** Returns if the command signal has ever received a SIGTERM,
   * SIGKILL, SIGABRT, SIGQUIT, SIGINT, or SIGSTOP
   */
  get aborted() {
    return this.#state.abortedCode !== void 0;
  }
  /** Gets the exit code to use if aborted. */
  get abortedExitCode() {
    return this.#state.abortedCode;
  }
  /**
   * Causes the provided kill signal to be triggered when this
   * signal receives a signal.
   */
  linkChild(killSignal) {
    const listener = (signal) => {
      sendSignalToState(killSignal.#state, signal);
    };
    this.addListener(listener);
    return {
      unsubscribe: () => {
        this.removeListener(listener);
      }
    };
  }
  addListener(listener) {
    this.#state.listeners.push(listener);
  }
  removeListener(listener) {
    const index = this.#state.listeners.indexOf(listener);
    if (index >= 0) {
      this.#state.listeners.splice(index, 1);
    }
  }
};
function sendSignalToState(state, signal) {
  const code4 = getSignalAbortCode(signal);
  if (code4 !== void 0) {
    state.abortedCode = code4;
  }
  for (const listener of state.listeners) {
    listener(signal);
  }
}
function getSignalAbortCode(signal) {
  switch (signal) {
    case "SIGTERM":
      return 128 + 15;
    case "SIGKILL":
      return 128 + 9;
    case "SIGABRT":
      return 128 + 6;
    case "SIGQUIT":
      return 128 + 3;
    case "SIGINT":
      return 128 + 2;
    case "SIGSTOP":
      return 128 + 19;
    default:
      return void 0;
  }
}
function template(strings, exprs) {
  return templateInner(strings, exprs, escapeArg);
}
function templateRaw(strings, exprs) {
  return templateInner(strings, exprs, void 0);
}
function templateInner(strings, exprs, escape) {
  let nextStreamFd = 3;
  let text = "";
  let streams;
  const exprsCount = exprs.length;
  for (let i = 0; i < Math.max(strings.length, exprs.length); i++) {
    if (strings.length > i) {
      text += strings[i];
    }
    if (exprs.length > i) {
      try {
        const expr = exprs[i];
        if (expr == null) {
          throw "Expression was null or undefined.";
        }
        const inputOrOutputRedirect = detectInputOrOutputRedirect(text);
        if (inputOrOutputRedirect === "<") {
          if (expr instanceof Path) {
            text += templateLiteralExprToString(expr, escape);
          } else if (typeof expr === "string") {
            handleReadableStream(
              () => new ReadableStream({
                start(controller) {
                  controller.enqueue(new TextEncoder().encode(expr));
                  controller.close();
                }
              })
            );
          } else if (expr instanceof ReadableStream) {
            handleReadableStream(() => expr);
          } else if (expr?.[symbols.readable]) {
            handleReadableStream(() => {
              const stream = expr[symbols.readable]?.();
              if (!(stream instanceof ReadableStream)) {
                throw new Error(
                  `Expected a ReadableStream or an object with a [$.symbols.readable] method that returns a ReadableStream at expression ${i + 1}/${exprsCount}.`
                );
              }
              return stream;
            });
          } else if (expr instanceof FsFileWrapper) {
            handleReadableStream(() => expr.readable);
          } else if (expr instanceof Uint8Array) {
            handleReadableStream(() => {
              return new ReadableStream({
                start(controller) {
                  controller.enqueue(expr);
                  controller.close();
                }
              });
            });
          } else if (expr instanceof Response) {
            handleReadableStream(() => {
              return expr.body ?? new ReadableStream({
                start(controller) {
                  controller.close();
                }
              });
            });
          } else if (expr instanceof Function) {
            handleReadableStream(() => {
              try {
                const result = expr();
                if (!(result instanceof ReadableStream)) {
                  throw new Error("Function did not return a ReadableStream.");
                }
                return result;
              } catch (err) {
                throw new Error(
                  `Error getting ReadableStream from function at expression ${i + 1}/${exprsCount}. ${errorToString(err)}`
                );
              }
            });
          } else {
            throw new Error("Unsupported object provided to input redirect.");
          }
        } else if (inputOrOutputRedirect === ">") {
          if (expr instanceof Path) {
            text += templateLiteralExprToString(expr, escape);
          } else if (expr instanceof WritableStream) {
            handleWritableStream(() => expr);
          } else if (expr instanceof Uint8Array) {
            let pos = 0;
            handleWritableStream(() => {
              return new WritableStream({
                write(chunk) {
                  const nextPos = chunk.length + pos;
                  if (nextPos > expr.length) {
                    const chunkLength = expr.length - pos;
                    expr.set(chunk.slice(0, chunkLength), pos);
                    throw new Error(`Overflow writing ${nextPos} bytes to Uint8Array (length: ${exprsCount}).`);
                  }
                  expr.set(chunk, pos);
                  pos = nextPos;
                }
              });
            });
          } else if (expr instanceof FsFileWrapper) {
            handleWritableStream(() => expr.writable);
          } else if (expr?.[symbols.writable]) {
            handleWritableStream(() => {
              const stream = expr[symbols.writable]?.();
              if (!(stream instanceof WritableStream)) {
                throw new Error(
                  `Expected a WritableStream or an object with a [$.symbols.writable] method that returns a WritableStream at expression ${i + 1}/${exprsCount}.`
                );
              }
              return stream;
            });
          } else if (expr instanceof Function) {
            handleWritableStream(() => {
              try {
                const result = expr();
                if (!(result instanceof WritableStream)) {
                  throw new Error("Function did not return a WritableStream.");
                }
                return result;
              } catch (err) {
                throw new Error(
                  `Error getting WritableStream from function at expression ${i + 1}/${exprsCount}. ${errorToString(err)}`
                );
              }
            });
          } else if (typeof expr === "string") {
            throw new Error(
              "Cannot provide strings to output redirects. Did you mean to provide a path instead via the `$.path(...)` API?"
            );
          } else {
            throw new Error("Unsupported object provided to output redirect.");
          }
        } else {
          text += templateLiteralExprToString(expr, escape);
        }
      } catch (err) {
        const startMessage = exprsCount === 1 ? "Failed resolving expression in command." : `Failed resolving expression ${i + 1}/${exprsCount} in command.`;
        throw new Error(`${startMessage} ${errorToString(err)}`);
      }
    }
  }
  return {
    text,
    fds: streams
  };
  function handleReadableStream(createStream) {
    streams ??= new StreamFds();
    const fd = nextStreamFd++;
    streams.insertReader(fd, () => {
      const reader = createStream().getReader();
      return {
        ...readerFromStreamReader2(reader),
        [Symbol.dispose]() {
          reader.releaseLock();
        }
      };
    });
    text = text.trimEnd() + "&" + fd;
  }
  function handleWritableStream(createStream) {
    streams ??= new StreamFds();
    const fd = nextStreamFd++;
    streams.insertWriter(fd, () => {
      const stream = createStream();
      const writer = stream.getWriter();
      return {
        ...writerFromStreamWriter(writer),
        async [Symbol.asyncDispose]() {
          writer.releaseLock();
          try {
            await stream.close();
          } catch {
          }
        }
      };
    });
    text = text.trimEnd() + "&" + fd;
  }
}
function detectInputOrOutputRedirect(text) {
  text = text.trimEnd();
  if (text.endsWith(">")) {
    return ">";
  } else if (text.endsWith("<")) {
    return "<";
  } else {
    return void 0;
  }
}
function templateLiteralExprToString(expr, escape) {
  let result;
  if (typeof expr === "string") {
    result = expr;
  } else if (expr instanceof Array) {
    return expr.map((e) => templateLiteralExprToString(e, escape)).join(" ");
  } else if (expr instanceof CommandResult) {
    result = expr.stdout.replace(/\r?\n$/, "");
  } else if (expr instanceof CommandBuilder) {
    throw new Error(
      "Providing a command builder is not yet supported (https://github.com/dsherret/dax/issues/239). Await the command builder's text before using it in an expression (ex. await $`cmd`.text())."
    );
  } else if (typeof expr === "object" && expr.toString === Object.prototype.toString) {
    throw new Error("Provided object does not override `toString()`.");
  } else {
    result = `${expr}`;
  }
  return escape ? escape(result) : result;
}
function extend(target, source) {
  for (const prop in source) {
    if (Object.hasOwn(source, prop)) {
      target[prop] = source[prop];
    }
  }
  return target;
}
var reLeadingNewline = /^[ \t]*(?:\r\n|\r|\n)/;
var reTrailingNewline = /(?:\r\n|\r|\n)[ \t]*$/;
var reStartsWithNewlineOrIsEmpty = /^(?:[\r\n]|$)/;
var reDetectIndentation = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/;
var reOnlyWhitespaceWithAtLeastOneNewline = /^[ \t]*[\r\n][ \t\r\n]*$/;
function _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {
  let indentationLevel = 0;
  const match = strings[0].match(reDetectIndentation);
  if (match) {
    indentationLevel = match[1].length;
  }
  const reSource = `(\\r\\n|\\r|\\n).{0,${indentationLevel}}`;
  const reMatchIndent = new RegExp(reSource, "g");
  if (firstInterpolatedValueSetsIndentationLevel) {
    strings = strings.slice(1);
  }
  const { newline, trimLeadingNewline, trimTrailingNewline } = options;
  const normalizeNewlines = typeof newline === "string";
  const l = strings.length;
  const outdentedStrings = strings.map((v, i) => {
    v = v.replace(reMatchIndent, "$1");
    if (i === 0 && trimLeadingNewline) {
      v = v.replace(reLeadingNewline, "");
    }
    if (i === l - 1 && trimTrailingNewline) {
      v = v.replace(reTrailingNewline, "");
    }
    if (normalizeNewlines) {
      v = v.replace(/\r\n|\n|\r/g, (_) => newline);
    }
    return v;
  });
  return outdentedStrings;
}
function concatStringsAndValues(strings, values) {
  let ret = "";
  for (let i = 0, l = strings.length; i < l; i++) {
    ret += strings[i];
    if (i < l - 1) {
      ret += values[i];
    }
  }
  return ret;
}
function isTemplateStringsArray(v) {
  return Object.hasOwn(v, "raw") && Object.hasOwn(v, "length");
}
function createInstance(options) {
  const arrayAutoIndentCache = /* @__PURE__ */ new WeakMap();
  const arrayFirstInterpSetsIndentCache = /* @__PURE__ */ new WeakMap();
  function outdent(stringsOrOptions, ...values) {
    if (isTemplateStringsArray(stringsOrOptions)) {
      const strings = stringsOrOptions;
      const firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]);
      const cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;
      let renderedArray = cache.get(strings);
      if (!renderedArray) {
        renderedArray = _outdentArray(
          strings,
          firstInterpolatedValueSetsIndentationLevel,
          options
        );
        cache.set(strings, renderedArray);
      }
      if (values.length === 0) {
        return renderedArray[0];
      }
      const rendered = concatStringsAndValues(
        renderedArray,
        firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values
      );
      return rendered;
    } else {
      return createInstance(
        extend(extend({}, options), stringsOrOptions || {})
      );
    }
  }
  const fullOutdent = extend(outdent, {
    string(str) {
      return _outdentArray([str], false, options)[0];
    }
  });
  return fullOutdent;
}
var defaultOutdent = createInstance({
  trimLeadingNewline: true,
  trimTrailingNewline: true
});
function sleep(delay) {
  const ms = delayToMs(delay);
  return new Promise((resolve7) => setTimeout(resolve7, ms));
}
async function withRetries($local, errorLogger, opts) {
  const delayIterator = delayToIterator(opts.delay);
  for (let i = 0; i < opts.count; i++) {
    if (i > 0) {
      const nextDelay = delayIterator.next();
      if (!opts.quiet) {
        $local.logWarn(`Failed. Trying again in ${formatMillis(nextDelay)}...`);
      }
      await sleep(nextDelay);
      if (!opts.quiet) {
        $local.logStep(`Retrying attempt ${i + 1}/${opts.count}...`);
      }
    }
    try {
      return await opts.action();
    } catch (err) {
      errorLogger(err);
    }
  }
  throw new Error(`Failed after ${opts.count} attempts.`);
}
function cd(path) {
  if (typeof path === "string" || path instanceof URL) {
    path = new Path(path);
  } else if (!(path instanceof Path) && typeof path?.url === "string") {
    path = new Path(path.url).parentOrThrow();
  }
  Deno.chdir(path.toString());
}
function buildInitial$State(opts) {
  return {
    commandBuilder: new TreeBox(opts.commandBuilder ?? new CommandBuilder()),
    requestBuilder: opts.requestBuilder ?? new RequestBuilder(),
    // deno-lint-ignore no-console
    infoLogger: new LoggerTreeBox(console.error),
    // deno-lint-ignore no-console
    warnLogger: new LoggerTreeBox(console.error),
    // deno-lint-ignore no-console
    errorLogger: new LoggerTreeBox(console.error),
    indentLevel: new Box(0),
    extras: opts.extras
  };
}
var helperObject = {
  path: createPath,
  cd,
  escapeArg,
  stripAnsi(text) {
    return wasmInstance.strip_ansi_codes(text);
  },
  dedent: defaultOutdent,
  sleep,
  which(commandName) {
    if (commandName.toUpperCase() === "DENO") {
      return Promise.resolve(Deno.execPath());
    } else {
      return which(commandName, denoWhichRealEnv);
    }
  },
  whichSync(commandName) {
    if (commandName.toUpperCase() === "DENO") {
      return Deno.execPath();
    } else {
      return whichSync(commandName, denoWhichRealEnv);
    }
  }
};
function build$FromState(state) {
  const logDepthObj = {
    get logDepth() {
      return state.indentLevel.value;
    },
    set logDepth(value) {
      if (value < 0 || value % 1 !== 0) {
        throw new Error("Expected a positive integer.");
      }
      state.indentLevel.value = value;
    }
  };
  const result = Object.assign(
    (strings, ...exprs) => {
      const textState = template(strings, exprs);
      return state.commandBuilder.getValue()[setCommandTextStateSymbol](textState);
    },
    helperObject,
    logDepthObj,
    {
      build$(opts = {}) {
        return build$FromState({
          commandBuilder: opts.commandBuilder != null ? new TreeBox(opts.commandBuilder) : state.commandBuilder.createChild(),
          requestBuilder: opts.requestBuilder ?? state.requestBuilder,
          errorLogger: state.errorLogger.createChild(),
          infoLogger: state.infoLogger.createChild(),
          warnLogger: state.warnLogger.createChild(),
          indentLevel: state.indentLevel,
          extras: {
            ...state.extras,
            ...opts.extras
          }
        });
      },
      log(...data) {
        state.infoLogger.getValue()(getLogText(data));
      },
      logLight(...data) {
        state.infoLogger.getValue()(gray3(getLogText(data)));
      },
      logStep(firstArg, ...data) {
        logStep(firstArg, data, (t) => bold3(green2(t)), state.infoLogger.getValue());
      },
      logError(firstArg, ...data) {
        logStep(firstArg, data, (t) => bold3(red2(t)), state.errorLogger.getValue());
      },
      logWarn(firstArg, ...data) {
        logStep(firstArg, data, (t) => bold3(yellow(t)), state.warnLogger.getValue());
      },
      logGroup(labelOrAction, maybeAction) {
        const label = typeof labelOrAction === "string" ? labelOrAction : void 0;
        if (label) {
          state.infoLogger.getValue()(getLogText([label]));
        }
        state.indentLevel.value++;
        const action = label != null ? maybeAction : labelOrAction;
        if (action != null) {
          let wasPromise = false;
          try {
            const result2 = action();
            if (result2 instanceof Promise) {
              wasPromise = true;
              return result2.finally(() => {
                if (state.indentLevel.value > 0) {
                  state.indentLevel.value--;
                }
              });
            } else {
              return result2;
            }
          } finally {
            if (!wasPromise) {
              if (state.indentLevel.value > 0) {
                state.indentLevel.value--;
              }
            }
          }
        }
      },
      logGroupEnd() {
        if (state.indentLevel.value > 0) {
          state.indentLevel.value--;
        }
      },
      commandExists(commandName) {
        if (state.commandBuilder.getValue()[getRegisteredCommandNamesSymbol]().includes(commandName)) {
          return Promise.resolve(true);
        }
        return helperObject.which(commandName).then((c) => c != null);
      },
      commandExistsSync(commandName) {
        if (state.commandBuilder.getValue()[getRegisteredCommandNamesSymbol]().includes(commandName)) {
          return true;
        }
        return helperObject.whichSync(commandName) != null;
      },
      maybeConfirm,
      confirm,
      maybeSelect,
      select,
      maybeMultiSelect,
      multiSelect,
      maybePrompt,
      prompt,
      progress(messageOrText, options) {
        const opts = typeof messageOrText === "string" ? (() => {
          const words = messageOrText.split(" ");
          return {
            prefix: words[0],
            message: words.length > 1 ? words.slice(1).join(" ") : void 0,
            ...options
          };
        })() : messageOrText;
        return new ProgressBar((...data) => {
          state.infoLogger.getValue()(...data);
        }, opts);
      },
      setInfoLogger(logger3) {
        state.infoLogger.setValue(logger3);
      },
      setWarnLogger(logger3) {
        state.warnLogger.setValue(logger3);
      },
      setErrorLogger(logger3) {
        state.errorLogger.setValue(logger3);
        const commandBuilder = state.commandBuilder.getValue();
        commandBuilder.setPrintCommandLogger(
          (cmd) => logger3(white2(">"), blue(cmd))
        );
        state.commandBuilder.setValue(commandBuilder);
      },
      setPrintCommand(value) {
        const commandBuilder = state.commandBuilder.getValue().printCommand(value);
        state.commandBuilder.setValue(commandBuilder);
      },
      symbols,
      request(url) {
        return state.requestBuilder.url(url);
      },
      raw(strings, ...exprs) {
        const textState = templateRaw(strings, exprs);
        return state.commandBuilder.getValue()[setCommandTextStateSymbol](textState);
      },
      withRetries(opts) {
        return withRetries(result, state.errorLogger.getValue(), opts);
      }
    },
    state.extras
  );
  const keyName = "logDepth";
  Object.defineProperty(result, keyName, Object.getOwnPropertyDescriptor(logDepthObj, keyName));
  state.requestBuilder = state.requestBuilder[withProgressBarFactorySymbol]((message) => result.progress(message));
  return result;
  function getLogText(data) {
    const combinedText = data.map((d) => {
      const typeofD = typeof d;
      if (typeofD !== "object" && typeofD !== "undefined") {
        return d;
      } else {
        return Deno.inspect(d, { colors: true });
      }
    }).join(" ");
    if (state.indentLevel.value === 0) {
      return combinedText;
    } else {
      const indentText = "  ".repeat(state.indentLevel.value);
      return combinedText.split(/\n/).map((l) => `${indentText}${l}`).join("\n");
    }
  }
  function logStep(firstArg, data, colourize, logger3) {
    if (data.length === 0) {
      let i = 0;
      while (i < firstArg.length && firstArg[i] === " ") {
        i++;
      }
      while (i < firstArg.length && firstArg[i] !== " ") {
        i++;
      }
      firstArg = colourize(firstArg.substring(0, i)) + firstArg.substring(i);
    } else {
      firstArg = colourize(firstArg);
    }
    logger3(getLogText([firstArg, ...data]));
  }
}
var $ = build$FromState(buildInitial$State({
  isGlobal: true
}));
var mod_default = $;
function createPath(path) {
  if (path instanceof Path) {
    return path;
  } else {
    return new Path(path);
  }
}
var DesktopWebApp = (_hostname_dec = [help("Server hostname")], _port_dec = [help("Server port")], _openInBrowser_dec = [help("Open with chromium/chrome/gio if true or with the parameter"), type("boolean | string")], _openInBrowserAppMode_dec = [help("Add --app= to browser command if openInBrowser is used")], _update_dec = [hidden()], _assets_dec = [hidden()], _routes_dec = [hidden()], _onListen_dec = [hidden()], _assetsBundlePath_dec = [hidden()], _frontendPath_dec = [hidden()], _updateAssetsBundle_dec = [hidden()], _a = class {
  constructor(config) {
    __runInitializers(_init, 5, this);
    __privateAdd(this, _DesktopWebApp_instances);
    __publicField(this, "hostname", __runInitializers(_init, 8, this, "localhost")), __runInitializers(_init, 11, this);
    __publicField(this, "port", __runInitializers(_init, 12, this, 5555)), __runInitializers(_init, 15, this);
    __publicField(this, "openInBrowser", __runInitializers(_init, 16, this)), __runInitializers(_init, 19, this);
    __publicField(this, "openInBrowserAppMode", __runInitializers(_init, 20, this, false)), __runInitializers(_init, 23, this);
    __publicField(this, "update", __runInitializers(_init, 24, this, false)), __runInitializers(_init, 27, this);
    __publicField(this, "assets", __runInitializers(_init, 28, this, {})), __runInitializers(_init, 31, this);
    __publicField(this, "routes", __runInitializers(_init, 32, this, [])), __runInitializers(_init, 35, this);
    __publicField(this, "onListen", __runInitializers(_init, 36, this)), __runInitializers(_init, 39, this);
    __publicField(this, "assetsBundlePath", __runInitializers(_init, 40, this, "./assets_bundle.json")), __runInitializers(_init, 43, this);
    __publicField(this, "frontendPath", __runInitializers(_init, 44, this, "frontend/")), __runInitializers(_init, 47, this);
    const { assetsFromJson, ...configToAssign } = config;
    Object.assign(this, configToAssign);
    if (assetsFromJson) {
      this.assets = assetsFromJsonObj(assetsFromJson);
    }
  }
  async main() {
    await __privateMethod(this, _DesktopWebApp_instances, loadAssets_fn).call(this);
    const onListen = (params) => {
      this.port = params.port;
      this.hostname = params.hostname;
      console.log(`Listen on ${this.hostname}:${this.port}`);
      this.onListen?.(params);
      __privateMethod(this, _DesktopWebApp_instances, openInBrowser_fn).call(this);
    };
    const { hostname, port } = this;
    const handler = (r) => __privateMethod(this, _DesktopWebApp_instances, handleRequest_fn).call(this, r);
    Deno.serve({ hostname, port, onListen }, handler);
  }
  // update assets bundle from frontend files
  async updateAssetsBundle() {
    console.log("update assets bundle");
    const assets = await getAssetsFromFolder(this.frontendPath);
    await writeAssets(assets, this.assetsBundlePath);
    return assets;
  }
}, _init = __decoratorStart(null), _DesktopWebApp_instances = new WeakSet(), handleRequest_fn = function(request) {
  console.log(`handle ${request.url}`);
  for (const { route, exec } of this.routes ?? []) {
    const match = route.exec(request.url);
    if (match) {
      return exec(match, request);
    }
  }
  for (const file of Object.values(this.assets)) {
    if (file.route?.exec(request.url)) {
      const headers = { "Content-Type": file.type };
      return new Response(file.content, { status: 200, headers });
    }
  }
  return new Response("", { status: 404 });
}, openInBrowser_fn = async function() {
  if (this.openInBrowser) {
    const arg = this.openInBrowserAppMode ? "--app=" : "";
    if (this.openInBrowser === true) {
      if (await mod_default.commandExists("chromium")) {
        await mod_default`chromium ${arg}http://${this.hostname}:${this.port}/`;
      } else if (await mod_default.commandExists("google-chrome")) {
        await mod_default`google-chrome ${arg}http://${this.hostname}:${this.port}/`;
      } else {
        await mod_default`gio open http://${this.hostname}:${this.port}/`;
      }
    } else if (typeof this.openInBrowser === "string") {
      await mod_default`${this.openInBrowser} ${arg}http://${this.hostname}:${this.port}/`;
    }
  }
}, loadAssets_fn = async function() {
  if (this.update === true) {
    this.assets = await this.updateAssetsBundle();
  }
  if (this.assets["/index.html"]) {
    const route = new URLPattern({ pathname: "/" });
    this.assets["/"] = { ...this.assets["/index.html"], route };
  }
}, __decorateElement(_init, 1, "updateAssetsBundle", _updateAssetsBundle_dec, _a), __decorateElement(_init, 5, "hostname", _hostname_dec, _a), __decorateElement(_init, 5, "port", _port_dec, _a), __decorateElement(_init, 5, "openInBrowser", _openInBrowser_dec, _a), __decorateElement(_init, 5, "openInBrowserAppMode", _openInBrowserAppMode_dec, _a), __decorateElement(_init, 5, "update", _update_dec, _a), __decorateElement(_init, 5, "assets", _assets_dec, _a), __decorateElement(_init, 5, "routes", _routes_dec, _a), __decorateElement(_init, 5, "onListen", _onListen_dec, _a), __decorateElement(_init, 5, "assetsBundlePath", _assetsBundlePath_dec, _a), __decorateElement(_init, 5, "frontendPath", _frontendPath_dec, _a), __decoratorMetadata(_init, _a), _a);
async function getAssetsFromFolder(path) {
  const assetsUnordered = {};
  const frontendPath = mod_default.path(path).resolve().toString();
  for await (const entry of walk(frontendPath, { includeDirs: false })) {
    assert(entry.path.startsWith(frontendPath));
    const path2 = entry.path.substring(frontendPath.length);
    const type2 = contentType(extname3(path2)) ?? "";
    const content = await Deno.readFile(entry.path);
    const route = new URLPattern({ pathname: path2 });
    assetsUnordered[path2] = { type: type2, route, content };
    console.log({ path: path2, type: type2 });
  }
  const paths = Object.keys(assetsUnordered).sort();
  const assets = {};
  paths.forEach((path2) => assets[path2] = assetsUnordered[path2]);
  return assets;
}
async function writeAssets(assets, path) {
  const replacer = (key, value) => key === "content" ? encodeBase64(value) : key === "route" ? value.pathname : value;
  await mod_default.path(path).writeText(JSON.stringify(assets, replacer, "  "));
}
function assetsFromJsonObj(jsonObj) {
  const assets = {};
  Object.entries(jsonObj).forEach(([key, asset]) => assets[key] = {
    type: asset?.type,
    route: new URLPattern({ pathname: asset.route }),
    content: decodeBase64(asset.content)
  });
  return assets;
}
var assets_bundle_default = {
  "/assets/index-C2BprT5E.css": {
    type: "text/css; charset=UTF-8",
    route: "/assets/index-C2BprT5E.css",
    content: "Ym9keXttYXJnaW46MTBweDtmb250LWZhbWlseTotYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sT3h5Z2VuLFVidW50dSxDYW50YXJlbGwsRmlyYSBTYW5zLERyb2lkIFNhbnMsSGVsdmV0aWNhIE5ldWUsc2Fucy1zZXJpZjstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWV9Lm1haW57bWFyZ2luOjEwcHh9LmJ0bi1wYXJ0e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5idG4tcGFydCBidXR0b257bWFyZ2luOjEwcHh9Lk11aVRhYmxlQ2VsbC1yb290e3BhZGRpbmc6NHB4IWltcG9ydGFudH0ubGFzdC1pc3N1ZXMgYnV0dG9ue3RleHQtYWxpZ246bGVmdDttYXJnaW46NHB4fS5pc3N1ZS1idG57dGV4dC10cmFuc2Zvcm06bm9uZSFpbXBvcnRhbnR9Zm9ybSAuTXVpRm9ybUNvbnRyb2wtcm9vdHttYXJnaW46MjBweH1mb3Jte2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXJ9dGQsdGh7Ym9yZGVyLWxlZnQ6c29saWQgMXB4ICNkZGRkZGR9LnJvdy1oZWFkZXJ7bWF4LXdpZHRoOjI1MHB4fXRyLm9kZHtiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y3Zjd9dHIub2RkIC50b3RhbHtiYWNrZ3JvdW5kLWNvbG9yOiNkZWRlZGV9dHIuZXZlbntiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTZ9dHIuZXZlbiAudG90YWx7YmFja2dyb3VuZC1jb2xvcjojY2ZjZmNmfS50b3RhbC1yb3d7YmFja2dyb3VuZC1jb2xvcjojYzJjNmRjfXRye3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuNnN9dHIgdGQsdHIgdGgsdHIgdGQgZGl2LHRyIHRoIGRpdnt0cmFuc2l0aW9uOm1heC1oZWlnaHQgLjZzLGxpbmUtaGVpZ2h0IC42cyxwYWRkaW5nIC42cyxib3JkZXIgLjZzLGJhY2tncm91bmQtY29sb3IgLjZzfS5pc3N1ZS1lbC1leGl0LWFjdGl2ZSB0ZCwuaXNzdWUtZWwtZXhpdC1hY3RpdmUgdGh7Ym9yZGVyOjAhaW1wb3J0YW50O3BhZGRpbmctdG9wOjAhaW1wb3J0YW50O3BhZGRpbmctYm90dG9tOjAhaW1wb3J0YW50O2xpbmUtaGVpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjojZmZkY2RjIWltcG9ydGFudDtvdmVyZmxvdzpoaWRkZW59Lmlzc3VlLWVsLWV4aXQtYWN0aXZlIHRkIGRpdiwuaXNzdWUtZWwtZXhpdC1hY3RpdmUgdGggZGl2e21heC1oZWlnaHQ6MDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmRjZGMhaW1wb3J0YW50fS5pc3N1ZS1lbC1lbnRlciB0ZCwuaXNzdWUtZWwtZW50ZXIgdGh7bGluZS1oZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW59Lmlzc3VlLWVsLWVudGVyIHRkIGRpdiwuaXNzdWUtZWwtZW50ZXIgdGggZGl2e21heC1oZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW59Lmlzc3VlLWVsLWVudGVyLmlzc3VlLWVsLWVudGVyLWFjdGl2ZSB0ZCwuaXNzdWUtZWwtZW50ZXIuaXNzdWUtZWwtZW50ZXItYWN0aXZlIHRoe2xpbmUtaGVpZ2h0OjEuNDN9Lmlzc3VlLWVsLWVudGVyLmlzc3VlLWVsLWVudGVyLWFjdGl2ZSB0ZCBkaXYsLmlzc3VlLWVsLWVudGVyLmlzc3VlLWVsLWVudGVyLWFjdGl2ZSB0aCBkaXZ7bWF4LWhlaWdodDoyMDBweCFpbXBvcnRhbnR9LmFkZC1idXR0b257cG9zaXRpb246cmVsYXRpdmV9LmFkZC1idXR0b24gYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO3dpZHRoOjEwMCU7ZmxleDoxO2JhY2tncm91bmQtY29sb3I6I2MyYzZkY30uaXNzdWV7bWF4LXdpZHRoOjE1MHB4O3RleHQtYWxpZ246Y2VudGVyfS5pc3N1ZS1zdW1tYXJ5e2ZvbnQtc2l6ZToxNnB4fS5jb21tZW50e21hcmdpbi1sZWZ0OjVweCFpbXBvcnRhbnR9LmNvbW1lbnQgaW5wdXR7Y29sb3I6I2QxOGQwMH0uaG91cnttYXgtd2lkdGg6NjBweDt0ZXh0LWFsaWduOmNlbnRlcn0uaG91ciBpbnB1dHt0ZXh0LWFsaWduOmNlbnRlcn0uaG91ciAuTXVpSW5wdXQtdW5kZXJsaW5lOmJlZm9yZXtib3JkZXItYm90dG9tOjB9LmhvdXItY2VsbHtkaXNwbGF5OmZsZXg7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7cmlnaHQ6MDtsZWZ0OjB9LmhvdXItY2VsbCBidXR0b257ZmxleDoxO2NvbG9yOiNhMWExYTF9LmhvdXItY2VsbCBkaXZ7anVzdGlmeS1jb250ZW50OmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS53b3JrTG9nRGF0ZXttYXgtd2lkdGg6MjAwcHg7dGV4dC1hbGlnbjpjZW50ZXJ9LndvcmtMb2dEYXRlIGlucHV0e3RleHQtYWxpZ246Y2VudGVyfQo="
  },
  "/assets/index-pzLXgDYu.js": {
    type: "text/javascript; charset=UTF-8",
    route: "/assets/index-pzLXgDYu.js",
    content: "dmFyIHMxPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgYTE9KGUsdCxuKT0+dCBpbiBlP3MxKGUsdCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pOmVbdF09bjt2YXIgdGk9KGUsdCxuKT0+YTEoZSx0eXBlb2YgdCE9InN5bWJvbCI/dCsiIjp0LG4pO2Z1bmN0aW9uIGwxKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTtpZih0eXBlb2YgciE9InN0cmluZyImJiFBcnJheS5pc0FycmF5KHIpKXtmb3IoY29uc3QgbyBpbiByKWlmKG8hPT0iZGVmYXVsdCImJiEobyBpbiBlKSl7Y29uc3QgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsbyk7aSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbyxpLmdldD9pOntlbnVtZXJhYmxlOiEwLGdldDooKT0+cltvXX0pfX19cmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pKX0oZnVuY3Rpb24oKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImxpbmsiKS5yZWxMaXN0O2lmKHQmJnQuc3VwcG9ydHMmJnQuc3VwcG9ydHMoIm1vZHVsZXByZWxvYWQiKSlyZXR1cm47Zm9yKGNvbnN0IG8gb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9Im1vZHVsZXByZWxvYWQiXScpKXIobyk7bmV3IE11dGF0aW9uT2JzZXJ2ZXIobz0+e2Zvcihjb25zdCBpIG9mIG8paWYoaS50eXBlPT09ImNoaWxkTGlzdCIpZm9yKGNvbnN0IHMgb2YgaS5hZGRlZE5vZGVzKXMudGFnTmFtZT09PSJMSU5LIiYmcy5yZWw9PT0ibW9kdWxlcHJlbG9hZCImJnIocyl9KS5vYnNlcnZlKGRvY3VtZW50LHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pO2Z1bmN0aW9uIG4obyl7Y29uc3QgaT17fTtyZXR1cm4gby5pbnRlZ3JpdHkmJihpLmludGVncml0eT1vLmludGVncml0eSksby5yZWZlcnJlclBvbGljeSYmKGkucmVmZXJyZXJQb2xpY3k9by5yZWZlcnJlclBvbGljeSksby5jcm9zc09yaWdpbj09PSJ1c2UtY3JlZGVudGlhbHMiP2kuY3JlZGVudGlhbHM9ImluY2x1ZGUiOm8uY3Jvc3NPcmlnaW49PT0iYW5vbnltb3VzIj9pLmNyZWRlbnRpYWxzPSJvbWl0IjppLmNyZWRlbnRpYWxzPSJzYW1lLW9yaWdpbiIsaX1mdW5jdGlvbiByKG8pe2lmKG8uZXApcmV0dXJuO28uZXA9ITA7Y29uc3QgaT1uKG8pO2ZldGNoKG8uaHJlZixpKX19KSgpO3ZhciBpZz10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PCJ1Ij93aW5kb3c6dHlwZW9mIGdsb2JhbDwidSI/Z2xvYmFsOnR5cGVvZiBzZWxmPCJ1Ij9zZWxmOnt9O2Z1bmN0aW9uIFJkKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCJkZWZhdWx0Iik/ZS5kZWZhdWx0OmV9dmFyIHNnPXtleHBvcnRzOnt9fSx1bD17fSxhZz17ZXhwb3J0czp7fX0sYWU9e307LyoqCiAqIEBsaWNlbnNlIFJlYWN0CiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzCiAqCiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLgogKgogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi92YXIgcHM9U3ltYm9sLmZvcigicmVhY3QuZWxlbWVudCIpLHUxPVN5bWJvbC5mb3IoInJlYWN0LnBvcnRhbCIpLGMxPVN5bWJvbC5mb3IoInJlYWN0LmZyYWdtZW50IiksZDE9U3ltYm9sLmZvcigicmVhY3Quc3RyaWN0X21vZGUiKSxmMT1TeW1ib2wuZm9yKCJyZWFjdC5wcm9maWxlciIpLHAxPVN5bWJvbC5mb3IoInJlYWN0LnByb3ZpZGVyIiksbTE9U3ltYm9sLmZvcigicmVhY3QuY29udGV4dCIpLGgxPVN5bWJvbC5mb3IoInJlYWN0LmZvcndhcmRfcmVmIiksZzE9U3ltYm9sLmZvcigicmVhY3Quc3VzcGVuc2UiKSx5MT1TeW1ib2wuZm9yKCJyZWFjdC5tZW1vIiksdjE9U3ltYm9sLmZvcigicmVhY3QubGF6eSIpLFNwPVN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiB3MShlKXtyZXR1cm4gZT09PW51bGx8fHR5cGVvZiBlIT0ib2JqZWN0Ij9udWxsOihlPVNwJiZlW1NwXXx8ZVsiQEBpdGVyYXRvciJdLHR5cGVvZiBlPT0iZnVuY3Rpb24iP2U6bnVsbCl9dmFyIGxnPXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fSx1Zz1PYmplY3QuYXNzaWduLGNnPXt9O2Z1bmN0aW9uIFlvKGUsdCxuKXt0aGlzLnByb3BzPWUsdGhpcy5jb250ZXh0PXQsdGhpcy5yZWZzPWNnLHRoaXMudXBkYXRlcj1ufHxsZ31Zby5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtZby5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgZSE9Im9iamVjdCImJnR5cGVvZiBlIT0iZnVuY3Rpb24iJiZlIT1udWxsKXRocm93IEVycm9yKCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4iKTt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsZSx0LCJzZXRTdGF0ZSIpfTtZby5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oZSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGUsImZvcmNlVXBkYXRlIil9O2Z1bmN0aW9uIGRnKCl7fWRnLnByb3RvdHlwZT1Zby5wcm90b3R5cGU7ZnVuY3Rpb24gVGQoZSx0LG4pe3RoaXMucHJvcHM9ZSx0aGlzLmNvbnRleHQ9dCx0aGlzLnJlZnM9Y2csdGhpcy51cGRhdGVyPW58fGxnfXZhciBQZD1UZC5wcm90b3R5cGU9bmV3IGRnO1BkLmNvbnN0cnVjdG9yPVRkO3VnKFBkLFlvLnByb3RvdHlwZSk7UGQuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIHhwPUFycmF5LmlzQXJyYXksZmc9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwkZD17Y3VycmVudDpudWxsfSxwZz17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O2Z1bmN0aW9uIG1nKGUsdCxuKXt2YXIgcixvPXt9LGk9bnVsbCxzPW51bGw7aWYodCE9bnVsbClmb3IociBpbiB0LnJlZiE9PXZvaWQgMCYmKHM9dC5yZWYpLHQua2V5IT09dm9pZCAwJiYoaT0iIit0LmtleSksdClmZy5jYWxsKHQscikmJiFwZy5oYXNPd25Qcm9wZXJ0eShyKSYmKG9bcl09dFtyXSk7dmFyIGE9YXJndW1lbnRzLmxlbmd0aC0yO2lmKGE9PT0xKW8uY2hpbGRyZW49bjtlbHNlIGlmKDE8YSl7Zm9yKHZhciBsPUFycmF5KGEpLHU9MDt1PGE7dSsrKWxbdV09YXJndW1lbnRzW3UrMl07by5jaGlsZHJlbj1sfWlmKGUmJmUuZGVmYXVsdFByb3BzKWZvcihyIGluIGE9ZS5kZWZhdWx0UHJvcHMsYSlvW3JdPT09dm9pZCAwJiYob1tyXT1hW3JdKTtyZXR1cm57JCR0eXBlb2Y6cHMsdHlwZTplLGtleTppLHJlZjpzLHByb3BzOm8sX293bmVyOiRkLmN1cnJlbnR9fWZ1bmN0aW9uIFMxKGUsdCl7cmV0dXJueyQkdHlwZW9mOnBzLHR5cGU6ZS50eXBlLGtleTp0LHJlZjplLnJlZixwcm9wczplLnByb3BzLF9vd25lcjplLl9vd25lcn19ZnVuY3Rpb24gT2QoZSl7cmV0dXJuIHR5cGVvZiBlPT0ib2JqZWN0IiYmZSE9PW51bGwmJmUuJCR0eXBlb2Y9PT1wc31mdW5jdGlvbiB4MShlKXt2YXIgdD17Ij0iOiI9MCIsIjoiOiI9MiJ9O3JldHVybiIkIitlLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihuKXtyZXR1cm4gdFtuXX0pfXZhciBDcD0vXC8rL2c7ZnVuY3Rpb24gdnUoZSx0KXtyZXR1cm4gdHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbCYmZS5rZXkhPW51bGw/eDEoIiIrZS5rZXkpOnQudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIG5hKGUsdCxuLHIsbyl7dmFyIGk9dHlwZW9mIGU7KGk9PT0idW5kZWZpbmVkInx8aT09PSJib29sZWFuIikmJihlPW51bGwpO3ZhciBzPSExO2lmKGU9PT1udWxsKXM9ITA7ZWxzZSBzd2l0Y2goaSl7Y2FzZSJzdHJpbmciOmNhc2UibnVtYmVyIjpzPSEwO2JyZWFrO2Nhc2Uib2JqZWN0Ijpzd2l0Y2goZS4kJHR5cGVvZil7Y2FzZSBwczpjYXNlIHUxOnM9ITB9fWlmKHMpcmV0dXJuIHM9ZSxvPW8ocyksZT1yPT09IiI/Ii4iK3Z1KHMsMCk6cix4cChvKT8obj0iIixlIT1udWxsJiYobj1lLnJlcGxhY2UoQ3AsIiQmLyIpKyIvIiksbmEobyx0LG4sIiIsZnVuY3Rpb24odSl7cmV0dXJuIHV9KSk6byE9bnVsbCYmKE9kKG8pJiYobz1TMShvLG4rKCFvLmtleXx8cyYmcy5rZXk9PT1vLmtleT8iIjooIiIrby5rZXkpLnJlcGxhY2UoQ3AsIiQmLyIpKyIvIikrZSkpLHQucHVzaChvKSksMTtpZihzPTAscj1yPT09IiI/Ii4iOnIrIjoiLHhwKGUpKWZvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSsrKXtpPWVbYV07dmFyIGw9cit2dShpLGEpO3MrPW5hKGksdCxuLGwsbyl9ZWxzZSBpZihsPXcxKGUpLHR5cGVvZiBsPT0iZnVuY3Rpb24iKWZvcihlPWwuY2FsbChlKSxhPTA7IShpPWUubmV4dCgpKS5kb25lOylpPWkudmFsdWUsbD1yK3Z1KGksYSsrKSxzKz1uYShpLHQsbixsLG8pO2Vsc2UgaWYoaT09PSJvYmplY3QiKXRocm93IHQ9U3RyaW5nKGUpLEVycm9yKCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICIrKHQ9PT0iW29iamVjdCBPYmplY3RdIj8ib2JqZWN0IHdpdGgga2V5cyB7IitPYmplY3Qua2V5cyhlKS5qb2luKCIsICIpKyJ9Ijp0KSsiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLiIpO3JldHVybiBzfWZ1bmN0aW9uIFBzKGUsdCxuKXtpZihlPT1udWxsKXJldHVybiBlO3ZhciByPVtdLG89MDtyZXR1cm4gbmEoZSxyLCIiLCIiLGZ1bmN0aW9uKGkpe3JldHVybiB0LmNhbGwobixpLG8rKyl9KSxyfWZ1bmN0aW9uIEMxKGUpe2lmKGUuX3N0YXR1cz09PS0xKXt2YXIgdD1lLl9yZXN1bHQ7dD10KCksdC50aGVuKGZ1bmN0aW9uKG4peyhlLl9zdGF0dXM9PT0wfHxlLl9zdGF0dXM9PT0tMSkmJihlLl9zdGF0dXM9MSxlLl9yZXN1bHQ9bil9LGZ1bmN0aW9uKG4peyhlLl9zdGF0dXM9PT0wfHxlLl9zdGF0dXM9PT0tMSkmJihlLl9zdGF0dXM9MixlLl9yZXN1bHQ9bil9KSxlLl9zdGF0dXM9PT0tMSYmKGUuX3N0YXR1cz0wLGUuX3Jlc3VsdD10KX1pZihlLl9zdGF0dXM9PT0xKXJldHVybiBlLl9yZXN1bHQuZGVmYXVsdDt0aHJvdyBlLl9yZXN1bHR9dmFyIHZ0PXtjdXJyZW50Om51bGx9LHJhPXt0cmFuc2l0aW9uOm51bGx9LGIxPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOnZ0LFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOnJhLFJlYWN0Q3VycmVudE93bmVyOiRkfTtmdW5jdGlvbiBoZygpe3Rocm93IEVycm9yKCJhY3QoLi4uKSBpcyBub3Qgc3VwcG9ydGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIFJlYWN0LiIpfWFlLkNoaWxkcmVuPXttYXA6UHMsZm9yRWFjaDpmdW5jdGlvbihlLHQsbil7UHMoZSxmdW5jdGlvbigpe3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxuKX0sY291bnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4gUHMoZSxmdW5jdGlvbigpe3QrK30pLHR9LHRvQXJyYXk6ZnVuY3Rpb24oZSl7cmV0dXJuIFBzKGUsZnVuY3Rpb24odCl7cmV0dXJuIHR9KXx8W119LG9ubHk6ZnVuY3Rpb24oZSl7aWYoIU9kKGUpKXRocm93IEVycm9yKCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4iKTtyZXR1cm4gZX19O2FlLkNvbXBvbmVudD1ZbzthZS5GcmFnbWVudD1jMTthZS5Qcm9maWxlcj1mMTthZS5QdXJlQ29tcG9uZW50PVRkO2FlLlN0cmljdE1vZGU9ZDE7YWUuU3VzcGVuc2U9ZzE7YWUuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9YjE7YWUuYWN0PWhnO2FlLmNsb25lRWxlbWVudD1mdW5jdGlvbihlLHQsbil7aWYoZT09bnVsbCl0aHJvdyBFcnJvcigiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgIitlKyIuIik7dmFyIHI9dWcoe30sZS5wcm9wcyksbz1lLmtleSxpPWUucmVmLHM9ZS5fb3duZXI7aWYodCE9bnVsbCl7aWYodC5yZWYhPT12b2lkIDAmJihpPXQucmVmLHM9JGQuY3VycmVudCksdC5rZXkhPT12b2lkIDAmJihvPSIiK3Qua2V5KSxlLnR5cGUmJmUudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGE9ZS50eXBlLmRlZmF1bHRQcm9wcztmb3IobCBpbiB0KWZnLmNhbGwodCxsKSYmIXBnLmhhc093blByb3BlcnR5KGwpJiYocltsXT10W2xdPT09dm9pZCAwJiZhIT09dm9pZCAwP2FbbF06dFtsXSl9dmFyIGw9YXJndW1lbnRzLmxlbmd0aC0yO2lmKGw9PT0xKXIuY2hpbGRyZW49bjtlbHNlIGlmKDE8bCl7YT1BcnJheShsKTtmb3IodmFyIHU9MDt1PGw7dSsrKWFbdV09YXJndW1lbnRzW3UrMl07ci5jaGlsZHJlbj1hfXJldHVybnskJHR5cGVvZjpwcyx0eXBlOmUudHlwZSxrZXk6byxyZWY6aSxwcm9wczpyLF9vd25lcjpzfX07YWUuY3JlYXRlQ29udGV4dD1mdW5jdGlvbihlKXtyZXR1cm4gZT17JCR0eXBlb2Y6bTEsX2N1cnJlbnRWYWx1ZTplLF9jdXJyZW50VmFsdWUyOmUsX3RocmVhZENvdW50OjAsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsLF9kZWZhdWx0VmFsdWU6bnVsbCxfZ2xvYmFsTmFtZTpudWxsfSxlLlByb3ZpZGVyPXskJHR5cGVvZjpwMSxfY29udGV4dDplfSxlLkNvbnN1bWVyPWV9O2FlLmNyZWF0ZUVsZW1lbnQ9bWc7YWUuY3JlYXRlRmFjdG9yeT1mdW5jdGlvbihlKXt2YXIgdD1tZy5iaW5kKG51bGwsZSk7cmV0dXJuIHQudHlwZT1lLHR9O2FlLmNyZWF0ZVJlZj1mdW5jdGlvbigpe3JldHVybntjdXJyZW50Om51bGx9fTthZS5mb3J3YXJkUmVmPWZ1bmN0aW9uKGUpe3JldHVybnskJHR5cGVvZjpoMSxyZW5kZXI6ZX19O2FlLmlzVmFsaWRFbGVtZW50PU9kO2FlLmxhenk9ZnVuY3Rpb24oZSl7cmV0dXJueyQkdHlwZW9mOnYxLF9wYXlsb2FkOntfc3RhdHVzOi0xLF9yZXN1bHQ6ZX0sX2luaXQ6QzF9fTthZS5tZW1vPWZ1bmN0aW9uKGUsdCl7cmV0dXJueyQkdHlwZW9mOnkxLHR5cGU6ZSxjb21wYXJlOnQ9PT12b2lkIDA/bnVsbDp0fX07YWUuc3RhcnRUcmFuc2l0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0PXJhLnRyYW5zaXRpb247cmEudHJhbnNpdGlvbj17fTt0cnl7ZSgpfWZpbmFsbHl7cmEudHJhbnNpdGlvbj10fX07YWUudW5zdGFibGVfYWN0PWhnO2FlLnVzZUNhbGxiYWNrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZ0LmN1cnJlbnQudXNlQ2FsbGJhY2soZSx0KX07YWUudXNlQ29udGV4dD1mdW5jdGlvbihlKXtyZXR1cm4gdnQuY3VycmVudC51c2VDb250ZXh0KGUpfTthZS51c2VEZWJ1Z1ZhbHVlPWZ1bmN0aW9uKCl7fTthZS51c2VEZWZlcnJlZFZhbHVlPWZ1bmN0aW9uKGUpe3JldHVybiB2dC5jdXJyZW50LnVzZURlZmVycmVkVmFsdWUoZSl9O2FlLnVzZUVmZmVjdD1mdW5jdGlvbihlLHQpe3JldHVybiB2dC5jdXJyZW50LnVzZUVmZmVjdChlLHQpfTthZS51c2VJZD1mdW5jdGlvbigpe3JldHVybiB2dC5jdXJyZW50LnVzZUlkKCl9O2FlLnVzZUltcGVyYXRpdmVIYW5kbGU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2dC5jdXJyZW50LnVzZUltcGVyYXRpdmVIYW5kbGUoZSx0LG4pfTthZS51c2VJbnNlcnRpb25FZmZlY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdnQuY3VycmVudC51c2VJbnNlcnRpb25FZmZlY3QoZSx0KX07YWUudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZ0LmN1cnJlbnQudXNlTGF5b3V0RWZmZWN0KGUsdCl9O2FlLnVzZU1lbW89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdnQuY3VycmVudC51c2VNZW1vKGUsdCl9O2FlLnVzZVJlZHVjZXI9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2dC5jdXJyZW50LnVzZVJlZHVjZXIoZSx0LG4pfTthZS51c2VSZWY9ZnVuY3Rpb24oZSl7cmV0dXJuIHZ0LmN1cnJlbnQudXNlUmVmKGUpfTthZS51c2VTdGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdnQuY3VycmVudC51c2VTdGF0ZShlKX07YWUudXNlU3luY0V4dGVybmFsU3RvcmU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2dC5jdXJyZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlKGUsdCxuKX07YWUudXNlVHJhbnNpdGlvbj1mdW5jdGlvbigpe3JldHVybiB2dC5jdXJyZW50LnVzZVRyYW5zaXRpb24oKX07YWUudmVyc2lvbj0iMTguMy4xIjthZy5leHBvcnRzPWFlO3ZhciBDPWFnLmV4cG9ydHM7Y29uc3QgSXQ9UmQoQyksRGk9bDEoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6SXR9LFtDXSk7LyoqCiAqIEBsaWNlbnNlIFJlYWN0CiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzCiAqCiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLgogKgogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi92YXIgazE9QyxFMT1TeW1ib2wuZm9yKCJyZWFjdC5lbGVtZW50IiksUjE9U3ltYm9sLmZvcigicmVhY3QuZnJhZ21lbnQiKSxUMT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFAxPWsxLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCQxPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07ZnVuY3Rpb24gZ2coZSx0LG4pe3ZhciByLG89e30saT1udWxsLHM9bnVsbDtuIT09dm9pZCAwJiYoaT0iIituKSx0LmtleSE9PXZvaWQgMCYmKGk9IiIrdC5rZXkpLHQucmVmIT09dm9pZCAwJiYocz10LnJlZik7Zm9yKHIgaW4gdClUMS5jYWxsKHQscikmJiEkMS5oYXNPd25Qcm9wZXJ0eShyKSYmKG9bcl09dFtyXSk7aWYoZSYmZS5kZWZhdWx0UHJvcHMpZm9yKHIgaW4gdD1lLmRlZmF1bHRQcm9wcyx0KW9bcl09PT12b2lkIDAmJihvW3JdPXRbcl0pO3JldHVybnskJHR5cGVvZjpFMSx0eXBlOmUsa2V5OmkscmVmOnMscHJvcHM6byxfb3duZXI6UDEuY3VycmVudH19dWwuRnJhZ21lbnQ9UjE7dWwuanN4PWdnO3VsLmpzeHM9Z2c7c2cuZXhwb3J0cz11bDt2YXIgaz1zZy5leHBvcnRzLE8xPXt9Oy8qKgogKiBAbGljZW5zZSBSZWFjdAogKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzCiAqCiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLgogKgogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi92YXIgbXM9QztmdW5jdGlvbiBNMShlLHQpe3JldHVybiBlPT09dCYmKGUhPT0wfHwxL2U9PT0xL3QpfHxlIT09ZSYmdCE9PXR9dmFyIF8xPXR5cGVvZiBPYmplY3QuaXM9PSJmdW5jdGlvbiI/T2JqZWN0LmlzOk0xLE4xPW1zLnVzZVN5bmNFeHRlcm5hbFN0b3JlLEkxPW1zLnVzZVJlZixBMT1tcy51c2VFZmZlY3QsejE9bXMudXNlTWVtbyxMMT1tcy51c2VEZWJ1Z1ZhbHVlO08xLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yPWZ1bmN0aW9uKGUsdCxuLHIsbyl7dmFyIGk9STEobnVsbCk7aWYoaS5jdXJyZW50PT09bnVsbCl7dmFyIHM9e2hhc1ZhbHVlOiExLHZhbHVlOm51bGx9O2kuY3VycmVudD1zfWVsc2Ugcz1pLmN1cnJlbnQ7aT16MShmdW5jdGlvbigpe2Z1bmN0aW9uIGwodil7aWYoIXUpe2lmKHU9ITAsYz12LHY9cih2KSxvIT09dm9pZCAwJiZzLmhhc1ZhbHVlKXt2YXIgdz1zLnZhbHVlO2lmKG8odyx2KSlyZXR1cm4gZD13fXJldHVybiBkPXZ9aWYodz1kLF8xKGMsdikpcmV0dXJuIHc7dmFyIFM9cih2KTtyZXR1cm4gbyE9PXZvaWQgMCYmbyh3LFMpP3c6KGM9dixkPVMpfXZhciB1PSExLGMsZCxtPW49PT12b2lkIDA/bnVsbDpuO3JldHVybltmdW5jdGlvbigpe3JldHVybiBsKHQoKSl9LG09PT1udWxsP3ZvaWQgMDpmdW5jdGlvbigpe3JldHVybiBsKG0oKSl9XX0sW3QsbixyLG9dKTt2YXIgYT1OMShlLGlbMF0saVsxXSk7cmV0dXJuIEExKGZ1bmN0aW9uKCl7cy5oYXNWYWx1ZT0hMCxzLnZhbHVlPWF9LFthXSksTDEoYSksYX07dmFyIFNlPSJkZWZhdWx0ImluIERpP0l0OkRpLGJwPVN5bWJvbC5mb3IoInJlYWN0LXJlZHV4LWNvbnRleHQiKSxrcD10eXBlb2YgZ2xvYmFsVGhpczwidSI/Z2xvYmFsVGhpczp7fTtmdW5jdGlvbiBqMSgpe2lmKCFTZS5jcmVhdGVDb250ZXh0KXJldHVybnt9O2NvbnN0IGU9a3BbYnBdPz8oa3BbYnBdPW5ldyBNYXApO2xldCB0PWUuZ2V0KFNlLmNyZWF0ZUNvbnRleHQpO3JldHVybiB0fHwodD1TZS5jcmVhdGVDb250ZXh0KG51bGwpLGUuc2V0KFNlLmNyZWF0ZUNvbnRleHQsdCkpLHR9dmFyIHlnPWoxKCksRDE9KCk9Pnt0aHJvdyBuZXcgRXJyb3IoInVTRVMgbm90IGluaXRpYWxpemVkISIpfSxGMT1TeW1ib2wuZm9yKCJyZWFjdC5lbGVtZW50IiksQjE9U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIiksVzE9U3ltYm9sLmZvcigicmVhY3QuZnJhZ21lbnQiKSxVMT1TeW1ib2wuZm9yKCJyZWFjdC5zdHJpY3RfbW9kZSIpLEgxPVN5bWJvbC5mb3IoInJlYWN0LnByb2ZpbGVyIiksVjE9U3ltYm9sLmZvcigicmVhY3QucHJvdmlkZXIiKSxLMT1TeW1ib2wuZm9yKCJyZWFjdC5jb250ZXh0IiksWTE9U3ltYm9sLmZvcigicmVhY3Quc2VydmVyX2NvbnRleHQiKSx2Zz1TeW1ib2wuZm9yKCJyZWFjdC5mb3J3YXJkX3JlZiIpLEcxPVN5bWJvbC5mb3IoInJlYWN0LnN1c3BlbnNlIiksUTE9U3ltYm9sLmZvcigicmVhY3Quc3VzcGVuc2VfbGlzdCIpLE1kPVN5bWJvbC5mb3IoInJlYWN0Lm1lbW8iKSxYMT1TeW1ib2wuZm9yKCJyZWFjdC5sYXp5IikscTE9dmcsWjE9TWQ7ZnVuY3Rpb24gSjEoZSl7aWYodHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbCl7Y29uc3QgdD1lLiQkdHlwZW9mO3N3aXRjaCh0KXtjYXNlIEYxOntjb25zdCBuPWUudHlwZTtzd2l0Y2gobil7Y2FzZSBXMTpjYXNlIEgxOmNhc2UgVTE6Y2FzZSBHMTpjYXNlIFExOnJldHVybiBuO2RlZmF1bHQ6e2NvbnN0IHI9biYmbi4kJHR5cGVvZjtzd2l0Y2gocil7Y2FzZSBZMTpjYXNlIEsxOmNhc2Ugdmc6Y2FzZSBYMTpjYXNlIE1kOmNhc2UgVjE6cmV0dXJuIHI7ZGVmYXVsdDpyZXR1cm4gdH19fX1jYXNlIEIxOnJldHVybiB0fX19ZnVuY3Rpb24gZXcoZSl7cmV0dXJuIEoxKGUpPT09TWR9ZnVuY3Rpb24gdHcoZSx0LG4scix7YXJlU3RhdGVzRXF1YWw6byxhcmVPd25Qcm9wc0VxdWFsOmksYXJlU3RhdGVQcm9wc0VxdWFsOnN9KXtsZXQgYT0hMSxsLHUsYyxkLG07ZnVuY3Rpb24gdihnLGYpe3JldHVybiBsPWcsdT1mLGM9ZShsLHUpLGQ9dChyLHUpLG09bihjLGQsdSksYT0hMCxtfWZ1bmN0aW9uIHcoKXtyZXR1cm4gYz1lKGwsdSksdC5kZXBlbmRzT25Pd25Qcm9wcyYmKGQ9dChyLHUpKSxtPW4oYyxkLHUpLG19ZnVuY3Rpb24gUygpe3JldHVybiBlLmRlcGVuZHNPbk93blByb3BzJiYoYz1lKGwsdSkpLHQuZGVwZW5kc09uT3duUHJvcHMmJihkPXQocix1KSksbT1uKGMsZCx1KSxtfWZ1bmN0aW9uIHgoKXtjb25zdCBnPWUobCx1KSxmPSFzKGcsYyk7cmV0dXJuIGM9ZyxmJiYobT1uKGMsZCx1KSksbX1mdW5jdGlvbiBoKGcsZil7Y29uc3QgeT0haShmLHUpLGI9IW8oZyxsLGYsdSk7cmV0dXJuIGw9Zyx1PWYseSYmYj93KCk6eT9TKCk6Yj94KCk6bX1yZXR1cm4gZnVuY3Rpb24oZix5KXtyZXR1cm4gYT9oKGYseSk6dihmLHkpfX1mdW5jdGlvbiBudyhlLHtpbml0TWFwU3RhdGVUb1Byb3BzOnQsaW5pdE1hcERpc3BhdGNoVG9Qcm9wczpuLGluaXRNZXJnZVByb3BzOnIsLi4ub30pe2NvbnN0IGk9dChlLG8pLHM9bihlLG8pLGE9cihlLG8pO3JldHVybiB0dyhpLHMsYSxlLG8pfWZ1bmN0aW9uIHJ3KGUsdCl7Y29uc3Qgbj17fTtmb3IoY29uc3QgciBpbiBlKXtjb25zdCBvPWVbcl07dHlwZW9mIG89PSJmdW5jdGlvbiImJihuW3JdPSguLi5pKT0+dChvKC4uLmkpKSl9cmV0dXJuIG59ZnVuY3Rpb24gc2MoZSl7cmV0dXJuIGZ1bmN0aW9uKG4pe2NvbnN0IHI9ZShuKTtmdW5jdGlvbiBvKCl7cmV0dXJuIHJ9cmV0dXJuIG8uZGVwZW5kc09uT3duUHJvcHM9ITEsb319ZnVuY3Rpb24gRXAoZSl7cmV0dXJuIGUuZGVwZW5kc09uT3duUHJvcHM/ISFlLmRlcGVuZHNPbk93blByb3BzOmUubGVuZ3RoIT09MX1mdW5jdGlvbiB3ZyhlLHQpe3JldHVybiBmdW5jdGlvbihyLHtkaXNwbGF5TmFtZTpvfSl7Y29uc3QgaT1mdW5jdGlvbihhLGwpe3JldHVybiBpLmRlcGVuZHNPbk93blByb3BzP2kubWFwVG9Qcm9wcyhhLGwpOmkubWFwVG9Qcm9wcyhhLHZvaWQgMCl9O3JldHVybiBpLmRlcGVuZHNPbk93blByb3BzPSEwLGkubWFwVG9Qcm9wcz1mdW5jdGlvbihhLGwpe2kubWFwVG9Qcm9wcz1lLGkuZGVwZW5kc09uT3duUHJvcHM9RXAoZSk7bGV0IHU9aShhLGwpO3JldHVybiB0eXBlb2YgdT09ImZ1bmN0aW9uIiYmKGkubWFwVG9Qcm9wcz11LGkuZGVwZW5kc09uT3duUHJvcHM9RXAodSksdT1pKGEsbCkpLHV9LGl9fWZ1bmN0aW9uIF9kKGUsdCl7cmV0dXJuKG4scik9Pnt0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBlfSBmb3IgJHt0fSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7ci53cmFwcGVkQ29tcG9uZW50TmFtZX0uYCl9fWZ1bmN0aW9uIG93KGUpe3JldHVybiBlJiZ0eXBlb2YgZT09Im9iamVjdCI/c2ModD0+cncoZSx0KSk6ZT90eXBlb2YgZT09ImZ1bmN0aW9uIj93ZyhlKTpfZChlLCJtYXBEaXNwYXRjaFRvUHJvcHMiKTpzYyh0PT4oe2Rpc3BhdGNoOnR9KSl9ZnVuY3Rpb24gaXcoZSl7cmV0dXJuIGU/dHlwZW9mIGU9PSJmdW5jdGlvbiI/d2coZSk6X2QoZSwibWFwU3RhdGVUb1Byb3BzIik6c2MoKCk9Pih7fSkpfWZ1bmN0aW9uIHN3KGUsdCxuKXtyZXR1cm57Li4ubiwuLi5lLC4uLnR9fWZ1bmN0aW9uIGF3KGUpe3JldHVybiBmdW5jdGlvbihuLHtkaXNwbGF5TmFtZTpyLGFyZU1lcmdlZFByb3BzRXF1YWw6b30pe2xldCBpPSExLHM7cmV0dXJuIGZ1bmN0aW9uKGwsdSxjKXtjb25zdCBkPWUobCx1LGMpO3JldHVybiBpP28oZCxzKXx8KHM9ZCk6KGk9ITAscz1kKSxzfX19ZnVuY3Rpb24gbHcoZSl7cmV0dXJuIGU/dHlwZW9mIGU9PSJmdW5jdGlvbiI/YXcoZSk6X2QoZSwibWVyZ2VQcm9wcyIpOigpPT5zd31mdW5jdGlvbiB1dyhlKXtlKCl9ZnVuY3Rpb24gY3coKXtsZXQgZT1udWxsLHQ9bnVsbDtyZXR1cm57Y2xlYXIoKXtlPW51bGwsdD1udWxsfSxub3RpZnkoKXt1dygoKT0+e2xldCBuPWU7Zm9yKDtuOyluLmNhbGxiYWNrKCksbj1uLm5leHR9KX0sZ2V0KCl7Y29uc3Qgbj1bXTtsZXQgcj1lO2Zvcig7cjspbi5wdXNoKHIpLHI9ci5uZXh0O3JldHVybiBufSxzdWJzY3JpYmUobil7bGV0IHI9ITA7Y29uc3Qgbz10PXtjYWxsYmFjazpuLG5leHQ6bnVsbCxwcmV2OnR9O3JldHVybiBvLnByZXY/by5wcmV2Lm5leHQ9bzplPW8sZnVuY3Rpb24oKXshcnx8ZT09PW51bGx8fChyPSExLG8ubmV4dD9vLm5leHQucHJldj1vLnByZXY6dD1vLnByZXYsby5wcmV2P28ucHJldi5uZXh0PW8ubmV4dDplPW8ubmV4dCl9fX19dmFyIFJwPXtub3RpZnkoKXt9LGdldDooKT0+W119O2Z1bmN0aW9uIFNnKGUsdCl7bGV0IG4scj1ScCxvPTAsaT0hMTtmdW5jdGlvbiBzKFMpe2MoKTtjb25zdCB4PXIuc3Vic2NyaWJlKFMpO2xldCBoPSExO3JldHVybigpPT57aHx8KGg9ITAseCgpLGQoKSl9fWZ1bmN0aW9uIGEoKXtyLm5vdGlmeSgpfWZ1bmN0aW9uIGwoKXt3Lm9uU3RhdGVDaGFuZ2UmJncub25TdGF0ZUNoYW5nZSgpfWZ1bmN0aW9uIHUoKXtyZXR1cm4gaX1mdW5jdGlvbiBjKCl7bysrLG58fChuPXQ/dC5hZGROZXN0ZWRTdWIobCk6ZS5zdWJzY3JpYmUobCkscj1jdygpKX1mdW5jdGlvbiBkKCl7by0tLG4mJm89PT0wJiYobigpLG49dm9pZCAwLHIuY2xlYXIoKSxyPVJwKX1mdW5jdGlvbiBtKCl7aXx8KGk9ITAsYygpKX1mdW5jdGlvbiB2KCl7aSYmKGk9ITEsZCgpKX1jb25zdCB3PXthZGROZXN0ZWRTdWI6cyxub3RpZnlOZXN0ZWRTdWJzOmEsaGFuZGxlQ2hhbmdlV3JhcHBlcjpsLGlzU3Vic2NyaWJlZDp1LHRyeVN1YnNjcmliZTptLHRyeVVuc3Vic2NyaWJlOnYsZ2V0TGlzdGVuZXJzOigpPT5yfTtyZXR1cm4gd312YXIgZHc9dHlwZW9mIHdpbmRvdzwidSImJnR5cGVvZiB3aW5kb3cuZG9jdW1lbnQ8InUiJiZ0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ8InUiLGZ3PXR5cGVvZiBuYXZpZ2F0b3I8InUiJiZuYXZpZ2F0b3IucHJvZHVjdD09PSJSZWFjdE5hdGl2ZSIsU2E9ZHd8fGZ3P1NlLnVzZUxheW91dEVmZmVjdDpTZS51c2VFZmZlY3Q7ZnVuY3Rpb24gVHAoZSx0KXtyZXR1cm4gZT09PXQ/ZSE9PTB8fHQhPT0wfHwxL2U9PT0xL3Q6ZSE9PWUmJnQhPT10fWZ1bmN0aW9uIHd1KGUsdCl7aWYoVHAoZSx0KSlyZXR1cm4hMDtpZih0eXBlb2YgZSE9Im9iamVjdCJ8fGU9PT1udWxsfHx0eXBlb2YgdCE9Im9iamVjdCJ8fHQ9PT1udWxsKXJldHVybiExO2NvbnN0IG49T2JqZWN0LmtleXMoZSkscj1PYmplY3Qua2V5cyh0KTtpZihuLmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbz0wO288bi5sZW5ndGg7bysrKWlmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuW29dKXx8IVRwKGVbbltvXV0sdFtuW29dXSkpcmV0dXJuITE7cmV0dXJuITB9dmFyIHB3PXtjaGlsZENvbnRleHRUeXBlczohMCxjb250ZXh0VHlwZTohMCxjb250ZXh0VHlwZXM6ITAsZGVmYXVsdFByb3BzOiEwLGRpc3BsYXlOYW1lOiEwLGdldERlZmF1bHRQcm9wczohMCxnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6ITAsZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiEwLG1peGluczohMCxwcm9wVHlwZXM6ITAsdHlwZTohMH0sbXc9e25hbWU6ITAsbGVuZ3RoOiEwLHByb3RvdHlwZTohMCxjYWxsZXI6ITAsY2FsbGVlOiEwLGFyZ3VtZW50czohMCxhcml0eTohMH0saHc9eyQkdHlwZW9mOiEwLHJlbmRlcjohMCxkZWZhdWx0UHJvcHM6ITAsZGlzcGxheU5hbWU6ITAscHJvcFR5cGVzOiEwfSx4Zz17JCR0eXBlb2Y6ITAsY29tcGFyZTohMCxkZWZhdWx0UHJvcHM6ITAsZGlzcGxheU5hbWU6ITAscHJvcFR5cGVzOiEwLHR5cGU6ITB9LGd3PXtbcTFdOmh3LFtaMV06eGd9O2Z1bmN0aW9uIFBwKGUpe3JldHVybiBldyhlKT94Zzpnd1tlLiQkdHlwZW9mXXx8cHd9dmFyIHl3PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSx2dz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywkcD1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLHd3PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsU3c9T2JqZWN0LmdldFByb3RvdHlwZU9mLE9wPU9iamVjdC5wcm90b3R5cGU7ZnVuY3Rpb24gYWMoZSx0KXtpZih0eXBlb2YgdCE9InN0cmluZyIpe2lmKE9wKXtjb25zdCBpPVN3KHQpO2kmJmkhPT1PcCYmYWMoZSxpKX1sZXQgbj12dyh0KTskcCYmKG49bi5jb25jYXQoJHAodCkpKTtjb25zdCByPVBwKGUpLG89UHAodCk7Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDsrK2kpe2NvbnN0IHM9bltpXTtpZighbXdbc10mJiEobyYmb1tzXSkmJiEociYmcltzXSkpe2NvbnN0IGE9d3codCxzKTt0cnl7eXcoZSxzLGEpfWNhdGNoe319fX1yZXR1cm4gZX12YXIgQ2c9RDEseHc9ZT0+e0NnPWV9LEN3PVtudWxsLG51bGxdO2Z1bmN0aW9uIGJ3KGUsdCxuKXtTYSgoKT0+ZSguLi50KSxuKX1mdW5jdGlvbiBrdyhlLHQsbixyLG8saSl7ZS5jdXJyZW50PXIsbi5jdXJyZW50PSExLG8uY3VycmVudCYmKG8uY3VycmVudD1udWxsLGkoKSl9ZnVuY3Rpb24gRXcoZSx0LG4scixvLGkscyxhLGwsdSxjKXtpZighZSlyZXR1cm4oKT0+e307bGV0IGQ9ITEsbT1udWxsO2NvbnN0IHY9KCk9PntpZihkfHwhYS5jdXJyZW50KXJldHVybjtjb25zdCBTPXQuZ2V0U3RhdGUoKTtsZXQgeCxoO3RyeXt4PXIoUyxvLmN1cnJlbnQpfWNhdGNoKGcpe2g9ZyxtPWd9aHx8KG09bnVsbCkseD09PWkuY3VycmVudD9zLmN1cnJlbnR8fHUoKTooaS5jdXJyZW50PXgsbC5jdXJyZW50PXgscy5jdXJyZW50PSEwLGMoKSl9O3JldHVybiBuLm9uU3RhdGVDaGFuZ2U9dixuLnRyeVN1YnNjcmliZSgpLHYoKSwoKT0+e2lmKGQ9ITAsbi50cnlVbnN1YnNjcmliZSgpLG4ub25TdGF0ZUNoYW5nZT1udWxsLG0pdGhyb3cgbX19ZnVuY3Rpb24gUncoZSx0KXtyZXR1cm4gZT09PXR9ZnVuY3Rpb24gVHcoZSx0LG4se3B1cmU6cixhcmVTdGF0ZXNFcXVhbDpvPVJ3LGFyZU93blByb3BzRXF1YWw6aT13dSxhcmVTdGF0ZVByb3BzRXF1YWw6cz13dSxhcmVNZXJnZWRQcm9wc0VxdWFsOmE9d3UsZm9yd2FyZFJlZjpsPSExLGNvbnRleHQ6dT15Z309e30pe2NvbnN0IGM9dSxkPWl3KGUpLG09b3codCksdj1sdyhuKSx3PSEhZTtyZXR1cm4geD0+e2NvbnN0IGg9eC5kaXNwbGF5TmFtZXx8eC5uYW1lfHwiQ29tcG9uZW50IixnPWBDb25uZWN0KCR7aH0pYCxmPXtzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6dyxkaXNwbGF5TmFtZTpnLHdyYXBwZWRDb21wb25lbnROYW1lOmgsV3JhcHBlZENvbXBvbmVudDp4LGluaXRNYXBTdGF0ZVRvUHJvcHM6ZCxpbml0TWFwRGlzcGF0Y2hUb1Byb3BzOm0saW5pdE1lcmdlUHJvcHM6dixhcmVTdGF0ZXNFcXVhbDpvLGFyZVN0YXRlUHJvcHNFcXVhbDpzLGFyZU93blByb3BzRXF1YWw6aSxhcmVNZXJnZWRQcm9wc0VxdWFsOmF9O2Z1bmN0aW9uIHkoUil7Y29uc3RbUCxJLHBdPVNlLnVzZU1lbW8oKCk9Pntjb25zdHtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOlksLi4udWV9PVI7cmV0dXJuW1IuY29udGV4dCxZLHVlXX0sW1JdKSwkPVNlLnVzZU1lbW8oKCk9PntsZXQgWT1jO3JldHVybiBQIT1udWxsJiZQLkNvbnN1bWVyLFl9LFtQLGNdKSxMPVNlLnVzZUNvbnRleHQoJCksaj0hIVIuc3RvcmUmJiEhUi5zdG9yZS5nZXRTdGF0ZSYmISFSLnN0b3JlLmRpc3BhdGNoLE49ISFMJiYhIUwuc3RvcmUsTz1qP1Iuc3RvcmU6TC5zdG9yZSxNPU4/TC5nZXRTZXJ2ZXJTdGF0ZTpPLmdldFN0YXRlLF89U2UudXNlTWVtbygoKT0+bncoTy5kaXNwYXRjaCxmKSxbT10pLFtULEFdPVNlLnVzZU1lbW8oKCk9PntpZighdylyZXR1cm4gQ3c7Y29uc3QgWT1TZyhPLGo/dm9pZCAwOkwuc3Vic2NyaXB0aW9uKSx1ZT1ZLm5vdGlmeU5lc3RlZFN1YnMuYmluZChZKTtyZXR1cm5bWSx1ZV19LFtPLGosTF0pLEQ9U2UudXNlTWVtbygoKT0+aj9MOnsuLi5MLHN1YnNjcmlwdGlvbjpUfSxbaixMLFRdKSxCPVNlLnVzZVJlZih2b2lkIDApLEg9U2UudXNlUmVmKHApLFY9U2UudXNlUmVmKHZvaWQgMCksVT1TZS51c2VSZWYoITEpLFg9U2UudXNlUmVmKCExKSxXPVNlLnVzZVJlZih2b2lkIDApO1NhKCgpPT4oWC5jdXJyZW50PSEwLCgpPT57WC5jdXJyZW50PSExfSksW10pO2NvbnN0IEo9U2UudXNlTWVtbygoKT0+KCk9PlYuY3VycmVudCYmcD09PUguY3VycmVudD9WLmN1cnJlbnQ6XyhPLmdldFN0YXRlKCkscCksW08scF0pLG9lPVNlLnVzZU1lbW8oKCk9PnVlPT5UP0V3KHcsTyxULF8sSCxCLFUsWCxWLEEsdWUpOigpPT57fSxbVF0pO2J3KGt3LFtILEIsVSxwLFYsQV0pO2xldCByZTt0cnl7cmU9Q2cob2UsSixNPygpPT5fKE0oKSxwKTpKKX1jYXRjaChZKXt0aHJvdyBXLmN1cnJlbnQmJihZLm1lc3NhZ2UrPWAKVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjoKJHtXLmN1cnJlbnQuc3RhY2t9CgpgKSxZfVNhKCgpPT57Vy5jdXJyZW50PXZvaWQgMCxWLmN1cnJlbnQ9dm9pZCAwLEIuY3VycmVudD1yZX0pO2NvbnN0IFE9U2UudXNlTWVtbygoKT0+U2UuY3JlYXRlRWxlbWVudCh4LHsuLi5yZSxyZWY6SX0pLFtJLHgscmVdKTtyZXR1cm4gU2UudXNlTWVtbygoKT0+dz9TZS5jcmVhdGVFbGVtZW50KCQuUHJvdmlkZXIse3ZhbHVlOkR9LFEpOlEsWyQsUSxEXSl9Y29uc3QgRT1TZS5tZW1vKHkpO2lmKEUuV3JhcHBlZENvbXBvbmVudD14LEUuZGlzcGxheU5hbWU9eS5kaXNwbGF5TmFtZT1nLGwpe2NvbnN0IFA9U2UuZm9yd2FyZFJlZihmdW5jdGlvbihwLCQpe3JldHVybiBTZS5jcmVhdGVFbGVtZW50KEUsey4uLnAscmVhY3RSZWR1eEZvcndhcmRlZFJlZjokfSl9KTtyZXR1cm4gUC5kaXNwbGF5TmFtZT1nLFAuV3JhcHBlZENvbXBvbmVudD14LGFjKFAseCl9cmV0dXJuIGFjKEUseCl9fXZhciBocz1UdztmdW5jdGlvbiBQdyh7c3RvcmU6ZSxjb250ZXh0OnQsY2hpbGRyZW46bixzZXJ2ZXJTdGF0ZTpyLHN0YWJpbGl0eUNoZWNrOm89Im9uY2UiLGlkZW50aXR5RnVuY3Rpb25DaGVjazppPSJvbmNlIn0pe2NvbnN0IHM9U2UudXNlTWVtbygoKT0+e2NvbnN0IHU9U2coZSk7cmV0dXJue3N0b3JlOmUsc3Vic2NyaXB0aW9uOnUsZ2V0U2VydmVyU3RhdGU6cj8oKT0+cjp2b2lkIDAsc3RhYmlsaXR5Q2hlY2s6byxpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6aX19LFtlLHIsbyxpXSksYT1TZS51c2VNZW1vKCgpPT5lLmdldFN0YXRlKCksW2VdKTtTYSgoKT0+e2NvbnN0e3N1YnNjcmlwdGlvbjp1fT1zO3JldHVybiB1Lm9uU3RhdGVDaGFuZ2U9dS5ub3RpZnlOZXN0ZWRTdWJzLHUudHJ5U3Vic2NyaWJlKCksYSE9PWUuZ2V0U3RhdGUoKSYmdS5ub3RpZnlOZXN0ZWRTdWJzKCksKCk9Pnt1LnRyeVVuc3Vic2NyaWJlKCksdS5vblN0YXRlQ2hhbmdlPXZvaWQgMH19LFtzLGFdKTtjb25zdCBsPXR8fHlnO3JldHVybiBTZS5jcmVhdGVFbGVtZW50KGwuUHJvdmlkZXIse3ZhbHVlOnN9LG4pfXZhciAkdz1Qdzt4dyhDLnVzZVN5bmNFeHRlcm5hbFN0b3JlKTtjb25zdCBGaT17YmxhY2s6IiMwMDAiLHdoaXRlOiIjZmZmIn0sSnI9ezUwOiIjZmZlYmVlIiwxMDA6IiNmZmNkZDIiLDIwMDoiI2VmOWE5YSIsMzAwOiIjZTU3MzczIiw0MDA6IiNlZjUzNTAiLDUwMDoiI2Y0NDMzNiIsNjAwOiIjZTUzOTM1Iiw3MDA6IiNkMzJmMmYiLDgwMDoiI2M2MjgyOCIsOTAwOiIjYjcxYzFjIixBMTAwOiIjZmY4YTgwIixBMjAwOiIjZmY1MjUyIixBNDAwOiIjZmYxNzQ0IixBNzAwOiIjZDUwMDAwIn0sZW89ezUwOiIjZjNlNWY1IiwxMDA6IiNlMWJlZTciLDIwMDoiI2NlOTNkOCIsMzAwOiIjYmE2OGM4Iiw0MDA6IiNhYjQ3YmMiLDUwMDoiIzljMjdiMCIsNjAwOiIjOGUyNGFhIiw3MDA6IiM3YjFmYTIiLDgwMDoiIzZhMWI5YSIsOTAwOiIjNGExNDhjIixBMTAwOiIjZWE4MGZjIixBMjAwOiIjZTA0MGZiIixBNDAwOiIjZDUwMGY5IixBNzAwOiIjYWEwMGZmIn0sdG89ezUwOiIjZTNmMmZkIiwxMDA6IiNiYmRlZmIiLDIwMDoiIzkwY2FmOSIsMzAwOiIjNjRiNWY2Iiw0MDA6IiM0MmE1ZjUiLDUwMDoiIzIxOTZmMyIsNjAwOiIjMWU4OGU1Iiw3MDA6IiMxOTc2ZDIiLDgwMDoiIzE1NjVjMCIsOTAwOiIjMGQ0N2ExIixBMTAwOiIjODJiMWZmIixBMjAwOiIjNDQ4YWZmIixBNDAwOiIjMjk3OWZmIixBNzAwOiIjMjk2MmZmIn0sbm89ezUwOiIjZTFmNWZlIiwxMDA6IiNiM2U1ZmMiLDIwMDoiIzgxZDRmYSIsMzAwOiIjNGZjM2Y3Iiw0MDA6IiMyOWI2ZjYiLDUwMDoiIzAzYTlmNCIsNjAwOiIjMDM5YmU1Iiw3MDA6IiMwMjg4ZDEiLDgwMDoiIzAyNzdiZCIsOTAwOiIjMDE1NzliIixBMTAwOiIjODBkOGZmIixBMjAwOiIjNDBjNGZmIixBNDAwOiIjMDBiMGZmIixBNzAwOiIjMDA5MWVhIn0scm89ezUwOiIjZThmNWU5IiwxMDA6IiNjOGU2YzkiLDIwMDoiI2E1ZDZhNyIsMzAwOiIjODFjNzg0Iiw0MDA6IiM2NmJiNmEiLDUwMDoiIzRjYWY1MCIsNjAwOiIjNDNhMDQ3Iiw3MDA6IiMzODhlM2MiLDgwMDoiIzJlN2QzMiIsOTAwOiIjMWI1ZTIwIixBMTAwOiIjYjlmNmNhIixBMjAwOiIjNjlmMGFlIixBNDAwOiIjMDBlNjc2IixBNzAwOiIjMDBjODUzIn0sbmk9ezUwOiIjZmZmM2UwIiwxMDA6IiNmZmUwYjIiLDIwMDoiI2ZmY2M4MCIsMzAwOiIjZmZiNzRkIiw0MDA6IiNmZmE3MjYiLDUwMDoiI2ZmOTgwMCIsNjAwOiIjZmI4YzAwIiw3MDA6IiNmNTdjMDAiLDgwMDoiI2VmNmMwMCIsOTAwOiIjZTY1MTAwIixBMTAwOiIjZmZkMTgwIixBMjAwOiIjZmZhYjQwIixBNDAwOiIjZmY5MTAwIixBNzAwOiIjZmY2ZDAwIn0sT3c9ezUwOiIjZmFmYWZhIiwxMDA6IiNmNWY1ZjUiLDIwMDoiI2VlZWVlZSIsMzAwOiIjZTBlMGUwIiw0MDA6IiNiZGJkYmQiLDUwMDoiIzllOWU5ZSIsNjAwOiIjNzU3NTc1Iiw3MDA6IiM2MTYxNjEiLDgwMDoiIzQyNDI0MiIsOTAwOiIjMjEyMTIxIixBMTAwOiIjZjVmNWY1IixBMjAwOiIjZWVlZWVlIixBNDAwOiIjYmRiZGJkIixBNzAwOiIjNjE2MTYxIn07ZnVuY3Rpb24gVm4oZSwuLi50KXtjb25zdCBuPW5ldyBVUkwoYGh0dHBzOi8vbXVpLmNvbS9wcm9kdWN0aW9uLWVycm9yLz9jb2RlPSR7ZX1gKTtyZXR1cm4gdC5mb3JFYWNoKHI9Pm4uc2VhcmNoUGFyYW1zLmFwcGVuZCgiYXJnc1tdIixyKSksYE1pbmlmaWVkIE1VSSBlcnJvciAjJHtlfTsgdmlzaXQgJHtufSBmb3IgdGhlIGZ1bGwgbWVzc2FnZS5gfWNvbnN0IE5kPSIkJG1hdGVyaWFsIjtmdW5jdGlvbiBCaSgpe3JldHVybiBCaT1PYmplY3QuYXNzaWduP09iamVjdC5hc3NpZ24uYmluZCgpOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPWFyZ3VtZW50c1t0XTtmb3IodmFyIHIgaW4gbikoe30pLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmKGVbcl09bltyXSl9cmV0dXJuIGV9LEJpLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBiZyhlKXt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gdFtuXT09PXZvaWQgMCYmKHRbbl09ZShuKSksdFtuXX19dmFyIE13PS9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZGlzYWJsZVJlbW90ZVBsYXliYWNrfGRvd25sb2FkfGRyYWdnYWJsZXxlbmNUeXBlfGVudGVyS2V5SGludHxmZXRjaHByaW9yaXR5fGZldGNoUHJpb3JpdHl8Zm9ybXxmb3JtQWN0aW9ufGZvcm1FbmNUeXBlfGZvcm1NZXRob2R8Zm9ybU5vVmFsaWRhdGV8Zm9ybVRhcmdldHxmcmFtZUJvcmRlcnxoZWFkZXJzfGhlaWdodHxoaWRkZW58aGlnaHxocmVmfGhyZWZMYW5nfGh0bWxGb3J8aHR0cEVxdWl2fGlkfGlucHV0TW9kZXxpbnRlZ3JpdHl8aXN8a2V5UGFyYW1zfGtleVR5cGV8a2luZHxsYWJlbHxsYW5nfGxpc3R8bG9hZGluZ3xsb29wfGxvd3xtYXJnaW5IZWlnaHR8bWFyZ2luV2lkdGh8bWF4fG1heExlbmd0aHxtZWRpYXxtZWRpYUdyb3VwfG1ldGhvZHxtaW58bWluTGVuZ3RofG11bHRpcGxlfG11dGVkfG5hbWV8bm9uY2V8bm9WYWxpZGF0ZXxvcGVufG9wdGltdW18cGF0dGVybnxwbGFjZWhvbGRlcnxwbGF5c0lubGluZXxwb3N0ZXJ8cHJlbG9hZHxwcm9maWxlfHJhZGlvR3JvdXB8cmVhZE9ubHl8cmVmZXJyZXJQb2xpY3l8cmVsfHJlcXVpcmVkfHJldmVyc2VkfHJvbGV8cm93c3xyb3dTcGFufHNhbmRib3h8c2NvcGV8c2NvcGVkfHNjcm9sbGluZ3xzZWFtbGVzc3xzZWxlY3RlZHxzaGFwZXxzaXplfHNpemVzfHNsb3R8c3BhbnxzcGVsbENoZWNrfHNyY3xzcmNEb2N8c3JjTGFuZ3xzcmNTZXR8c3RhcnR8c3RlcHxzdHlsZXxzdW1tYXJ5fHRhYkluZGV4fHRhcmdldHx0aXRsZXx0cmFuc2xhdGV8dHlwZXx1c2VNYXB8dmFsdWV8d2lkdGh8d21vZGV8d3JhcHxhYm91dHxkYXRhdHlwZXxpbmxpc3R8cHJlZml4fHByb3BlcnR5fHJlc291cmNlfHR5cGVvZnx2b2NhYnxhdXRvQ2FwaXRhbGl6ZXxhdXRvQ29ycmVjdHxhdXRvU2F2ZXxjb2xvcnxpbmNyZW1lbnRhbHxmYWxsYmFja3xpbmVydHxpdGVtUHJvcHxpdGVtU2NvcGV8aXRlbVR5cGV8aXRlbUlEfGl0ZW1SZWZ8b258b3B0aW9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLyxfdz1iZyhmdW5jdGlvbihlKXtyZXR1cm4gTXcudGVzdChlKXx8ZS5jaGFyQ29kZUF0KDApPT09MTExJiZlLmNoYXJDb2RlQXQoMSk9PT0xMTAmJmUuY2hhckNvZGVBdCgyKTw5MX0pLE53PSExO2Z1bmN0aW9uIEl3KGUpe2lmKGUuc2hlZXQpcmV0dXJuIGUuc2hlZXQ7Zm9yKHZhciB0PTA7dDxkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7dCsrKWlmKGRvY3VtZW50LnN0eWxlU2hlZXRzW3RdLm93bmVyTm9kZT09PWUpcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW3RdfWZ1bmN0aW9uIEF3KGUpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7cmV0dXJuIHQuc2V0QXR0cmlidXRlKCJkYXRhLWVtb3Rpb24iLGUua2V5KSxlLm5vbmNlIT09dm9pZCAwJiZ0LnNldEF0dHJpYnV0ZSgibm9uY2UiLGUubm9uY2UpLHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIiIpKSx0LnNldEF0dHJpYnV0ZSgiZGF0YS1zIiwiIiksdH12YXIgenc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe3ZhciByPXRoaXM7dGhpcy5faW5zZXJ0VGFnPWZ1bmN0aW9uKG8pe3ZhciBpO3IudGFncy5sZW5ndGg9PT0wP3IuaW5zZXJ0aW9uUG9pbnQ/aT1yLmluc2VydGlvblBvaW50Lm5leHRTaWJsaW5nOnIucHJlcGVuZD9pPXIuY29udGFpbmVyLmZpcnN0Q2hpbGQ6aT1yLmJlZm9yZTppPXIudGFnc1tyLnRhZ3MubGVuZ3RoLTFdLm5leHRTaWJsaW5nLHIuY29udGFpbmVyLmluc2VydEJlZm9yZShvLGkpLHIudGFncy5wdXNoKG8pfSx0aGlzLmlzU3BlZWR5PW4uc3BlZWR5PT09dm9pZCAwPyFOdzpuLnNwZWVkeSx0aGlzLnRhZ3M9W10sdGhpcy5jdHI9MCx0aGlzLm5vbmNlPW4ubm9uY2UsdGhpcy5rZXk9bi5rZXksdGhpcy5jb250YWluZXI9bi5jb250YWluZXIsdGhpcy5wcmVwZW5kPW4ucHJlcGVuZCx0aGlzLmluc2VydGlvblBvaW50PW4uaW5zZXJ0aW9uUG9pbnQsdGhpcy5iZWZvcmU9bnVsbH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5oeWRyYXRlPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaCh0aGlzLl9pbnNlcnRUYWcpfSx0Lmluc2VydD1mdW5jdGlvbihyKXt0aGlzLmN0ciUodGhpcy5pc1NwZWVkeT82NWUzOjEpPT09MCYmdGhpcy5faW5zZXJ0VGFnKEF3KHRoaXMpKTt2YXIgbz10aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aC0xXTtpZih0aGlzLmlzU3BlZWR5KXt2YXIgaT1JdyhvKTt0cnl7aS5pbnNlcnRSdWxlKHIsaS5jc3NSdWxlcy5sZW5ndGgpfWNhdGNoe319ZWxzZSBvLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIpKTt0aGlzLmN0cisrfSx0LmZsdXNoPWZ1bmN0aW9uKCl7dGhpcy50YWdzLmZvckVhY2goZnVuY3Rpb24ocil7dmFyIG87cmV0dXJuKG89ci5wYXJlbnROb2RlKT09bnVsbD92b2lkIDA6by5yZW1vdmVDaGlsZChyKX0pLHRoaXMudGFncz1bXSx0aGlzLmN0cj0wfSxlfSgpLGN0PSItbXMtIix4YT0iLW1vei0iLHZlPSItd2Via2l0LSIsa2c9ImNvbW0iLElkPSJydWxlIixBZD0iZGVjbCIsTHc9IkBpbXBvcnQiLEVnPSJAa2V5ZnJhbWVzIixqdz0iQGxheWVyIixEdz1NYXRoLmFicyxjbD1TdHJpbmcuZnJvbUNoYXJDb2RlLEZ3PU9iamVjdC5hc3NpZ247ZnVuY3Rpb24gQncoZSx0KXtyZXR1cm4gb3QoZSwwKV40NT8oKCh0PDwyXm90KGUsMCkpPDwyXm90KGUsMSkpPDwyXm90KGUsMikpPDwyXm90KGUsMyk6MH1mdW5jdGlvbiBSZyhlKXtyZXR1cm4gZS50cmltKCl9ZnVuY3Rpb24gV3coZSx0KXtyZXR1cm4oZT10LmV4ZWMoZSkpP2VbMF06ZX1mdW5jdGlvbiB3ZShlLHQsbil7cmV0dXJuIGUucmVwbGFjZSh0LG4pfWZ1bmN0aW9uIGxjKGUsdCl7cmV0dXJuIGUuaW5kZXhPZih0KX1mdW5jdGlvbiBvdChlLHQpe3JldHVybiBlLmNoYXJDb2RlQXQodCl8MH1mdW5jdGlvbiBXaShlLHQsbil7cmV0dXJuIGUuc2xpY2UodCxuKX1mdW5jdGlvbiBQbihlKXtyZXR1cm4gZS5sZW5ndGh9ZnVuY3Rpb24gemQoZSl7cmV0dXJuIGUubGVuZ3RofWZ1bmN0aW9uICRzKGUsdCl7cmV0dXJuIHQucHVzaChlKSxlfWZ1bmN0aW9uIFV3KGUsdCl7cmV0dXJuIGUubWFwKHQpLmpvaW4oIiIpfXZhciBkbD0xLE1vPTEsVGc9MCxPdD0wLFllPTAsR289IiI7ZnVuY3Rpb24gZmwoZSx0LG4scixvLGkscyl7cmV0dXJue3ZhbHVlOmUscm9vdDp0LHBhcmVudDpuLHR5cGU6cixwcm9wczpvLGNoaWxkcmVuOmksbGluZTpkbCxjb2x1bW46TW8sbGVuZ3RoOnMscmV0dXJuOiIifX1mdW5jdGlvbiByaShlLHQpe3JldHVybiBGdyhmbCgiIixudWxsLG51bGwsIiIsbnVsbCxudWxsLDApLGUse2xlbmd0aDotZS5sZW5ndGh9LHQpfWZ1bmN0aW9uIEh3KCl7cmV0dXJuIFllfWZ1bmN0aW9uIFZ3KCl7cmV0dXJuIFllPU90PjA/b3QoR28sLS1PdCk6MCxNby0tLFllPT09MTAmJihNbz0xLGRsLS0pLFllfWZ1bmN0aW9uIEx0KCl7cmV0dXJuIFllPU90PFRnP290KEdvLE90KyspOjAsTW8rKyxZZT09PTEwJiYoTW89MSxkbCsrKSxZZX1mdW5jdGlvbiBfbigpe3JldHVybiBvdChHbyxPdCl9ZnVuY3Rpb24gb2EoKXtyZXR1cm4gT3R9ZnVuY3Rpb24gZ3MoZSx0KXtyZXR1cm4gV2koR28sZSx0KX1mdW5jdGlvbiBVaShlKXtzd2l0Y2goZSl7Y2FzZSAwOmNhc2UgOTpjYXNlIDEwOmNhc2UgMTM6Y2FzZSAzMjpyZXR1cm4gNTtjYXNlIDMzOmNhc2UgNDM6Y2FzZSA0NDpjYXNlIDQ3OmNhc2UgNjI6Y2FzZSA2NDpjYXNlIDEyNjpjYXNlIDU5OmNhc2UgMTIzOmNhc2UgMTI1OnJldHVybiA0O2Nhc2UgNTg6cmV0dXJuIDM7Y2FzZSAzNDpjYXNlIDM5OmNhc2UgNDA6Y2FzZSA5MTpyZXR1cm4gMjtjYXNlIDQxOmNhc2UgOTM6cmV0dXJuIDF9cmV0dXJuIDB9ZnVuY3Rpb24gUGcoZSl7cmV0dXJuIGRsPU1vPTEsVGc9UG4oR289ZSksT3Q9MCxbXX1mdW5jdGlvbiAkZyhlKXtyZXR1cm4gR289IiIsZX1mdW5jdGlvbiBpYShlKXtyZXR1cm4gUmcoZ3MoT3QtMSx1YyhlPT09OTE/ZSsyOmU9PT00MD9lKzE6ZSkpKX1mdW5jdGlvbiBLdyhlKXtmb3IoOyhZZT1fbigpKSYmWWU8MzM7KUx0KCk7cmV0dXJuIFVpKGUpPjJ8fFVpKFllKT4zPyIiOiIgIn1mdW5jdGlvbiBZdyhlLHQpe2Zvcig7LS10JiZMdCgpJiYhKFllPDQ4fHxZZT4xMDJ8fFllPjU3JiZZZTw2NXx8WWU+NzAmJlllPDk3KTspO3JldHVybiBncyhlLG9hKCkrKHQ8NiYmX24oKT09MzImJkx0KCk9PTMyKSl9ZnVuY3Rpb24gdWMoZSl7Zm9yKDtMdCgpOylzd2l0Y2goWWUpe2Nhc2UgZTpyZXR1cm4gT3Q7Y2FzZSAzNDpjYXNlIDM5OmUhPT0zNCYmZSE9PTM5JiZ1YyhZZSk7YnJlYWs7Y2FzZSA0MDplPT09NDEmJnVjKGUpO2JyZWFrO2Nhc2UgOTI6THQoKTticmVha31yZXR1cm4gT3R9ZnVuY3Rpb24gR3coZSx0KXtmb3IoO0x0KCkmJmUrWWUhPT01NzspaWYoZStZZT09PTg0JiZfbigpPT09NDcpYnJlYWs7cmV0dXJuIi8qIitncyh0LE90LTEpKyIqIitjbChlPT09NDc/ZTpMdCgpKX1mdW5jdGlvbiBRdyhlKXtmb3IoOyFVaShfbigpKTspTHQoKTtyZXR1cm4gZ3MoZSxPdCl9ZnVuY3Rpb24gWHcoZSl7cmV0dXJuICRnKHNhKCIiLG51bGwsbnVsbCxudWxsLFsiIl0sZT1QZyhlKSwwLFswXSxlKSl9ZnVuY3Rpb24gc2EoZSx0LG4scixvLGkscyxhLGwpe2Zvcih2YXIgdT0wLGM9MCxkPXMsbT0wLHY9MCx3PTAsUz0xLHg9MSxoPTEsZz0wLGY9IiIseT1vLGI9aSxFPXIsUj1mO3g7KXN3aXRjaCh3PWcsZz1MdCgpKXtjYXNlIDQwOmlmKHchPTEwOCYmb3QoUixkLTEpPT01OCl7bGMoUis9d2UoaWEoZyksIiYiLCImXGYiKSwiJlxmIikhPS0xJiYoaD0tMSk7YnJlYWt9Y2FzZSAzNDpjYXNlIDM5OmNhc2UgOTE6Uis9aWEoZyk7YnJlYWs7Y2FzZSA5OmNhc2UgMTA6Y2FzZSAxMzpjYXNlIDMyOlIrPUt3KHcpO2JyZWFrO2Nhc2UgOTI6Uis9WXcob2EoKS0xLDcpO2NvbnRpbnVlO2Nhc2UgNDc6c3dpdGNoKF9uKCkpe2Nhc2UgNDI6Y2FzZSA0NzokcyhxdyhHdyhMdCgpLG9hKCkpLHQsbiksbCk7YnJlYWs7ZGVmYXVsdDpSKz0iLyJ9YnJlYWs7Y2FzZSAxMjMqUzphW3UrK109UG4oUikqaDtjYXNlIDEyNSpTOmNhc2UgNTk6Y2FzZSAwOnN3aXRjaChnKXtjYXNlIDA6Y2FzZSAxMjU6eD0wO2Nhc2UgNTkrYzpoPT0tMSYmKFI9d2UoUiwvXGYvZywiIikpLHY+MCYmUG4oUiktZCYmJHModj4zMj9fcChSKyI7IixyLG4sZC0xKTpfcCh3ZShSLCIgIiwiIikrIjsiLHIsbixkLTIpLGwpO2JyZWFrO2Nhc2UgNTk6Uis9IjsiO2RlZmF1bHQ6aWYoJHMoRT1NcChSLHQsbix1LGMsbyxhLGYseT1bXSxiPVtdLGQpLGkpLGc9PT0xMjMpaWYoYz09PTApc2EoUix0LEUsRSx5LGksZCxhLGIpO2Vsc2Ugc3dpdGNoKG09PT05OSYmb3QoUiwzKT09PTExMD8xMDA6bSl7Y2FzZSAxMDA6Y2FzZSAxMDg6Y2FzZSAxMDk6Y2FzZSAxMTU6c2EoZSxFLEUsciYmJHMoTXAoZSxFLEUsMCwwLG8sYSxmLG8seT1bXSxkKSxiKSxvLGIsZCxhLHI/eTpiKTticmVhaztkZWZhdWx0OnNhKFIsRSxFLEUsWyIiXSxiLDAsYSxiKX19dT1jPXY9MCxTPWg9MSxmPVI9IiIsZD1zO2JyZWFrO2Nhc2UgNTg6ZD0xK1BuKFIpLHY9dztkZWZhdWx0OmlmKFM8MSl7aWYoZz09MTIzKS0tUztlbHNlIGlmKGc9PTEyNSYmUysrPT0wJiZWdygpPT0xMjUpY29udGludWV9c3dpdGNoKFIrPWNsKGcpLGcqUyl7Y2FzZSAzODpoPWM+MD8xOihSKz0iXGYiLC0xKTticmVhaztjYXNlIDQ0OmFbdSsrXT0oUG4oUiktMSkqaCxoPTE7YnJlYWs7Y2FzZSA2NDpfbigpPT09NDUmJihSKz1pYShMdCgpKSksbT1fbigpLGM9ZD1QbihmPVIrPVF3KG9hKCkpKSxnKys7YnJlYWs7Y2FzZSA0NTp3PT09NDUmJlBuKFIpPT0yJiYoUz0wKX19cmV0dXJuIGl9ZnVuY3Rpb24gTXAoZSx0LG4scixvLGkscyxhLGwsdSxjKXtmb3IodmFyIGQ9by0xLG09bz09PTA/aTpbIiJdLHY9emQobSksdz0wLFM9MCx4PTA7dzxyOysrdylmb3IodmFyIGg9MCxnPVdpKGUsZCsxLGQ9RHcoUz1zW3ddKSksZj1lO2g8djsrK2gpKGY9UmcoUz4wP21baF0rIiAiK2c6d2UoZywvJlxmL2csbVtoXSkpKSYmKGxbeCsrXT1mKTtyZXR1cm4gZmwoZSx0LG4sbz09PTA/SWQ6YSxsLHUsYyl9ZnVuY3Rpb24gcXcoZSx0LG4pe3JldHVybiBmbChlLHQsbixrZyxjbChIdygpKSxXaShlLDIsLTIpLDApfWZ1bmN0aW9uIF9wKGUsdCxuLHIpe3JldHVybiBmbChlLHQsbixBZCxXaShlLDAsciksV2koZSxyKzEsLTEpLHIpfWZ1bmN0aW9uIGJvKGUsdCl7Zm9yKHZhciBuPSIiLHI9emQoZSksbz0wO288cjtvKyspbis9dChlW29dLG8sZSx0KXx8IiI7cmV0dXJuIG59ZnVuY3Rpb24gWncoZSx0LG4scil7c3dpdGNoKGUudHlwZSl7Y2FzZSBqdzppZihlLmNoaWxkcmVuLmxlbmd0aClicmVhaztjYXNlIEx3OmNhc2UgQWQ6cmV0dXJuIGUucmV0dXJuPWUucmV0dXJufHxlLnZhbHVlO2Nhc2Uga2c6cmV0dXJuIiI7Y2FzZSBFZzpyZXR1cm4gZS5yZXR1cm49ZS52YWx1ZSsieyIrYm8oZS5jaGlsZHJlbixyKSsifSI7Y2FzZSBJZDplLnZhbHVlPWUucHJvcHMuam9pbigiLCIpfXJldHVybiBQbihuPWJvKGUuY2hpbGRyZW4scikpP2UucmV0dXJuPWUudmFsdWUrInsiK24rIn0iOiIifWZ1bmN0aW9uIEp3KGUpe3ZhciB0PXpkKGUpO3JldHVybiBmdW5jdGlvbihuLHIsbyxpKXtmb3IodmFyIHM9IiIsYT0wO2E8dDthKyspcys9ZVthXShuLHIsbyxpKXx8IiI7cmV0dXJuIHN9fWZ1bmN0aW9uIGVTKGUpe3JldHVybiBmdW5jdGlvbih0KXt0LnJvb3R8fCh0PXQucmV0dXJuKSYmZSh0KX19dmFyIHRTPWZ1bmN0aW9uKHQsbixyKXtmb3IodmFyIG89MCxpPTA7bz1pLGk9X24oKSxvPT09MzgmJmk9PT0xMiYmKG5bcl09MSksIVVpKGkpOylMdCgpO3JldHVybiBncyh0LE90KX0sblM9ZnVuY3Rpb24odCxuKXt2YXIgcj0tMSxvPTQ0O2RvIHN3aXRjaChVaShvKSl7Y2FzZSAwOm89PT0zOCYmX24oKT09PTEyJiYobltyXT0xKSx0W3JdKz10UyhPdC0xLG4scik7YnJlYWs7Y2FzZSAyOnRbcl0rPWlhKG8pO2JyZWFrO2Nhc2UgNDppZihvPT09NDQpe3RbKytyXT1fbigpPT09NTg/IiZcZiI6IiIsbltyXT10W3JdLmxlbmd0aDticmVha31kZWZhdWx0OnRbcl0rPWNsKG8pfXdoaWxlKG89THQoKSk7cmV0dXJuIHR9LHJTPWZ1bmN0aW9uKHQsbil7cmV0dXJuICRnKG5TKFBnKHQpLG4pKX0sTnA9bmV3IFdlYWtNYXAsb1M9ZnVuY3Rpb24odCl7aWYoISh0LnR5cGUhPT0icnVsZSJ8fCF0LnBhcmVudHx8dC5sZW5ndGg8MSkpe2Zvcih2YXIgbj10LnZhbHVlLHI9dC5wYXJlbnQsbz10LmNvbHVtbj09PXIuY29sdW1uJiZ0LmxpbmU9PT1yLmxpbmU7ci50eXBlIT09InJ1bGUiOylpZihyPXIucGFyZW50LCFyKXJldHVybjtpZighKHQucHJvcHMubGVuZ3RoPT09MSYmbi5jaGFyQ29kZUF0KDApIT09NTgmJiFOcC5nZXQocikpJiYhbyl7TnAuc2V0KHQsITApO2Zvcih2YXIgaT1bXSxzPXJTKG4saSksYT1yLnByb3BzLGw9MCx1PTA7bDxzLmxlbmd0aDtsKyspZm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyssdSsrKXQucHJvcHNbdV09aVtsXT9zW2xdLnJlcGxhY2UoLyZcZi9nLGFbY10pOmFbY10rIiAiK3NbbF19fX0saVM9ZnVuY3Rpb24odCl7aWYodC50eXBlPT09ImRlY2wiKXt2YXIgbj10LnZhbHVlO24uY2hhckNvZGVBdCgwKT09PTEwOCYmbi5jaGFyQ29kZUF0KDIpPT09OTgmJih0LnJldHVybj0iIix0LnZhbHVlPSIiKX19O2Z1bmN0aW9uIE9nKGUsdCl7c3dpdGNoKEJ3KGUsdCkpe2Nhc2UgNTEwMzpyZXR1cm4gdmUrInByaW50LSIrZStlO2Nhc2UgNTczNzpjYXNlIDQyMDE6Y2FzZSAzMTc3OmNhc2UgMzQzMzpjYXNlIDE2NDE6Y2FzZSA0NDU3OmNhc2UgMjkyMTpjYXNlIDU1NzI6Y2FzZSA2MzU2OmNhc2UgNTg0NDpjYXNlIDMxOTE6Y2FzZSA2NjQ1OmNhc2UgMzAwNTpjYXNlIDYzOTE6Y2FzZSA1ODc5OmNhc2UgNTYyMzpjYXNlIDYxMzU6Y2FzZSA0NTk5OmNhc2UgNDg1NTpjYXNlIDQyMTU6Y2FzZSA2Mzg5OmNhc2UgNTEwOTpjYXNlIDUzNjU6Y2FzZSA1NjIxOmNhc2UgMzgyOTpyZXR1cm4gdmUrZStlO2Nhc2UgNTM0OTpjYXNlIDQyNDY6Y2FzZSA0ODEwOmNhc2UgNjk2ODpjYXNlIDI3NTY6cmV0dXJuIHZlK2UreGErZStjdCtlK2U7Y2FzZSA2ODI4OmNhc2UgNDI2ODpyZXR1cm4gdmUrZStjdCtlK2U7Y2FzZSA2MTY1OnJldHVybiB2ZStlK2N0KyJmbGV4LSIrZStlO2Nhc2UgNTE4NzpyZXR1cm4gdmUrZSt3ZShlLC8oXHcrKS4rKDpbXl0rKS8sdmUrImJveC0kMSQyIitjdCsiZmxleC0kMSQyIikrZTtjYXNlIDU0NDM6cmV0dXJuIHZlK2UrY3QrImZsZXgtaXRlbS0iK3dlKGUsL2ZsZXgtfC1zZWxmLywiIikrZTtjYXNlIDQ2NzU6cmV0dXJuIHZlK2UrY3QrImZsZXgtbGluZS1wYWNrIit3ZShlLC9hbGlnbi1jb250ZW50fGZsZXgtfC1zZWxmLywiIikrZTtjYXNlIDU1NDg6cmV0dXJuIHZlK2UrY3Qrd2UoZSwic2hyaW5rIiwibmVnYXRpdmUiKStlO2Nhc2UgNTI5MjpyZXR1cm4gdmUrZStjdCt3ZShlLCJiYXNpcyIsInByZWZlcnJlZC1zaXplIikrZTtjYXNlIDYwNjA6cmV0dXJuIHZlKyJib3gtIit3ZShlLCItZ3JvdyIsIiIpK3ZlK2UrY3Qrd2UoZSwiZ3JvdyIsInBvc2l0aXZlIikrZTtjYXNlIDQ1NTQ6cmV0dXJuIHZlK3dlKGUsLyhbXi1dKSh0cmFuc2Zvcm0pL2csIiQxIit2ZSsiJDIiKStlO2Nhc2UgNjE4NzpyZXR1cm4gd2Uod2Uod2UoZSwvKHpvb20tfGdyYWIpLyx2ZSsiJDEiKSwvKGltYWdlLXNldCkvLHZlKyIkMSIpLGUsIiIpK2U7Y2FzZSA1NDk1OmNhc2UgMzk1OTpyZXR1cm4gd2UoZSwvKGltYWdlLXNldFwoW15dKikvLHZlKyIkMSRgJDEiKTtjYXNlIDQ5Njg6cmV0dXJuIHdlKHdlKGUsLyguKzopKGZsZXgtKT8oLiopLyx2ZSsiYm94LXBhY2s6JDMiK2N0KyJmbGV4LXBhY2s6JDMiKSwvcy4rLWJbXjtdKy8sImp1c3RpZnkiKSt2ZStlK2U7Y2FzZSA0MDk1OmNhc2UgMzU4MzpjYXNlIDQwNjg6Y2FzZSAyNTMyOnJldHVybiB3ZShlLC8oLispLWlubGluZSguKykvLHZlKyIkMSQyIikrZTtjYXNlIDgxMTY6Y2FzZSA3MDU5OmNhc2UgNTc1MzpjYXNlIDU1MzU6Y2FzZSA1NDQ1OmNhc2UgNTcwMTpjYXNlIDQ5MzM6Y2FzZSA0Njc3OmNhc2UgNTUzMzpjYXNlIDU3ODk6Y2FzZSA1MDIxOmNhc2UgNDc2NTppZihQbihlKS0xLXQ+Nilzd2l0Y2gob3QoZSx0KzEpKXtjYXNlIDEwOTppZihvdChlLHQrNCkhPT00NSlicmVhaztjYXNlIDEwMjpyZXR1cm4gd2UoZSwvKC4rOikoLispLShbXl0rKS8sIiQxIit2ZSsiJDItJDMkMSIreGErKG90KGUsdCszKT09MTA4PyIkMyI6IiQyLSQzIikpK2U7Y2FzZSAxMTU6cmV0dXJufmxjKGUsInN0cmV0Y2giKT9PZyh3ZShlLCJzdHJldGNoIiwiZmlsbC1hdmFpbGFibGUiKSx0KStlOmV9YnJlYWs7Y2FzZSA0OTQ5OmlmKG90KGUsdCsxKSE9PTExNSlicmVhaztjYXNlIDY0NDQ6c3dpdGNoKG90KGUsUG4oZSktMy0ofmxjKGUsIiFpbXBvcnRhbnQiKSYmMTApKSl7Y2FzZSAxMDc6cmV0dXJuIHdlKGUsIjoiLCI6Iit2ZSkrZTtjYXNlIDEwMTpyZXR1cm4gd2UoZSwvKC4rOikoW147IV0rKSg7fCEuKyk/LywiJDEiK3ZlKyhvdChlLDE0KT09PTQ1PyJpbmxpbmUtIjoiIikrImJveCQzJDEiK3ZlKyIkMiQzJDEiK2N0KyIkMmJveCQzIikrZX1icmVhaztjYXNlIDU5MzY6c3dpdGNoKG90KGUsdCsxMSkpe2Nhc2UgMTE0OnJldHVybiB2ZStlK2N0K3dlKGUsL1tzdmhdXHcrLVt0YmxyXXsyfS8sInRiIikrZTtjYXNlIDEwODpyZXR1cm4gdmUrZStjdCt3ZShlLC9bc3ZoXVx3Ky1bdGJscl17Mn0vLCJ0Yi1ybCIpK2U7Y2FzZSA0NTpyZXR1cm4gdmUrZStjdCt3ZShlLC9bc3ZoXVx3Ky1bdGJscl17Mn0vLCJsciIpK2V9cmV0dXJuIHZlK2UrY3QrZStlfXJldHVybiBlfXZhciBzUz1mdW5jdGlvbih0LG4scixvKXtpZih0Lmxlbmd0aD4tMSYmIXQucmV0dXJuKXN3aXRjaCh0LnR5cGUpe2Nhc2UgQWQ6dC5yZXR1cm49T2codC52YWx1ZSx0Lmxlbmd0aCk7YnJlYWs7Y2FzZSBFZzpyZXR1cm4gYm8oW3JpKHQse3ZhbHVlOndlKHQudmFsdWUsIkAiLCJAIit2ZSl9KV0sbyk7Y2FzZSBJZDppZih0Lmxlbmd0aClyZXR1cm4gVXcodC5wcm9wcyxmdW5jdGlvbihpKXtzd2l0Y2goV3coaSwvKDo6cGxhY1x3K3w6cmVhZC1cdyspLykpe2Nhc2UiOnJlYWQtb25seSI6Y2FzZSI6cmVhZC13cml0ZSI6cmV0dXJuIGJvKFtyaSh0LHtwcm9wczpbd2UoaSwvOihyZWFkLVx3KykvLCI6Iit4YSsiJDEiKV19KV0sbyk7Y2FzZSI6OnBsYWNlaG9sZGVyIjpyZXR1cm4gYm8oW3JpKHQse3Byb3BzOlt3ZShpLC86KHBsYWNcdyspLywiOiIrdmUrImlucHV0LSQxIildfSkscmkodCx7cHJvcHM6W3dlKGksLzoocGxhY1x3KykvLCI6Iit4YSsiJDEiKV19KSxyaSh0LHtwcm9wczpbd2UoaSwvOihwbGFjXHcrKS8sY3QrImlucHV0LSQxIildfSldLG8pfXJldHVybiIifSl9fSxhUz1bc1NdLGxTPWZ1bmN0aW9uKHQpe3ZhciBuPXQua2V5O2lmKG49PT0iY3NzIil7dmFyIHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgic3R5bGVbZGF0YS1lbW90aW9uXTpub3QoW2RhdGEtc10pIik7QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChyLGZ1bmN0aW9uKFMpe3ZhciB4PVMuZ2V0QXR0cmlidXRlKCJkYXRhLWVtb3Rpb24iKTt4LmluZGV4T2YoIiAiKSE9PS0xJiYoZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChTKSxTLnNldEF0dHJpYnV0ZSgiZGF0YS1zIiwiIikpfSl9dmFyIG89dC5zdHlsaXNQbHVnaW5zfHxhUyxpPXt9LHMsYT1bXTtzPXQuY29udGFpbmVyfHxkb2N1bWVudC5oZWFkLEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1lbW90aW9uXj0iJytuKycgIl0nKSxmdW5jdGlvbihTKXtmb3IodmFyIHg9Uy5nZXRBdHRyaWJ1dGUoImRhdGEtZW1vdGlvbiIpLnNwbGl0KCIgIiksaD0xO2g8eC5sZW5ndGg7aCsrKWlbeFtoXV09ITA7YS5wdXNoKFMpfSk7dmFyIGwsdT1bb1MsaVNdO3t2YXIgYyxkPVtadyxlUyhmdW5jdGlvbihTKXtjLmluc2VydChTKX0pXSxtPUp3KHUuY29uY2F0KG8sZCkpLHY9ZnVuY3Rpb24oeCl7cmV0dXJuIGJvKFh3KHgpLG0pfTtsPWZ1bmN0aW9uKHgsaCxnLGYpe2M9Zyx2KHg/eCsieyIraC5zdHlsZXMrIn0iOmguc3R5bGVzKSxmJiYody5pbnNlcnRlZFtoLm5hbWVdPSEwKX19dmFyIHc9e2tleTpuLHNoZWV0Om5ldyB6dyh7a2V5Om4sY29udGFpbmVyOnMsbm9uY2U6dC5ub25jZSxzcGVlZHk6dC5zcGVlZHkscHJlcGVuZDp0LnByZXBlbmQsaW5zZXJ0aW9uUG9pbnQ6dC5pbnNlcnRpb25Qb2ludH0pLG5vbmNlOnQubm9uY2UsaW5zZXJ0ZWQ6aSxyZWdpc3RlcmVkOnt9LGluc2VydDpsfTtyZXR1cm4gdy5zaGVldC5oeWRyYXRlKGEpLHd9LE1nPXtleHBvcnRzOnt9fSxiZT17fTsvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjEKICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuCiAqCiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQogKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuCiAqL3ZhciB0dD10eXBlb2YgU3ltYm9sPT0iZnVuY3Rpb24iJiZTeW1ib2wuZm9yLExkPXR0P1N5bWJvbC5mb3IoInJlYWN0LmVsZW1lbnQiKTo2MDEwMyxqZD10dD9TeW1ib2wuZm9yKCJyZWFjdC5wb3J0YWwiKTo2MDEwNixwbD10dD9TeW1ib2wuZm9yKCJyZWFjdC5mcmFnbWVudCIpOjYwMTA3LG1sPXR0P1N5bWJvbC5mb3IoInJlYWN0LnN0cmljdF9tb2RlIik6NjAxMDgsaGw9dHQ/U3ltYm9sLmZvcigicmVhY3QucHJvZmlsZXIiKTo2MDExNCxnbD10dD9TeW1ib2wuZm9yKCJyZWFjdC5wcm92aWRlciIpOjYwMTA5LHlsPXR0P1N5bWJvbC5mb3IoInJlYWN0LmNvbnRleHQiKTo2MDExMCxEZD10dD9TeW1ib2wuZm9yKCJyZWFjdC5hc3luY19tb2RlIik6NjAxMTEsdmw9dHQ/U3ltYm9sLmZvcigicmVhY3QuY29uY3VycmVudF9tb2RlIik6NjAxMTEsd2w9dHQ/U3ltYm9sLmZvcigicmVhY3QuZm9yd2FyZF9yZWYiKTo2MDExMixTbD10dD9TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZSIpOjYwMTEzLHVTPXR0P1N5bWJvbC5mb3IoInJlYWN0LnN1c3BlbnNlX2xpc3QiKTo2MDEyMCx4bD10dD9TeW1ib2wuZm9yKCJyZWFjdC5tZW1vIik6NjAxMTUsQ2w9dHQ/U3ltYm9sLmZvcigicmVhY3QubGF6eSIpOjYwMTE2LGNTPXR0P1N5bWJvbC5mb3IoInJlYWN0LmJsb2NrIik6NjAxMjEsZFM9dHQ/U3ltYm9sLmZvcigicmVhY3QuZnVuZGFtZW50YWwiKTo2MDExNyxmUz10dD9TeW1ib2wuZm9yKCJyZWFjdC5yZXNwb25kZXIiKTo2MDExOCxwUz10dD9TeW1ib2wuZm9yKCJyZWFjdC5zY29wZSIpOjYwMTE5O2Z1bmN0aW9uIEh0KGUpe2lmKHR5cGVvZiBlPT0ib2JqZWN0IiYmZSE9PW51bGwpe3ZhciB0PWUuJCR0eXBlb2Y7c3dpdGNoKHQpe2Nhc2UgTGQ6c3dpdGNoKGU9ZS50eXBlLGUpe2Nhc2UgRGQ6Y2FzZSB2bDpjYXNlIHBsOmNhc2UgaGw6Y2FzZSBtbDpjYXNlIFNsOnJldHVybiBlO2RlZmF1bHQ6c3dpdGNoKGU9ZSYmZS4kJHR5cGVvZixlKXtjYXNlIHlsOmNhc2Ugd2w6Y2FzZSBDbDpjYXNlIHhsOmNhc2UgZ2w6cmV0dXJuIGU7ZGVmYXVsdDpyZXR1cm4gdH19Y2FzZSBqZDpyZXR1cm4gdH19fWZ1bmN0aW9uIF9nKGUpe3JldHVybiBIdChlKT09PXZsfWJlLkFzeW5jTW9kZT1EZDtiZS5Db25jdXJyZW50TW9kZT12bDtiZS5Db250ZXh0Q29uc3VtZXI9eWw7YmUuQ29udGV4dFByb3ZpZGVyPWdsO2JlLkVsZW1lbnQ9TGQ7YmUuRm9yd2FyZFJlZj13bDtiZS5GcmFnbWVudD1wbDtiZS5MYXp5PUNsO2JlLk1lbW89eGw7YmUuUG9ydGFsPWpkO2JlLlByb2ZpbGVyPWhsO2JlLlN0cmljdE1vZGU9bWw7YmUuU3VzcGVuc2U9U2w7YmUuaXNBc3luY01vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIF9nKGUpfHxIdChlKT09PURkfTtiZS5pc0NvbmN1cnJlbnRNb2RlPV9nO2JlLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGUpe3JldHVybiBIdChlKT09PXlsfTtiZS5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihlKXtyZXR1cm4gSHQoZSk9PT1nbH07YmUuaXNFbGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09Im9iamVjdCImJmUhPT1udWxsJiZlLiQkdHlwZW9mPT09TGR9O2JlLmlzRm9yd2FyZFJlZj1mdW5jdGlvbihlKXtyZXR1cm4gSHQoZSk9PT13bH07YmUuaXNGcmFnbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gSHQoZSk9PT1wbH07YmUuaXNMYXp5PWZ1bmN0aW9uKGUpe3JldHVybiBIdChlKT09PUNsfTtiZS5pc01lbW89ZnVuY3Rpb24oZSl7cmV0dXJuIEh0KGUpPT09eGx9O2JlLmlzUG9ydGFsPWZ1bmN0aW9uKGUpe3JldHVybiBIdChlKT09PWpkfTtiZS5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGUpe3JldHVybiBIdChlKT09PWhsfTtiZS5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIEh0KGUpPT09bWx9O2JlLmlzU3VzcGVuc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIEh0KGUpPT09U2x9O2JlLmlzVmFsaWRFbGVtZW50VHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PSJzdHJpbmcifHx0eXBlb2YgZT09ImZ1bmN0aW9uInx8ZT09PXBsfHxlPT09dmx8fGU9PT1obHx8ZT09PW1sfHxlPT09U2x8fGU9PT11U3x8dHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbCYmKGUuJCR0eXBlb2Y9PT1DbHx8ZS4kJHR5cGVvZj09PXhsfHxlLiQkdHlwZW9mPT09Z2x8fGUuJCR0eXBlb2Y9PT15bHx8ZS4kJHR5cGVvZj09PXdsfHxlLiQkdHlwZW9mPT09ZFN8fGUuJCR0eXBlb2Y9PT1mU3x8ZS4kJHR5cGVvZj09PXBTfHxlLiQkdHlwZW9mPT09Y1MpfTtiZS50eXBlT2Y9SHQ7TWcuZXhwb3J0cz1iZTt2YXIgbVM9TWcuZXhwb3J0cyxOZz1tUyxoUz17JCR0eXBlb2Y6ITAscmVuZGVyOiEwLGRlZmF1bHRQcm9wczohMCxkaXNwbGF5TmFtZTohMCxwcm9wVHlwZXM6ITB9LGdTPXskJHR5cGVvZjohMCxjb21wYXJlOiEwLGRlZmF1bHRQcm9wczohMCxkaXNwbGF5TmFtZTohMCxwcm9wVHlwZXM6ITAsdHlwZTohMH0sSWc9e307SWdbTmcuRm9yd2FyZFJlZl09aFM7SWdbTmcuTWVtb109Z1M7dmFyIHlTPSEwO2Z1bmN0aW9uIHZTKGUsdCxuKXt2YXIgcj0iIjtyZXR1cm4gbi5zcGxpdCgiICIpLmZvckVhY2goZnVuY3Rpb24obyl7ZVtvXSE9PXZvaWQgMD90LnB1c2goZVtvXSsiOyIpOm8mJihyKz1vKyIgIil9KSxyfXZhciBBZz1mdW5jdGlvbih0LG4scil7dmFyIG89dC5rZXkrIi0iK24ubmFtZTsocj09PSExfHx5Uz09PSExKSYmdC5yZWdpc3RlcmVkW29dPT09dm9pZCAwJiYodC5yZWdpc3RlcmVkW29dPW4uc3R5bGVzKX0semc9ZnVuY3Rpb24odCxuLHIpe0FnKHQsbixyKTt2YXIgbz10LmtleSsiLSIrbi5uYW1lO2lmKHQuaW5zZXJ0ZWRbbi5uYW1lXT09PXZvaWQgMCl7dmFyIGk9bjtkbyB0Lmluc2VydChuPT09aT8iLiIrbzoiIixpLHQuc2hlZXQsITApLGk9aS5uZXh0O3doaWxlKGkhPT12b2lkIDApfX07ZnVuY3Rpb24gd1MoZSl7Zm9yKHZhciB0PTAsbixyPTAsbz1lLmxlbmd0aDtvPj00OysrcixvLT00KW49ZS5jaGFyQ29kZUF0KHIpJjI1NXwoZS5jaGFyQ29kZUF0KCsrcikmMjU1KTw8OHwoZS5jaGFyQ29kZUF0KCsrcikmMjU1KTw8MTZ8KGUuY2hhckNvZGVBdCgrK3IpJjI1NSk8PDI0LG49KG4mNjU1MzUpKjE1NDA0ODM0NzcrKChuPj4+MTYpKjU5Nzk3PDwxNiksbl49bj4+PjI0LHQ9KG4mNjU1MzUpKjE1NDA0ODM0NzcrKChuPj4+MTYpKjU5Nzk3PDwxNileKHQmNjU1MzUpKjE1NDA0ODM0NzcrKCh0Pj4+MTYpKjU5Nzk3PDwxNik7c3dpdGNoKG8pe2Nhc2UgMzp0Xj0oZS5jaGFyQ29kZUF0KHIrMikmMjU1KTw8MTY7Y2FzZSAyOnRePShlLmNoYXJDb2RlQXQocisxKSYyNTUpPDw4O2Nhc2UgMTp0Xj1lLmNoYXJDb2RlQXQocikmMjU1LHQ9KHQmNjU1MzUpKjE1NDA0ODM0NzcrKCh0Pj4+MTYpKjU5Nzk3PDwxNil9cmV0dXJuIHRePXQ+Pj4xMyx0PSh0JjY1NTM1KSoxNTQwNDgzNDc3KygodD4+PjE2KSo1OTc5Nzw8MTYpLCgodF50Pj4+MTUpPj4+MCkudG9TdHJpbmcoMzYpfXZhciBTUz17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6MSxhc3BlY3RSYXRpbzoxLGJvcmRlckltYWdlT3V0c2V0OjEsYm9yZGVySW1hZ2VTbGljZToxLGJvcmRlckltYWdlV2lkdGg6MSxib3hGbGV4OjEsYm94RmxleEdyb3VwOjEsYm94T3JkaW5hbEdyb3VwOjEsY29sdW1uQ291bnQ6MSxjb2x1bW5zOjEsZmxleDoxLGZsZXhHcm93OjEsZmxleFBvc2l0aXZlOjEsZmxleFNocmluazoxLGZsZXhOZWdhdGl2ZToxLGZsZXhPcmRlcjoxLGdyaWRSb3c6MSxncmlkUm93RW5kOjEsZ3JpZFJvd1NwYW46MSxncmlkUm93U3RhcnQ6MSxncmlkQ29sdW1uOjEsZ3JpZENvbHVtbkVuZDoxLGdyaWRDb2x1bW5TcGFuOjEsZ3JpZENvbHVtblN0YXJ0OjEsbXNHcmlkUm93OjEsbXNHcmlkUm93U3BhbjoxLG1zR3JpZENvbHVtbjoxLG1zR3JpZENvbHVtblNwYW46MSxmb250V2VpZ2h0OjEsbGluZUhlaWdodDoxLG9wYWNpdHk6MSxvcmRlcjoxLG9ycGhhbnM6MSxzY2FsZToxLHRhYlNpemU6MSx3aWRvd3M6MSx6SW5kZXg6MSx6b29tOjEsV2Via2l0TGluZUNsYW1wOjEsZmlsbE9wYWNpdHk6MSxmbG9vZE9wYWNpdHk6MSxzdG9wT3BhY2l0eToxLHN0cm9rZURhc2hhcnJheToxLHN0cm9rZURhc2hvZmZzZXQ6MSxzdHJva2VNaXRlcmxpbWl0OjEsc3Ryb2tlT3BhY2l0eToxLHN0cm9rZVdpZHRoOjF9LHhTPSExLENTPS9bQS1aXXxebXMvZyxiUz0vX0VNT18oW15fXSs/KV8oW15dKj8pX0VNT18vZyxMZz1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQ29kZUF0KDEpPT09NDV9LElwPWZ1bmN0aW9uKHQpe3JldHVybiB0IT1udWxsJiZ0eXBlb2YgdCE9ImJvb2xlYW4ifSxTdT1iZyhmdW5jdGlvbihlKXtyZXR1cm4gTGcoZSk/ZTplLnJlcGxhY2UoQ1MsIi0kJiIpLnRvTG93ZXJDYXNlKCl9KSxBcD1mdW5jdGlvbih0LG4pe3N3aXRjaCh0KXtjYXNlImFuaW1hdGlvbiI6Y2FzZSJhbmltYXRpb25OYW1lIjppZih0eXBlb2Ygbj09InN0cmluZyIpcmV0dXJuIG4ucmVwbGFjZShiUyxmdW5jdGlvbihyLG8saSl7cmV0dXJuICRuPXtuYW1lOm8sc3R5bGVzOmksbmV4dDokbn0sb30pfXJldHVybiBTU1t0XSE9PTEmJiFMZyh0KSYmdHlwZW9mIG49PSJudW1iZXIiJiZuIT09MD9uKyJweCI6bn0sa1M9IkNvbXBvbmVudCBzZWxlY3RvcnMgY2FuIG9ubHkgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIEBlbW90aW9uL2JhYmVsLXBsdWdpbiwgdGhlIHN3YyBFbW90aW9uIHBsdWdpbiwgb3IgYW5vdGhlciBFbW90aW9uLWF3YXJlIGNvbXBpbGVyIHRyYW5zZm9ybS4iO2Z1bmN0aW9uIEhpKGUsdCxuKXtpZihuPT1udWxsKXJldHVybiIiO3ZhciByPW47aWYoci5fX2Vtb3Rpb25fc3R5bGVzIT09dm9pZCAwKXJldHVybiByO3N3aXRjaCh0eXBlb2Ygbil7Y2FzZSJib29sZWFuIjpyZXR1cm4iIjtjYXNlIm9iamVjdCI6e3ZhciBvPW47aWYoby5hbmltPT09MSlyZXR1cm4gJG49e25hbWU6by5uYW1lLHN0eWxlczpvLnN0eWxlcyxuZXh0OiRufSxvLm5hbWU7dmFyIGk9bjtpZihpLnN0eWxlcyE9PXZvaWQgMCl7dmFyIHM9aS5uZXh0O2lmKHMhPT12b2lkIDApZm9yKDtzIT09dm9pZCAwOykkbj17bmFtZTpzLm5hbWUsc3R5bGVzOnMuc3R5bGVzLG5leHQ6JG59LHM9cy5uZXh0O3ZhciBhPWkuc3R5bGVzKyI7IjtyZXR1cm4gYX1yZXR1cm4gRVMoZSx0LG4pfWNhc2UiZnVuY3Rpb24iOntpZihlIT09dm9pZCAwKXt2YXIgbD0kbix1PW4oZSk7cmV0dXJuICRuPWwsSGkoZSx0LHUpfWJyZWFrfX12YXIgYz1uO2lmKHQ9PW51bGwpcmV0dXJuIGM7dmFyIGQ9dFtjXTtyZXR1cm4gZCE9PXZvaWQgMD9kOmN9ZnVuY3Rpb24gRVMoZSx0LG4pe3ZhciByPSIiO2lmKEFycmF5LmlzQXJyYXkobikpZm9yKHZhciBvPTA7bzxuLmxlbmd0aDtvKyspcis9SGkoZSx0LG5bb10pKyI7IjtlbHNlIGZvcih2YXIgaSBpbiBuKXt2YXIgcz1uW2ldO2lmKHR5cGVvZiBzIT0ib2JqZWN0Iil7dmFyIGE9czt0IT1udWxsJiZ0W2FdIT09dm9pZCAwP3IrPWkrInsiK3RbYV0rIn0iOklwKGEpJiYocis9U3UoaSkrIjoiK0FwKGksYSkrIjsiKX1lbHNle2lmKGk9PT0iTk9fQ09NUE9ORU5UX1NFTEVDVE9SIiYmeFMpdGhyb3cgbmV3IEVycm9yKGtTKTtpZihBcnJheS5pc0FycmF5KHMpJiZ0eXBlb2Ygc1swXT09InN0cmluZyImJih0PT1udWxsfHx0W3NbMF1dPT09dm9pZCAwKSlmb3IodmFyIGw9MDtsPHMubGVuZ3RoO2wrKylJcChzW2xdKSYmKHIrPVN1KGkpKyI6IitBcChpLHNbbF0pKyI7Iik7ZWxzZXt2YXIgdT1IaShlLHQscyk7c3dpdGNoKGkpe2Nhc2UiYW5pbWF0aW9uIjpjYXNlImFuaW1hdGlvbk5hbWUiOntyKz1TdShpKSsiOiIrdSsiOyI7YnJlYWt9ZGVmYXVsdDpyKz1pKyJ7Iit1KyJ9In19fX1yZXR1cm4gcn12YXIgenA9L2xhYmVsOlxzKihbXlxzO3tdKylccyooO3wkKS9nLCRuO2Z1bmN0aW9uIGJsKGUsdCxuKXtpZihlLmxlbmd0aD09PTEmJnR5cGVvZiBlWzBdPT0ib2JqZWN0IiYmZVswXSE9PW51bGwmJmVbMF0uc3R5bGVzIT09dm9pZCAwKXJldHVybiBlWzBdO3ZhciByPSEwLG89IiI7JG49dm9pZCAwO3ZhciBpPWVbMF07aWYoaT09bnVsbHx8aS5yYXc9PT12b2lkIDApcj0hMSxvKz1IaShuLHQsaSk7ZWxzZXt2YXIgcz1pO28rPXNbMF19Zm9yKHZhciBhPTE7YTxlLmxlbmd0aDthKyspaWYobys9SGkobix0LGVbYV0pLHIpe3ZhciBsPWk7bys9bFthXX16cC5sYXN0SW5kZXg9MDtmb3IodmFyIHU9IiIsYzsoYz16cC5leGVjKG8pKSE9PW51bGw7KXUrPSItIitjWzFdO3ZhciBkPXdTKG8pK3U7cmV0dXJue25hbWU6ZCxzdHlsZXM6byxuZXh0OiRufX12YXIgUlM9ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0samc9RGkudXNlSW5zZXJ0aW9uRWZmZWN0P0RpLnVzZUluc2VydGlvbkVmZmVjdDohMSxUUz1qZ3x8UlMsTHA9amd8fEMudXNlTGF5b3V0RWZmZWN0LERnPUMuY3JlYXRlQ29udGV4dCh0eXBlb2YgSFRNTEVsZW1lbnQ8InUiP2xTKHtrZXk6ImNzcyJ9KTpudWxsKTtEZy5Qcm92aWRlcjt2YXIgRmc9ZnVuY3Rpb24odCl7cmV0dXJuIEMuZm9yd2FyZFJlZihmdW5jdGlvbihuLHIpe3ZhciBvPUMudXNlQ29udGV4dChEZyk7cmV0dXJuIHQobixvLHIpfSl9LEZkPUMuY3JlYXRlQ29udGV4dCh7fSksUFM9RmcoZnVuY3Rpb24oZSx0KXt2YXIgbj1lLnN0eWxlcyxyPWJsKFtuXSx2b2lkIDAsQy51c2VDb250ZXh0KEZkKSksbz1DLnVzZVJlZigpO3JldHVybiBMcChmdW5jdGlvbigpe3ZhciBpPXQua2V5KyItZ2xvYmFsIixzPW5ldyB0LnNoZWV0LmNvbnN0cnVjdG9yKHtrZXk6aSxub25jZTp0LnNoZWV0Lm5vbmNlLGNvbnRhaW5lcjp0LnNoZWV0LmNvbnRhaW5lcixzcGVlZHk6dC5zaGVldC5pc1NwZWVkeX0pLGE9ITEsbD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWVtb3Rpb249IicraSsiICIrci5uYW1lKyciXScpO3JldHVybiB0LnNoZWV0LnRhZ3MubGVuZ3RoJiYocy5iZWZvcmU9dC5zaGVldC50YWdzWzBdKSxsIT09bnVsbCYmKGE9ITAsbC5zZXRBdHRyaWJ1dGUoImRhdGEtZW1vdGlvbiIsaSkscy5oeWRyYXRlKFtsXSkpLG8uY3VycmVudD1bcyxhXSxmdW5jdGlvbigpe3MuZmx1c2goKX19LFt0XSksTHAoZnVuY3Rpb24oKXt2YXIgaT1vLmN1cnJlbnQscz1pWzBdLGE9aVsxXTtpZihhKXtpWzFdPSExO3JldHVybn1pZihyLm5leHQhPT12b2lkIDAmJnpnKHQsci5uZXh0LCEwKSxzLnRhZ3MubGVuZ3RoKXt2YXIgbD1zLnRhZ3Nbcy50YWdzLmxlbmd0aC0xXS5uZXh0RWxlbWVudFNpYmxpbmc7cy5iZWZvcmU9bCxzLmZsdXNoKCl9dC5pbnNlcnQoIiIscixzLCExKX0sW3Qsci5uYW1lXSksbnVsbH0pO2Z1bmN0aW9uICRTKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSksbj0wO248ZTtuKyspdFtuXT1hcmd1bWVudHNbbl07cmV0dXJuIGJsKHQpfXZhciBCZD1mdW5jdGlvbigpe3ZhciB0PSRTLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpLG49ImFuaW1hdGlvbi0iK3QubmFtZTtyZXR1cm57bmFtZTpuLHN0eWxlczoiQGtleWZyYW1lcyAiK24rInsiK3Quc3R5bGVzKyJ9IixhbmltOjEsdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4iX0VNT18iK3RoaXMubmFtZSsiXyIrdGhpcy5zdHlsZXMrIl9FTU9fIn19fSxPUz1fdyxNUz1mdW5jdGlvbih0KXtyZXR1cm4gdCE9PSJ0aGVtZSJ9LGpwPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09InN0cmluZyImJnQuY2hhckNvZGVBdCgwKT45Nj9PUzpNU30sRHA9ZnVuY3Rpb24odCxuLHIpe3ZhciBvO2lmKG4pe3ZhciBpPW4uc2hvdWxkRm9yd2FyZFByb3A7bz10Ll9fZW1vdGlvbl9mb3J3YXJkUHJvcCYmaT9mdW5jdGlvbihzKXtyZXR1cm4gdC5fX2Vtb3Rpb25fZm9yd2FyZFByb3AocykmJmkocyl9Oml9cmV0dXJuIHR5cGVvZiBvIT0iZnVuY3Rpb24iJiZyJiYobz10Ll9fZW1vdGlvbl9mb3J3YXJkUHJvcCksb30sX1M9ITEsTlM9ZnVuY3Rpb24odCl7dmFyIG49dC5jYWNoZSxyPXQuc2VyaWFsaXplZCxvPXQuaXNTdHJpbmdUYWc7cmV0dXJuIEFnKG4scixvKSxUUyhmdW5jdGlvbigpe3JldHVybiB6ZyhuLHIsbyl9KSxudWxsfSxJUz1mdW5jdGlvbiBlKHQsbil7dmFyIHI9dC5fX2Vtb3Rpb25fcmVhbD09PXQsbz1yJiZ0Ll9fZW1vdGlvbl9iYXNlfHx0LGkscztuIT09dm9pZCAwJiYoaT1uLmxhYmVsLHM9bi50YXJnZXQpO3ZhciBhPURwKHQsbixyKSxsPWF8fGpwKG8pLHU9IWwoImFzIik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9YXJndW1lbnRzLGQ9ciYmdC5fX2Vtb3Rpb25fc3R5bGVzIT09dm9pZCAwP3QuX19lbW90aW9uX3N0eWxlcy5zbGljZSgwKTpbXTtpZihpIT09dm9pZCAwJiZkLnB1c2goImxhYmVsOiIraSsiOyIpLGNbMF09PW51bGx8fGNbMF0ucmF3PT09dm9pZCAwKWQucHVzaC5hcHBseShkLGMpO2Vsc2V7ZC5wdXNoKGNbMF1bMF0pO2Zvcih2YXIgbT1jLmxlbmd0aCx2PTE7djxtO3YrKylkLnB1c2goY1t2XSxjWzBdW3ZdKX12YXIgdz1GZyhmdW5jdGlvbihTLHgsaCl7dmFyIGc9dSYmUy5hc3x8byxmPSIiLHk9W10sYj1TO2lmKFMudGhlbWU9PW51bGwpe2I9e307Zm9yKHZhciBFIGluIFMpYltFXT1TW0VdO2IudGhlbWU9Qy51c2VDb250ZXh0KEZkKX10eXBlb2YgUy5jbGFzc05hbWU9PSJzdHJpbmciP2Y9dlMoeC5yZWdpc3RlcmVkLHksUy5jbGFzc05hbWUpOlMuY2xhc3NOYW1lIT1udWxsJiYoZj1TLmNsYXNzTmFtZSsiICIpO3ZhciBSPWJsKGQuY29uY2F0KHkpLHgucmVnaXN0ZXJlZCxiKTtmKz14LmtleSsiLSIrUi5uYW1lLHMhPT12b2lkIDAmJihmKz0iICIrcyk7dmFyIFA9dSYmYT09PXZvaWQgMD9qcChnKTpsLEk9e307Zm9yKHZhciBwIGluIFMpdSYmcD09PSJhcyJ8fFAocCkmJihJW3BdPVNbcF0pO3JldHVybiBJLmNsYXNzTmFtZT1mLGgmJihJLnJlZj1oKSxDLmNyZWF0ZUVsZW1lbnQoQy5GcmFnbWVudCxudWxsLEMuY3JlYXRlRWxlbWVudChOUyx7Y2FjaGU6eCxzZXJpYWxpemVkOlIsaXNTdHJpbmdUYWc6dHlwZW9mIGc9PSJzdHJpbmcifSksQy5jcmVhdGVFbGVtZW50KGcsSSkpfSk7cmV0dXJuIHcuZGlzcGxheU5hbWU9aSE9PXZvaWQgMD9pOiJTdHlsZWQoIisodHlwZW9mIG89PSJzdHJpbmciP286by5kaXNwbGF5TmFtZXx8by5uYW1lfHwiQ29tcG9uZW50IikrIikiLHcuZGVmYXVsdFByb3BzPXQuZGVmYXVsdFByb3BzLHcuX19lbW90aW9uX3JlYWw9dyx3Ll9fZW1vdGlvbl9iYXNlPW8sdy5fX2Vtb3Rpb25fc3R5bGVzPWQsdy5fX2Vtb3Rpb25fZm9yd2FyZFByb3A9YSxPYmplY3QuZGVmaW5lUHJvcGVydHkodywidG9TdHJpbmciLHt2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBzPT09dm9pZCAwJiZfUz8iTk9fQ09NUE9ORU5UX1NFTEVDVE9SIjoiLiIrc319KSx3LndpdGhDb21wb25lbnQ9ZnVuY3Rpb24oUyx4KXtyZXR1cm4gZShTLEJpKHt9LG4seCx7c2hvdWxkRm9yd2FyZFByb3A6RHAodyx4LCEwKX0pKS5hcHBseSh2b2lkIDAsZCl9LHd9fSxBUz1bImEiLCJhYmJyIiwiYWRkcmVzcyIsImFyZWEiLCJhcnRpY2xlIiwiYXNpZGUiLCJhdWRpbyIsImIiLCJiYXNlIiwiYmRpIiwiYmRvIiwiYmlnIiwiYmxvY2txdW90ZSIsImJvZHkiLCJiciIsImJ1dHRvbiIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29kZSIsImNvbCIsImNvbGdyb3VwIiwiZGF0YSIsImRhdGFsaXN0IiwiZGQiLCJkZWwiLCJkZXRhaWxzIiwiZGZuIiwiZGlhbG9nIiwiZGl2IiwiZGwiLCJkdCIsImVtIiwiZW1iZWQiLCJmaWVsZHNldCIsImZpZ2NhcHRpb24iLCJmaWd1cmUiLCJmb290ZXIiLCJmb3JtIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZCIsImhlYWRlciIsImhncm91cCIsImhyIiwiaHRtbCIsImkiLCJpZnJhbWUiLCJpbWciLCJpbnB1dCIsImlucyIsImtiZCIsImtleWdlbiIsImxhYmVsIiwibGVnZW5kIiwibGkiLCJsaW5rIiwibWFpbiIsIm1hcCIsIm1hcmsiLCJtYXJxdWVlIiwibWVudSIsIm1lbnVpdGVtIiwibWV0YSIsIm1ldGVyIiwibmF2Iiwibm9zY3JpcHQiLCJvYmplY3QiLCJvbCIsIm9wdGdyb3VwIiwib3B0aW9uIiwib3V0cHV0IiwicCIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInByb2dyZXNzIiwicSIsInJwIiwicnQiLCJydWJ5IiwicyIsInNhbXAiLCJzY3JpcHQiLCJzZWN0aW9uIiwic2VsZWN0Iiwic21hbGwiLCJzb3VyY2UiLCJzcGFuIiwic3Ryb25nIiwic3R5bGUiLCJzdWIiLCJzdW1tYXJ5Iiwic3VwIiwidGFibGUiLCJ0Ym9keSIsInRkIiwidGV4dGFyZWEiLCJ0Zm9vdCIsInRoIiwidGhlYWQiLCJ0aW1lIiwidGl0bGUiLCJ0ciIsInRyYWNrIiwidSIsInVsIiwidmFyIiwidmlkZW8iLCJ3YnIiLCJjaXJjbGUiLCJjbGlwUGF0aCIsImRlZnMiLCJlbGxpcHNlIiwiZm9yZWlnbk9iamVjdCIsImciLCJpbWFnZSIsImxpbmUiLCJsaW5lYXJHcmFkaWVudCIsIm1hc2siLCJwYXRoIiwicGF0dGVybiIsInBvbHlnb24iLCJwb2x5bGluZSIsInJhZGlhbEdyYWRpZW50IiwicmVjdCIsInN0b3AiLCJzdmciLCJ0ZXh0IiwidHNwYW4iXSxjYz1JUy5iaW5kKCk7QVMuZm9yRWFjaChmdW5jdGlvbihlKXtjY1tlXT1jYyhlKX0pO2Z1bmN0aW9uIHpTKGUpe3JldHVybiBlPT1udWxsfHxPYmplY3Qua2V5cyhlKS5sZW5ndGg9PT0wfWZ1bmN0aW9uIExTKGUpe2NvbnN0e3N0eWxlczp0LGRlZmF1bHRUaGVtZTpuPXt9fT1lLHI9dHlwZW9mIHQ9PSJmdW5jdGlvbiI/bz0+dCh6UyhvKT9uOm8pOnQ7cmV0dXJuIGsuanN4KFBTLHtzdHlsZXM6cn0pfS8qKgogKiBAbXVpL3N0eWxlZC1lbmdpbmUgdjYuMS42CiAqCiAqIEBsaWNlbnNlIE1JVAogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi9mdW5jdGlvbiBqUyhlLHQpe3JldHVybiBjYyhlLHQpfWZ1bmN0aW9uIERTKGUsdCl7QXJyYXkuaXNBcnJheShlLl9fZW1vdGlvbl9zdHlsZXMpJiYoZS5fX2Vtb3Rpb25fc3R5bGVzPXQoZS5fX2Vtb3Rpb25fc3R5bGVzKSl9Y29uc3QgRnA9W107ZnVuY3Rpb24gQnAoZSl7cmV0dXJuIEZwWzBdPWUsYmwoRnApfWZ1bmN0aW9uIE9uKGUpe2lmKHR5cGVvZiBlIT0ib2JqZWN0Inx8ZT09PW51bGwpcmV0dXJuITE7Y29uc3QgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7cmV0dXJuKHQ9PT1udWxsfHx0PT09T2JqZWN0LnByb3RvdHlwZXx8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpPT09bnVsbCkmJiEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpJiYhKFN5bWJvbC5pdGVyYXRvciBpbiBlKX1mdW5jdGlvbiBCZyhlKXtpZighT24oZSkpcmV0dXJuIGU7Y29uc3QgdD17fTtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaChuPT57dFtuXT1CZyhlW25dKX0pLHR9ZnVuY3Rpb24gcHQoZSx0LG49e2Nsb25lOiEwfSl7Y29uc3Qgcj1uLmNsb25lP3suLi5lfTplO3JldHVybiBPbihlKSYmT24odCkmJk9iamVjdC5rZXlzKHQpLmZvckVhY2gobz0+e09uKHRbb10pJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmT24oZVtvXSk/cltvXT1wdChlW29dLHRbb10sbik6bi5jbG9uZT9yW29dPU9uKHRbb10pP0JnKHRbb10pOnRbb106cltvXT10W29dfSkscn1jb25zdCBGUz1lPT57Y29uc3QgdD1PYmplY3Qua2V5cyhlKS5tYXAobj0+KHtrZXk6bix2YWw6ZVtuXX0pKXx8W107cmV0dXJuIHQuc29ydCgobixyKT0+bi52YWwtci52YWwpLHQucmVkdWNlKChuLHIpPT4oey4uLm4sW3Iua2V5XTpyLnZhbH0pLHt9KX07ZnVuY3Rpb24gQlMoZSl7Y29uc3R7dmFsdWVzOnQ9e3hzOjAsc206NjAwLG1kOjkwMCxsZzoxMjAwLHhsOjE1MzZ9LHVuaXQ6bj0icHgiLHN0ZXA6cj01LC4uLm99PWUsaT1GUyh0KSxzPU9iamVjdC5rZXlzKGkpO2Z1bmN0aW9uIGEobSl7cmV0dXJuYEBtZWRpYSAobWluLXdpZHRoOiR7dHlwZW9mIHRbbV09PSJudW1iZXIiP3RbbV06bX0ke259KWB9ZnVuY3Rpb24gbChtKXtyZXR1cm5gQG1lZGlhIChtYXgtd2lkdGg6JHsodHlwZW9mIHRbbV09PSJudW1iZXIiP3RbbV06bSktci8xMDB9JHtufSlgfWZ1bmN0aW9uIHUobSx2KXtjb25zdCB3PXMuaW5kZXhPZih2KTtyZXR1cm5gQG1lZGlhIChtaW4td2lkdGg6JHt0eXBlb2YgdFttXT09Im51bWJlciI/dFttXTptfSR7bn0pIGFuZCAobWF4LXdpZHRoOiR7KHchPT0tMSYmdHlwZW9mIHRbc1t3XV09PSJudW1iZXIiP3Rbc1t3XV06diktci8xMDB9JHtufSlgfWZ1bmN0aW9uIGMobSl7cmV0dXJuIHMuaW5kZXhPZihtKSsxPHMubGVuZ3RoP3UobSxzW3MuaW5kZXhPZihtKSsxXSk6YShtKX1mdW5jdGlvbiBkKG0pe2NvbnN0IHY9cy5pbmRleE9mKG0pO3JldHVybiB2PT09MD9hKHNbMV0pOnY9PT1zLmxlbmd0aC0xP2woc1t2XSk6dShtLHNbcy5pbmRleE9mKG0pKzFdKS5yZXBsYWNlKCJAbWVkaWEiLCJAbWVkaWEgbm90IGFsbCBhbmQiKX1yZXR1cm57a2V5czpzLHZhbHVlczppLHVwOmEsZG93bjpsLGJldHdlZW46dSxvbmx5OmMsbm90OmQsdW5pdDpuLC4uLm99fWZ1bmN0aW9uIFdTKGUsdCl7aWYoIWUuY29udGFpbmVyUXVlcmllcylyZXR1cm4gdDtjb25zdCBuPU9iamVjdC5rZXlzKHQpLmZpbHRlcihyPT5yLnN0YXJ0c1dpdGgoIkBjb250YWluZXIiKSkuc29ydCgocixvKT0+e3ZhciBzLGE7Y29uc3QgaT0vbWluLXdpZHRoOlxzKihbMC05Ll0rKS87cmV0dXJuKygoKHM9ci5tYXRjaChpKSk9PW51bGw/dm9pZCAwOnNbMV0pfHwwKS0rKCgoYT1vLm1hdGNoKGkpKT09bnVsbD92b2lkIDA6YVsxXSl8fDApfSk7cmV0dXJuIG4ubGVuZ3RoP24ucmVkdWNlKChyLG8pPT57Y29uc3QgaT10W29dO3JldHVybiBkZWxldGUgcltvXSxyW29dPWkscn0sey4uLnR9KTp0fWZ1bmN0aW9uIFVTKGUsdCl7cmV0dXJuIHQ9PT0iQCJ8fHQuc3RhcnRzV2l0aCgiQCIpJiYoZS5zb21lKG49PnQuc3RhcnRzV2l0aChgQCR7bn1gKSl8fCEhdC5tYXRjaCgvXkBcZC8pKX1mdW5jdGlvbiBIUyhlLHQpe2NvbnN0IG49dC5tYXRjaCgvXkAoW14vXSspP1wvPyguKyk/JC8pO2lmKCFuKXJldHVybiBudWxsO2NvbnN0WyxyLG9dPW4saT1OdW1iZXIuaXNOYU4oK3IpP3J8fDA6K3I7cmV0dXJuIGUuY29udGFpbmVyUXVlcmllcyhvKS51cChpKX1mdW5jdGlvbiBWUyhlKXtjb25zdCB0PShpLHMpPT5pLnJlcGxhY2UoIkBtZWRpYSIscz9gQGNvbnRhaW5lciAke3N9YDoiQGNvbnRhaW5lciIpO2Z1bmN0aW9uIG4oaSxzKXtpLnVwPSguLi5hKT0+dChlLmJyZWFrcG9pbnRzLnVwKC4uLmEpLHMpLGkuZG93bj0oLi4uYSk9PnQoZS5icmVha3BvaW50cy5kb3duKC4uLmEpLHMpLGkuYmV0d2Vlbj0oLi4uYSk9PnQoZS5icmVha3BvaW50cy5iZXR3ZWVuKC4uLmEpLHMpLGkub25seT0oLi4uYSk9PnQoZS5icmVha3BvaW50cy5vbmx5KC4uLmEpLHMpLGkubm90PSguLi5hKT0+e2NvbnN0IGw9dChlLmJyZWFrcG9pbnRzLm5vdCguLi5hKSxzKTtyZXR1cm4gbC5pbmNsdWRlcygibm90IGFsbCBhbmQiKT9sLnJlcGxhY2UoIm5vdCBhbGwgYW5kICIsIiIpLnJlcGxhY2UoIm1pbi13aWR0aDoiLCJ3aWR0aDwiKS5yZXBsYWNlKCJtYXgtd2lkdGg6Iiwid2lkdGg+IikucmVwbGFjZSgiYW5kIiwib3IiKTpsfX1jb25zdCByPXt9LG89aT0+KG4ocixpKSxyKTtyZXR1cm4gbihvKSx7Li4uZSxjb250YWluZXJRdWVyaWVzOm99fWNvbnN0IEtTPXtib3JkZXJSYWRpdXM6NH07ZnVuY3Rpb24gRWkoZSx0KXtyZXR1cm4gdD9wdChlLHQse2Nsb25lOiExfSk6ZX1jb25zdCBrbD17eHM6MCxzbTo2MDAsbWQ6OTAwLGxnOjEyMDAseGw6MTUzNn0sV3A9e2tleXM6WyJ4cyIsInNtIiwibWQiLCJsZyIsInhsIl0sdXA6ZT0+YEBtZWRpYSAobWluLXdpZHRoOiR7a2xbZV19cHgpYH0sWVM9e2NvbnRhaW5lclF1ZXJpZXM6ZT0+KHt1cDp0PT57bGV0IG49dHlwZW9mIHQ9PSJudW1iZXIiP3Q6a2xbdF18fHQ7cmV0dXJuIHR5cGVvZiBuPT0ibnVtYmVyIiYmKG49YCR7bn1weGApLGU/YEBjb250YWluZXIgJHtlfSAobWluLXdpZHRoOiR7bn0pYDpgQGNvbnRhaW5lciAobWluLXdpZHRoOiR7bn0pYH19KX07ZnVuY3Rpb24gS24oZSx0LG4pe2NvbnN0IHI9ZS50aGVtZXx8e307aWYoQXJyYXkuaXNBcnJheSh0KSl7Y29uc3QgaT1yLmJyZWFrcG9pbnRzfHxXcDtyZXR1cm4gdC5yZWR1Y2UoKHMsYSxsKT0+KHNbaS51cChpLmtleXNbbF0pXT1uKHRbbF0pLHMpLHt9KX1pZih0eXBlb2YgdD09Im9iamVjdCIpe2NvbnN0IGk9ci5icmVha3BvaW50c3x8V3A7cmV0dXJuIE9iamVjdC5rZXlzKHQpLnJlZHVjZSgocyxhKT0+e2lmKFVTKGkua2V5cyxhKSl7Y29uc3QgbD1IUyhyLmNvbnRhaW5lclF1ZXJpZXM/cjpZUyxhKTtsJiYoc1tsXT1uKHRbYV0sYSkpfWVsc2UgaWYoT2JqZWN0LmtleXMoaS52YWx1ZXN8fGtsKS5pbmNsdWRlcyhhKSl7Y29uc3QgbD1pLnVwKGEpO3NbbF09bih0W2FdLGEpfWVsc2V7Y29uc3QgbD1hO3NbbF09dFtsXX1yZXR1cm4gc30se30pfXJldHVybiBuKHQpfWZ1bmN0aW9uIEdTKGU9e30pe3ZhciBuO3JldHVybigobj1lLmtleXMpPT1udWxsP3ZvaWQgMDpuLnJlZHVjZSgocixvKT0+e2NvbnN0IGk9ZS51cChvKTtyZXR1cm4gcltpXT17fSxyfSx7fSkpfHx7fX1mdW5jdGlvbiBRUyhlLHQpe3JldHVybiBlLnJlZHVjZSgobixyKT0+e2NvbnN0IG89bltyXTtyZXR1cm4oIW98fE9iamVjdC5rZXlzKG8pLmxlbmd0aD09PTApJiZkZWxldGUgbltyXSxufSx0KX1mdW5jdGlvbiBuZShlKXtpZih0eXBlb2YgZSE9InN0cmluZyIpdGhyb3cgbmV3IEVycm9yKFZuKDcpKTtyZXR1cm4gZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpfWZ1bmN0aW9uIEVsKGUsdCxuPSEwKXtpZighdHx8dHlwZW9mIHQhPSJzdHJpbmciKXJldHVybiBudWxsO2lmKGUmJmUudmFycyYmbil7Y29uc3Qgcj1gdmFycy4ke3R9YC5zcGxpdCgiLiIpLnJlZHVjZSgobyxpKT0+byYmb1tpXT9vW2ldOm51bGwsZSk7aWYociE9bnVsbClyZXR1cm4gcn1yZXR1cm4gdC5zcGxpdCgiLiIpLnJlZHVjZSgocixvKT0+ciYmcltvXSE9bnVsbD9yW29dOm51bGwsZSl9ZnVuY3Rpb24gQ2EoZSx0LG4scj1uKXtsZXQgbztyZXR1cm4gdHlwZW9mIGU9PSJmdW5jdGlvbiI/bz1lKG4pOkFycmF5LmlzQXJyYXkoZSk/bz1lW25dfHxyOm89RWwoZSxuKXx8cix0JiYobz10KG8scixlKSksb31mdW5jdGlvbiBIZShlKXtjb25zdHtwcm9wOnQsY3NzUHJvcGVydHk6bj1lLnByb3AsdGhlbWVLZXk6cix0cmFuc2Zvcm06b309ZSxpPXM9PntpZihzW3RdPT1udWxsKXJldHVybiBudWxsO2NvbnN0IGE9c1t0XSxsPXMudGhlbWUsdT1FbChsLHIpfHx7fTtyZXR1cm4gS24ocyxhLGQ9PntsZXQgbT1DYSh1LG8sZCk7cmV0dXJuIGQ9PT1tJiZ0eXBlb2YgZD09InN0cmluZyImJihtPUNhKHUsbyxgJHt0fSR7ZD09PSJkZWZhdWx0Ij8iIjpuZShkKX1gLGQpKSxuPT09ITE/bTp7W25dOm19fSl9O3JldHVybiBpLnByb3BUeXBlcz17fSxpLmZpbHRlclByb3BzPVt0XSxpfWZ1bmN0aW9uIFhTKGUpe2NvbnN0IHQ9e307cmV0dXJuIG49Pih0W25dPT09dm9pZCAwJiYodFtuXT1lKG4pKSx0W25dKX1jb25zdCBxUz17bToibWFyZ2luIixwOiJwYWRkaW5nIn0sWlM9e3Q6IlRvcCIscjoiUmlnaHQiLGI6IkJvdHRvbSIsbDoiTGVmdCIseDpbIkxlZnQiLCJSaWdodCJdLHk6WyJUb3AiLCJCb3R0b20iXX0sVXA9e21hcmdpblg6Im14IixtYXJnaW5ZOiJteSIscGFkZGluZ1g6InB4IixwYWRkaW5nWToicHkifSxKUz1YUyhlPT57aWYoZS5sZW5ndGg+MilpZihVcFtlXSllPVVwW2VdO2Vsc2UgcmV0dXJuW2VdO2NvbnN0W3Qsbl09ZS5zcGxpdCgiIikscj1xU1t0XSxvPVpTW25dfHwiIjtyZXR1cm4gQXJyYXkuaXNBcnJheShvKT9vLm1hcChpPT5yK2kpOltyK29dfSksV2Q9WyJtIiwibXQiLCJtciIsIm1iIiwibWwiLCJteCIsIm15IiwibWFyZ2luIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luWCIsIm1hcmdpblkiLCJtYXJnaW5JbmxpbmUiLCJtYXJnaW5JbmxpbmVTdGFydCIsIm1hcmdpbklubGluZUVuZCIsIm1hcmdpbkJsb2NrIiwibWFyZ2luQmxvY2tTdGFydCIsIm1hcmdpbkJsb2NrRW5kIl0sVWQ9WyJwIiwicHQiLCJwciIsInBiIiwicGwiLCJweCIsInB5IiwicGFkZGluZyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwicGFkZGluZ0lubGluZSIsInBhZGRpbmdJbmxpbmVTdGFydCIsInBhZGRpbmdJbmxpbmVFbmQiLCJwYWRkaW5nQmxvY2siLCJwYWRkaW5nQmxvY2tTdGFydCIsInBhZGRpbmdCbG9ja0VuZCJdO1suLi5XZCwuLi5VZF07ZnVuY3Rpb24geXMoZSx0LG4scil7Y29uc3Qgbz1FbChlLHQsITApPz9uO3JldHVybiB0eXBlb2Ygbz09Im51bWJlciJ8fHR5cGVvZiBvPT0ic3RyaW5nIj9pPT50eXBlb2YgaT09InN0cmluZyI/aTp0eXBlb2Ygbz09InN0cmluZyI/YGNhbGMoJHtpfSAqICR7b30pYDpvKmk6QXJyYXkuaXNBcnJheShvKT9pPT57aWYodHlwZW9mIGk9PSJzdHJpbmciKXJldHVybiBpO2NvbnN0IHM9TWF0aC5hYnMoaSksYT1vW3NdO3JldHVybiBpPj0wP2E6dHlwZW9mIGE9PSJudW1iZXIiPy1hOmAtJHthfWB9OnR5cGVvZiBvPT0iZnVuY3Rpb24iP286KCk9Pnt9fWZ1bmN0aW9uIEhkKGUpe3JldHVybiB5cyhlLCJzcGFjaW5nIiw4KX1mdW5jdGlvbiB2cyhlLHQpe3JldHVybiB0eXBlb2YgdD09InN0cmluZyJ8fHQ9PW51bGw/dDplKHQpfWZ1bmN0aW9uIGV4KGUsdCl7cmV0dXJuIG49PmUucmVkdWNlKChyLG8pPT4ocltvXT12cyh0LG4pLHIpLHt9KX1mdW5jdGlvbiB0eChlLHQsbixyKXtpZighdC5pbmNsdWRlcyhuKSlyZXR1cm4gbnVsbDtjb25zdCBvPUpTKG4pLGk9ZXgobyxyKSxzPWVbbl07cmV0dXJuIEtuKGUscyxpKX1mdW5jdGlvbiBXZyhlLHQpe2NvbnN0IG49SGQoZS50aGVtZSk7cmV0dXJuIE9iamVjdC5rZXlzKGUpLm1hcChyPT50eChlLHQscixuKSkucmVkdWNlKEVpLHt9KX1mdW5jdGlvbiBqZShlKXtyZXR1cm4gV2coZSxXZCl9amUucHJvcFR5cGVzPXt9O2plLmZpbHRlclByb3BzPVdkO2Z1bmN0aW9uIERlKGUpe3JldHVybiBXZyhlLFVkKX1EZS5wcm9wVHlwZXM9e307RGUuZmlsdGVyUHJvcHM9VWQ7ZnVuY3Rpb24gVWcoZT04LHQ9SGQoe3NwYWNpbmc6ZX0pKXtpZihlLm11aSlyZXR1cm4gZTtjb25zdCBuPSguLi5yKT0+KHIubGVuZ3RoPT09MD9bMV06cikubWFwKGk9Pntjb25zdCBzPXQoaSk7cmV0dXJuIHR5cGVvZiBzPT0ibnVtYmVyIj9gJHtzfXB4YDpzfSkuam9pbigiICIpO3JldHVybiBuLm11aT0hMCxufWZ1bmN0aW9uIFJsKC4uLmUpe2NvbnN0IHQ9ZS5yZWR1Y2UoKHIsbyk9PihvLmZpbHRlclByb3BzLmZvckVhY2goaT0+e3JbaV09b30pLHIpLHt9KSxuPXI9Pk9iamVjdC5rZXlzKHIpLnJlZHVjZSgobyxpKT0+dFtpXT9FaShvLHRbaV0ocikpOm8se30pO3JldHVybiBuLnByb3BUeXBlcz17fSxuLmZpbHRlclByb3BzPWUucmVkdWNlKChyLG8pPT5yLmNvbmNhdChvLmZpbHRlclByb3BzKSxbXSksbn1mdW5jdGlvbiBRdChlKXtyZXR1cm4gdHlwZW9mIGUhPSJudW1iZXIiP2U6YCR7ZX1weCBzb2xpZGB9ZnVuY3Rpb24gc24oZSx0KXtyZXR1cm4gSGUoe3Byb3A6ZSx0aGVtZUtleToiYm9yZGVycyIsdHJhbnNmb3JtOnR9KX1jb25zdCBueD1zbigiYm9yZGVyIixRdCkscng9c24oImJvcmRlclRvcCIsUXQpLG94PXNuKCJib3JkZXJSaWdodCIsUXQpLGl4PXNuKCJib3JkZXJCb3R0b20iLFF0KSxzeD1zbigiYm9yZGVyTGVmdCIsUXQpLGF4PXNuKCJib3JkZXJDb2xvciIpLGx4PXNuKCJib3JkZXJUb3BDb2xvciIpLHV4PXNuKCJib3JkZXJSaWdodENvbG9yIiksY3g9c24oImJvcmRlckJvdHRvbUNvbG9yIiksZHg9c24oImJvcmRlckxlZnRDb2xvciIpLGZ4PXNuKCJvdXRsaW5lIixRdCkscHg9c24oIm91dGxpbmVDb2xvciIpLFRsPWU9PntpZihlLmJvcmRlclJhZGl1cyE9PXZvaWQgMCYmZS5ib3JkZXJSYWRpdXMhPT1udWxsKXtjb25zdCB0PXlzKGUudGhlbWUsInNoYXBlLmJvcmRlclJhZGl1cyIsNCksbj1yPT4oe2JvcmRlclJhZGl1czp2cyh0LHIpfSk7cmV0dXJuIEtuKGUsZS5ib3JkZXJSYWRpdXMsbil9cmV0dXJuIG51bGx9O1RsLnByb3BUeXBlcz17fTtUbC5maWx0ZXJQcm9wcz1bImJvcmRlclJhZGl1cyJdO1JsKG54LHJ4LG94LGl4LHN4LGF4LGx4LHV4LGN4LGR4LFRsLGZ4LHB4KTtjb25zdCBQbD1lPT57aWYoZS5nYXAhPT12b2lkIDAmJmUuZ2FwIT09bnVsbCl7Y29uc3QgdD15cyhlLnRoZW1lLCJzcGFjaW5nIiw4KSxuPXI9Pih7Z2FwOnZzKHQscil9KTtyZXR1cm4gS24oZSxlLmdhcCxuKX1yZXR1cm4gbnVsbH07UGwucHJvcFR5cGVzPXt9O1BsLmZpbHRlclByb3BzPVsiZ2FwIl07Y29uc3QgJGw9ZT0+e2lmKGUuY29sdW1uR2FwIT09dm9pZCAwJiZlLmNvbHVtbkdhcCE9PW51bGwpe2NvbnN0IHQ9eXMoZS50aGVtZSwic3BhY2luZyIsOCksbj1yPT4oe2NvbHVtbkdhcDp2cyh0LHIpfSk7cmV0dXJuIEtuKGUsZS5jb2x1bW5HYXAsbil9cmV0dXJuIG51bGx9OyRsLnByb3BUeXBlcz17fTskbC5maWx0ZXJQcm9wcz1bImNvbHVtbkdhcCJdO2NvbnN0IE9sPWU9PntpZihlLnJvd0dhcCE9PXZvaWQgMCYmZS5yb3dHYXAhPT1udWxsKXtjb25zdCB0PXlzKGUudGhlbWUsInNwYWNpbmciLDgpLG49cj0+KHtyb3dHYXA6dnModCxyKX0pO3JldHVybiBLbihlLGUucm93R2FwLG4pfXJldHVybiBudWxsfTtPbC5wcm9wVHlwZXM9e307T2wuZmlsdGVyUHJvcHM9WyJyb3dHYXAiXTtjb25zdCBteD1IZSh7cHJvcDoiZ3JpZENvbHVtbiJ9KSxoeD1IZSh7cHJvcDoiZ3JpZFJvdyJ9KSxneD1IZSh7cHJvcDoiZ3JpZEF1dG9GbG93In0pLHl4PUhlKHtwcm9wOiJncmlkQXV0b0NvbHVtbnMifSksdng9SGUoe3Byb3A6ImdyaWRBdXRvUm93cyJ9KSx3eD1IZSh7cHJvcDoiZ3JpZFRlbXBsYXRlQ29sdW1ucyJ9KSxTeD1IZSh7cHJvcDoiZ3JpZFRlbXBsYXRlUm93cyJ9KSx4eD1IZSh7cHJvcDoiZ3JpZFRlbXBsYXRlQXJlYXMifSksQ3g9SGUoe3Byb3A6ImdyaWRBcmVhIn0pO1JsKFBsLCRsLE9sLG14LGh4LGd4LHl4LHZ4LHd4LFN4LHh4LEN4KTtmdW5jdGlvbiBrbyhlLHQpe3JldHVybiB0PT09ImdyZXkiP3Q6ZX1jb25zdCBieD1IZSh7cHJvcDoiY29sb3IiLHRoZW1lS2V5OiJwYWxldHRlIix0cmFuc2Zvcm06a299KSxreD1IZSh7cHJvcDoiYmdjb2xvciIsY3NzUHJvcGVydHk6ImJhY2tncm91bmRDb2xvciIsdGhlbWVLZXk6InBhbGV0dGUiLHRyYW5zZm9ybTprb30pLEV4PUhlKHtwcm9wOiJiYWNrZ3JvdW5kQ29sb3IiLHRoZW1lS2V5OiJwYWxldHRlIix0cmFuc2Zvcm06a299KTtSbChieCxreCxFeCk7ZnVuY3Rpb24gX3QoZSl7cmV0dXJuIGU8PTEmJmUhPT0wP2Ake2UqMTAwfSVgOmV9Y29uc3QgUng9SGUoe3Byb3A6IndpZHRoIix0cmFuc2Zvcm06X3R9KSxWZD1lPT57aWYoZS5tYXhXaWR0aCE9PXZvaWQgMCYmZS5tYXhXaWR0aCE9PW51bGwpe2NvbnN0IHQ9bj0+e3ZhciBvLGkscyxhLGw7Y29uc3Qgcj0oKHM9KGk9KG89ZS50aGVtZSk9PW51bGw/dm9pZCAwOm8uYnJlYWtwb2ludHMpPT1udWxsP3ZvaWQgMDppLnZhbHVlcyk9PW51bGw/dm9pZCAwOnNbbl0pfHxrbFtuXTtyZXR1cm4gcj8oKGw9KGE9ZS50aGVtZSk9PW51bGw/dm9pZCAwOmEuYnJlYWtwb2ludHMpPT1udWxsP3ZvaWQgMDpsLnVuaXQpIT09InB4Ij97bWF4V2lkdGg6YCR7cn0ke2UudGhlbWUuYnJlYWtwb2ludHMudW5pdH1gfTp7bWF4V2lkdGg6cn06e21heFdpZHRoOl90KG4pfX07cmV0dXJuIEtuKGUsZS5tYXhXaWR0aCx0KX1yZXR1cm4gbnVsbH07VmQuZmlsdGVyUHJvcHM9WyJtYXhXaWR0aCJdO2NvbnN0IFR4PUhlKHtwcm9wOiJtaW5XaWR0aCIsdHJhbnNmb3JtOl90fSksUHg9SGUoe3Byb3A6ImhlaWdodCIsdHJhbnNmb3JtOl90fSksJHg9SGUoe3Byb3A6Im1heEhlaWdodCIsdHJhbnNmb3JtOl90fSksT3g9SGUoe3Byb3A6Im1pbkhlaWdodCIsdHJhbnNmb3JtOl90fSk7SGUoe3Byb3A6InNpemUiLGNzc1Byb3BlcnR5OiJ3aWR0aCIsdHJhbnNmb3JtOl90fSk7SGUoe3Byb3A6InNpemUiLGNzc1Byb3BlcnR5OiJoZWlnaHQiLHRyYW5zZm9ybTpfdH0pO2NvbnN0IE14PUhlKHtwcm9wOiJib3hTaXppbmcifSk7UmwoUngsVmQsVHgsUHgsJHgsT3gsTXgpO2NvbnN0IHdzPXtib3JkZXI6e3RoZW1lS2V5OiJib3JkZXJzIix0cmFuc2Zvcm06UXR9LGJvcmRlclRvcDp7dGhlbWVLZXk6ImJvcmRlcnMiLHRyYW5zZm9ybTpRdH0sYm9yZGVyUmlnaHQ6e3RoZW1lS2V5OiJib3JkZXJzIix0cmFuc2Zvcm06UXR9LGJvcmRlckJvdHRvbTp7dGhlbWVLZXk6ImJvcmRlcnMiLHRyYW5zZm9ybTpRdH0sYm9yZGVyTGVmdDp7dGhlbWVLZXk6ImJvcmRlcnMiLHRyYW5zZm9ybTpRdH0sYm9yZGVyQ29sb3I6e3RoZW1lS2V5OiJwYWxldHRlIn0sYm9yZGVyVG9wQ29sb3I6e3RoZW1lS2V5OiJwYWxldHRlIn0sYm9yZGVyUmlnaHRDb2xvcjp7dGhlbWVLZXk6InBhbGV0dGUifSxib3JkZXJCb3R0b21Db2xvcjp7dGhlbWVLZXk6InBhbGV0dGUifSxib3JkZXJMZWZ0Q29sb3I6e3RoZW1lS2V5OiJwYWxldHRlIn0sb3V0bGluZTp7dGhlbWVLZXk6ImJvcmRlcnMiLHRyYW5zZm9ybTpRdH0sb3V0bGluZUNvbG9yOnt0aGVtZUtleToicGFsZXR0ZSJ9LGJvcmRlclJhZGl1czp7dGhlbWVLZXk6InNoYXBlLmJvcmRlclJhZGl1cyIsc3R5bGU6VGx9LGNvbG9yOnt0aGVtZUtleToicGFsZXR0ZSIsdHJhbnNmb3JtOmtvfSxiZ2NvbG9yOnt0aGVtZUtleToicGFsZXR0ZSIsY3NzUHJvcGVydHk6ImJhY2tncm91bmRDb2xvciIsdHJhbnNmb3JtOmtvfSxiYWNrZ3JvdW5kQ29sb3I6e3RoZW1lS2V5OiJwYWxldHRlIix0cmFuc2Zvcm06a299LHA6e3N0eWxlOkRlfSxwdDp7c3R5bGU6RGV9LHByOntzdHlsZTpEZX0scGI6e3N0eWxlOkRlfSxwbDp7c3R5bGU6RGV9LHB4OntzdHlsZTpEZX0scHk6e3N0eWxlOkRlfSxwYWRkaW5nOntzdHlsZTpEZX0scGFkZGluZ1RvcDp7c3R5bGU6RGV9LHBhZGRpbmdSaWdodDp7c3R5bGU6RGV9LHBhZGRpbmdCb3R0b206e3N0eWxlOkRlfSxwYWRkaW5nTGVmdDp7c3R5bGU6RGV9LHBhZGRpbmdYOntzdHlsZTpEZX0scGFkZGluZ1k6e3N0eWxlOkRlfSxwYWRkaW5nSW5saW5lOntzdHlsZTpEZX0scGFkZGluZ0lubGluZVN0YXJ0OntzdHlsZTpEZX0scGFkZGluZ0lubGluZUVuZDp7c3R5bGU6RGV9LHBhZGRpbmdCbG9jazp7c3R5bGU6RGV9LHBhZGRpbmdCbG9ja1N0YXJ0OntzdHlsZTpEZX0scGFkZGluZ0Jsb2NrRW5kOntzdHlsZTpEZX0sbTp7c3R5bGU6amV9LG10OntzdHlsZTpqZX0sbXI6e3N0eWxlOmplfSxtYjp7c3R5bGU6amV9LG1sOntzdHlsZTpqZX0sbXg6e3N0eWxlOmplfSxteTp7c3R5bGU6amV9LG1hcmdpbjp7c3R5bGU6amV9LG1hcmdpblRvcDp7c3R5bGU6amV9LG1hcmdpblJpZ2h0OntzdHlsZTpqZX0sbWFyZ2luQm90dG9tOntzdHlsZTpqZX0sbWFyZ2luTGVmdDp7c3R5bGU6amV9LG1hcmdpblg6e3N0eWxlOmplfSxtYXJnaW5ZOntzdHlsZTpqZX0sbWFyZ2luSW5saW5lOntzdHlsZTpqZX0sbWFyZ2luSW5saW5lU3RhcnQ6e3N0eWxlOmplfSxtYXJnaW5JbmxpbmVFbmQ6e3N0eWxlOmplfSxtYXJnaW5CbG9jazp7c3R5bGU6amV9LG1hcmdpbkJsb2NrU3RhcnQ6e3N0eWxlOmplfSxtYXJnaW5CbG9ja0VuZDp7c3R5bGU6amV9LGRpc3BsYXlQcmludDp7Y3NzUHJvcGVydHk6ITEsdHJhbnNmb3JtOmU9Pih7IkBtZWRpYSBwcmludCI6e2Rpc3BsYXk6ZX19KX0sZGlzcGxheTp7fSxvdmVyZmxvdzp7fSx0ZXh0T3ZlcmZsb3c6e30sdmlzaWJpbGl0eTp7fSx3aGl0ZVNwYWNlOnt9LGZsZXhCYXNpczp7fSxmbGV4RGlyZWN0aW9uOnt9LGZsZXhXcmFwOnt9LGp1c3RpZnlDb250ZW50Ont9LGFsaWduSXRlbXM6e30sYWxpZ25Db250ZW50Ont9LG9yZGVyOnt9LGZsZXg6e30sZmxleEdyb3c6e30sZmxleFNocmluazp7fSxhbGlnblNlbGY6e30sanVzdGlmeUl0ZW1zOnt9LGp1c3RpZnlTZWxmOnt9LGdhcDp7c3R5bGU6UGx9LHJvd0dhcDp7c3R5bGU6T2x9LGNvbHVtbkdhcDp7c3R5bGU6JGx9LGdyaWRDb2x1bW46e30sZ3JpZFJvdzp7fSxncmlkQXV0b0Zsb3c6e30sZ3JpZEF1dG9Db2x1bW5zOnt9LGdyaWRBdXRvUm93czp7fSxncmlkVGVtcGxhdGVDb2x1bW5zOnt9LGdyaWRUZW1wbGF0ZVJvd3M6e30sZ3JpZFRlbXBsYXRlQXJlYXM6e30sZ3JpZEFyZWE6e30scG9zaXRpb246e30sekluZGV4Ont0aGVtZUtleToiekluZGV4In0sdG9wOnt9LHJpZ2h0Ont9LGJvdHRvbTp7fSxsZWZ0Ont9LGJveFNoYWRvdzp7dGhlbWVLZXk6InNoYWRvd3MifSx3aWR0aDp7dHJhbnNmb3JtOl90fSxtYXhXaWR0aDp7c3R5bGU6VmR9LG1pbldpZHRoOnt0cmFuc2Zvcm06X3R9LGhlaWdodDp7dHJhbnNmb3JtOl90fSxtYXhIZWlnaHQ6e3RyYW5zZm9ybTpfdH0sbWluSGVpZ2h0Ont0cmFuc2Zvcm06X3R9LGJveFNpemluZzp7fSxmb250Ont0aGVtZUtleToiZm9udCJ9LGZvbnRGYW1pbHk6e3RoZW1lS2V5OiJ0eXBvZ3JhcGh5In0sZm9udFNpemU6e3RoZW1lS2V5OiJ0eXBvZ3JhcGh5In0sZm9udFN0eWxlOnt0aGVtZUtleToidHlwb2dyYXBoeSJ9LGZvbnRXZWlnaHQ6e3RoZW1lS2V5OiJ0eXBvZ3JhcGh5In0sbGV0dGVyU3BhY2luZzp7fSx0ZXh0VHJhbnNmb3JtOnt9LGxpbmVIZWlnaHQ6e30sdGV4dEFsaWduOnt9LHR5cG9ncmFwaHk6e2Nzc1Byb3BlcnR5OiExLHRoZW1lS2V5OiJ0eXBvZ3JhcGh5In19O2Z1bmN0aW9uIF94KC4uLmUpe2NvbnN0IHQ9ZS5yZWR1Y2UoKHIsbyk9PnIuY29uY2F0KE9iamVjdC5rZXlzKG8pKSxbXSksbj1uZXcgU2V0KHQpO3JldHVybiBlLmV2ZXJ5KHI9Pm4uc2l6ZT09PU9iamVjdC5rZXlzKHIpLmxlbmd0aCl9ZnVuY3Rpb24gTngoZSx0KXtyZXR1cm4gdHlwZW9mIGU9PSJmdW5jdGlvbiI/ZSh0KTplfWZ1bmN0aW9uIEl4KCl7ZnVuY3Rpb24gZShuLHIsbyxpKXtjb25zdCBzPXtbbl06cix0aGVtZTpvfSxhPWlbbl07aWYoIWEpcmV0dXJue1tuXTpyfTtjb25zdHtjc3NQcm9wZXJ0eTpsPW4sdGhlbWVLZXk6dSx0cmFuc2Zvcm06YyxzdHlsZTpkfT1hO2lmKHI9PW51bGwpcmV0dXJuIG51bGw7aWYodT09PSJ0eXBvZ3JhcGh5IiYmcj09PSJpbmhlcml0IilyZXR1cm57W25dOnJ9O2NvbnN0IG09RWwobyx1KXx8e307cmV0dXJuIGQ/ZChzKTpLbihzLHIsdz0+e2xldCBTPUNhKG0sYyx3KTtyZXR1cm4gdz09PVMmJnR5cGVvZiB3PT0ic3RyaW5nIiYmKFM9Q2EobSxjLGAke259JHt3PT09ImRlZmF1bHQiPyIiOm5lKHcpfWAsdykpLGw9PT0hMT9TOntbbF06U319KX1mdW5jdGlvbiB0KG4pe2NvbnN0e3N4OnIsdGhlbWU6bz17fX09bnx8e307aWYoIXIpcmV0dXJuIG51bGw7Y29uc3QgaT1vLnVuc3RhYmxlX3N4Q29uZmlnPz93cztmdW5jdGlvbiBzKGEpe2xldCBsPWE7aWYodHlwZW9mIGE9PSJmdW5jdGlvbiIpbD1hKG8pO2Vsc2UgaWYodHlwZW9mIGEhPSJvYmplY3QiKXJldHVybiBhO2lmKCFsKXJldHVybiBudWxsO2NvbnN0IHU9R1Moby5icmVha3BvaW50cyksYz1PYmplY3Qua2V5cyh1KTtsZXQgZD11O3JldHVybiBPYmplY3Qua2V5cyhsKS5mb3JFYWNoKG09Pntjb25zdCB2PU54KGxbbV0sbyk7aWYodiE9bnVsbClpZih0eXBlb2Ygdj09Im9iamVjdCIpaWYoaVttXSlkPUVpKGQsZShtLHYsbyxpKSk7ZWxzZXtjb25zdCB3PUtuKHt0aGVtZTpvfSx2LFM9Pih7W21dOlN9KSk7X3godyx2KT9kW21dPXQoe3N4OnYsdGhlbWU6b30pOmQ9RWkoZCx3KX1lbHNlIGQ9RWkoZCxlKG0sdixvLGkpKX0pLFdTKG8sUVMoYyxkKSl9cmV0dXJuIEFycmF5LmlzQXJyYXkocik/ci5tYXAocyk6cyhyKX1yZXR1cm4gdH1jb25zdCBfbz1JeCgpO19vLmZpbHRlclByb3BzPVsic3giXTtmdW5jdGlvbiBBeChlLHQpe3ZhciByO2NvbnN0IG49dGhpcztpZihuLnZhcnMpe2lmKCEoKHI9bi5jb2xvclNjaGVtZXMpIT1udWxsJiZyW2VdKXx8dHlwZW9mIG4uZ2V0Q29sb3JTY2hlbWVTZWxlY3RvciE9ImZ1bmN0aW9uIilyZXR1cm57fTtsZXQgbz1uLmdldENvbG9yU2NoZW1lU2VsZWN0b3IoZSk7cmV0dXJuIG89PT0iJiI/dDooKG8uaW5jbHVkZXMoImRhdGEtIil8fG8uaW5jbHVkZXMoIi4iKSkmJihvPWAqOndoZXJlKCR7by5yZXBsYWNlKC9ccyomJC8sIiIpfSkgJmApLHtbb106dH0pfXJldHVybiBuLnBhbGV0dGUubW9kZT09PWU/dDp7fX1mdW5jdGlvbiBLZChlPXt9LC4uLnQpe2NvbnN0e2JyZWFrcG9pbnRzOm49e30scGFsZXR0ZTpyPXt9LHNwYWNpbmc6byxzaGFwZTppPXt9LC4uLnN9PWUsYT1CUyhuKSxsPVVnKG8pO2xldCB1PXB0KHticmVha3BvaW50czphLGRpcmVjdGlvbjoibHRyIixjb21wb25lbnRzOnt9LHBhbGV0dGU6e21vZGU6ImxpZ2h0IiwuLi5yfSxzcGFjaW5nOmwsc2hhcGU6ey4uLktTLC4uLml9fSxzKTtyZXR1cm4gdT1WUyh1KSx1LmFwcGx5U3R5bGVzPUF4LHU9dC5yZWR1Y2UoKGMsZCk9PnB0KGMsZCksdSksdS51bnN0YWJsZV9zeENvbmZpZz17Li4ud3MsLi4ucz09bnVsbD92b2lkIDA6cy51bnN0YWJsZV9zeENvbmZpZ30sdS51bnN0YWJsZV9zeD1mdW5jdGlvbihkKXtyZXR1cm4gX28oe3N4OmQsdGhlbWU6dGhpc30pfSx1fWZ1bmN0aW9uIHp4KGUpe3JldHVybiBPYmplY3Qua2V5cyhlKS5sZW5ndGg9PT0wfWZ1bmN0aW9uIEx4KGU9bnVsbCl7Y29uc3QgdD1DLnVzZUNvbnRleHQoRmQpO3JldHVybiF0fHx6eCh0KT9lOnR9Y29uc3Qgang9S2QoKTtmdW5jdGlvbiBIZyhlPWp4KXtyZXR1cm4gTHgoZSl9ZnVuY3Rpb24gRHgoe3N0eWxlczplLHRoZW1lSWQ6dCxkZWZhdWx0VGhlbWU6bj17fX0pe2NvbnN0IHI9SGcobiksbz10eXBlb2YgZT09ImZ1bmN0aW9uIj9lKHQmJnJbdF18fHIpOmU7cmV0dXJuIGsuanN4KExTLHtzdHlsZXM6b30pfWNvbnN0IEZ4PWU9Pnt2YXIgcjtjb25zdCB0PXtzeXN0ZW1Qcm9wczp7fSxvdGhlclByb3BzOnt9fSxuPSgocj1lPT1udWxsP3ZvaWQgMDplLnRoZW1lKT09bnVsbD92b2lkIDA6ci51bnN0YWJsZV9zeENvbmZpZyk/P3dzO3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKG89PntuW29dP3Quc3lzdGVtUHJvcHNbb109ZVtvXTp0Lm90aGVyUHJvcHNbb109ZVtvXX0pLHR9O2Z1bmN0aW9uIEJ4KGUpe2NvbnN0e3N4OnQsLi4ubn09ZSx7c3lzdGVtUHJvcHM6cixvdGhlclByb3BzOm99PUZ4KG4pO2xldCBpO3JldHVybiBBcnJheS5pc0FycmF5KHQpP2k9W3IsLi4udF06dHlwZW9mIHQ9PSJmdW5jdGlvbiI/aT0oLi4ucyk9Pntjb25zdCBhPXQoLi4ucyk7cmV0dXJuIE9uKGEpP3suLi5yLC4uLmF9OnJ9Omk9ey4uLnIsLi4udH0sey4uLm8sc3g6aX19Y29uc3QgSHA9ZT0+ZSxXeD0oKT0+e2xldCBlPUhwO3JldHVybntjb25maWd1cmUodCl7ZT10fSxnZW5lcmF0ZSh0KXtyZXR1cm4gZSh0KX0scmVzZXQoKXtlPUhwfX19LFV4PVd4KCk7ZnVuY3Rpb24gVmcoZSl7dmFyIHQsbixyPSIiO2lmKHR5cGVvZiBlPT0ic3RyaW5nInx8dHlwZW9mIGU9PSJudW1iZXIiKXIrPWU7ZWxzZSBpZih0eXBlb2YgZT09Im9iamVjdCIpaWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG89ZS5sZW5ndGg7Zm9yKHQ9MDt0PG87dCsrKWVbdF0mJihuPVZnKGVbdF0pKSYmKHImJihyKz0iICIpLHIrPW4pfWVsc2UgZm9yKG4gaW4gZSllW25dJiYociYmKHIrPSIgIikscis9bik7cmV0dXJuIHJ9ZnVuY3Rpb24gdGUoKXtmb3IodmFyIGUsdCxuPTAscj0iIixvPWFyZ3VtZW50cy5sZW5ndGg7bjxvO24rKykoZT1hcmd1bWVudHNbbl0pJiYodD1WZyhlKSkmJihyJiYocis9IiAiKSxyKz10KTtyZXR1cm4gcn1jb25zdCBIeD17YWN0aXZlOiJhY3RpdmUiLGNoZWNrZWQ6ImNoZWNrZWQiLGNvbXBsZXRlZDoiY29tcGxldGVkIixkaXNhYmxlZDoiZGlzYWJsZWQiLGVycm9yOiJlcnJvciIsZXhwYW5kZWQ6ImV4cGFuZGVkIixmb2N1c2VkOiJmb2N1c2VkIixmb2N1c1Zpc2libGU6ImZvY3VzVmlzaWJsZSIsb3Blbjoib3BlbiIscmVhZE9ubHk6InJlYWRPbmx5IixyZXF1aXJlZDoicmVxdWlyZWQiLHNlbGVjdGVkOiJzZWxlY3RlZCJ9O2Z1bmN0aW9uIGNlKGUsdCxuPSJNdWkiKXtjb25zdCByPUh4W3RdO3JldHVybiByP2Ake259LSR7cn1gOmAke1V4LmdlbmVyYXRlKGUpfS0ke3R9YH1mdW5jdGlvbiBkZShlLHQsbj0iTXVpIil7Y29uc3Qgcj17fTtyZXR1cm4gdC5mb3JFYWNoKG89PntyW29dPWNlKGUsbyxuKX0pLHJ9dmFyIGtlPXt9Oy8qKgogKiBAbGljZW5zZSBSZWFjdAogKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcwogKgogKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy4KICoKICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlCiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KICovdmFyIFlkPVN5bWJvbC5mb3IoInJlYWN0LmVsZW1lbnQiKSxHZD1TeW1ib2wuZm9yKCJyZWFjdC5wb3J0YWwiKSxNbD1TeW1ib2wuZm9yKCJyZWFjdC5mcmFnbWVudCIpLF9sPVN5bWJvbC5mb3IoInJlYWN0LnN0cmljdF9tb2RlIiksTmw9U3ltYm9sLmZvcigicmVhY3QucHJvZmlsZXIiKSxJbD1TeW1ib2wuZm9yKCJyZWFjdC5wcm92aWRlciIpLEFsPVN5bWJvbC5mb3IoInJlYWN0LmNvbnRleHQiKSxWeD1TeW1ib2wuZm9yKCJyZWFjdC5zZXJ2ZXJfY29udGV4dCIpLHpsPVN5bWJvbC5mb3IoInJlYWN0LmZvcndhcmRfcmVmIiksTGw9U3ltYm9sLmZvcigicmVhY3Quc3VzcGVuc2UiKSxqbD1TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZV9saXN0IiksRGw9U3ltYm9sLmZvcigicmVhY3QubWVtbyIpLEZsPVN5bWJvbC5mb3IoInJlYWN0LmxhenkiKSxLeD1TeW1ib2wuZm9yKCJyZWFjdC5vZmZzY3JlZW4iKSxLZztLZz1TeW1ib2wuZm9yKCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlIik7ZnVuY3Rpb24gYW4oZSl7aWYodHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbCl7dmFyIHQ9ZS4kJHR5cGVvZjtzd2l0Y2godCl7Y2FzZSBZZDpzd2l0Y2goZT1lLnR5cGUsZSl7Y2FzZSBNbDpjYXNlIE5sOmNhc2UgX2w6Y2FzZSBMbDpjYXNlIGpsOnJldHVybiBlO2RlZmF1bHQ6c3dpdGNoKGU9ZSYmZS4kJHR5cGVvZixlKXtjYXNlIFZ4OmNhc2UgQWw6Y2FzZSB6bDpjYXNlIEZsOmNhc2UgRGw6Y2FzZSBJbDpyZXR1cm4gZTtkZWZhdWx0OnJldHVybiB0fX1jYXNlIEdkOnJldHVybiB0fX19a2UuQ29udGV4dENvbnN1bWVyPUFsO2tlLkNvbnRleHRQcm92aWRlcj1JbDtrZS5FbGVtZW50PVlkO2tlLkZvcndhcmRSZWY9emw7a2UuRnJhZ21lbnQ9TWw7a2UuTGF6eT1GbDtrZS5NZW1vPURsO2tlLlBvcnRhbD1HZDtrZS5Qcm9maWxlcj1ObDtrZS5TdHJpY3RNb2RlPV9sO2tlLlN1c3BlbnNlPUxsO2tlLlN1c3BlbnNlTGlzdD1qbDtrZS5pc0FzeW5jTW9kZT1mdW5jdGlvbigpe3JldHVybiExfTtrZS5pc0NvbmN1cnJlbnRNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2tlLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGUpe3JldHVybiBhbihlKT09PUFsfTtrZS5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihlKXtyZXR1cm4gYW4oZSk9PT1JbH07a2UuaXNFbGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09Im9iamVjdCImJmUhPT1udWxsJiZlLiQkdHlwZW9mPT09WWR9O2tlLmlzRm9yd2FyZFJlZj1mdW5jdGlvbihlKXtyZXR1cm4gYW4oZSk9PT16bH07a2UuaXNGcmFnbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gYW4oZSk9PT1NbH07a2UuaXNMYXp5PWZ1bmN0aW9uKGUpe3JldHVybiBhbihlKT09PUZsfTtrZS5pc01lbW89ZnVuY3Rpb24oZSl7cmV0dXJuIGFuKGUpPT09RGx9O2tlLmlzUG9ydGFsPWZ1bmN0aW9uKGUpe3JldHVybiBhbihlKT09PUdkfTtrZS5pc1Byb2ZpbGVyPWZ1bmN0aW9uKGUpe3JldHVybiBhbihlKT09PU5sfTtrZS5pc1N0cmljdE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFuKGUpPT09X2x9O2tlLmlzU3VzcGVuc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGFuKGUpPT09TGx9O2tlLmlzU3VzcGVuc2VMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiBhbihlKT09PWpsfTtrZS5pc1ZhbGlkRWxlbWVudFR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlPT0ic3RyaW5nInx8dHlwZW9mIGU9PSJmdW5jdGlvbiJ8fGU9PT1NbHx8ZT09PU5sfHxlPT09X2x8fGU9PT1MbHx8ZT09PWpsfHxlPT09S3h8fHR5cGVvZiBlPT0ib2JqZWN0IiYmZSE9PW51bGwmJihlLiQkdHlwZW9mPT09Rmx8fGUuJCR0eXBlb2Y9PT1EbHx8ZS4kJHR5cGVvZj09PUlsfHxlLiQkdHlwZW9mPT09QWx8fGUuJCR0eXBlb2Y9PT16bHx8ZS4kJHR5cGVvZj09PUtnfHxlLmdldE1vZHVsZUlkIT09dm9pZCAwKX07a2UudHlwZU9mPWFuO2Z1bmN0aW9uIFlnKGUpe2NvbnN0e3ZhcmlhbnRzOnQsLi4ubn09ZSxyPXt2YXJpYW50czp0LHN0eWxlOkJwKG4pLGlzUHJvY2Vzc2VkOiEwfTtyZXR1cm4gci5zdHlsZT09PW58fHQmJnQuZm9yRWFjaChvPT57dHlwZW9mIG8uc3R5bGUhPSJmdW5jdGlvbiImJihvLnN0eWxlPUJwKG8uc3R5bGUpKX0pLHJ9Y29uc3QgWXg9S2QoKTtmdW5jdGlvbiB4dShlKXtyZXR1cm4gZSE9PSJvd25lclN0YXRlIiYmZSE9PSJ0aGVtZSImJmUhPT0ic3giJiZlIT09ImFzIn1mdW5jdGlvbiBHeChlKXtyZXR1cm4gZT8odCxuKT0+bltlXTpudWxsfWZ1bmN0aW9uIFF4KGUsdCxuKXtlLnRoZW1lPVp4KGUudGhlbWUpP246ZS50aGVtZVt0XXx8ZS50aGVtZX1mdW5jdGlvbiBhYShlLHQpe2NvbnN0IG49dHlwZW9mIHQ9PSJmdW5jdGlvbiI/dChlKTp0O2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIG4uZmxhdE1hcChyPT5hYShlLHIpKTtpZihBcnJheS5pc0FycmF5KG49PW51bGw/dm9pZCAwOm4udmFyaWFudHMpKXtsZXQgcjtpZihuLmlzUHJvY2Vzc2VkKXI9bi5zdHlsZTtlbHNle2NvbnN0e3ZhcmlhbnRzOm8sLi4uaX09bjtyPWl9cmV0dXJuIEdnKGUsbi52YXJpYW50cyxbcl0pfXJldHVybiBuIT1udWxsJiZuLmlzUHJvY2Vzc2VkP24uc3R5bGU6bn1mdW5jdGlvbiBHZyhlLHQsbj1bXSl7dmFyIG87bGV0IHI7ZTpmb3IobGV0IGk9MDtpPHQubGVuZ3RoO2krPTEpe2NvbnN0IHM9dFtpXTtpZih0eXBlb2Ygcy5wcm9wcz09ImZ1bmN0aW9uIil7aWYocj8/KHI9ey4uLmUsLi4uZS5vd25lclN0YXRlLG93bmVyU3RhdGU6ZS5vd25lclN0YXRlfSksIXMucHJvcHMocikpY29udGludWV9ZWxzZSBmb3IoY29uc3QgYSBpbiBzLnByb3BzKWlmKGVbYV0hPT1zLnByb3BzW2FdJiYoKG89ZS5vd25lclN0YXRlKT09bnVsbD92b2lkIDA6b1thXSkhPT1zLnByb3BzW2FdKWNvbnRpbnVlIGU7dHlwZW9mIHMuc3R5bGU9PSJmdW5jdGlvbiI/KHI/PyhyPXsuLi5lLC4uLmUub3duZXJTdGF0ZSxvd25lclN0YXRlOmUub3duZXJTdGF0ZX0pLG4ucHVzaChzLnN0eWxlKHIpKSk6bi5wdXNoKHMuc3R5bGUpfXJldHVybiBufWZ1bmN0aW9uIFh4KGU9e30pe2NvbnN0e3RoZW1lSWQ6dCxkZWZhdWx0VGhlbWU6bj1ZeCxyb290U2hvdWxkRm9yd2FyZFByb3A6cj14dSxzbG90U2hvdWxkRm9yd2FyZFByb3A6bz14dX09ZTtmdW5jdGlvbiBpKGEpe1F4KGEsdCxuKX1yZXR1cm4oYSxsPXt9KT0+e0RTKGEsYj0+Yi5maWx0ZXIoRT0+RSE9PV9vKSk7Y29uc3R7bmFtZTp1LHNsb3Q6Yyxza2lwVmFyaWFudHNSZXNvbHZlcjpkLHNraXBTeDptLG92ZXJyaWRlc1Jlc29sdmVyOnY9R3goZUMoYykpLC4uLnd9PWwsUz1kIT09dm9pZCAwP2Q6YyYmYyE9PSJSb290IiYmYyE9PSJyb290Inx8ITEseD1tfHwhMTtsZXQgaD14dTtjPT09IlJvb3QifHxjPT09InJvb3QiP2g9cjpjP2g9bzpKeChhKSYmKGg9dm9pZCAwKTtjb25zdCBnPWpTKGEse3Nob3VsZEZvcndhcmRQcm9wOmgsbGFiZWw6cXgoKSwuLi53fSksZj1iPT57aWYodHlwZW9mIGI9PSJmdW5jdGlvbiImJmIuX19lbW90aW9uX3JlYWwhPT1iKXJldHVybiBmdW5jdGlvbihSKXtyZXR1cm4gYWEoUixiKX07aWYoT24oYikpe2NvbnN0IEU9WWcoYik7cmV0dXJuIEUudmFyaWFudHM/ZnVuY3Rpb24oUCl7cmV0dXJuIGFhKFAsRSl9OkUuc3R5bGV9cmV0dXJuIGJ9LHk9KC4uLmIpPT57Y29uc3QgRT1bXSxSPWIubWFwKGYpLFA9W107aWYoRS5wdXNoKGkpLHUmJnYmJlAucHVzaChmdW5jdGlvbihMKXt2YXIgTSxfO2NvbnN0IE49KF89KE09TC50aGVtZS5jb21wb25lbnRzKT09bnVsbD92b2lkIDA6TVt1XSk9PW51bGw/dm9pZCAwOl8uc3R5bGVPdmVycmlkZXM7aWYoIU4pcmV0dXJuIG51bGw7Y29uc3QgTz17fTtmb3IoY29uc3QgVCBpbiBOKU9bVF09YWEoTCxOW1RdKTtyZXR1cm4gdihMLE8pfSksdSYmIVMmJlAucHVzaChmdW5jdGlvbihMKXt2YXIgTyxNO2NvbnN0IGo9TC50aGVtZSxOPShNPShPPWo9PW51bGw/dm9pZCAwOmouY29tcG9uZW50cyk9PW51bGw/dm9pZCAwOk9bdV0pPT1udWxsP3ZvaWQgMDpNLnZhcmlhbnRzO3JldHVybiBOP0dnKEwsTik6bnVsbH0pLHh8fFAucHVzaChfbyksQXJyYXkuaXNBcnJheShSWzBdKSl7Y29uc3QgJD1SLnNoaWZ0KCksTD1uZXcgQXJyYXkoRS5sZW5ndGgpLmZpbGwoIiIpLGo9bmV3IEFycmF5KFAubGVuZ3RoKS5maWxsKCIiKTtsZXQgTjtOPVsuLi5MLC4uLiQsLi4ual0sTi5yYXc9Wy4uLkwsLi4uJC5yYXcsLi4ual0sRS51bnNoaWZ0KE4pfWNvbnN0IEk9Wy4uLkUsLi4uUiwuLi5QXSxwPWcoLi4uSSk7cmV0dXJuIGEubXVpTmFtZSYmKHAubXVpTmFtZT1hLm11aU5hbWUpLHB9O3JldHVybiBnLndpdGhDb25maWcmJih5LndpdGhDb25maWc9Zy53aXRoQ29uZmlnKSx5fX1mdW5jdGlvbiBxeChlLHQpe3JldHVybiB2b2lkIDB9ZnVuY3Rpb24gWngoZSl7Zm9yKGNvbnN0IHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBKeChlKXtyZXR1cm4gdHlwZW9mIGU9PSJzdHJpbmciJiZlLmNoYXJDb2RlQXQoMCk+OTZ9ZnVuY3Rpb24gZUMoZSl7cmV0dXJuIGUmJmUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkrZS5zbGljZSgxKX1mdW5jdGlvbiBiYShlLHQpe2NvbnN0IG49ey4uLnR9O2Zvcihjb25zdCByIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikpe2NvbnN0IG89cjtpZihvPT09ImNvbXBvbmVudHMifHxvPT09InNsb3RzIiluW29dPXsuLi5lW29dLC4uLm5bb119O2Vsc2UgaWYobz09PSJjb21wb25lbnRzUHJvcHMifHxvPT09InNsb3RQcm9wcyIpe2NvbnN0IGk9ZVtvXSxzPXRbb107aWYoIXMpbltvXT1pfHx7fTtlbHNlIGlmKCFpKW5bb109cztlbHNle25bb109ey4uLnN9O2Zvcihjb25zdCBhIGluIGkpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksYSkpe2NvbnN0IGw9YTtuW29dW2xdPWJhKGlbbF0sc1tsXSl9fX1lbHNlIG5bb109PT12b2lkIDAmJihuW29dPWVbb10pfXJldHVybiBufWNvbnN0IFluPXR5cGVvZiB3aW5kb3c8InUiP0MudXNlTGF5b3V0RWZmZWN0OkMudXNlRWZmZWN0O2Z1bmN0aW9uIHRDKGUsdD1OdW1iZXIuTUlOX1NBRkVfSU5URUdFUixuPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLG4pKX1mdW5jdGlvbiBRZChlLHQ9MCxuPTEpe3JldHVybiB0QyhlLHQsbil9ZnVuY3Rpb24gbkMoZSl7ZT1lLnNsaWNlKDEpO2NvbnN0IHQ9bmV3IFJlZ0V4cChgLnsxLCR7ZS5sZW5ndGg+PTY/MjoxfX1gLCJnIik7bGV0IG49ZS5tYXRjaCh0KTtyZXR1cm4gbiYmblswXS5sZW5ndGg9PT0xJiYobj1uLm1hcChyPT5yK3IpKSxuP2ByZ2Ike24ubGVuZ3RoPT09ND8iYSI6IiJ9KCR7bi5tYXAoKHIsbyk9Pm88Mz9wYXJzZUludChyLDE2KTpNYXRoLnJvdW5kKHBhcnNlSW50KHIsMTYpLzI1NSoxZTMpLzFlMykuam9pbigiLCAiKX0pYDoiIn1mdW5jdGlvbiBTcihlKXtpZihlLnR5cGUpcmV0dXJuIGU7aWYoZS5jaGFyQXQoMCk9PT0iIyIpcmV0dXJuIFNyKG5DKGUpKTtjb25zdCB0PWUuaW5kZXhPZigiKCIpLG49ZS5zdWJzdHJpbmcoMCx0KTtpZighWyJyZ2IiLCJyZ2JhIiwiaHNsIiwiaHNsYSIsImNvbG9yIl0uaW5jbHVkZXMobikpdGhyb3cgbmV3IEVycm9yKFZuKDksZSkpO2xldCByPWUuc3Vic3RyaW5nKHQrMSxlLmxlbmd0aC0xKSxvO2lmKG49PT0iY29sb3IiKXtpZihyPXIuc3BsaXQoIiAiKSxvPXIuc2hpZnQoKSxyLmxlbmd0aD09PTQmJnJbM10uY2hhckF0KDApPT09Ii8iJiYoclszXT1yWzNdLnNsaWNlKDEpKSwhWyJzcmdiIiwiZGlzcGxheS1wMyIsImE5OC1yZ2IiLCJwcm9waG90by1yZ2IiLCJyZWMtMjAyMCJdLmluY2x1ZGVzKG8pKXRocm93IG5ldyBFcnJvcihWbigxMCxvKSl9ZWxzZSByPXIuc3BsaXQoIiwiKTtyZXR1cm4gcj1yLm1hcChpPT5wYXJzZUZsb2F0KGkpKSx7dHlwZTpuLHZhbHVlczpyLGNvbG9yU3BhY2U6b319Y29uc3QgckM9ZT0+e2NvbnN0IHQ9U3IoZSk7cmV0dXJuIHQudmFsdWVzLnNsaWNlKDAsMykubWFwKChuLHIpPT50LnR5cGUuaW5jbHVkZXMoImhzbCIpJiZyIT09MD9gJHtufSVgOm4pLmpvaW4oIiAiKX0seWk9KGUsdCk9Pnt0cnl7cmV0dXJuIHJDKGUpfWNhdGNoe3JldHVybiBlfX07ZnVuY3Rpb24gQmwoZSl7Y29uc3R7dHlwZTp0LGNvbG9yU3BhY2U6bn09ZTtsZXR7dmFsdWVzOnJ9PWU7cmV0dXJuIHQuaW5jbHVkZXMoInJnYiIpP3I9ci5tYXAoKG8saSk9Pmk8Mz9wYXJzZUludChvLDEwKTpvKTp0LmluY2x1ZGVzKCJoc2wiKSYmKHJbMV09YCR7clsxXX0lYCxyWzJdPWAke3JbMl19JWApLHQuaW5jbHVkZXMoImNvbG9yIik/cj1gJHtufSAke3Iuam9pbigiICIpfWA6cj1gJHtyLmpvaW4oIiwgIil9YCxgJHt0fSgke3J9KWB9ZnVuY3Rpb24gUWcoZSl7ZT1TcihlKTtjb25zdHt2YWx1ZXM6dH09ZSxuPXRbMF0scj10WzFdLzEwMCxvPXRbMl0vMTAwLGk9cipNYXRoLm1pbihvLDEtbykscz0odSxjPSh1K24vMzApJTEyKT0+by1pKk1hdGgubWF4KE1hdGgubWluKGMtMyw5LWMsMSksLTEpO2xldCBhPSJyZ2IiO2NvbnN0IGw9W01hdGgucm91bmQocygwKSoyNTUpLE1hdGgucm91bmQocyg4KSoyNTUpLE1hdGgucm91bmQocyg0KSoyNTUpXTtyZXR1cm4gZS50eXBlPT09ImhzbGEiJiYoYSs9ImEiLGwucHVzaCh0WzNdKSksQmwoe3R5cGU6YSx2YWx1ZXM6bH0pfWZ1bmN0aW9uIGRjKGUpe2U9U3IoZSk7bGV0IHQ9ZS50eXBlPT09ImhzbCJ8fGUudHlwZT09PSJoc2xhIj9TcihRZyhlKSkudmFsdWVzOmUudmFsdWVzO3JldHVybiB0PXQubWFwKG49PihlLnR5cGUhPT0iY29sb3IiJiYobi89MjU1KSxuPD0uMDM5Mjg/bi8xMi45MjooKG4rLjA1NSkvMS4wNTUpKioyLjQpKSxOdW1iZXIoKC4yMTI2KnRbMF0rLjcxNTIqdFsxXSsuMDcyMip0WzJdKS50b0ZpeGVkKDMpKX1mdW5jdGlvbiBvQyhlLHQpe2NvbnN0IG49ZGMoZSkscj1kYyh0KTtyZXR1cm4oTWF0aC5tYXgobixyKSsuMDUpLyhNYXRoLm1pbihuLHIpKy4wNSl9ZnVuY3Rpb24gZnQoZSx0KXtyZXR1cm4gZT1TcihlKSx0PVFkKHQpLChlLnR5cGU9PT0icmdiInx8ZS50eXBlPT09ImhzbCIpJiYoZS50eXBlKz0iYSIpLGUudHlwZT09PSJjb2xvciI/ZS52YWx1ZXNbM109YC8ke3R9YDplLnZhbHVlc1szXT10LEJsKGUpfWZ1bmN0aW9uIE9zKGUsdCxuKXt0cnl7cmV0dXJuIGZ0KGUsdCl9Y2F0Y2h7cmV0dXJuIGV9fWZ1bmN0aW9uIFdsKGUsdCl7aWYoZT1TcihlKSx0PVFkKHQpLGUudHlwZS5pbmNsdWRlcygiaHNsIikpZS52YWx1ZXNbMl0qPTEtdDtlbHNlIGlmKGUudHlwZS5pbmNsdWRlcygicmdiIil8fGUudHlwZS5pbmNsdWRlcygiY29sb3IiKSlmb3IobGV0IG49MDtuPDM7bis9MSllLnZhbHVlc1tuXSo9MS10O3JldHVybiBCbChlKX1mdW5jdGlvbiBFZShlLHQsbil7dHJ5e3JldHVybiBXbChlLHQpfWNhdGNoe3JldHVybiBlfX1mdW5jdGlvbiBVbChlLHQpe2lmKGU9U3IoZSksdD1RZCh0KSxlLnR5cGUuaW5jbHVkZXMoImhzbCIpKWUudmFsdWVzWzJdKz0oMTAwLWUudmFsdWVzWzJdKSp0O2Vsc2UgaWYoZS50eXBlLmluY2x1ZGVzKCJyZ2IiKSlmb3IobGV0IG49MDtuPDM7bis9MSllLnZhbHVlc1tuXSs9KDI1NS1lLnZhbHVlc1tuXSkqdDtlbHNlIGlmKGUudHlwZS5pbmNsdWRlcygiY29sb3IiKSlmb3IobGV0IG49MDtuPDM7bis9MSllLnZhbHVlc1tuXSs9KDEtZS52YWx1ZXNbbl0pKnQ7cmV0dXJuIEJsKGUpfWZ1bmN0aW9uIFJlKGUsdCxuKXt0cnl7cmV0dXJuIFVsKGUsdCl9Y2F0Y2h7cmV0dXJuIGV9fWZ1bmN0aW9uIGlDKGUsdD0uMTUpe3JldHVybiBkYyhlKT4uNT9XbChlLHQpOlVsKGUsdCl9ZnVuY3Rpb24gTXMoZSx0LG4pe3RyeXtyZXR1cm4gaUMoZSx0KX1jYXRjaHtyZXR1cm4gZX19ZnVuY3Rpb24gVnAoLi4uZSl7cmV0dXJuIGUucmVkdWNlKCh0LG4pPT5uPT1udWxsP3Q6ZnVuY3Rpb24oLi4ubyl7dC5hcHBseSh0aGlzLG8pLG4uYXBwbHkodGhpcyxvKX0sKCk9Pnt9KX1mdW5jdGlvbiBYZyhlLHQ9MTY2KXtsZXQgbjtmdW5jdGlvbiByKC4uLm8pe2NvbnN0IGk9KCk9PntlLmFwcGx5KHRoaXMsbyl9O2NsZWFyVGltZW91dChuKSxuPXNldFRpbWVvdXQoaSx0KX1yZXR1cm4gci5jbGVhcj0oKT0+e2NsZWFyVGltZW91dChuKX0scn1mdW5jdGlvbiBDdShlLHQpe3ZhciBuLHIsbztyZXR1cm4gQy5pc1ZhbGlkRWxlbWVudChlKSYmdC5pbmRleE9mKGUudHlwZS5tdWlOYW1lPz8oKG89KHI9KG49ZS50eXBlKT09bnVsbD92b2lkIDA6bi5fcGF5bG9hZCk9PW51bGw/dm9pZCAwOnIudmFsdWUpPT1udWxsP3ZvaWQgMDpvLm11aU5hbWUpKSE9PS0xfWZ1bmN0aW9uIER0KGUpe3JldHVybiBlJiZlLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50fWZ1bmN0aW9uIEduKGUpe3JldHVybiBEdChlKS5kZWZhdWx0Vmlld3x8d2luZG93fWZ1bmN0aW9uIGZjKGUsdCl7dHlwZW9mIGU9PSJmdW5jdGlvbiI/ZSh0KTplJiYoZS5jdXJyZW50PXQpfWxldCBLcD0wO2Z1bmN0aW9uIHNDKGUpe2NvbnN0W3Qsbl09Qy51c2VTdGF0ZShlKSxyPWV8fHQ7cmV0dXJuIEMudXNlRWZmZWN0KCgpPT57dD09bnVsbCYmKEtwKz0xLG4oYG11aS0ke0twfWApKX0sW3RdKSxyfWNvbnN0IGFDPXsuLi5EaX0sWXA9YUMudXNlSWQ7ZnVuY3Rpb24gWGQoZSl7aWYoWXAhPT12b2lkIDApe2NvbnN0IHQ9WXAoKTtyZXR1cm4gZT8/dH1yZXR1cm4gc0MoZSl9ZnVuY3Rpb24ga2Eoe2NvbnRyb2xsZWQ6ZSxkZWZhdWx0OnQsbmFtZTpuLHN0YXRlOnI9InZhbHVlIn0pe2NvbnN0e2N1cnJlbnQ6b309Qy51c2VSZWYoZSE9PXZvaWQgMCksW2ksc109Qy51c2VTdGF0ZSh0KSxhPW8/ZTppLGw9Qy51c2VDYWxsYmFjayh1PT57b3x8cyh1KX0sW10pO3JldHVyblthLGxdfWZ1bmN0aW9uIHVyKGUpe2NvbnN0IHQ9Qy51c2VSZWYoZSk7cmV0dXJuIFluKCgpPT57dC5jdXJyZW50PWV9KSxDLnVzZVJlZigoLi4ubik9PigwLHQuY3VycmVudCkoLi4ubikpLmN1cnJlbnR9ZnVuY3Rpb24gUWUoLi4uZSl7cmV0dXJuIEMudXNlTWVtbygoKT0+ZS5ldmVyeSh0PT50PT1udWxsKT9udWxsOnQ9PntlLmZvckVhY2gobj0+e2ZjKG4sdCl9KX0sZSl9Y29uc3QgR3A9e307ZnVuY3Rpb24gcWcoZSx0KXtjb25zdCBuPUMudXNlUmVmKEdwKTtyZXR1cm4gbi5jdXJyZW50PT09R3AmJihuLmN1cnJlbnQ9ZSh0KSksbn1jb25zdCBsQz1bXTtmdW5jdGlvbiB1QyhlKXtDLnVzZUVmZmVjdChlLGxDKX1jbGFzcyBIbHtjb25zdHJ1Y3Rvcigpe3RpKHRoaXMsImN1cnJlbnRJZCIsbnVsbCk7dGkodGhpcywiY2xlYXIiLCgpPT57dGhpcy5jdXJyZW50SWQhPT1udWxsJiYoY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudElkKSx0aGlzLmN1cnJlbnRJZD1udWxsKX0pO3RpKHRoaXMsImRpc3Bvc2VFZmZlY3QiLCgpPT50aGlzLmNsZWFyKX1zdGF0aWMgY3JlYXRlKCl7cmV0dXJuIG5ldyBIbH1zdGFydCh0LG4pe3RoaXMuY2xlYXIoKSx0aGlzLmN1cnJlbnRJZD1zZXRUaW1lb3V0KCgpPT57dGhpcy5jdXJyZW50SWQ9bnVsbCxuKCl9LHQpfX1mdW5jdGlvbiBBcigpe2NvbnN0IGU9cWcoSGwuY3JlYXRlKS5jdXJyZW50O3JldHVybiB1QyhlLmRpc3Bvc2VFZmZlY3QpLGV9ZnVuY3Rpb24gRWEoZSl7dHJ5e3JldHVybiBlLm1hdGNoZXMoIjpmb2N1cy12aXNpYmxlIil9Y2F0Y2h7fXJldHVybiExfWZ1bmN0aW9uIFpnKGU9d2luZG93KXtjb25zdCB0PWUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO3JldHVybiBlLmlubmVyV2lkdGgtdH1mdW5jdGlvbiBwZShlLHQsbj12b2lkIDApe2NvbnN0IHI9e307Zm9yKGNvbnN0IG8gaW4gZSl7Y29uc3QgaT1lW29dO2xldCBzPSIiLGE9ITA7Zm9yKGxldCBsPTA7bDxpLmxlbmd0aDtsKz0xKXtjb25zdCB1PWlbbF07dSYmKHMrPShhPT09ITA/IiI6IiAiKSt0KHUpLGE9ITEsbiYmblt1XSYmKHMrPSIgIituW3VdKSl9cltvXT1zfXJldHVybiByfWZ1bmN0aW9uIGNDKGUpe3JldHVybiB0eXBlb2YgZT09InN0cmluZyJ9ZnVuY3Rpb24gbG8oZSx0LG4pe3JldHVybiBlPT09dm9pZCAwfHxjQyhlKT90OnsuLi50LG93bmVyU3RhdGU6ey4uLnQub3duZXJTdGF0ZSwuLi5ufX19ZnVuY3Rpb24gSmcoZSx0PVtdKXtpZihlPT09dm9pZCAwKXJldHVybnt9O2NvbnN0IG49e307cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZpbHRlcihyPT5yLm1hdGNoKC9eb25bQS1aXS8pJiZ0eXBlb2YgZVtyXT09ImZ1bmN0aW9uIiYmIXQuaW5jbHVkZXMocikpLmZvckVhY2gocj0+e25bcl09ZVtyXX0pLG59ZnVuY3Rpb24gUXAoZSl7aWYoZT09PXZvaWQgMClyZXR1cm57fTtjb25zdCB0PXt9O3JldHVybiBPYmplY3Qua2V5cyhlKS5maWx0ZXIobj0+IShuLm1hdGNoKC9eb25bQS1aXS8pJiZ0eXBlb2YgZVtuXT09ImZ1bmN0aW9uIikpLmZvckVhY2gobj0+e3Rbbl09ZVtuXX0pLHR9ZnVuY3Rpb24gZXkoZSl7Y29uc3R7Z2V0U2xvdFByb3BzOnQsYWRkaXRpb25hbFByb3BzOm4sZXh0ZXJuYWxTbG90UHJvcHM6cixleHRlcm5hbEZvcndhcmRlZFByb3BzOm8sY2xhc3NOYW1lOml9PWU7aWYoIXQpe2NvbnN0IHY9dGUobj09bnVsbD92b2lkIDA6bi5jbGFzc05hbWUsaSxvPT1udWxsP3ZvaWQgMDpvLmNsYXNzTmFtZSxyPT1udWxsP3ZvaWQgMDpyLmNsYXNzTmFtZSksdz17Li4ubj09bnVsbD92b2lkIDA6bi5zdHlsZSwuLi5vPT1udWxsP3ZvaWQgMDpvLnN0eWxlLC4uLnI9PW51bGw/dm9pZCAwOnIuc3R5bGV9LFM9ey4uLm4sLi4ubywuLi5yfTtyZXR1cm4gdi5sZW5ndGg+MCYmKFMuY2xhc3NOYW1lPXYpLE9iamVjdC5rZXlzKHcpLmxlbmd0aD4wJiYoUy5zdHlsZT13KSx7cHJvcHM6UyxpbnRlcm5hbFJlZjp2b2lkIDB9fWNvbnN0IHM9Smcoey4uLm8sLi4ucn0pLGE9UXAociksbD1RcChvKSx1PXQocyksYz10ZSh1PT1udWxsP3ZvaWQgMDp1LmNsYXNzTmFtZSxuPT1udWxsP3ZvaWQgMDpuLmNsYXNzTmFtZSxpLG89PW51bGw/dm9pZCAwOm8uY2xhc3NOYW1lLHI9PW51bGw/dm9pZCAwOnIuY2xhc3NOYW1lKSxkPXsuLi51PT1udWxsP3ZvaWQgMDp1LnN0eWxlLC4uLm49PW51bGw/dm9pZCAwOm4uc3R5bGUsLi4ubz09bnVsbD92b2lkIDA6by5zdHlsZSwuLi5yPT1udWxsP3ZvaWQgMDpyLnN0eWxlfSxtPXsuLi51LC4uLm4sLi4ubCwuLi5hfTtyZXR1cm4gYy5sZW5ndGg+MCYmKG0uY2xhc3NOYW1lPWMpLE9iamVjdC5rZXlzKGQpLmxlbmd0aD4wJiYobS5zdHlsZT1kKSx7cHJvcHM6bSxpbnRlcm5hbFJlZjp1LnJlZn19ZnVuY3Rpb24gdHkoZSx0LG4pe3JldHVybiB0eXBlb2YgZT09ImZ1bmN0aW9uIj9lKHQsbik6ZX1mdW5jdGlvbiBwYyhlKXt2YXIgZDtjb25zdHtlbGVtZW50VHlwZTp0LGV4dGVybmFsU2xvdFByb3BzOm4sb3duZXJTdGF0ZTpyLHNraXBSZXNvbHZpbmdTbG90UHJvcHM6bz0hMSwuLi5pfT1lLHM9bz97fTp0eShuLHIpLHtwcm9wczphLGludGVybmFsUmVmOmx9PWV5KHsuLi5pLGV4dGVybmFsU2xvdFByb3BzOnN9KSx1PVFlKGwscz09bnVsbD92b2lkIDA6cy5yZWYsKGQ9ZS5hZGRpdGlvbmFsUHJvcHMpPT1udWxsP3ZvaWQgMDpkLnJlZik7cmV0dXJuIGxvKHQsey4uLmEscmVmOnV9LHIpfWZ1bmN0aW9uIFFvKGUpe3ZhciB0O3JldHVybiBwYXJzZUludChDLnZlcnNpb24sMTApPj0xOT8oKHQ9ZT09bnVsbD92b2lkIDA6ZS5wcm9wcyk9PW51bGw/dm9pZCAwOnQucmVmKXx8bnVsbDooZT09bnVsbD92b2lkIDA6ZS5yZWYpfHxudWxsfWNvbnN0IGRDPUMuY3JlYXRlQ29udGV4dCgpLHFkPSgpPT5DLnVzZUNvbnRleHQoZEMpPz8hMSxmQz1DLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtmdW5jdGlvbiBwQyhlKXtjb25zdHt0aGVtZTp0LG5hbWU6bixwcm9wczpyfT1lO2lmKCF0fHwhdC5jb21wb25lbnRzfHwhdC5jb21wb25lbnRzW25dKXJldHVybiByO2NvbnN0IG89dC5jb21wb25lbnRzW25dO3JldHVybiBvLmRlZmF1bHRQcm9wcz9iYShvLmRlZmF1bHRQcm9wcyxyKTohby5zdHlsZU92ZXJyaWRlcyYmIW8udmFyaWFudHM/YmEobyxyKTpyfWZ1bmN0aW9uIG1DKHtwcm9wczplLG5hbWU6dH0pe2NvbnN0IG49Qy51c2VDb250ZXh0KGZDKTtyZXR1cm4gcEMoe3Byb3BzOmUsbmFtZTp0LHRoZW1lOntjb21wb25lbnRzOm59fSl9Y29uc3QgWHA9e3RoZW1lOnZvaWQgMH07ZnVuY3Rpb24gaEMoZSl7bGV0IHQsbjtyZXR1cm4gZnVuY3Rpb24obyl7bGV0IGk9dDtyZXR1cm4oaT09PXZvaWQgMHx8by50aGVtZSE9PW4pJiYoWHAudGhlbWU9by50aGVtZSxpPVlnKGUoWHApKSx0PWksbj1vLnRoZW1lKSxpfX1mdW5jdGlvbiBnQyhlPSIiKXtmdW5jdGlvbiB0KC4uLnIpe2lmKCFyLmxlbmd0aClyZXR1cm4iIjtjb25zdCBvPXJbMF07cmV0dXJuIHR5cGVvZiBvPT0ic3RyaW5nIiYmIW8ubWF0Y2goLygjfFwofFwpfCgtPyhcZCpcLik/XGQrKShweHxlbXwlfGV4fGNofHJlbXx2d3x2aHx2bWlufHZtYXh8Y218bW18aW58cHR8cGMpKXxeKC0/KFxkKlwuKT9cZCspJHwoXGQrIFxkKyBcZCspLyk/YCwgdmFyKC0tJHtlP2Ake2V9LWA6IiJ9JHtvfSR7dCguLi5yLnNsaWNlKDEpKX0pYDpgLCAke299YH1yZXR1cm4ociwuLi5vKT0+YHZhcigtLSR7ZT9gJHtlfS1gOiIifSR7cn0ke3QoLi4ubyl9KWB9Y29uc3QgcXA9KGUsdCxuLHI9W10pPT57bGV0IG89ZTt0LmZvckVhY2goKGkscyk9PntzPT09dC5sZW5ndGgtMT9BcnJheS5pc0FycmF5KG8pP29bTnVtYmVyKGkpXT1uOm8mJnR5cGVvZiBvPT0ib2JqZWN0IiYmKG9baV09bik6byYmdHlwZW9mIG89PSJvYmplY3QiJiYob1tpXXx8KG9baV09ci5pbmNsdWRlcyhpKT9bXTp7fSksbz1vW2ldKX0pfSx5Qz0oZSx0LG4pPT57ZnVuY3Rpb24gcihvLGk9W10scz1bXSl7T2JqZWN0LmVudHJpZXMobykuZm9yRWFjaCgoW2EsbF0pPT57KCFufHxuJiYhbihbLi4uaSxhXSkpJiZsIT1udWxsJiYodHlwZW9mIGw9PSJvYmplY3QiJiZPYmplY3Qua2V5cyhsKS5sZW5ndGg+MD9yKGwsWy4uLmksYV0sQXJyYXkuaXNBcnJheShsKT9bLi4ucyxhXTpzKTp0KFsuLi5pLGFdLGwscykpfSl9cihlKX0sdkM9KGUsdCk9PnR5cGVvZiB0PT0ibnVtYmVyIj9bImxpbmVIZWlnaHQiLCJmb250V2VpZ2h0Iiwib3BhY2l0eSIsInpJbmRleCJdLnNvbWUocj0+ZS5pbmNsdWRlcyhyKSl8fGVbZS5sZW5ndGgtMV0udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygib3BhY2l0eSIpP3Q6YCR7dH1weGA6dDtmdW5jdGlvbiBidShlLHQpe2NvbnN0e3ByZWZpeDpuLHNob3VsZFNraXBHZW5lcmF0aW5nVmFyOnJ9PXR8fHt9LG89e30saT17fSxzPXt9O3JldHVybiB5QyhlLChhLGwsdSk9PntpZigodHlwZW9mIGw9PSJzdHJpbmcifHx0eXBlb2YgbD09Im51bWJlciIpJiYoIXJ8fCFyKGEsbCkpKXtjb25zdCBjPWAtLSR7bj9gJHtufS1gOiIifSR7YS5qb2luKCItIil9YCxkPXZDKGEsbCk7T2JqZWN0LmFzc2lnbihvLHtbY106ZH0pLHFwKGksYSxgdmFyKCR7Y30pYCx1KSxxcChzLGEsYHZhcigke2N9LCAke2R9KWAsdSl9fSxhPT5hWzBdPT09InZhcnMiKSx7Y3NzOm8sdmFyczppLHZhcnNXaXRoRGVmYXVsdHM6c319ZnVuY3Rpb24gd0MoZSx0PXt9KXtjb25zdHtnZXRTZWxlY3RvcjpuPXgsZGlzYWJsZUNzc0NvbG9yU2NoZW1lOnIsY29sb3JTY2hlbWVTZWxlY3RvcjpvfT10LHtjb2xvclNjaGVtZXM6aT17fSxjb21wb25lbnRzOnMsZGVmYXVsdENvbG9yU2NoZW1lOmE9ImxpZ2h0IiwuLi5sfT1lLHt2YXJzOnUsY3NzOmMsdmFyc1dpdGhEZWZhdWx0czpkfT1idShsLHQpO2xldCBtPWQ7Y29uc3Qgdj17fSx7W2FdOncsLi4uU309aTtpZihPYmplY3QuZW50cmllcyhTfHx7fSkuZm9yRWFjaCgoW2YseV0pPT57Y29uc3R7dmFyczpiLGNzczpFLHZhcnNXaXRoRGVmYXVsdHM6Un09YnUoeSx0KTttPXB0KG0sUiksdltmXT17Y3NzOkUsdmFyczpifX0pLHcpe2NvbnN0e2NzczpmLHZhcnM6eSx2YXJzV2l0aERlZmF1bHRzOmJ9PWJ1KHcsdCk7bT1wdChtLGIpLHZbYV09e2NzczpmLHZhcnM6eX19ZnVuY3Rpb24geChmLHkpe3ZhciBFLFI7bGV0IGI9bztpZihvPT09ImNsYXNzIiYmKGI9Ii4lcyIpLG89PT0iZGF0YSImJihiPSJbZGF0YS0lc10iKSxvIT1udWxsJiZvLnN0YXJ0c1dpdGgoImRhdGEtIikmJiFvLmluY2x1ZGVzKCIlcyIpJiYoYj1gWyR7b309IiVzIl1gKSxmKXtpZihiPT09Im1lZGlhIilyZXR1cm4gZS5kZWZhdWx0Q29sb3JTY2hlbWU9PT1mPyI6cm9vdCI6e1tgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogJHsoKFI9KEU9aVtmXSk9PW51bGw/dm9pZCAwOkUucGFsZXR0ZSk9PW51bGw/dm9pZCAwOlIubW9kZSl8fGZ9KWBdOnsiOnJvb3QiOnl9fTtpZihiKXJldHVybiBlLmRlZmF1bHRDb2xvclNjaGVtZT09PWY/YDpyb290LCAke2IucmVwbGFjZSgiJXMiLFN0cmluZyhmKSl9YDpiLnJlcGxhY2UoIiVzIixTdHJpbmcoZikpfXJldHVybiI6cm9vdCJ9cmV0dXJue3ZhcnM6bSxnZW5lcmF0ZVRoZW1lVmFyczooKT0+e2xldCBmPXsuLi51fTtyZXR1cm4gT2JqZWN0LmVudHJpZXModikuZm9yRWFjaCgoWyx7dmFyczp5fV0pPT57Zj1wdChmLHkpfSksZn0sZ2VuZXJhdGVTdHlsZVNoZWV0czooKT0+e3ZhciBQLEk7Y29uc3QgZj1bXSx5PWUuZGVmYXVsdENvbG9yU2NoZW1lfHwibGlnaHQiO2Z1bmN0aW9uIGIocCwkKXtPYmplY3Qua2V5cygkKS5sZW5ndGgmJmYucHVzaCh0eXBlb2YgcD09InN0cmluZyI/e1twXTp7Li4uJH19OnApfWIobih2b2lkIDAsey4uLmN9KSxjKTtjb25zdHtbeV06RSwuLi5SfT12O2lmKEUpe2NvbnN0e2NzczpwfT1FLCQ9KEk9KFA9aVt5XSk9PW51bGw/dm9pZCAwOlAucGFsZXR0ZSk9PW51bGw/dm9pZCAwOkkubW9kZSxMPSFyJiYkP3tjb2xvclNjaGVtZTokLC4uLnB9OnsuLi5wfTtiKG4oeSx7Li4uTH0pLEwpfXJldHVybiBPYmplY3QuZW50cmllcyhSKS5mb3JFYWNoKChbcCx7Y3NzOiR9XSk9Pnt2YXIgTixPO2NvbnN0IEw9KE89KE49aVtwXSk9PW51bGw/dm9pZCAwOk4ucGFsZXR0ZSk9PW51bGw/dm9pZCAwOk8ubW9kZSxqPSFyJiZMP3tjb2xvclNjaGVtZTpMLC4uLiR9OnsuLi4kfTtiKG4ocCx7Li4uan0pLGopfSksZn19fWZ1bmN0aW9uIFNDKGUpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gZT09PSJtZWRpYSI/YEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6ICR7bn0pYDplP2Uuc3RhcnRzV2l0aCgiZGF0YS0iKSYmIWUuaW5jbHVkZXMoIiVzIik/YFske2V9PSIke259Il0gJmA6ZT09PSJjbGFzcyI/YC4ke259ICZgOmU9PT0iZGF0YSI/YFtkYXRhLSR7bn1dICZgOmAke2UucmVwbGFjZSgiJXMiLG4pfSAmYDoiJiJ9fWZ1bmN0aW9uIG55KCl7cmV0dXJue3RleHQ6e3ByaW1hcnk6InJnYmEoMCwgMCwgMCwgMC44NykiLHNlY29uZGFyeToicmdiYSgwLCAwLCAwLCAwLjYpIixkaXNhYmxlZDoicmdiYSgwLCAwLCAwLCAwLjM4KSJ9LGRpdmlkZXI6InJnYmEoMCwgMCwgMCwgMC4xMikiLGJhY2tncm91bmQ6e3BhcGVyOkZpLndoaXRlLGRlZmF1bHQ6Rmkud2hpdGV9LGFjdGlvbjp7YWN0aXZlOiJyZ2JhKDAsIDAsIDAsIDAuNTQpIixob3ZlcjoicmdiYSgwLCAwLCAwLCAwLjA0KSIsaG92ZXJPcGFjaXR5Oi4wNCxzZWxlY3RlZDoicmdiYSgwLCAwLCAwLCAwLjA4KSIsc2VsZWN0ZWRPcGFjaXR5Oi4wOCxkaXNhYmxlZDoicmdiYSgwLCAwLCAwLCAwLjI2KSIsZGlzYWJsZWRCYWNrZ3JvdW5kOiJyZ2JhKDAsIDAsIDAsIDAuMTIpIixkaXNhYmxlZE9wYWNpdHk6LjM4LGZvY3VzOiJyZ2JhKDAsIDAsIDAsIDAuMTIpIixmb2N1c09wYWNpdHk6LjEyLGFjdGl2YXRlZE9wYWNpdHk6LjEyfX19Y29uc3QgeEM9bnkoKTtmdW5jdGlvbiByeSgpe3JldHVybnt0ZXh0OntwcmltYXJ5OkZpLndoaXRlLHNlY29uZGFyeToicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpIixkaXNhYmxlZDoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpIixpY29uOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkifSxkaXZpZGVyOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpIixiYWNrZ3JvdW5kOntwYXBlcjoiIzEyMTIxMiIsZGVmYXVsdDoiIzEyMTIxMiJ9LGFjdGlvbjp7YWN0aXZlOkZpLndoaXRlLGhvdmVyOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDgpIixob3Zlck9wYWNpdHk6LjA4LHNlbGVjdGVkOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTYpIixzZWxlY3RlZE9wYWNpdHk6LjE2LGRpc2FibGVkOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMykiLGRpc2FibGVkQmFja2dyb3VuZDoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKSIsZGlzYWJsZWRPcGFjaXR5Oi4zOCxmb2N1czoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKSIsZm9jdXNPcGFjaXR5Oi4xMixhY3RpdmF0ZWRPcGFjaXR5Oi4yNH19fWNvbnN0IFpwPXJ5KCk7ZnVuY3Rpb24gSnAoZSx0LG4scil7Y29uc3Qgbz1yLmxpZ2h0fHxyLGk9ci5kYXJrfHxyKjEuNTtlW3RdfHwoZS5oYXNPd25Qcm9wZXJ0eShuKT9lW3RdPWVbbl06dD09PSJsaWdodCI/ZS5saWdodD1VbChlLm1haW4sbyk6dD09PSJkYXJrIiYmKGUuZGFyaz1XbChlLm1haW4saSkpKX1mdW5jdGlvbiBDQyhlPSJsaWdodCIpe3JldHVybiBlPT09ImRhcmsiP3ttYWluOnRvWzIwMF0sbGlnaHQ6dG9bNTBdLGRhcms6dG9bNDAwXX06e21haW46dG9bNzAwXSxsaWdodDp0b1s0MDBdLGRhcms6dG9bODAwXX19ZnVuY3Rpb24gYkMoZT0ibGlnaHQiKXtyZXR1cm4gZT09PSJkYXJrIj97bWFpbjplb1syMDBdLGxpZ2h0OmVvWzUwXSxkYXJrOmVvWzQwMF19OnttYWluOmVvWzUwMF0sbGlnaHQ6ZW9bMzAwXSxkYXJrOmVvWzcwMF19fWZ1bmN0aW9uIGtDKGU9ImxpZ2h0Iil7cmV0dXJuIGU9PT0iZGFyayI/e21haW46SnJbNTAwXSxsaWdodDpKclszMDBdLGRhcms6SnJbNzAwXX06e21haW46SnJbNzAwXSxsaWdodDpKcls0MDBdLGRhcms6SnJbODAwXX19ZnVuY3Rpb24gRUMoZT0ibGlnaHQiKXtyZXR1cm4gZT09PSJkYXJrIj97bWFpbjpub1s0MDBdLGxpZ2h0Om5vWzMwMF0sZGFyazpub1s3MDBdfTp7bWFpbjpub1s3MDBdLGxpZ2h0Om5vWzUwMF0sZGFyazpub1s5MDBdfX1mdW5jdGlvbiBSQyhlPSJsaWdodCIpe3JldHVybiBlPT09ImRhcmsiP3ttYWluOnJvWzQwMF0sbGlnaHQ6cm9bMzAwXSxkYXJrOnJvWzcwMF19OnttYWluOnJvWzgwMF0sbGlnaHQ6cm9bNTAwXSxkYXJrOnJvWzkwMF19fWZ1bmN0aW9uIFRDKGU9ImxpZ2h0Iil7cmV0dXJuIGU9PT0iZGFyayI/e21haW46bmlbNDAwXSxsaWdodDpuaVszMDBdLGRhcms6bmlbNzAwXX06e21haW46IiNlZDZjMDIiLGxpZ2h0Om5pWzUwMF0sZGFyazpuaVs5MDBdfX1mdW5jdGlvbiBaZChlKXtjb25zdHttb2RlOnQ9ImxpZ2h0Iixjb250cmFzdFRocmVzaG9sZDpuPTMsdG9uYWxPZmZzZXQ6cj0uMiwuLi5vfT1lLGk9ZS5wcmltYXJ5fHxDQyh0KSxzPWUuc2Vjb25kYXJ5fHxiQyh0KSxhPWUuZXJyb3J8fGtDKHQpLGw9ZS5pbmZvfHxFQyh0KSx1PWUuc3VjY2Vzc3x8UkModCksYz1lLndhcm5pbmd8fFRDKHQpO2Z1bmN0aW9uIGQoUyl7cmV0dXJuIG9DKFMsWnAudGV4dC5wcmltYXJ5KT49bj9acC50ZXh0LnByaW1hcnk6eEMudGV4dC5wcmltYXJ5fWNvbnN0IG09KHtjb2xvcjpTLG5hbWU6eCxtYWluU2hhZGU6aD01MDAsbGlnaHRTaGFkZTpnPTMwMCxkYXJrU2hhZGU6Zj03MDB9KT0+e2lmKFM9ey4uLlN9LCFTLm1haW4mJlNbaF0mJihTLm1haW49U1toXSksIVMuaGFzT3duUHJvcGVydHkoIm1haW4iKSl0aHJvdyBuZXcgRXJyb3IoVm4oMTEseD9gICgke3h9KWA6IiIsaCkpO2lmKHR5cGVvZiBTLm1haW4hPSJzdHJpbmciKXRocm93IG5ldyBFcnJvcihWbigxMix4P2AgKCR7eH0pYDoiIixKU09OLnN0cmluZ2lmeShTLm1haW4pKSk7cmV0dXJuIEpwKFMsImxpZ2h0IixnLHIpLEpwKFMsImRhcmsiLGYsciksUy5jb250cmFzdFRleHR8fChTLmNvbnRyYXN0VGV4dD1kKFMubWFpbikpLFN9O2xldCB2O3JldHVybiB0PT09ImxpZ2h0Ij92PW55KCk6dD09PSJkYXJrIiYmKHY9cnkoKSkscHQoe2NvbW1vbjp7Li4uRml9LG1vZGU6dCxwcmltYXJ5Om0oe2NvbG9yOmksbmFtZToicHJpbWFyeSJ9KSxzZWNvbmRhcnk6bSh7Y29sb3I6cyxuYW1lOiJzZWNvbmRhcnkiLG1haW5TaGFkZToiQTQwMCIsbGlnaHRTaGFkZToiQTIwMCIsZGFya1NoYWRlOiJBNzAwIn0pLGVycm9yOm0oe2NvbG9yOmEsbmFtZToiZXJyb3IifSksd2FybmluZzptKHtjb2xvcjpjLG5hbWU6Indhcm5pbmcifSksaW5mbzptKHtjb2xvcjpsLG5hbWU6ImluZm8ifSksc3VjY2VzczptKHtjb2xvcjp1LG5hbWU6InN1Y2Nlc3MifSksZ3JleTpPdyxjb250cmFzdFRocmVzaG9sZDpuLGdldENvbnRyYXN0VGV4dDpkLGF1Z21lbnRDb2xvcjptLHRvbmFsT2Zmc2V0OnIsLi4udn0sbyl9ZnVuY3Rpb24gUEMoZSl7Y29uc3QgdD17fTtyZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaChyPT57Y29uc3RbbyxpXT1yO3R5cGVvZiBpPT0ib2JqZWN0IiYmKHRbb109YCR7aS5mb250U3R5bGU/YCR7aS5mb250U3R5bGV9IGA6IiJ9JHtpLmZvbnRWYXJpYW50P2Ake2kuZm9udFZhcmlhbnR9IGA6IiJ9JHtpLmZvbnRXZWlnaHQ/YCR7aS5mb250V2VpZ2h0fSBgOiIifSR7aS5mb250U3RyZXRjaD9gJHtpLmZvbnRTdHJldGNofSBgOiIifSR7aS5mb250U2l6ZXx8IiJ9JHtpLmxpbmVIZWlnaHQ/YC8ke2kubGluZUhlaWdodH0gYDoiIn0ke2kuZm9udEZhbWlseXx8IiJ9YCl9KSx0fWZ1bmN0aW9uICRDKGUsdCl7cmV0dXJue3Rvb2xiYXI6e21pbkhlaWdodDo1NixbZS51cCgieHMiKV06eyJAbWVkaWEgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIjp7bWluSGVpZ2h0OjQ4fX0sW2UudXAoInNtIildOnttaW5IZWlnaHQ6NjR9fSwuLi50fX1mdW5jdGlvbiBPQyhlKXtyZXR1cm4gTWF0aC5yb3VuZChlKjFlNSkvMWU1fWNvbnN0IGVtPXt0ZXh0VHJhbnNmb3JtOiJ1cHBlcmNhc2UifSx0bT0nIlJvYm90byIsICJIZWx2ZXRpY2EiLCAiQXJpYWwiLCBzYW5zLXNlcmlmJztmdW5jdGlvbiBNQyhlLHQpe2NvbnN0e2ZvbnRGYW1pbHk6bj10bSxmb250U2l6ZTpyPTE0LGZvbnRXZWlnaHRMaWdodDpvPTMwMCxmb250V2VpZ2h0UmVndWxhcjppPTQwMCxmb250V2VpZ2h0TWVkaXVtOnM9NTAwLGZvbnRXZWlnaHRCb2xkOmE9NzAwLGh0bWxGb250U2l6ZTpsPTE2LGFsbFZhcmlhbnRzOnUscHhUb1JlbTpjLC4uLmR9PXR5cGVvZiB0PT0iZnVuY3Rpb24iP3QoZSk6dCxtPXIvMTQsdj1jfHwoeD0+YCR7eC9sKm19cmVtYCksdz0oeCxoLGcsZix5KT0+KHtmb250RmFtaWx5Om4sZm9udFdlaWdodDp4LGZvbnRTaXplOnYoaCksbGluZUhlaWdodDpnLC4uLm49PT10bT97bGV0dGVyU3BhY2luZzpgJHtPQyhmL2gpfWVtYH06e30sLi4ueSwuLi51fSksUz17aDE6dyhvLDk2LDEuMTY3LC0xLjUpLGgyOncobyw2MCwxLjIsLS41KSxoMzp3KGksNDgsMS4xNjcsMCksaDQ6dyhpLDM0LDEuMjM1LC4yNSksaDU6dyhpLDI0LDEuMzM0LDApLGg2OncocywyMCwxLjYsLjE1KSxzdWJ0aXRsZTE6dyhpLDE2LDEuNzUsLjE1KSxzdWJ0aXRsZTI6dyhzLDE0LDEuNTcsLjEpLGJvZHkxOncoaSwxNiwxLjUsLjE1KSxib2R5Mjp3KGksMTQsMS40MywuMTUpLGJ1dHRvbjp3KHMsMTQsMS43NSwuNCxlbSksY2FwdGlvbjp3KGksMTIsMS42NiwuNCksb3ZlcmxpbmU6dyhpLDEyLDIuNjYsMSxlbSksaW5oZXJpdDp7Zm9udEZhbWlseToiaW5oZXJpdCIsZm9udFdlaWdodDoiaW5oZXJpdCIsZm9udFNpemU6ImluaGVyaXQiLGxpbmVIZWlnaHQ6ImluaGVyaXQiLGxldHRlclNwYWNpbmc6ImluaGVyaXQifX07cmV0dXJuIHB0KHtodG1sRm9udFNpemU6bCxweFRvUmVtOnYsZm9udEZhbWlseTpuLGZvbnRTaXplOnIsZm9udFdlaWdodExpZ2h0Om8sZm9udFdlaWdodFJlZ3VsYXI6aSxmb250V2VpZ2h0TWVkaXVtOnMsZm9udFdlaWdodEJvbGQ6YSwuLi5TfSxkLHtjbG9uZTohMX0pfWNvbnN0IF9DPS4yLE5DPS4xNCxJQz0uMTI7ZnVuY3Rpb24gTWUoLi4uZSl7cmV0dXJuW2Ake2VbMF19cHggJHtlWzFdfXB4ICR7ZVsyXX1weCAke2VbM119cHggcmdiYSgwLDAsMCwke19DfSlgLGAke2VbNF19cHggJHtlWzVdfXB4ICR7ZVs2XX1weCAke2VbN119cHggcmdiYSgwLDAsMCwke05DfSlgLGAke2VbOF19cHggJHtlWzldfXB4ICR7ZVsxMF19cHggJHtlWzExXX1weCByZ2JhKDAsMCwwLCR7SUN9KWBdLmpvaW4oIiwiKX1jb25zdCBBQz1bIm5vbmUiLE1lKDAsMiwxLC0xLDAsMSwxLDAsMCwxLDMsMCksTWUoMCwzLDEsLTIsMCwyLDIsMCwwLDEsNSwwKSxNZSgwLDMsMywtMiwwLDMsNCwwLDAsMSw4LDApLE1lKDAsMiw0LC0xLDAsNCw1LDAsMCwxLDEwLDApLE1lKDAsMyw1LC0xLDAsNSw4LDAsMCwxLDE0LDApLE1lKDAsMyw1LC0xLDAsNiwxMCwwLDAsMSwxOCwwKSxNZSgwLDQsNSwtMiwwLDcsMTAsMSwwLDIsMTYsMSksTWUoMCw1LDUsLTMsMCw4LDEwLDEsMCwzLDE0LDIpLE1lKDAsNSw2LC0zLDAsOSwxMiwxLDAsMywxNiwyKSxNZSgwLDYsNiwtMywwLDEwLDE0LDEsMCw0LDE4LDMpLE1lKDAsNiw3LC00LDAsMTEsMTUsMSwwLDQsMjAsMyksTWUoMCw3LDgsLTQsMCwxMiwxNywyLDAsNSwyMiw0KSxNZSgwLDcsOCwtNCwwLDEzLDE5LDIsMCw1LDI0LDQpLE1lKDAsNyw5LC00LDAsMTQsMjEsMiwwLDUsMjYsNCksTWUoMCw4LDksLTUsMCwxNSwyMiwyLDAsNiwyOCw1KSxNZSgwLDgsMTAsLTUsMCwxNiwyNCwyLDAsNiwzMCw1KSxNZSgwLDgsMTEsLTUsMCwxNywyNiwyLDAsNiwzMiw1KSxNZSgwLDksMTEsLTUsMCwxOCwyOCwyLDAsNywzNCw2KSxNZSgwLDksMTIsLTYsMCwxOSwyOSwyLDAsNywzNiw2KSxNZSgwLDEwLDEzLC02LDAsMjAsMzEsMywwLDgsMzgsNyksTWUoMCwxMCwxMywtNiwwLDIxLDMzLDMsMCw4LDQwLDcpLE1lKDAsMTAsMTQsLTYsMCwyMiwzNSwzLDAsOCw0Miw3KSxNZSgwLDExLDE0LC03LDAsMjMsMzYsMywwLDksNDQsOCksTWUoMCwxMSwxNSwtNywwLDI0LDM4LDMsMCw5LDQ2LDgpXSx6Qz17ZWFzZUluT3V0OiJjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpIixlYXNlT3V0OiJjdWJpYy1iZXppZXIoMC4wLCAwLCAwLjIsIDEpIixlYXNlSW46ImN1YmljLWJlemllcigwLjQsIDAsIDEsIDEpIixzaGFycDoiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC42LCAxKSJ9LG95PXtzaG9ydGVzdDoxNTAsc2hvcnRlcjoyMDAsc2hvcnQ6MjUwLHN0YW5kYXJkOjMwMCxjb21wbGV4OjM3NSxlbnRlcmluZ1NjcmVlbjoyMjUsbGVhdmluZ1NjcmVlbjoxOTV9O2Z1bmN0aW9uIG5tKGUpe3JldHVybmAke01hdGgucm91bmQoZSl9bXNgfWZ1bmN0aW9uIExDKGUpe2lmKCFlKXJldHVybiAwO2NvbnN0IHQ9ZS8zNjtyZXR1cm4gTWF0aC5taW4oTWF0aC5yb3VuZCgoNCsxNSp0KiouMjUrdC81KSoxMCksM2UzKX1mdW5jdGlvbiBqQyhlKXtjb25zdCB0PXsuLi56QywuLi5lLmVhc2luZ30sbj17Li4ub3ksLi4uZS5kdXJhdGlvbn07cmV0dXJue2dldEF1dG9IZWlnaHREdXJhdGlvbjpMQyxjcmVhdGU6KG89WyJhbGwiXSxpPXt9KT0+e2NvbnN0e2R1cmF0aW9uOnM9bi5zdGFuZGFyZCxlYXNpbmc6YT10LmVhc2VJbk91dCxkZWxheTpsPTAsLi4udX09aTtyZXR1cm4oQXJyYXkuaXNBcnJheShvKT9vOltvXSkubWFwKGM9PmAke2N9ICR7dHlwZW9mIHM9PSJzdHJpbmciP3M6bm0ocyl9ICR7YX0gJHt0eXBlb2YgbD09InN0cmluZyI/bDpubShsKX1gKS5qb2luKCIsIil9LC4uLmUsZWFzaW5nOnQsZHVyYXRpb246bn19Y29uc3QgREM9e21vYmlsZVN0ZXBwZXI6MWUzLGZhYjoxMDUwLHNwZWVkRGlhbDoxMDUwLGFwcEJhcjoxMTAwLGRyYXdlcjoxMjAwLG1vZGFsOjEzMDAsc25hY2tiYXI6MTQwMCx0b29sdGlwOjE1MDB9O2Z1bmN0aW9uIEZDKGUpe3JldHVybiBPbihlKXx8dHlwZW9mIGU+InUifHx0eXBlb2YgZT09InN0cmluZyJ8fHR5cGVvZiBlPT0iYm9vbGVhbiJ8fHR5cGVvZiBlPT0ibnVtYmVyInx8QXJyYXkuaXNBcnJheShlKX1mdW5jdGlvbiBpeShlPXt9KXtjb25zdCB0PXsuLi5lfTtmdW5jdGlvbiBuKHIpe2NvbnN0IG89T2JqZWN0LmVudHJpZXMocik7Zm9yKGxldCBpPTA7aTxvLmxlbmd0aDtpKyspe2NvbnN0W3MsYV09b1tpXTshRkMoYSl8fHMuc3RhcnRzV2l0aCgidW5zdGFibGVfIik/ZGVsZXRlIHJbc106T24oYSkmJihyW3NdPXsuLi5hfSxuKHJbc10pKX19cmV0dXJuIG4odCksYGltcG9ydCB7IHVuc3RhYmxlX2NyZWF0ZUJyZWFrcG9pbnRzIGFzIGNyZWF0ZUJyZWFrcG9pbnRzLCBjcmVhdGVUcmFuc2l0aW9ucyB9IGZyb20gJ0BtdWkvbWF0ZXJpYWwvc3R5bGVzJzsKCmNvbnN0IHRoZW1lID0gJHtKU09OLnN0cmluZ2lmeSh0LG51bGwsMil9OwoKdGhlbWUuYnJlYWtwb2ludHMgPSBjcmVhdGVCcmVha3BvaW50cyh0aGVtZS5icmVha3BvaW50cyB8fCB7fSk7CnRoZW1lLnRyYW5zaXRpb25zID0gY3JlYXRlVHJhbnNpdGlvbnModGhlbWUudHJhbnNpdGlvbnMgfHwge30pOwoKZXhwb3J0IGRlZmF1bHQgdGhlbWU7YH1mdW5jdGlvbiBtYyhlPXt9LC4uLnQpe2NvbnN0e2JyZWFrcG9pbnRzOm4sbWl4aW5zOnI9e30sc3BhY2luZzpvLHBhbGV0dGU6aT17fSx0cmFuc2l0aW9uczpzPXt9LHR5cG9ncmFwaHk6YT17fSxzaGFwZTpsLC4uLnV9PWU7aWYoZS52YXJzKXRocm93IG5ldyBFcnJvcihWbigyMCkpO2NvbnN0IGM9WmQoaSksZD1LZChlKTtsZXQgbT1wdChkLHttaXhpbnM6JEMoZC5icmVha3BvaW50cyxyKSxwYWxldHRlOmMsc2hhZG93czpBQy5zbGljZSgpLHR5cG9ncmFwaHk6TUMoYyxhKSx0cmFuc2l0aW9uczpqQyhzKSx6SW5kZXg6ey4uLkRDfX0pO3JldHVybiBtPXB0KG0sdSksbT10LnJlZHVjZSgodix3KT0+cHQodix3KSxtKSxtLnVuc3RhYmxlX3N4Q29uZmlnPXsuLi53cywuLi51PT1udWxsP3ZvaWQgMDp1LnVuc3RhYmxlX3N4Q29uZmlnfSxtLnVuc3RhYmxlX3N4PWZ1bmN0aW9uKHcpe3JldHVybiBfbyh7c3g6dyx0aGVtZTp0aGlzfSl9LG0udG9SdW50aW1lU291cmNlPWl5LG19ZnVuY3Rpb24gaGMoZSl7bGV0IHQ7cmV0dXJuIGU8MT90PTUuMTE5MTYqZSoqMjp0PTQuNSpNYXRoLmxvZyhlKzEpKzIsTWF0aC5yb3VuZCh0KjEwKS8xZTN9Y29uc3QgQkM9Wy4uLkFycmF5KDI1KV0ubWFwKChlLHQpPT57aWYodD09PTApcmV0dXJuIm5vbmUiO2NvbnN0IG49aGModCk7cmV0dXJuYGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSAyNTUgMjU1IC8gJHtufSksIHJnYmEoMjU1IDI1NSAyNTUgLyAke259KSlgfSk7ZnVuY3Rpb24gc3koZSl7cmV0dXJue2lucHV0UGxhY2Vob2xkZXI6ZT09PSJkYXJrIj8uNTouNDIsaW5wdXRVbmRlcmxpbmU6ZT09PSJkYXJrIj8uNzouNDIsc3dpdGNoVHJhY2tEaXNhYmxlZDplPT09ImRhcmsiPy4yOi4xMixzd2l0Y2hUcmFjazplPT09ImRhcmsiPy4zOi4zOH19ZnVuY3Rpb24gYXkoZSl7cmV0dXJuIGU9PT0iZGFyayI/QkM6W119ZnVuY3Rpb24gV0MoZSl7Y29uc3R7cGFsZXR0ZTp0PXttb2RlOiJsaWdodCJ9LG9wYWNpdHk6bixvdmVybGF5czpyLC4uLm99PWUsaT1aZCh0KTtyZXR1cm57cGFsZXR0ZTppLG9wYWNpdHk6ey4uLnN5KGkubW9kZSksLi4ubn0sb3ZlcmxheXM6cnx8YXkoaS5tb2RlKSwuLi5vfX1mdW5jdGlvbiBVQyhlKXt2YXIgdDtyZXR1cm4hIWVbMF0ubWF0Y2goLyhjc3NWYXJQcmVmaXh8Y29sb3JTY2hlbWVTZWxlY3Rvcnxyb290U2VsZWN0b3J8dHlwb2dyYXBoeXxtaXhpbnN8YnJlYWtwb2ludHN8ZGlyZWN0aW9ufHRyYW5zaXRpb25zKS8pfHwhIWVbMF0ubWF0Y2goL3N4Q29uZmlnJC8pfHxlWzBdPT09InBhbGV0dGUiJiYhISgodD1lWzFdKSE9bnVsbCYmdC5tYXRjaCgvKG1vZGV8Y29udHJhc3RUaHJlc2hvbGR8dG9uYWxPZmZzZXQpLykpfWNvbnN0IEhDPWU9PlsuLi5bLi4uQXJyYXkoMjUpXS5tYXAoKHQsbik9PmAtLSR7ZT9gJHtlfS1gOiIifW92ZXJsYXlzLSR7bn1gKSxgLS0ke2U/YCR7ZX0tYDoiIn1wYWxldHRlLUFwcEJhci1kYXJrQmdgLGAtLSR7ZT9gJHtlfS1gOiIifXBhbGV0dGUtQXBwQmFyLWRhcmtDb2xvcmBdLFZDPWU9Pih0LG4pPT57Y29uc3Qgcj1lLnJvb3RTZWxlY3Rvcnx8Ijpyb290IixvPWUuY29sb3JTY2hlbWVTZWxlY3RvcjtsZXQgaT1vO2lmKG89PT0iY2xhc3MiJiYoaT0iLiVzIiksbz09PSJkYXRhIiYmKGk9IltkYXRhLSVzXSIpLG8hPW51bGwmJm8uc3RhcnRzV2l0aCgiZGF0YS0iKSYmIW8uaW5jbHVkZXMoIiVzIikmJihpPWBbJHtvfT0iJXMiXWApLGUuZGVmYXVsdENvbG9yU2NoZW1lPT09dCl7aWYodD09PSJkYXJrIil7Y29uc3Qgcz17fTtyZXR1cm4gSEMoZS5jc3NWYXJQcmVmaXgpLmZvckVhY2goYT0+e3NbYV09blthXSxkZWxldGUgblthXX0pLGk9PT0ibWVkaWEiP3tbcl06biwiQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykiOntbcl06c319Omk/e1tpLnJlcGxhY2UoIiVzIix0KV06cyxbYCR7cn0sICR7aS5yZXBsYWNlKCIlcyIsdCl9YF06bn06e1tyXTp7Li4ubiwuLi5zfX19aWYoaSYmaSE9PSJtZWRpYSIpcmV0dXJuYCR7cn0sICR7aS5yZXBsYWNlKCIlcyIsU3RyaW5nKHQpKX1gfWVsc2UgaWYodCl7aWYoaT09PSJtZWRpYSIpcmV0dXJue1tgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogJHtTdHJpbmcodCl9KWBdOntbcl06bn19O2lmKGkpcmV0dXJuIGkucmVwbGFjZSgiJXMiLFN0cmluZyh0KSl9cmV0dXJuIHJ9O2Z1bmN0aW9uIEtDKGUsdCl7dC5mb3JFYWNoKG49PntlW25dfHwoZVtuXT17fSl9KX1mdW5jdGlvbiB6KGUsdCxuKXshZVt0XSYmbiYmKGVbdF09bil9ZnVuY3Rpb24gdmkoZSl7cmV0dXJuIWV8fCFlLnN0YXJ0c1dpdGgoImhzbCIpP2U6UWcoZSl9ZnVuY3Rpb24gRG4oZSx0KXtgJHt0fUNoYW5uZWxgaW4gZXx8KGVbYCR7dH1DaGFubmVsYF09eWkodmkoZVt0XSksYE1VSTogQ2FuJ3QgY3JlYXRlIFxgcGFsZXR0ZS4ke3R9Q2hhbm5lbFxgIGJlY2F1c2UgXGBwYWxldHRlLiR7dH1cYCBpcyBub3Qgb25lIG9mIHRoZXNlIGZvcm1hdHM6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKCksIGNvbG9yKCkuClRvIHN1cHByZXNzIHRoaXMgd2FybmluZywgeW91IG5lZWQgdG8gZXhwbGljaXRseSBwcm92aWRlIHRoZSBcYHBhbGV0dGUuJHt0fUNoYW5uZWxcYCBhcyBhIHN0cmluZyAoaW4gcmdiIGZvcm1hdCwgZm9yIGV4YW1wbGUgIjEyIDEyIDEyIikgb3IgdW5kZWZpbmVkIGlmIHlvdSB3YW50IHRvIHJlbW92ZSB0aGUgY2hhbm5lbCB0b2tlbi5gKSl9ZnVuY3Rpb24gWUMoZSl7cmV0dXJuIHR5cGVvZiBlPT0ibnVtYmVyIj9gJHtlfXB4YDp0eXBlb2YgZT09InN0cmluZyJ8fHR5cGVvZiBlPT0iZnVuY3Rpb24ifHxBcnJheS5pc0FycmF5KGUpP2U6IjhweCJ9Y29uc3Qga249ZT0+e3RyeXtyZXR1cm4gZSgpfWNhdGNoe319LEdDPShlPSJtdWkiKT0+Z0MoZSk7ZnVuY3Rpb24ga3UoZSx0LG4scil7aWYoIXQpcmV0dXJuO3Q9dD09PSEwP3t9OnQ7Y29uc3Qgbz1yPT09ImRhcmsiPyJkYXJrIjoibGlnaHQiO2lmKCFuKXtlW3JdPVdDKHsuLi50LHBhbGV0dGU6e21vZGU6bywuLi50PT1udWxsP3ZvaWQgMDp0LnBhbGV0dGV9fSk7cmV0dXJufWNvbnN0e3BhbGV0dGU6aSwuLi5zfT1tYyh7Li4ubixwYWxldHRlOnttb2RlOm8sLi4udD09bnVsbD92b2lkIDA6dC5wYWxldHRlfX0pO3JldHVybiBlW3JdPXsuLi50LHBhbGV0dGU6aSxvcGFjaXR5OnsuLi5zeShvKSwuLi50PT1udWxsP3ZvaWQgMDp0Lm9wYWNpdHl9LG92ZXJsYXlzOih0PT1udWxsP3ZvaWQgMDp0Lm92ZXJsYXlzKXx8YXkobyl9LHN9ZnVuY3Rpb24gUUMoZT17fSwuLi50KXtjb25zdHtjb2xvclNjaGVtZXM6bj17bGlnaHQ6ITB9LGRlZmF1bHRDb2xvclNjaGVtZTpyLGRpc2FibGVDc3NDb2xvclNjaGVtZTpvPSExLGNzc1ZhclByZWZpeDppPSJtdWkiLHNob3VsZFNraXBHZW5lcmF0aW5nVmFyOnM9VUMsY29sb3JTY2hlbWVTZWxlY3RvcjphPW4ubGlnaHQmJm4uZGFyaz8ibWVkaWEiOnZvaWQgMCxyb290U2VsZWN0b3I6bD0iOnJvb3QiLC4uLnV9PWUsYz1PYmplY3Qua2V5cyhuKVswXSxkPXJ8fChuLmxpZ2h0JiZjIT09ImxpZ2h0Ij8ibGlnaHQiOmMpLG09R0MoaSkse1tkXTp2LGxpZ2h0OncsZGFyazpTLC4uLnh9PW4saD17Li4ueH07bGV0IGc9djtpZigoZD09PSJkYXJrIiYmISgiZGFyayJpbiBuKXx8ZD09PSJsaWdodCImJiEoImxpZ2h0ImluIG4pKSYmKGc9ITApLCFnKXRocm93IG5ldyBFcnJvcihWbigyMSxkKSk7Y29uc3QgZj1rdShoLGcsdSxkKTt3JiYhaC5saWdodCYma3UoaCx3LHZvaWQgMCwibGlnaHQiKSxTJiYhaC5kYXJrJiZrdShoLFMsdm9pZCAwLCJkYXJrIik7bGV0IHk9e2RlZmF1bHRDb2xvclNjaGVtZTpkLC4uLmYsY3NzVmFyUHJlZml4OmksY29sb3JTY2hlbWVTZWxlY3RvcjphLHJvb3RTZWxlY3RvcjpsLGdldENzc1ZhcjptLGNvbG9yU2NoZW1lczpoLGZvbnQ6ey4uLlBDKGYudHlwb2dyYXBoeSksLi4uZi5mb250fSxzcGFjaW5nOllDKHUuc3BhY2luZyl9O09iamVjdC5rZXlzKHkuY29sb3JTY2hlbWVzKS5mb3JFYWNoKEk9Pntjb25zdCBwPXkuY29sb3JTY2hlbWVzW0ldLnBhbGV0dGUsJD1MPT57Y29uc3Qgaj1MLnNwbGl0KCItIiksTj1qWzFdLE89alsyXTtyZXR1cm4gbShMLHBbTl1bT10pfTtpZihwLm1vZGU9PT0ibGlnaHQiJiYoeihwLmNvbW1vbiwiYmFja2dyb3VuZCIsIiNmZmYiKSx6KHAuY29tbW9uLCJvbkJhY2tncm91bmQiLCIjMDAwIikpLHAubW9kZT09PSJkYXJrIiYmKHoocC5jb21tb24sImJhY2tncm91bmQiLCIjMDAwIikseihwLmNvbW1vbiwib25CYWNrZ3JvdW5kIiwiI2ZmZiIpKSxLQyhwLFsiQWxlcnQiLCJBcHBCYXIiLCJBdmF0YXIiLCJCdXR0b24iLCJDaGlwIiwiRmlsbGVkSW5wdXQiLCJMaW5lYXJQcm9ncmVzcyIsIlNrZWxldG9uIiwiU2xpZGVyIiwiU25hY2tiYXJDb250ZW50IiwiU3BlZWREaWFsQWN0aW9uIiwiU3RlcENvbm5lY3RvciIsIlN0ZXBDb250ZW50IiwiU3dpdGNoIiwiVGFibGVDZWxsIiwiVG9vbHRpcCJdKSxwLm1vZGU9PT0ibGlnaHQiKXt6KHAuQWxlcnQsImVycm9yQ29sb3IiLEVlKHAuZXJyb3IubGlnaHQsLjYpKSx6KHAuQWxlcnQsImluZm9Db2xvciIsRWUocC5pbmZvLmxpZ2h0LC42KSkseihwLkFsZXJ0LCJzdWNjZXNzQ29sb3IiLEVlKHAuc3VjY2Vzcy5saWdodCwuNikpLHoocC5BbGVydCwid2FybmluZ0NvbG9yIixFZShwLndhcm5pbmcubGlnaHQsLjYpKSx6KHAuQWxlcnQsImVycm9yRmlsbGVkQmciLCQoInBhbGV0dGUtZXJyb3ItbWFpbiIpKSx6KHAuQWxlcnQsImluZm9GaWxsZWRCZyIsJCgicGFsZXR0ZS1pbmZvLW1haW4iKSkseihwLkFsZXJ0LCJzdWNjZXNzRmlsbGVkQmciLCQoInBhbGV0dGUtc3VjY2Vzcy1tYWluIikpLHoocC5BbGVydCwid2FybmluZ0ZpbGxlZEJnIiwkKCJwYWxldHRlLXdhcm5pbmctbWFpbiIpKSx6KHAuQWxlcnQsImVycm9yRmlsbGVkQ29sb3IiLGtuKCgpPT5wLmdldENvbnRyYXN0VGV4dChwLmVycm9yLm1haW4pKSkseihwLkFsZXJ0LCJpbmZvRmlsbGVkQ29sb3IiLGtuKCgpPT5wLmdldENvbnRyYXN0VGV4dChwLmluZm8ubWFpbikpKSx6KHAuQWxlcnQsInN1Y2Nlc3NGaWxsZWRDb2xvciIsa24oKCk9PnAuZ2V0Q29udHJhc3RUZXh0KHAuc3VjY2Vzcy5tYWluKSkpLHoocC5BbGVydCwid2FybmluZ0ZpbGxlZENvbG9yIixrbigoKT0+cC5nZXRDb250cmFzdFRleHQocC53YXJuaW5nLm1haW4pKSkseihwLkFsZXJ0LCJlcnJvclN0YW5kYXJkQmciLFJlKHAuZXJyb3IubGlnaHQsLjkpKSx6KHAuQWxlcnQsImluZm9TdGFuZGFyZEJnIixSZShwLmluZm8ubGlnaHQsLjkpKSx6KHAuQWxlcnQsInN1Y2Nlc3NTdGFuZGFyZEJnIixSZShwLnN1Y2Nlc3MubGlnaHQsLjkpKSx6KHAuQWxlcnQsIndhcm5pbmdTdGFuZGFyZEJnIixSZShwLndhcm5pbmcubGlnaHQsLjkpKSx6KHAuQWxlcnQsImVycm9ySWNvbkNvbG9yIiwkKCJwYWxldHRlLWVycm9yLW1haW4iKSkseihwLkFsZXJ0LCJpbmZvSWNvbkNvbG9yIiwkKCJwYWxldHRlLWluZm8tbWFpbiIpKSx6KHAuQWxlcnQsInN1Y2Nlc3NJY29uQ29sb3IiLCQoInBhbGV0dGUtc3VjY2Vzcy1tYWluIikpLHoocC5BbGVydCwid2FybmluZ0ljb25Db2xvciIsJCgicGFsZXR0ZS13YXJuaW5nLW1haW4iKSkseihwLkFwcEJhciwiZGVmYXVsdEJnIiwkKCJwYWxldHRlLWdyZXktMTAwIikpLHoocC5BdmF0YXIsImRlZmF1bHRCZyIsJCgicGFsZXR0ZS1ncmV5LTQwMCIpKSx6KHAuQnV0dG9uLCJpbmhlcml0Q29udGFpbmVkQmciLCQoInBhbGV0dGUtZ3JleS0zMDAiKSkseihwLkJ1dHRvbiwiaW5oZXJpdENvbnRhaW5lZEhvdmVyQmciLCQoInBhbGV0dGUtZ3JleS1BMTAwIikpLHoocC5DaGlwLCJkZWZhdWx0Qm9yZGVyIiwkKCJwYWxldHRlLWdyZXktNDAwIikpLHoocC5DaGlwLCJkZWZhdWx0QXZhdGFyQ29sb3IiLCQoInBhbGV0dGUtZ3JleS03MDAiKSkseihwLkNoaXAsImRlZmF1bHRJY29uQ29sb3IiLCQoInBhbGV0dGUtZ3JleS03MDAiKSkseihwLkZpbGxlZElucHV0LCJiZyIsInJnYmEoMCwgMCwgMCwgMC4wNikiKSx6KHAuRmlsbGVkSW5wdXQsImhvdmVyQmciLCJyZ2JhKDAsIDAsIDAsIDAuMDkpIikseihwLkZpbGxlZElucHV0LCJkaXNhYmxlZEJnIiwicmdiYSgwLCAwLCAwLCAwLjEyKSIpLHoocC5MaW5lYXJQcm9ncmVzcywicHJpbWFyeUJnIixSZShwLnByaW1hcnkubWFpbiwuNjIpKSx6KHAuTGluZWFyUHJvZ3Jlc3MsInNlY29uZGFyeUJnIixSZShwLnNlY29uZGFyeS5tYWluLC42MikpLHoocC5MaW5lYXJQcm9ncmVzcywiZXJyb3JCZyIsUmUocC5lcnJvci5tYWluLC42MikpLHoocC5MaW5lYXJQcm9ncmVzcywiaW5mb0JnIixSZShwLmluZm8ubWFpbiwuNjIpKSx6KHAuTGluZWFyUHJvZ3Jlc3MsInN1Y2Nlc3NCZyIsUmUocC5zdWNjZXNzLm1haW4sLjYyKSkseihwLkxpbmVhclByb2dyZXNzLCJ3YXJuaW5nQmciLFJlKHAud2FybmluZy5tYWluLC42MikpLHoocC5Ta2VsZXRvbiwiYmciLGByZ2JhKCR7JCgicGFsZXR0ZS10ZXh0LXByaW1hcnlDaGFubmVsIil9IC8gMC4xMSlgKSx6KHAuU2xpZGVyLCJwcmltYXJ5VHJhY2siLFJlKHAucHJpbWFyeS5tYWluLC42MikpLHoocC5TbGlkZXIsInNlY29uZGFyeVRyYWNrIixSZShwLnNlY29uZGFyeS5tYWluLC42MikpLHoocC5TbGlkZXIsImVycm9yVHJhY2siLFJlKHAuZXJyb3IubWFpbiwuNjIpKSx6KHAuU2xpZGVyLCJpbmZvVHJhY2siLFJlKHAuaW5mby5tYWluLC42MikpLHoocC5TbGlkZXIsInN1Y2Nlc3NUcmFjayIsUmUocC5zdWNjZXNzLm1haW4sLjYyKSkseihwLlNsaWRlciwid2FybmluZ1RyYWNrIixSZShwLndhcm5pbmcubWFpbiwuNjIpKTtjb25zdCBMPU1zKHAuYmFja2dyb3VuZC5kZWZhdWx0LC44KTt6KHAuU25hY2tiYXJDb250ZW50LCJiZyIsTCkseihwLlNuYWNrYmFyQ29udGVudCwiY29sb3IiLGtuKCgpPT5wLmdldENvbnRyYXN0VGV4dChMKSkpLHoocC5TcGVlZERpYWxBY3Rpb24sImZhYkhvdmVyQmciLE1zKHAuYmFja2dyb3VuZC5wYXBlciwuMTUpKSx6KHAuU3RlcENvbm5lY3RvciwiYm9yZGVyIiwkKCJwYWxldHRlLWdyZXktNDAwIikpLHoocC5TdGVwQ29udGVudCwiYm9yZGVyIiwkKCJwYWxldHRlLWdyZXktNDAwIikpLHoocC5Td2l0Y2gsImRlZmF1bHRDb2xvciIsJCgicGFsZXR0ZS1jb21tb24td2hpdGUiKSkseihwLlN3aXRjaCwiZGVmYXVsdERpc2FibGVkQ29sb3IiLCQoInBhbGV0dGUtZ3JleS0xMDAiKSkseihwLlN3aXRjaCwicHJpbWFyeURpc2FibGVkQ29sb3IiLFJlKHAucHJpbWFyeS5tYWluLC42MikpLHoocC5Td2l0Y2gsInNlY29uZGFyeURpc2FibGVkQ29sb3IiLFJlKHAuc2Vjb25kYXJ5Lm1haW4sLjYyKSkseihwLlN3aXRjaCwiZXJyb3JEaXNhYmxlZENvbG9yIixSZShwLmVycm9yLm1haW4sLjYyKSkseihwLlN3aXRjaCwiaW5mb0Rpc2FibGVkQ29sb3IiLFJlKHAuaW5mby5tYWluLC42MikpLHoocC5Td2l0Y2gsInN1Y2Nlc3NEaXNhYmxlZENvbG9yIixSZShwLnN1Y2Nlc3MubWFpbiwuNjIpKSx6KHAuU3dpdGNoLCJ3YXJuaW5nRGlzYWJsZWRDb2xvciIsUmUocC53YXJuaW5nLm1haW4sLjYyKSkseihwLlRhYmxlQ2VsbCwiYm9yZGVyIixSZShPcyhwLmRpdmlkZXIsMSksLjg4KSkseihwLlRvb2x0aXAsImJnIixPcyhwLmdyZXlbNzAwXSwuOTIpKX1pZihwLm1vZGU9PT0iZGFyayIpe3oocC5BbGVydCwiZXJyb3JDb2xvciIsUmUocC5lcnJvci5saWdodCwuNikpLHoocC5BbGVydCwiaW5mb0NvbG9yIixSZShwLmluZm8ubGlnaHQsLjYpKSx6KHAuQWxlcnQsInN1Y2Nlc3NDb2xvciIsUmUocC5zdWNjZXNzLmxpZ2h0LC42KSkseihwLkFsZXJ0LCJ3YXJuaW5nQ29sb3IiLFJlKHAud2FybmluZy5saWdodCwuNikpLHoocC5BbGVydCwiZXJyb3JGaWxsZWRCZyIsJCgicGFsZXR0ZS1lcnJvci1kYXJrIikpLHoocC5BbGVydCwiaW5mb0ZpbGxlZEJnIiwkKCJwYWxldHRlLWluZm8tZGFyayIpKSx6KHAuQWxlcnQsInN1Y2Nlc3NGaWxsZWRCZyIsJCgicGFsZXR0ZS1zdWNjZXNzLWRhcmsiKSkseihwLkFsZXJ0LCJ3YXJuaW5nRmlsbGVkQmciLCQoInBhbGV0dGUtd2FybmluZy1kYXJrIikpLHoocC5BbGVydCwiZXJyb3JGaWxsZWRDb2xvciIsa24oKCk9PnAuZ2V0Q29udHJhc3RUZXh0KHAuZXJyb3IuZGFyaykpKSx6KHAuQWxlcnQsImluZm9GaWxsZWRDb2xvciIsa24oKCk9PnAuZ2V0Q29udHJhc3RUZXh0KHAuaW5mby5kYXJrKSkpLHoocC5BbGVydCwic3VjY2Vzc0ZpbGxlZENvbG9yIixrbigoKT0+cC5nZXRDb250cmFzdFRleHQocC5zdWNjZXNzLmRhcmspKSkseihwLkFsZXJ0LCJ3YXJuaW5nRmlsbGVkQ29sb3IiLGtuKCgpPT5wLmdldENvbnRyYXN0VGV4dChwLndhcm5pbmcuZGFyaykpKSx6KHAuQWxlcnQsImVycm9yU3RhbmRhcmRCZyIsRWUocC5lcnJvci5saWdodCwuOSkpLHoocC5BbGVydCwiaW5mb1N0YW5kYXJkQmciLEVlKHAuaW5mby5saWdodCwuOSkpLHoocC5BbGVydCwic3VjY2Vzc1N0YW5kYXJkQmciLEVlKHAuc3VjY2Vzcy5saWdodCwuOSkpLHoocC5BbGVydCwid2FybmluZ1N0YW5kYXJkQmciLEVlKHAud2FybmluZy5saWdodCwuOSkpLHoocC5BbGVydCwiZXJyb3JJY29uQ29sb3IiLCQoInBhbGV0dGUtZXJyb3ItbWFpbiIpKSx6KHAuQWxlcnQsImluZm9JY29uQ29sb3IiLCQoInBhbGV0dGUtaW5mby1tYWluIikpLHoocC5BbGVydCwic3VjY2Vzc0ljb25Db2xvciIsJCgicGFsZXR0ZS1zdWNjZXNzLW1haW4iKSkseihwLkFsZXJ0LCJ3YXJuaW5nSWNvbkNvbG9yIiwkKCJwYWxldHRlLXdhcm5pbmctbWFpbiIpKSx6KHAuQXBwQmFyLCJkZWZhdWx0QmciLCQoInBhbGV0dGUtZ3JleS05MDAiKSkseihwLkFwcEJhciwiZGFya0JnIiwkKCJwYWxldHRlLWJhY2tncm91bmQtcGFwZXIiKSkseihwLkFwcEJhciwiZGFya0NvbG9yIiwkKCJwYWxldHRlLXRleHQtcHJpbWFyeSIpKSx6KHAuQXZhdGFyLCJkZWZhdWx0QmciLCQoInBhbGV0dGUtZ3JleS02MDAiKSkseihwLkJ1dHRvbiwiaW5oZXJpdENvbnRhaW5lZEJnIiwkKCJwYWxldHRlLWdyZXktODAwIikpLHoocC5CdXR0b24sImluaGVyaXRDb250YWluZWRIb3ZlckJnIiwkKCJwYWxldHRlLWdyZXktNzAwIikpLHoocC5DaGlwLCJkZWZhdWx0Qm9yZGVyIiwkKCJwYWxldHRlLWdyZXktNzAwIikpLHoocC5DaGlwLCJkZWZhdWx0QXZhdGFyQ29sb3IiLCQoInBhbGV0dGUtZ3JleS0zMDAiKSkseihwLkNoaXAsImRlZmF1bHRJY29uQ29sb3IiLCQoInBhbGV0dGUtZ3JleS0zMDAiKSkseihwLkZpbGxlZElucHV0LCJiZyIsInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOSkiKSx6KHAuRmlsbGVkSW5wdXQsImhvdmVyQmciLCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTMpIikseihwLkZpbGxlZElucHV0LCJkaXNhYmxlZEJnIiwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKSIpLHoocC5MaW5lYXJQcm9ncmVzcywicHJpbWFyeUJnIixFZShwLnByaW1hcnkubWFpbiwuNSkpLHoocC5MaW5lYXJQcm9ncmVzcywic2Vjb25kYXJ5QmciLEVlKHAuc2Vjb25kYXJ5Lm1haW4sLjUpKSx6KHAuTGluZWFyUHJvZ3Jlc3MsImVycm9yQmciLEVlKHAuZXJyb3IubWFpbiwuNSkpLHoocC5MaW5lYXJQcm9ncmVzcywiaW5mb0JnIixFZShwLmluZm8ubWFpbiwuNSkpLHoocC5MaW5lYXJQcm9ncmVzcywic3VjY2Vzc0JnIixFZShwLnN1Y2Nlc3MubWFpbiwuNSkpLHoocC5MaW5lYXJQcm9ncmVzcywid2FybmluZ0JnIixFZShwLndhcm5pbmcubWFpbiwuNSkpLHoocC5Ta2VsZXRvbiwiYmciLGByZ2JhKCR7JCgicGFsZXR0ZS10ZXh0LXByaW1hcnlDaGFubmVsIil9IC8gMC4xMylgKSx6KHAuU2xpZGVyLCJwcmltYXJ5VHJhY2siLEVlKHAucHJpbWFyeS5tYWluLC41KSkseihwLlNsaWRlciwic2Vjb25kYXJ5VHJhY2siLEVlKHAuc2Vjb25kYXJ5Lm1haW4sLjUpKSx6KHAuU2xpZGVyLCJlcnJvclRyYWNrIixFZShwLmVycm9yLm1haW4sLjUpKSx6KHAuU2xpZGVyLCJpbmZvVHJhY2siLEVlKHAuaW5mby5tYWluLC41KSkseihwLlNsaWRlciwic3VjY2Vzc1RyYWNrIixFZShwLnN1Y2Nlc3MubWFpbiwuNSkpLHoocC5TbGlkZXIsIndhcm5pbmdUcmFjayIsRWUocC53YXJuaW5nLm1haW4sLjUpKTtjb25zdCBMPU1zKHAuYmFja2dyb3VuZC5kZWZhdWx0LC45OCk7eihwLlNuYWNrYmFyQ29udGVudCwiYmciLEwpLHoocC5TbmFja2JhckNvbnRlbnQsImNvbG9yIixrbigoKT0+cC5nZXRDb250cmFzdFRleHQoTCkpKSx6KHAuU3BlZWREaWFsQWN0aW9uLCJmYWJIb3ZlckJnIixNcyhwLmJhY2tncm91bmQucGFwZXIsLjE1KSkseihwLlN0ZXBDb25uZWN0b3IsImJvcmRlciIsJCgicGFsZXR0ZS1ncmV5LTYwMCIpKSx6KHAuU3RlcENvbnRlbnQsImJvcmRlciIsJCgicGFsZXR0ZS1ncmV5LTYwMCIpKSx6KHAuU3dpdGNoLCJkZWZhdWx0Q29sb3IiLCQoInBhbGV0dGUtZ3JleS0zMDAiKSkseihwLlN3aXRjaCwiZGVmYXVsdERpc2FibGVkQ29sb3IiLCQoInBhbGV0dGUtZ3JleS02MDAiKSkseihwLlN3aXRjaCwicHJpbWFyeURpc2FibGVkQ29sb3IiLEVlKHAucHJpbWFyeS5tYWluLC41NSkpLHoocC5Td2l0Y2gsInNlY29uZGFyeURpc2FibGVkQ29sb3IiLEVlKHAuc2Vjb25kYXJ5Lm1haW4sLjU1KSkseihwLlN3aXRjaCwiZXJyb3JEaXNhYmxlZENvbG9yIixFZShwLmVycm9yLm1haW4sLjU1KSkseihwLlN3aXRjaCwiaW5mb0Rpc2FibGVkQ29sb3IiLEVlKHAuaW5mby5tYWluLC41NSkpLHoocC5Td2l0Y2gsInN1Y2Nlc3NEaXNhYmxlZENvbG9yIixFZShwLnN1Y2Nlc3MubWFpbiwuNTUpKSx6KHAuU3dpdGNoLCJ3YXJuaW5nRGlzYWJsZWRDb2xvciIsRWUocC53YXJuaW5nLm1haW4sLjU1KSkseihwLlRhYmxlQ2VsbCwiYm9yZGVyIixFZShPcyhwLmRpdmlkZXIsMSksLjY4KSkseihwLlRvb2x0aXAsImJnIixPcyhwLmdyZXlbNzAwXSwuOTIpKX1EbihwLmJhY2tncm91bmQsImRlZmF1bHQiKSxEbihwLmJhY2tncm91bmQsInBhcGVyIiksRG4ocC5jb21tb24sImJhY2tncm91bmQiKSxEbihwLmNvbW1vbiwib25CYWNrZ3JvdW5kIiksRG4ocCwiZGl2aWRlciIpLE9iamVjdC5rZXlzKHApLmZvckVhY2goTD0+e2NvbnN0IGo9cFtMXTtqJiZ0eXBlb2Ygaj09Im9iamVjdCImJihqLm1haW4mJnoocFtMXSwibWFpbkNoYW5uZWwiLHlpKHZpKGoubWFpbikpKSxqLmxpZ2h0JiZ6KHBbTF0sImxpZ2h0Q2hhbm5lbCIseWkodmkoai5saWdodCkpKSxqLmRhcmsmJnoocFtMXSwiZGFya0NoYW5uZWwiLHlpKHZpKGouZGFyaykpKSxqLmNvbnRyYXN0VGV4dCYmeihwW0xdLCJjb250cmFzdFRleHRDaGFubmVsIix5aSh2aShqLmNvbnRyYXN0VGV4dCkpKSxMPT09InRleHQiJiYoRG4ocFtMXSwicHJpbWFyeSIpLERuKHBbTF0sInNlY29uZGFyeSIpKSxMPT09ImFjdGlvbiImJihqLmFjdGl2ZSYmRG4ocFtMXSwiYWN0aXZlIiksai5zZWxlY3RlZCYmRG4ocFtMXSwic2VsZWN0ZWQiKSkpfSl9KSx5PXQucmVkdWNlKChJLHApPT5wdChJLHApLHkpO2NvbnN0IGI9e3ByZWZpeDppLGRpc2FibGVDc3NDb2xvclNjaGVtZTpvLHNob3VsZFNraXBHZW5lcmF0aW5nVmFyOnMsZ2V0U2VsZWN0b3I6VkMoeSl9LHt2YXJzOkUsZ2VuZXJhdGVUaGVtZVZhcnM6UixnZW5lcmF0ZVN0eWxlU2hlZXRzOlB9PXdDKHksYik7cmV0dXJuIHkudmFycz1FLE9iamVjdC5lbnRyaWVzKHkuY29sb3JTY2hlbWVzW3kuZGVmYXVsdENvbG9yU2NoZW1lXSkuZm9yRWFjaCgoW0kscF0pPT57eVtJXT1wfSkseS5nZW5lcmF0ZVRoZW1lVmFycz1SLHkuZ2VuZXJhdGVTdHlsZVNoZWV0cz1QLHkuZ2VuZXJhdGVTcGFjaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIFVnKHUuc3BhY2luZyxIZCh0aGlzKSl9LHkuZ2V0Q29sb3JTY2hlbWVTZWxlY3Rvcj1TQyhhKSx5LnNwYWNpbmc9eS5nZW5lcmF0ZVNwYWNpbmcoKSx5LnNob3VsZFNraXBHZW5lcmF0aW5nVmFyPXMseS51bnN0YWJsZV9zeENvbmZpZz17Li4ud3MsLi4udT09bnVsbD92b2lkIDA6dS51bnN0YWJsZV9zeENvbmZpZ30seS51bnN0YWJsZV9zeD1mdW5jdGlvbihwKXtyZXR1cm4gX28oe3N4OnAsdGhlbWU6dGhpc30pfSx5LnRvUnVudGltZVNvdXJjZT1peSx5fWZ1bmN0aW9uIHJtKGUsdCxuKXtlLmNvbG9yU2NoZW1lcyYmbiYmKGUuY29sb3JTY2hlbWVzW3RdPXsuLi5uIT09ITAmJm4scGFsZXR0ZTpaZCh7Li4ubj09PSEwP3t9Om4ucGFsZXR0ZSxtb2RlOnR9KX0pfWZ1bmN0aW9uIFhDKGU9e30sLi4udCl7Y29uc3R7cGFsZXR0ZTpuLGNzc1ZhcmlhYmxlczpyPSExLGNvbG9yU2NoZW1lczpvPW4/dm9pZCAwOntsaWdodDohMH0sZGVmYXVsdENvbG9yU2NoZW1lOmk9bj09bnVsbD92b2lkIDA6bi5tb2RlLC4uLnN9PWUsYT1pfHwibGlnaHQiLGw9bz09bnVsbD92b2lkIDA6b1thXSx1PXsuLi5vLC4uLm4/e1thXTp7Li4udHlwZW9mIGwhPSJib29sZWFuIiYmbCxwYWxldHRlOm59fTp2b2lkIDB9O2lmKHI9PT0hMSl7aWYoISgiY29sb3JTY2hlbWVzImluIGUpKXJldHVybiBtYyhlLC4uLnQpO2xldCBjPW47InBhbGV0dGUiaW4gZXx8dVthXSYmKHVbYV0hPT0hMD9jPXVbYV0ucGFsZXR0ZTphPT09ImRhcmsiJiYoYz17bW9kZToiZGFyayJ9KSk7Y29uc3QgZD1tYyh7Li4uZSxwYWxldHRlOmN9LC4uLnQpO3JldHVybiBkLmRlZmF1bHRDb2xvclNjaGVtZT1hLGQuY29sb3JTY2hlbWVzPXUsZC5wYWxldHRlLm1vZGU9PT0ibGlnaHQiJiYoZC5jb2xvclNjaGVtZXMubGlnaHQ9ey4uLnUubGlnaHQhPT0hMCYmdS5saWdodCxwYWxldHRlOmQucGFsZXR0ZX0scm0oZCwiZGFyayIsdS5kYXJrKSksZC5wYWxldHRlLm1vZGU9PT0iZGFyayImJihkLmNvbG9yU2NoZW1lcy5kYXJrPXsuLi51LmRhcmshPT0hMCYmdS5kYXJrLHBhbGV0dGU6ZC5wYWxldHRlfSxybShkLCJsaWdodCIsdS5saWdodCkpLGR9cmV0dXJuIW4mJiEoImxpZ2h0ImluIHUpJiZhPT09ImxpZ2h0IiYmKHUubGlnaHQ9ITApLFFDKHsuLi5zLGNvbG9yU2NoZW1lczp1LGRlZmF1bHRDb2xvclNjaGVtZTphLC4uLnR5cGVvZiByIT0iYm9vbGVhbiImJnJ9LC4uLnQpfWNvbnN0IEpkPVhDKCk7ZnVuY3Rpb24gU3MoKXtjb25zdCBlPUhnKEpkKTtyZXR1cm4gZVtOZF18fGV9ZnVuY3Rpb24gbHkoZSl7cmV0dXJuIGUhPT0ib3duZXJTdGF0ZSImJmUhPT0idGhlbWUiJiZlIT09InN4IiYmZSE9PSJhcyJ9Y29uc3QgU249ZT0+bHkoZSkmJmUhPT0iY2xhc3NlcyIsRz1YeCh7dGhlbWVJZDpOZCxkZWZhdWx0VGhlbWU6SmQscm9vdFNob3VsZEZvcndhcmRQcm9wOlNufSk7ZnVuY3Rpb24gcUMoZSl7cmV0dXJuIGsuanN4KER4LHsuLi5lLGRlZmF1bHRUaGVtZTpKZCx0aGVtZUlkOk5kfSl9ZnVuY3Rpb24gWkMoZSl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiBrLmpzeChxQyx7c3R5bGVzOnR5cGVvZiBlPT0iZnVuY3Rpb24iP3I9PmUoe3RoZW1lOnIsLi4ubn0pOmV9KX19ZnVuY3Rpb24gSkMoKXtyZXR1cm4gQnh9Y29uc3QgeWU9aEM7ZnVuY3Rpb24gbWUoZSl7cmV0dXJuIG1DKGUpfWZ1bmN0aW9uIGViKGUpe3JldHVybiBjZSgiTXVpU3ZnSWNvbiIsZSl9ZGUoIk11aVN2Z0ljb24iLFsicm9vdCIsImNvbG9yUHJpbWFyeSIsImNvbG9yU2Vjb25kYXJ5IiwiY29sb3JBY3Rpb24iLCJjb2xvckVycm9yIiwiY29sb3JEaXNhYmxlZCIsImZvbnRTaXplSW5oZXJpdCIsImZvbnRTaXplU21hbGwiLCJmb250U2l6ZU1lZGl1bSIsImZvbnRTaXplTGFyZ2UiXSk7Y29uc3QgdGI9ZT0+e2NvbnN0e2NvbG9yOnQsZm9udFNpemU6bixjbGFzc2VzOnJ9PWUsbz17cm9vdDpbInJvb3QiLHQhPT0iaW5oZXJpdCImJmBjb2xvciR7bmUodCl9YCxgZm9udFNpemUke25lKG4pfWBdfTtyZXR1cm4gcGUobyxlYixyKX0sbmI9Rygic3ZnIix7bmFtZToiTXVpU3ZnSWNvbiIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3Qucm9vdCxuLmNvbG9yIT09ImluaGVyaXQiJiZ0W2Bjb2xvciR7bmUobi5jb2xvcil9YF0sdFtgZm9udFNpemUke25lKG4uZm9udFNpemUpfWBdXX19KSh5ZSgoe3RoZW1lOmV9KT0+e3ZhciB0LG4scixvLGkscyxhLGwsdSxjLGQsbSx2LHc7cmV0dXJue3VzZXJTZWxlY3Q6Im5vbmUiLHdpZHRoOiIxZW0iLGhlaWdodDoiMWVtIixkaXNwbGF5OiJpbmxpbmUtYmxvY2siLGZsZXhTaHJpbms6MCx0cmFuc2l0aW9uOihvPSh0PWUudHJhbnNpdGlvbnMpPT1udWxsP3ZvaWQgMDp0LmNyZWF0ZSk9PW51bGw/dm9pZCAwOm8uY2FsbCh0LCJmaWxsIix7ZHVyYXRpb246KHI9KG49KGUudmFycz8/ZSkudHJhbnNpdGlvbnMpPT1udWxsP3ZvaWQgMDpuLmR1cmF0aW9uKT09bnVsbD92b2lkIDA6ci5zaG9ydGVyfSksdmFyaWFudHM6W3twcm9wczpTPT4hUy5oYXNTdmdBc0NoaWxkLHN0eWxlOntmaWxsOiJjdXJyZW50Q29sb3IifX0se3Byb3BzOntmb250U2l6ZToiaW5oZXJpdCJ9LHN0eWxlOntmb250U2l6ZToiaW5oZXJpdCJ9fSx7cHJvcHM6e2ZvbnRTaXplOiJzbWFsbCJ9LHN0eWxlOntmb250U2l6ZTooKHM9KGk9ZS50eXBvZ3JhcGh5KT09bnVsbD92b2lkIDA6aS5weFRvUmVtKT09bnVsbD92b2lkIDA6cy5jYWxsKGksMjApKXx8IjEuMjVyZW0ifX0se3Byb3BzOntmb250U2l6ZToibWVkaXVtIn0sc3R5bGU6e2ZvbnRTaXplOigobD0oYT1lLnR5cG9ncmFwaHkpPT1udWxsP3ZvaWQgMDphLnB4VG9SZW0pPT1udWxsP3ZvaWQgMDpsLmNhbGwoYSwyNCkpfHwiMS41cmVtIn19LHtwcm9wczp7Zm9udFNpemU6ImxhcmdlIn0sc3R5bGU6e2ZvbnRTaXplOigoYz0odT1lLnR5cG9ncmFwaHkpPT1udWxsP3ZvaWQgMDp1LnB4VG9SZW0pPT1udWxsP3ZvaWQgMDpjLmNhbGwodSwzNSkpfHwiMi4xODc1cmVtIn19LC4uLk9iamVjdC5lbnRyaWVzKChlLnZhcnM/P2UpLnBhbGV0dGUpLmZpbHRlcigoWyxTXSk9PlMmJlMubWFpbikubWFwKChbU10pPT57dmFyIHgsaDtyZXR1cm57cHJvcHM6e2NvbG9yOlN9LHN0eWxlOntjb2xvcjooaD0oeD0oZS52YXJzPz9lKS5wYWxldHRlKT09bnVsbD92b2lkIDA6eFtTXSk9PW51bGw/dm9pZCAwOmgubWFpbn19fSkse3Byb3BzOntjb2xvcjoiYWN0aW9uIn0sc3R5bGU6e2NvbG9yOihtPShkPShlLnZhcnM/P2UpLnBhbGV0dGUpPT1udWxsP3ZvaWQgMDpkLmFjdGlvbik9PW51bGw/dm9pZCAwOm0uYWN0aXZlfX0se3Byb3BzOntjb2xvcjoiZGlzYWJsZWQifSxzdHlsZTp7Y29sb3I6KHc9KHY9KGUudmFycz8/ZSkucGFsZXR0ZSk9PW51bGw/dm9pZCAwOnYuYWN0aW9uKT09bnVsbD92b2lkIDA6dy5kaXNhYmxlZH19LHtwcm9wczp7Y29sb3I6ImluaGVyaXQifSxzdHlsZTp7Y29sb3I6dm9pZCAwfX1dfX0pKSxSYT1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aVN2Z0ljb24ifSkse2NoaWxkcmVuOm8sY2xhc3NOYW1lOmksY29sb3I6cz0iaW5oZXJpdCIsY29tcG9uZW50OmE9InN2ZyIsZm9udFNpemU6bD0ibWVkaXVtIixodG1sQ29sb3I6dSxpbmhlcml0Vmlld0JveDpjPSExLHRpdGxlQWNjZXNzOmQsdmlld0JveDptPSIwIDAgMjQgMjQiLC4uLnZ9PXIsdz1DLmlzVmFsaWRFbGVtZW50KG8pJiZvLnR5cGU9PT0ic3ZnIixTPXsuLi5yLGNvbG9yOnMsY29tcG9uZW50OmEsZm9udFNpemU6bCxpbnN0YW5jZUZvbnRTaXplOnQuZm9udFNpemUsaW5oZXJpdFZpZXdCb3g6Yyx2aWV3Qm94Om0saGFzU3ZnQXNDaGlsZDp3fSx4PXt9O2N8fCh4LnZpZXdCb3g9bSk7Y29uc3QgaD10YihTKTtyZXR1cm4gay5qc3hzKG5iLHthczphLGNsYXNzTmFtZTp0ZShoLnJvb3QsaSksZm9jdXNhYmxlOiJmYWxzZSIsY29sb3I6dSwiYXJpYS1oaWRkZW4iOmQ/dm9pZCAwOiEwLHJvbGU6ZD8iaW1nIjp2b2lkIDAscmVmOm4sLi4ueCwuLi52LC4uLncmJm8ucHJvcHMsb3duZXJTdGF0ZTpTLGNoaWxkcmVuOlt3P28ucHJvcHMuY2hpbGRyZW46byxkP2suanN4KCJ0aXRsZSIse2NoaWxkcmVuOmR9KTpudWxsXX0pfSk7UmEmJihSYS5tdWlOYW1lPSJTdmdJY29uIik7ZnVuY3Rpb24gVnQoZSx0KXtmdW5jdGlvbiBuKHIsbyl7cmV0dXJuIGsuanN4KFJhLHsiZGF0YS10ZXN0aWQiOmAke3R9SWNvbmAscmVmOm8sLi4ucixjaGlsZHJlbjplfSl9cmV0dXJuIG4ubXVpTmFtZT1SYS5tdWlOYW1lLEMubWVtbyhDLmZvcndhcmRSZWYobikpfWZ1bmN0aW9uIGVmKGUsdCl7aWYoZT09bnVsbClyZXR1cm57fTt2YXIgbj17fTtmb3IodmFyIHIgaW4gZSlpZih7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikpe2lmKHQuaW5jbHVkZXMocikpY29udGludWU7bltyXT1lW3JdfXJldHVybiBufWZ1bmN0aW9uIGdjKGUsdCl7cmV0dXJuIGdjPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpOmZ1bmN0aW9uKG4scil7cmV0dXJuIG4uX19wcm90b19fPXIsbn0sZ2MoZSx0KX1mdW5jdGlvbiB0ZihlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsZ2MoZSx0KX1mdW5jdGlvbiByYihlLHQpe3JldHVybiBlLmNsYXNzTGlzdD8hIXQmJmUuY2xhc3NMaXN0LmNvbnRhaW5zKHQpOigiICIrKGUuY2xhc3NOYW1lLmJhc2VWYWx8fGUuY2xhc3NOYW1lKSsiICIpLmluZGV4T2YoIiAiK3QrIiAiKSE9PS0xfWZ1bmN0aW9uIG9iKGUsdCl7ZS5jbGFzc0xpc3Q/ZS5jbGFzc0xpc3QuYWRkKHQpOnJiKGUsdCl8fCh0eXBlb2YgZS5jbGFzc05hbWU9PSJzdHJpbmciP2UuY2xhc3NOYW1lPWUuY2xhc3NOYW1lKyIgIit0OmUuc2V0QXR0cmlidXRlKCJjbGFzcyIsKGUuY2xhc3NOYW1lJiZlLmNsYXNzTmFtZS5iYXNlVmFsfHwiIikrIiAiK3QpKX1mdW5jdGlvbiBvbShlLHQpe3JldHVybiBlLnJlcGxhY2UobmV3IFJlZ0V4cCgiKF58XFxzKSIrdCsiKD86XFxzfCQpIiwiZyIpLCIkMSIpLnJlcGxhY2UoL1xzKy9nLCIgIikucmVwbGFjZSgvXlxzKnxccyokL2csIiIpfWZ1bmN0aW9uIGliKGUsdCl7ZS5jbGFzc0xpc3Q/ZS5jbGFzc0xpc3QucmVtb3ZlKHQpOnR5cGVvZiBlLmNsYXNzTmFtZT09InN0cmluZyI/ZS5jbGFzc05hbWU9b20oZS5jbGFzc05hbWUsdCk6ZS5zZXRBdHRyaWJ1dGUoImNsYXNzIixvbShlLmNsYXNzTmFtZSYmZS5jbGFzc05hbWUuYmFzZVZhbHx8IiIsdCkpfXZhciB1eT17ZXhwb3J0czp7fX0sS3Q9e30sY3k9e2V4cG9ydHM6e319LGR5PXt9Oy8qKgogKiBAbGljZW5zZSBSZWFjdAogKiBzY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMKICoKICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuCiAqCiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQogKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuCiAqLyhmdW5jdGlvbihlKXtmdW5jdGlvbiB0KFQsQSl7dmFyIEQ9VC5sZW5ndGg7VC5wdXNoKEEpO2U6Zm9yKDswPEQ7KXt2YXIgQj1ELTE+Pj4xLEg9VFtCXTtpZigwPG8oSCxBKSlUW0JdPUEsVFtEXT1ILEQ9QjtlbHNlIGJyZWFrIGV9fWZ1bmN0aW9uIG4oVCl7cmV0dXJuIFQubGVuZ3RoPT09MD9udWxsOlRbMF19ZnVuY3Rpb24gcihUKXtpZihULmxlbmd0aD09PTApcmV0dXJuIG51bGw7dmFyIEE9VFswXSxEPVQucG9wKCk7aWYoRCE9PUEpe1RbMF09RDtlOmZvcih2YXIgQj0wLEg9VC5sZW5ndGgsVj1IPj4+MTtCPFY7KXt2YXIgVT0yKihCKzEpLTEsWD1UW1VdLFc9VSsxLEo9VFtXXTtpZigwPm8oWCxEKSlXPEgmJjA+byhKLFgpPyhUW0JdPUosVFtXXT1ELEI9Vyk6KFRbQl09WCxUW1VdPUQsQj1VKTtlbHNlIGlmKFc8SCYmMD5vKEosRCkpVFtCXT1KLFRbV109RCxCPVc7ZWxzZSBicmVhayBlfX1yZXR1cm4gQX1mdW5jdGlvbiBvKFQsQSl7dmFyIEQ9VC5zb3J0SW5kZXgtQS5zb3J0SW5kZXg7cmV0dXJuIEQhPT0wP0Q6VC5pZC1BLmlkfWlmKHR5cGVvZiBwZXJmb3JtYW5jZT09Im9iamVjdCImJnR5cGVvZiBwZXJmb3JtYW5jZS5ub3c9PSJmdW5jdGlvbiIpe3ZhciBpPXBlcmZvcm1hbmNlO2UudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIGkubm93KCl9fWVsc2V7dmFyIHM9RGF0ZSxhPXMubm93KCk7ZS51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gcy5ub3coKS1hfX12YXIgbD1bXSx1PVtdLGM9MSxkPW51bGwsbT0zLHY9ITEsdz0hMSxTPSExLHg9dHlwZW9mIHNldFRpbWVvdXQ9PSJmdW5jdGlvbiI/c2V0VGltZW91dDpudWxsLGg9dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9jbGVhclRpbWVvdXQ6bnVsbCxnPXR5cGVvZiBzZXRJbW1lZGlhdGU8InUiP3NldEltbWVkaWF0ZTpudWxsO3R5cGVvZiBuYXZpZ2F0b3I8InUiJiZuYXZpZ2F0b3Iuc2NoZWR1bGluZyE9PXZvaWQgMCYmbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmchPT12b2lkIDAmJm5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpO2Z1bmN0aW9uIGYoVCl7Zm9yKHZhciBBPW4odSk7QSE9PW51bGw7KXtpZihBLmNhbGxiYWNrPT09bnVsbClyKHUpO2Vsc2UgaWYoQS5zdGFydFRpbWU8PVQpcih1KSxBLnNvcnRJbmRleD1BLmV4cGlyYXRpb25UaW1lLHQobCxBKTtlbHNlIGJyZWFrO0E9bih1KX19ZnVuY3Rpb24geShUKXtpZihTPSExLGYoVCksIXcpaWYobihsKSE9PW51bGwpdz0hMCxNKGIpO2Vsc2V7dmFyIEE9bih1KTtBIT09bnVsbCYmXyh5LEEuc3RhcnRUaW1lLVQpfX1mdW5jdGlvbiBiKFQsQSl7dz0hMSxTJiYoUz0hMSxoKFApLFA9LTEpLHY9ITA7dmFyIEQ9bTt0cnl7Zm9yKGYoQSksZD1uKGwpO2QhPT1udWxsJiYoIShkLmV4cGlyYXRpb25UaW1lPkEpfHxUJiYhJCgpKTspe3ZhciBCPWQuY2FsbGJhY2s7aWYodHlwZW9mIEI9PSJmdW5jdGlvbiIpe2QuY2FsbGJhY2s9bnVsbCxtPWQucHJpb3JpdHlMZXZlbDt2YXIgSD1CKGQuZXhwaXJhdGlvblRpbWU8PUEpO0E9ZS51bnN0YWJsZV9ub3coKSx0eXBlb2YgSD09ImZ1bmN0aW9uIj9kLmNhbGxiYWNrPUg6ZD09PW4obCkmJnIobCksZihBKX1lbHNlIHIobCk7ZD1uKGwpfWlmKGQhPT1udWxsKXZhciBWPSEwO2Vsc2V7dmFyIFU9bih1KTtVIT09bnVsbCYmXyh5LFUuc3RhcnRUaW1lLUEpLFY9ITF9cmV0dXJuIFZ9ZmluYWxseXtkPW51bGwsbT1ELHY9ITF9fXZhciBFPSExLFI9bnVsbCxQPS0xLEk9NSxwPS0xO2Z1bmN0aW9uICQoKXtyZXR1cm4hKGUudW5zdGFibGVfbm93KCktcDxJKX1mdW5jdGlvbiBMKCl7aWYoUiE9PW51bGwpe3ZhciBUPWUudW5zdGFibGVfbm93KCk7cD1UO3ZhciBBPSEwO3RyeXtBPVIoITAsVCl9ZmluYWxseXtBP2ooKTooRT0hMSxSPW51bGwpfX1lbHNlIEU9ITF9dmFyIGo7aWYodHlwZW9mIGc9PSJmdW5jdGlvbiIpaj1mdW5jdGlvbigpe2coTCl9O2Vsc2UgaWYodHlwZW9mIE1lc3NhZ2VDaGFubmVsPCJ1Iil7dmFyIE49bmV3IE1lc3NhZ2VDaGFubmVsLE89Ti5wb3J0MjtOLnBvcnQxLm9ubWVzc2FnZT1MLGo9ZnVuY3Rpb24oKXtPLnBvc3RNZXNzYWdlKG51bGwpfX1lbHNlIGo9ZnVuY3Rpb24oKXt4KEwsMCl9O2Z1bmN0aW9uIE0oVCl7Uj1ULEV8fChFPSEwLGooKSl9ZnVuY3Rpb24gXyhULEEpe1A9eChmdW5jdGlvbigpe1QoZS51bnN0YWJsZV9ub3coKSl9LEEpfWUudW5zdGFibGVfSWRsZVByaW9yaXR5PTUsZS51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xLGUudW5zdGFibGVfTG93UHJpb3JpdHk9NCxlLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTMsZS51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbCxlLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTIsZS51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihUKXtULmNhbGxiYWNrPW51bGx9LGUudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXt3fHx2fHwodz0hMCxNKGIpKX0sZS51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZT1mdW5jdGlvbihUKXswPlR8fDEyNTxUP2NvbnNvbGUuZXJyb3IoImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCIpOkk9MDxUP01hdGguZmxvb3IoMWUzL1QpOjV9LGUudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gbX0sZS51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZT1mdW5jdGlvbigpe3JldHVybiBuKGwpfSxlLnVuc3RhYmxlX25leHQ9ZnVuY3Rpb24oVCl7c3dpdGNoKG0pe2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOnZhciBBPTM7YnJlYWs7ZGVmYXVsdDpBPW19dmFyIEQ9bTttPUE7dHJ5e3JldHVybiBUKCl9ZmluYWxseXttPUR9fSxlLnVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uPWZ1bmN0aW9uKCl7fSxlLnVuc3RhYmxlX3JlcXVlc3RQYWludD1mdW5jdGlvbigpe30sZS51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk9ZnVuY3Rpb24oVCxBKXtzd2l0Y2goVCl7Y2FzZSAxOmNhc2UgMjpjYXNlIDM6Y2FzZSA0OmNhc2UgNTpicmVhaztkZWZhdWx0OlQ9M312YXIgRD1tO209VDt0cnl7cmV0dXJuIEEoKX1maW5hbGx5e209RH19LGUudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaz1mdW5jdGlvbihULEEsRCl7dmFyIEI9ZS51bnN0YWJsZV9ub3coKTtzd2l0Y2godHlwZW9mIEQ9PSJvYmplY3QiJiZEIT09bnVsbD8oRD1ELmRlbGF5LEQ9dHlwZW9mIEQ9PSJudW1iZXIiJiYwPEQ/QitEOkIpOkQ9QixUKXtjYXNlIDE6dmFyIEg9LTE7YnJlYWs7Y2FzZSAyOkg9MjUwO2JyZWFrO2Nhc2UgNTpIPTEwNzM3NDE4MjM7YnJlYWs7Y2FzZSA0Okg9MWU0O2JyZWFrO2RlZmF1bHQ6SD01ZTN9cmV0dXJuIEg9RCtILFQ9e2lkOmMrKyxjYWxsYmFjazpBLHByaW9yaXR5TGV2ZWw6VCxzdGFydFRpbWU6RCxleHBpcmF0aW9uVGltZTpILHNvcnRJbmRleDotMX0sRD5CPyhULnNvcnRJbmRleD1ELHQodSxUKSxuKGwpPT09bnVsbCYmVD09PW4odSkmJihTPyhoKFApLFA9LTEpOlM9ITAsXyh5LEQtQikpKTooVC5zb3J0SW5kZXg9SCx0KGwsVCksd3x8dnx8KHc9ITAsTShiKSkpLFR9LGUudW5zdGFibGVfc2hvdWxkWWllbGQ9JCxlLnVuc3RhYmxlX3dyYXBDYWxsYmFjaz1mdW5jdGlvbihUKXt2YXIgQT1tO3JldHVybiBmdW5jdGlvbigpe3ZhciBEPW07bT1BO3RyeXtyZXR1cm4gVC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXttPUR9fX19KShkeSk7Y3kuZXhwb3J0cz1keTt2YXIgc2I9Y3kuZXhwb3J0czsvKioKICogQGxpY2Vuc2UgUmVhY3QKICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzCiAqCiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLgogKgogKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGUKICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLgogKi92YXIgYWI9QyxGdD1zYjtmdW5jdGlvbiBGKGUpe2Zvcih2YXIgdD0iaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9IitlLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXQrPSImYXJnc1tdPSIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tuXSk7cmV0dXJuIk1pbmlmaWVkIFJlYWN0IGVycm9yICMiK2UrIjsgdmlzaXQgIit0KyIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLiJ9dmFyIGZ5PW5ldyBTZXQsVmk9e307ZnVuY3Rpb24gcXIoZSx0KXtObyhlLHQpLE5vKGUrIkNhcHR1cmUiLHQpfWZ1bmN0aW9uIE5vKGUsdCl7Zm9yKFZpW2VdPXQsZT0wO2U8dC5sZW5ndGg7ZSsrKWZ5LmFkZCh0W2VdKX12YXIgUW49ISh0eXBlb2Ygd2luZG93PiJ1Inx8dHlwZW9mIHdpbmRvdy5kb2N1bWVudD4idSJ8fHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudD4idSIpLHljPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksbGI9L15bOkEtWl9hLXpcdTAwQzAtXHUwMEQ2XHUwMEQ4LVx1MDBGNlx1MDBGOC1cdTAyRkZcdTAzNzAtXHUwMzdEXHUwMzdGLVx1MUZGRlx1MjAwQy1cdTIwMERcdTIwNzAtXHUyMThGXHUyQzAwLVx1MkZFRlx1MzAwMS1cdUQ3RkZcdUY5MDAtXHVGRENGXHVGREYwLVx1RkZGRF1bOkEtWl9hLXpcdTAwQzAtXHUwMEQ2XHUwMEQ4LVx1MDBGNlx1MDBGOC1cdTAyRkZcdTAzNzAtXHUwMzdEXHUwMzdGLVx1MUZGRlx1MjAwQy1cdTIwMERcdTIwNzAtXHUyMThGXHUyQzAwLVx1MkZFRlx1MzAwMS1cdUQ3RkZcdUY5MDAtXHVGRENGXHVGREYwLVx1RkZGRFwtLjAtOVx1MDBCN1x1MDMwMC1cdTAzNkZcdTIwM0YtXHUyMDQwXSokLyxpbT17fSxzbT17fTtmdW5jdGlvbiB1YihlKXtyZXR1cm4geWMuY2FsbChzbSxlKT8hMDp5Yy5jYWxsKGltLGUpPyExOmxiLnRlc3QoZSk/c21bZV09ITA6KGltW2VdPSEwLCExKX1mdW5jdGlvbiBjYihlLHQsbixyKXtpZihuIT09bnVsbCYmbi50eXBlPT09MClyZXR1cm4hMTtzd2l0Y2godHlwZW9mIHQpe2Nhc2UiZnVuY3Rpb24iOmNhc2Uic3ltYm9sIjpyZXR1cm4hMDtjYXNlImJvb2xlYW4iOnJldHVybiByPyExOm4hPT1udWxsPyFuLmFjY2VwdHNCb29sZWFuczooZT1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KSxlIT09ImRhdGEtIiYmZSE9PSJhcmlhLSIpO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGRiKGUsdCxuLHIpe2lmKHQ9PT1udWxsfHx0eXBlb2YgdD4idSJ8fGNiKGUsdCxuLHIpKXJldHVybiEwO2lmKHIpcmV0dXJuITE7aWYobiE9PW51bGwpc3dpdGNoKG4udHlwZSl7Y2FzZSAzOnJldHVybiF0O2Nhc2UgNDpyZXR1cm4gdD09PSExO2Nhc2UgNTpyZXR1cm4gaXNOYU4odCk7Y2FzZSA2OnJldHVybiBpc05hTih0KXx8MT50fXJldHVybiExfWZ1bmN0aW9uIHd0KGUsdCxuLHIsbyxpLHMpe3RoaXMuYWNjZXB0c0Jvb2xlYW5zPXQ9PT0yfHx0PT09M3x8dD09PTQsdGhpcy5hdHRyaWJ1dGVOYW1lPXIsdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2U9byx0aGlzLm11c3RVc2VQcm9wZXJ0eT1uLHRoaXMucHJvcGVydHlOYW1lPWUsdGhpcy50eXBlPXQsdGhpcy5zYW5pdGl6ZVVSTD1pLHRoaXMucmVtb3ZlRW1wdHlTdHJpbmc9c312YXIgYXQ9e307ImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZSIuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2F0W2VdPW5ldyB3dChlLDAsITEsZSxudWxsLCExLCExKX0pO1tbImFjY2VwdENoYXJzZXQiLCJhY2NlcHQtY2hhcnNldCJdLFsiY2xhc3NOYW1lIiwiY2xhc3MiXSxbImh0bWxGb3IiLCJmb3IiXSxbImh0dHBFcXVpdiIsImh0dHAtZXF1aXYiXV0uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lWzBdO2F0W3RdPW5ldyB3dCh0LDEsITEsZVsxXSxudWxsLCExLCExKX0pO1siY29udGVudEVkaXRhYmxlIiwiZHJhZ2dhYmxlIiwic3BlbGxDaGVjayIsInZhbHVlIl0uZm9yRWFjaChmdW5jdGlvbihlKXthdFtlXT1uZXcgd3QoZSwyLCExLGUudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1siYXV0b1JldmVyc2UiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwiZm9jdXNhYmxlIiwicHJlc2VydmVBbHBoYSJdLmZvckVhY2goZnVuY3Rpb24oZSl7YXRbZV09bmV3IHd0KGUsMiwhMSxlLG51bGwsITEsITEpfSk7ImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGUiLnNwbGl0KCIgIikuZm9yRWFjaChmdW5jdGlvbihlKXthdFtlXT1uZXcgd3QoZSwzLCExLGUudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1siY2hlY2tlZCIsIm11bHRpcGxlIiwibXV0ZWQiLCJzZWxlY3RlZCJdLmZvckVhY2goZnVuY3Rpb24oZSl7YXRbZV09bmV3IHd0KGUsMywhMCxlLG51bGwsITEsITEpfSk7WyJjYXB0dXJlIiwiZG93bmxvYWQiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2F0W2VdPW5ldyB3dChlLDQsITEsZSxudWxsLCExLCExKX0pO1siY29scyIsInJvd3MiLCJzaXplIiwic3BhbiJdLmZvckVhY2goZnVuY3Rpb24oZSl7YXRbZV09bmV3IHd0KGUsNiwhMSxlLG51bGwsITEsITEpfSk7WyJyb3dTcGFuIiwic3RhcnQiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2F0W2VdPW5ldyB3dChlLDUsITEsZS50b0xvd2VyQ2FzZSgpLG51bGwsITEsITEpfSk7dmFyIG5mPS9bXC06XShbYS16XSkvZztmdW5jdGlvbiByZihlKXtyZXR1cm4gZVsxXS50b1VwcGVyQ2FzZSgpfSJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4bWxuczp4bGluayB4LWhlaWdodCIuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZShuZixyZik7YXRbdF09bmV3IHd0KHQsMSwhMSxlLG51bGwsITEsITEpfSk7InhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZSIuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZShuZixyZik7YXRbdF09bmV3IHd0KHQsMSwhMSxlLCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiwhMSwhMSl9KTtbInhtbDpiYXNlIiwieG1sOmxhbmciLCJ4bWw6c3BhY2UiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZShuZixyZik7YXRbdF09bmV3IHd0KHQsMSwhMSxlLCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UiLCExLCExKX0pO1sidGFiSW5kZXgiLCJjcm9zc09yaWdpbiJdLmZvckVhY2goZnVuY3Rpb24oZSl7YXRbZV09bmV3IHd0KGUsMSwhMSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTthdC54bGlua0hyZWY9bmV3IHd0KCJ4bGlua0hyZWYiLDEsITEsInhsaW5rOmhyZWYiLCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiwhMCwhMSk7WyJzcmMiLCJocmVmIiwiYWN0aW9uIiwiZm9ybUFjdGlvbiJdLmZvckVhY2goZnVuY3Rpb24oZSl7YXRbZV09bmV3IHd0KGUsMSwhMSxlLnRvTG93ZXJDYXNlKCksbnVsbCwhMCwhMCl9KTtmdW5jdGlvbiBvZihlLHQsbixyKXt2YXIgbz1hdC5oYXNPd25Qcm9wZXJ0eSh0KT9hdFt0XTpudWxsOyhvIT09bnVsbD9vLnR5cGUhPT0wOnJ8fCEoMjx0Lmxlbmd0aCl8fHRbMF0hPT0ibyImJnRbMF0hPT0iTyJ8fHRbMV0hPT0ibiImJnRbMV0hPT0iTiIpJiYoZGIodCxuLG8scikmJihuPW51bGwpLHJ8fG89PT1udWxsP3ViKHQpJiYobj09PW51bGw/ZS5yZW1vdmVBdHRyaWJ1dGUodCk6ZS5zZXRBdHRyaWJ1dGUodCwiIituKSk6by5tdXN0VXNlUHJvcGVydHk/ZVtvLnByb3BlcnR5TmFtZV09bj09PW51bGw/by50eXBlPT09Mz8hMToiIjpuOih0PW8uYXR0cmlidXRlTmFtZSxyPW8uYXR0cmlidXRlTmFtZXNwYWNlLG49PT1udWxsP2UucmVtb3ZlQXR0cmlidXRlKHQpOihvPW8udHlwZSxuPW89PT0zfHxvPT09NCYmbj09PSEwPyIiOiIiK24scj9lLnNldEF0dHJpYnV0ZU5TKHIsdCxuKTplLnNldEF0dHJpYnV0ZSh0LG4pKSkpfXZhciBucj1hYi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxfcz1TeW1ib2wuZm9yKCJyZWFjdC5lbGVtZW50IiksdW89U3ltYm9sLmZvcigicmVhY3QucG9ydGFsIiksY289U3ltYm9sLmZvcigicmVhY3QuZnJhZ21lbnQiKSxzZj1TeW1ib2wuZm9yKCJyZWFjdC5zdHJpY3RfbW9kZSIpLHZjPVN5bWJvbC5mb3IoInJlYWN0LnByb2ZpbGVyIikscHk9U3ltYm9sLmZvcigicmVhY3QucHJvdmlkZXIiKSxteT1TeW1ib2wuZm9yKCJyZWFjdC5jb250ZXh0IiksYWY9U3ltYm9sLmZvcigicmVhY3QuZm9yd2FyZF9yZWYiKSx3Yz1TeW1ib2wuZm9yKCJyZWFjdC5zdXNwZW5zZSIpLFNjPVN5bWJvbC5mb3IoInJlYWN0LnN1c3BlbnNlX2xpc3QiKSxsZj1TeW1ib2wuZm9yKCJyZWFjdC5tZW1vIiksaXI9U3ltYm9sLmZvcigicmVhY3QubGF6eSIpLGh5PVN5bWJvbC5mb3IoInJlYWN0Lm9mZnNjcmVlbiIpLGFtPVN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiBvaShlKXtyZXR1cm4gZT09PW51bGx8fHR5cGVvZiBlIT0ib2JqZWN0Ij9udWxsOihlPWFtJiZlW2FtXXx8ZVsiQEBpdGVyYXRvciJdLHR5cGVvZiBlPT0iZnVuY3Rpb24iP2U6bnVsbCl9dmFyIExlPU9iamVjdC5hc3NpZ24sRXU7ZnVuY3Rpb24gd2koZSl7aWYoRXU9PT12b2lkIDApdHJ5e3Rocm93IEVycm9yKCl9Y2F0Y2gobil7dmFyIHQ9bi5zdGFjay50cmltKCkubWF0Y2goL1xuKCAqKGF0ICk/KS8pO0V1PXQmJnRbMV18fCIifXJldHVybmAKYCtFdStlfXZhciBSdT0hMTtmdW5jdGlvbiBUdShlLHQpe2lmKCFlfHxSdSlyZXR1cm4iIjtSdT0hMDt2YXIgbj1FcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT12b2lkIDA7dHJ5e2lmKHQpaWYodD1mdW5jdGlvbigpe3Rocm93IEVycm9yKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSwicHJvcHMiLHtzZXQ6ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpfX0pLHR5cGVvZiBSZWZsZWN0PT0ib2JqZWN0IiYmUmVmbGVjdC5jb25zdHJ1Y3Qpe3RyeXtSZWZsZWN0LmNvbnN0cnVjdCh0LFtdKX1jYXRjaCh1KXt2YXIgcj11fVJlZmxlY3QuY29uc3RydWN0KGUsW10sdCl9ZWxzZXt0cnl7dC5jYWxsKCl9Y2F0Y2godSl7cj11fWUuY2FsbCh0LnByb3RvdHlwZSl9ZWxzZXt0cnl7dGhyb3cgRXJyb3IoKX1jYXRjaCh1KXtyPXV9ZSgpfX1jYXRjaCh1KXtpZih1JiZyJiZ0eXBlb2YgdS5zdGFjaz09InN0cmluZyIpe2Zvcih2YXIgbz11LnN0YWNrLnNwbGl0KGAKYCksaT1yLnN0YWNrLnNwbGl0KGAKYCkscz1vLmxlbmd0aC0xLGE9aS5sZW5ndGgtMTsxPD1zJiYwPD1hJiZvW3NdIT09aVthXTspYS0tO2Zvcig7MTw9cyYmMDw9YTtzLS0sYS0tKWlmKG9bc10hPT1pW2FdKXtpZihzIT09MXx8YSE9PTEpZG8gaWYocy0tLGEtLSwwPmF8fG9bc10hPT1pW2FdKXt2YXIgbD1gCmArb1tzXS5yZXBsYWNlKCIgYXQgbmV3ICIsIiBhdCAiKTtyZXR1cm4gZS5kaXNwbGF5TmFtZSYmbC5pbmNsdWRlcygiPGFub255bW91cz4iKSYmKGw9bC5yZXBsYWNlKCI8YW5vbnltb3VzPiIsZS5kaXNwbGF5TmFtZSkpLGx9d2hpbGUoMTw9cyYmMDw9YSk7YnJlYWt9fX1maW5hbGx5e1J1PSExLEVycm9yLnByZXBhcmVTdGFja1RyYWNlPW59cmV0dXJuKGU9ZT9lLmRpc3BsYXlOYW1lfHxlLm5hbWU6IiIpP3dpKGUpOiIifWZ1bmN0aW9uIGZiKGUpe3N3aXRjaChlLnRhZyl7Y2FzZSA1OnJldHVybiB3aShlLnR5cGUpO2Nhc2UgMTY6cmV0dXJuIHdpKCJMYXp5Iik7Y2FzZSAxMzpyZXR1cm4gd2koIlN1c3BlbnNlIik7Y2FzZSAxOTpyZXR1cm4gd2koIlN1c3BlbnNlTGlzdCIpO2Nhc2UgMDpjYXNlIDI6Y2FzZSAxNTpyZXR1cm4gZT1UdShlLnR5cGUsITEpLGU7Y2FzZSAxMTpyZXR1cm4gZT1UdShlLnR5cGUucmVuZGVyLCExKSxlO2Nhc2UgMTpyZXR1cm4gZT1UdShlLnR5cGUsITApLGU7ZGVmYXVsdDpyZXR1cm4iIn19ZnVuY3Rpb24geGMoZSl7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZih0eXBlb2YgZT09ImZ1bmN0aW9uIilyZXR1cm4gZS5kaXNwbGF5TmFtZXx8ZS5uYW1lfHxudWxsO2lmKHR5cGVvZiBlPT0ic3RyaW5nIilyZXR1cm4gZTtzd2l0Y2goZSl7Y2FzZSBjbzpyZXR1cm4iRnJhZ21lbnQiO2Nhc2UgdW86cmV0dXJuIlBvcnRhbCI7Y2FzZSB2YzpyZXR1cm4iUHJvZmlsZXIiO2Nhc2Ugc2Y6cmV0dXJuIlN0cmljdE1vZGUiO2Nhc2Ugd2M6cmV0dXJuIlN1c3BlbnNlIjtjYXNlIFNjOnJldHVybiJTdXNwZW5zZUxpc3QifWlmKHR5cGVvZiBlPT0ib2JqZWN0Iilzd2l0Y2goZS4kJHR5cGVvZil7Y2FzZSBteTpyZXR1cm4oZS5kaXNwbGF5TmFtZXx8IkNvbnRleHQiKSsiLkNvbnN1bWVyIjtjYXNlIHB5OnJldHVybihlLl9jb250ZXh0LmRpc3BsYXlOYW1lfHwiQ29udGV4dCIpKyIuUHJvdmlkZXIiO2Nhc2UgYWY6dmFyIHQ9ZS5yZW5kZXI7cmV0dXJuIGU9ZS5kaXNwbGF5TmFtZSxlfHwoZT10LmRpc3BsYXlOYW1lfHx0Lm5hbWV8fCIiLGU9ZSE9PSIiPyJGb3J3YXJkUmVmKCIrZSsiKSI6IkZvcndhcmRSZWYiKSxlO2Nhc2UgbGY6cmV0dXJuIHQ9ZS5kaXNwbGF5TmFtZXx8bnVsbCx0IT09bnVsbD90OnhjKGUudHlwZSl8fCJNZW1vIjtjYXNlIGlyOnQ9ZS5fcGF5bG9hZCxlPWUuX2luaXQ7dHJ5e3JldHVybiB4YyhlKHQpKX1jYXRjaHt9fXJldHVybiBudWxsfWZ1bmN0aW9uIHBiKGUpe3ZhciB0PWUudHlwZTtzd2l0Y2goZS50YWcpe2Nhc2UgMjQ6cmV0dXJuIkNhY2hlIjtjYXNlIDk6cmV0dXJuKHQuZGlzcGxheU5hbWV8fCJDb250ZXh0IikrIi5Db25zdW1lciI7Y2FzZSAxMDpyZXR1cm4odC5fY29udGV4dC5kaXNwbGF5TmFtZXx8IkNvbnRleHQiKSsiLlByb3ZpZGVyIjtjYXNlIDE4OnJldHVybiJEZWh5ZHJhdGVkRnJhZ21lbnQiO2Nhc2UgMTE6cmV0dXJuIGU9dC5yZW5kZXIsZT1lLmRpc3BsYXlOYW1lfHxlLm5hbWV8fCIiLHQuZGlzcGxheU5hbWV8fChlIT09IiI/IkZvcndhcmRSZWYoIitlKyIpIjoiRm9yd2FyZFJlZiIpO2Nhc2UgNzpyZXR1cm4iRnJhZ21lbnQiO2Nhc2UgNTpyZXR1cm4gdDtjYXNlIDQ6cmV0dXJuIlBvcnRhbCI7Y2FzZSAzOnJldHVybiJSb290IjtjYXNlIDY6cmV0dXJuIlRleHQiO2Nhc2UgMTY6cmV0dXJuIHhjKHQpO2Nhc2UgODpyZXR1cm4gdD09PXNmPyJTdHJpY3RNb2RlIjoiTW9kZSI7Y2FzZSAyMjpyZXR1cm4iT2Zmc2NyZWVuIjtjYXNlIDEyOnJldHVybiJQcm9maWxlciI7Y2FzZSAyMTpyZXR1cm4iU2NvcGUiO2Nhc2UgMTM6cmV0dXJuIlN1c3BlbnNlIjtjYXNlIDE5OnJldHVybiJTdXNwZW5zZUxpc3QiO2Nhc2UgMjU6cmV0dXJuIlRyYWNpbmdNYXJrZXIiO2Nhc2UgMTpjYXNlIDA6Y2FzZSAxNzpjYXNlIDI6Y2FzZSAxNDpjYXNlIDE1OmlmKHR5cGVvZiB0PT0iZnVuY3Rpb24iKXJldHVybiB0LmRpc3BsYXlOYW1lfHx0Lm5hbWV8fG51bGw7aWYodHlwZW9mIHQ9PSJzdHJpbmciKXJldHVybiB0fXJldHVybiBudWxsfWZ1bmN0aW9uIHhyKGUpe3N3aXRjaCh0eXBlb2YgZSl7Y2FzZSJib29sZWFuIjpjYXNlIm51bWJlciI6Y2FzZSJzdHJpbmciOmNhc2UidW5kZWZpbmVkIjpyZXR1cm4gZTtjYXNlIm9iamVjdCI6cmV0dXJuIGU7ZGVmYXVsdDpyZXR1cm4iIn19ZnVuY3Rpb24gZ3koZSl7dmFyIHQ9ZS50eXBlO3JldHVybihlPWUubm9kZU5hbWUpJiZlLnRvTG93ZXJDYXNlKCk9PT0iaW5wdXQiJiYodD09PSJjaGVja2JveCJ8fHQ9PT0icmFkaW8iKX1mdW5jdGlvbiBtYihlKXt2YXIgdD1neShlKT8iY2hlY2tlZCI6InZhbHVlIixuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsdCkscj0iIitlW3RdO2lmKCFlLmhhc093blByb3BlcnR5KHQpJiZ0eXBlb2YgbjwidSImJnR5cGVvZiBuLmdldD09ImZ1bmN0aW9uIiYmdHlwZW9mIG4uc2V0PT0iZnVuY3Rpb24iKXt2YXIgbz1uLmdldCxpPW4uc2V0O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKHMpe3I9IiIrcyxpLmNhbGwodGhpcyxzKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOm4uZW51bWVyYWJsZX0pLHtnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiByfSxzZXRWYWx1ZTpmdW5jdGlvbihzKXtyPSIiK3N9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2UuX3ZhbHVlVHJhY2tlcj1udWxsLGRlbGV0ZSBlW3RdfX19fWZ1bmN0aW9uIE5zKGUpe2UuX3ZhbHVlVHJhY2tlcnx8KGUuX3ZhbHVlVHJhY2tlcj1tYihlKSl9ZnVuY3Rpb24geXkoZSl7aWYoIWUpcmV0dXJuITE7dmFyIHQ9ZS5fdmFsdWVUcmFja2VyO2lmKCF0KXJldHVybiEwO3ZhciBuPXQuZ2V0VmFsdWUoKSxyPSIiO3JldHVybiBlJiYocj1neShlKT9lLmNoZWNrZWQ/InRydWUiOiJmYWxzZSI6ZS52YWx1ZSksZT1yLGUhPT1uPyh0LnNldFZhbHVlKGUpLCEwKTohMX1mdW5jdGlvbiBUYShlKXtpZihlPWV8fCh0eXBlb2YgZG9jdW1lbnQ8InUiP2RvY3VtZW50OnZvaWQgMCksdHlwZW9mIGU+InUiKXJldHVybiBudWxsO3RyeXtyZXR1cm4gZS5hY3RpdmVFbGVtZW50fHxlLmJvZHl9Y2F0Y2h7cmV0dXJuIGUuYm9keX19ZnVuY3Rpb24gQ2MoZSx0KXt2YXIgbj10LmNoZWNrZWQ7cmV0dXJuIExlKHt9LHQse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOnZvaWQgMCxjaGVja2VkOm4/P2UuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIGxtKGUsdCl7dmFyIG49dC5kZWZhdWx0VmFsdWU9PW51bGw/IiI6dC5kZWZhdWx0VmFsdWUscj10LmNoZWNrZWQhPW51bGw/dC5jaGVja2VkOnQuZGVmYXVsdENoZWNrZWQ7bj14cih0LnZhbHVlIT1udWxsP3QudmFsdWU6biksZS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpyLGluaXRpYWxWYWx1ZTpuLGNvbnRyb2xsZWQ6dC50eXBlPT09ImNoZWNrYm94Inx8dC50eXBlPT09InJhZGlvIj90LmNoZWNrZWQhPW51bGw6dC52YWx1ZSE9bnVsbH19ZnVuY3Rpb24gdnkoZSx0KXt0PXQuY2hlY2tlZCx0IT1udWxsJiZvZihlLCJjaGVja2VkIix0LCExKX1mdW5jdGlvbiBiYyhlLHQpe3Z5KGUsdCk7dmFyIG49eHIodC52YWx1ZSkscj10LnR5cGU7aWYobiE9bnVsbClyPT09Im51bWJlciI/KG49PT0wJiZlLnZhbHVlPT09IiJ8fGUudmFsdWUhPW4pJiYoZS52YWx1ZT0iIituKTplLnZhbHVlIT09IiIrbiYmKGUudmFsdWU9IiIrbik7ZWxzZSBpZihyPT09InN1Ym1pdCJ8fHI9PT0icmVzZXQiKXtlLnJlbW92ZUF0dHJpYnV0ZSgidmFsdWUiKTtyZXR1cm59dC5oYXNPd25Qcm9wZXJ0eSgidmFsdWUiKT9rYyhlLHQudHlwZSxuKTp0Lmhhc093blByb3BlcnR5KCJkZWZhdWx0VmFsdWUiKSYma2MoZSx0LnR5cGUseHIodC5kZWZhdWx0VmFsdWUpKSx0LmNoZWNrZWQ9PW51bGwmJnQuZGVmYXVsdENoZWNrZWQhPW51bGwmJihlLmRlZmF1bHRDaGVja2VkPSEhdC5kZWZhdWx0Q2hlY2tlZCl9ZnVuY3Rpb24gdW0oZSx0LG4pe2lmKHQuaGFzT3duUHJvcGVydHkoInZhbHVlIil8fHQuaGFzT3duUHJvcGVydHkoImRlZmF1bHRWYWx1ZSIpKXt2YXIgcj10LnR5cGU7aWYoIShyIT09InN1Ym1pdCImJnIhPT0icmVzZXQifHx0LnZhbHVlIT09dm9pZCAwJiZ0LnZhbHVlIT09bnVsbCkpcmV0dXJuO3Q9IiIrZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxufHx0PT09ZS52YWx1ZXx8KGUudmFsdWU9dCksZS5kZWZhdWx0VmFsdWU9dH1uPWUubmFtZSxuIT09IiImJihlLm5hbWU9IiIpLGUuZGVmYXVsdENoZWNrZWQ9ISFlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsbiE9PSIiJiYoZS5uYW1lPW4pfWZ1bmN0aW9uIGtjKGUsdCxuKXsodCE9PSJudW1iZXIifHxUYShlLm93bmVyRG9jdW1lbnQpIT09ZSkmJihuPT1udWxsP2UuZGVmYXVsdFZhbHVlPSIiK2UuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU6ZS5kZWZhdWx0VmFsdWUhPT0iIituJiYoZS5kZWZhdWx0VmFsdWU9IiIrbikpfXZhciBTaT1BcnJheS5pc0FycmF5O2Z1bmN0aW9uIEVvKGUsdCxuLHIpe2lmKGU9ZS5vcHRpb25zLHQpe3Q9e307Zm9yKHZhciBvPTA7bzxuLmxlbmd0aDtvKyspdFsiJCIrbltvXV09ITA7Zm9yKG49MDtuPGUubGVuZ3RoO24rKylvPXQuaGFzT3duUHJvcGVydHkoIiQiK2Vbbl0udmFsdWUpLGVbbl0uc2VsZWN0ZWQhPT1vJiYoZVtuXS5zZWxlY3RlZD1vKSxvJiZyJiYoZVtuXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Zm9yKG49IiIreHIobiksdD1udWxsLG89MDtvPGUubGVuZ3RoO28rKyl7aWYoZVtvXS52YWx1ZT09PW4pe2Vbb10uc2VsZWN0ZWQ9ITAsciYmKGVbb10uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59dCE9PW51bGx8fGVbb10uZGlzYWJsZWR8fCh0PWVbb10pfXQhPT1udWxsJiYodC5zZWxlY3RlZD0hMCl9fWZ1bmN0aW9uIEVjKGUsdCl7aWYodC5kYW5nZXJvdXNseVNldElubmVySFRNTCE9bnVsbCl0aHJvdyBFcnJvcihGKDkxKSk7cmV0dXJuIExlKHt9LHQse3ZhbHVlOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLGNoaWxkcmVuOiIiK2UuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBjbShlLHQpe3ZhciBuPXQudmFsdWU7aWYobj09bnVsbCl7aWYobj10LmNoaWxkcmVuLHQ9dC5kZWZhdWx0VmFsdWUsbiE9bnVsbCl7aWYodCE9bnVsbCl0aHJvdyBFcnJvcihGKDkyKSk7aWYoU2kobikpe2lmKDE8bi5sZW5ndGgpdGhyb3cgRXJyb3IoRig5MykpO249blswXX10PW59dD09bnVsbCYmKHQ9IiIpLG49dH1lLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTp4cihuKX19ZnVuY3Rpb24gd3koZSx0KXt2YXIgbj14cih0LnZhbHVlKSxyPXhyKHQuZGVmYXVsdFZhbHVlKTtuIT1udWxsJiYobj0iIituLG4hPT1lLnZhbHVlJiYoZS52YWx1ZT1uKSx0LmRlZmF1bHRWYWx1ZT09bnVsbCYmZS5kZWZhdWx0VmFsdWUhPT1uJiYoZS5kZWZhdWx0VmFsdWU9bikpLHIhPW51bGwmJihlLmRlZmF1bHRWYWx1ZT0iIityKX1mdW5jdGlvbiBkbShlKXt2YXIgdD1lLnRleHRDb250ZW50O3Q9PT1lLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlJiZ0IT09IiImJnQhPT1udWxsJiYoZS52YWx1ZT10KX1mdW5jdGlvbiBTeShlKXtzd2l0Y2goZSl7Y2FzZSJzdmciOnJldHVybiJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI7Y2FzZSJtYXRoIjpyZXR1cm4iaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCI7ZGVmYXVsdDpyZXR1cm4iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCJ9fWZ1bmN0aW9uIFJjKGUsdCl7cmV0dXJuIGU9PW51bGx8fGU9PT0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI/U3kodCk6ZT09PSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyImJnQ9PT0iZm9yZWlnbk9iamVjdCI/Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiOmV9dmFyIElzLHh5PWZ1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgTVNBcHA8InUiJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbih0LG4scixvKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBlKHQsbixyLG8pfSl9OmV9KGZ1bmN0aW9uKGUsdCl7aWYoZS5uYW1lc3BhY2VVUkkhPT0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcifHwiaW5uZXJIVE1MImluIGUpZS5pbm5lckhUTUw9dDtlbHNle2ZvcihJcz1Jc3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksSXMuaW5uZXJIVE1MPSI8c3ZnPiIrdC52YWx1ZU9mKCkudG9TdHJpbmcoKSsiPC9zdmc+Iix0PUlzLmZpcnN0Q2hpbGQ7ZS5maXJzdENoaWxkOyllLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7Zm9yKDt0LmZpcnN0Q2hpbGQ7KWUuYXBwZW5kQ2hpbGQodC5maXJzdENoaWxkKX19KTtmdW5jdGlvbiBLaShlLHQpe2lmKHQpe3ZhciBuPWUuZmlyc3RDaGlsZDtpZihuJiZuPT09ZS5sYXN0Q2hpbGQmJm4ubm9kZVR5cGU9PT0zKXtuLm5vZGVWYWx1ZT10O3JldHVybn19ZS50ZXh0Q29udGVudD10fXZhciBSaT17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYXNwZWN0UmF0aW86ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkQXJlYTohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0saGI9WyJXZWJraXQiLCJtcyIsIk1veiIsIk8iXTtPYmplY3Qua2V5cyhSaSkuZm9yRWFjaChmdW5jdGlvbihlKXtoYi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Q9dCtlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc3Vic3RyaW5nKDEpLFJpW3RdPVJpW2VdfSl9KTtmdW5jdGlvbiBDeShlLHQsbil7cmV0dXJuIHQ9PW51bGx8fHR5cGVvZiB0PT0iYm9vbGVhbiJ8fHQ9PT0iIj8iIjpufHx0eXBlb2YgdCE9Im51bWJlciJ8fHQ9PT0wfHxSaS5oYXNPd25Qcm9wZXJ0eShlKSYmUmlbZV0/KCIiK3QpLnRyaW0oKTp0KyJweCJ9ZnVuY3Rpb24gYnkoZSx0KXtlPWUuc3R5bGU7Zm9yKHZhciBuIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShuKSl7dmFyIHI9bi5pbmRleE9mKCItLSIpPT09MCxvPUN5KG4sdFtuXSxyKTtuPT09ImZsb2F0IiYmKG49ImNzc0Zsb2F0Iikscj9lLnNldFByb3BlcnR5KG4sbyk6ZVtuXT1vfX12YXIgZ2I9TGUoe21lbnVpdGVtOiEwfSx7YXJlYTohMCxiYXNlOiEwLGJyOiEwLGNvbDohMCxlbWJlZDohMCxocjohMCxpbWc6ITAsaW5wdXQ6ITAsa2V5Z2VuOiEwLGxpbms6ITAsbWV0YTohMCxwYXJhbTohMCxzb3VyY2U6ITAsdHJhY2s6ITAsd2JyOiEwfSk7ZnVuY3Rpb24gVGMoZSx0KXtpZih0KXtpZihnYltlXSYmKHQuY2hpbGRyZW4hPW51bGx8fHQuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPW51bGwpKXRocm93IEVycm9yKEYoMTM3LGUpKTtpZih0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIT1udWxsKXtpZih0LmNoaWxkcmVuIT1udWxsKXRocm93IEVycm9yKEYoNjApKTtpZih0eXBlb2YgdC5kYW5nZXJvdXNseVNldElubmVySFRNTCE9Im9iamVjdCJ8fCEoIl9faHRtbCJpbiB0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcihGKDYxKSl9aWYodC5zdHlsZSE9bnVsbCYmdHlwZW9mIHQuc3R5bGUhPSJvYmplY3QiKXRocm93IEVycm9yKEYoNjIpKX19ZnVuY3Rpb24gUGMoZSx0KXtpZihlLmluZGV4T2YoIi0iKT09PS0xKXJldHVybiB0eXBlb2YgdC5pcz09InN0cmluZyI7c3dpdGNoKGUpe2Nhc2UiYW5ub3RhdGlvbi14bWwiOmNhc2UiY29sb3ItcHJvZmlsZSI6Y2FzZSJmb250LWZhY2UiOmNhc2UiZm9udC1mYWNlLXNyYyI6Y2FzZSJmb250LWZhY2UtdXJpIjpjYXNlImZvbnQtZmFjZS1mb3JtYXQiOmNhc2UiZm9udC1mYWNlLW5hbWUiOmNhc2UibWlzc2luZy1nbHlwaCI6cmV0dXJuITE7ZGVmYXVsdDpyZXR1cm4hMH19dmFyICRjPW51bGw7ZnVuY3Rpb24gdWYoZSl7cmV0dXJuIGU9ZS50YXJnZXR8fGUuc3JjRWxlbWVudHx8d2luZG93LGUuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihlPWUuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpLGUubm9kZVR5cGU9PT0zP2UucGFyZW50Tm9kZTplfXZhciBPYz1udWxsLFJvPW51bGwsVG89bnVsbDtmdW5jdGlvbiBmbShlKXtpZihlPWJzKGUpKXtpZih0eXBlb2YgT2MhPSJmdW5jdGlvbiIpdGhyb3cgRXJyb3IoRigyODApKTt2YXIgdD1lLnN0YXRlTm9kZTt0JiYodD1RbCh0KSxPYyhlLnN0YXRlTm9kZSxlLnR5cGUsdCkpfX1mdW5jdGlvbiBreShlKXtSbz9Ubz9Uby5wdXNoKGUpOlRvPVtlXTpSbz1lfWZ1bmN0aW9uIEV5KCl7aWYoUm8pe3ZhciBlPVJvLHQ9VG87aWYoVG89Um89bnVsbCxmbShlKSx0KWZvcihlPTA7ZTx0Lmxlbmd0aDtlKyspZm0odFtlXSl9fWZ1bmN0aW9uIFJ5KGUsdCl7cmV0dXJuIGUodCl9ZnVuY3Rpb24gVHkoKXt9dmFyIFB1PSExO2Z1bmN0aW9uIFB5KGUsdCxuKXtpZihQdSlyZXR1cm4gZSh0LG4pO1B1PSEwO3RyeXtyZXR1cm4gUnkoZSx0LG4pfWZpbmFsbHl7UHU9ITEsKFJvIT09bnVsbHx8VG8hPT1udWxsKSYmKFR5KCksRXkoKSl9fWZ1bmN0aW9uIFlpKGUsdCl7dmFyIG49ZS5zdGF0ZU5vZGU7aWYobj09PW51bGwpcmV0dXJuIG51bGw7dmFyIHI9UWwobik7aWYocj09PW51bGwpcmV0dXJuIG51bGw7bj1yW3RdO2U6c3dpdGNoKHQpe2Nhc2Uib25DbGljayI6Y2FzZSJvbkNsaWNrQ2FwdHVyZSI6Y2FzZSJvbkRvdWJsZUNsaWNrIjpjYXNlIm9uRG91YmxlQ2xpY2tDYXB0dXJlIjpjYXNlIm9uTW91c2VEb3duIjpjYXNlIm9uTW91c2VEb3duQ2FwdHVyZSI6Y2FzZSJvbk1vdXNlTW92ZSI6Y2FzZSJvbk1vdXNlTW92ZUNhcHR1cmUiOmNhc2Uib25Nb3VzZVVwIjpjYXNlIm9uTW91c2VVcENhcHR1cmUiOmNhc2Uib25Nb3VzZUVudGVyIjoocj0hci5kaXNhYmxlZCl8fChlPWUudHlwZSxyPSEoZT09PSJidXR0b24ifHxlPT09ImlucHV0Inx8ZT09PSJzZWxlY3QifHxlPT09InRleHRhcmVhIikpLGU9IXI7YnJlYWsgZTtkZWZhdWx0OmU9ITF9aWYoZSlyZXR1cm4gbnVsbDtpZihuJiZ0eXBlb2YgbiE9ImZ1bmN0aW9uIil0aHJvdyBFcnJvcihGKDIzMSx0LHR5cGVvZiBuKSk7cmV0dXJuIG59dmFyIE1jPSExO2lmKFFuKXRyeXt2YXIgaWk9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KGlpLCJwYXNzaXZlIix7Z2V0OmZ1bmN0aW9uKCl7TWM9ITB9fSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoInRlc3QiLGlpLGlpKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigidGVzdCIsaWksaWkpfWNhdGNoe01jPSExfWZ1bmN0aW9uIHliKGUsdCxuLHIsbyxpLHMsYSxsKXt2YXIgdT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e3QuYXBwbHkobix1KX1jYXRjaChjKXt0aGlzLm9uRXJyb3IoYyl9fXZhciBUaT0hMSxQYT1udWxsLCRhPSExLF9jPW51bGwsdmI9e29uRXJyb3I6ZnVuY3Rpb24oZSl7VGk9ITAsUGE9ZX19O2Z1bmN0aW9uIHdiKGUsdCxuLHIsbyxpLHMsYSxsKXtUaT0hMSxQYT1udWxsLHliLmFwcGx5KHZiLGFyZ3VtZW50cyl9ZnVuY3Rpb24gU2IoZSx0LG4scixvLGkscyxhLGwpe2lmKHdiLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxUaSl7aWYoVGkpe3ZhciB1PVBhO1RpPSExLFBhPW51bGx9ZWxzZSB0aHJvdyBFcnJvcihGKDE5OCkpOyRhfHwoJGE9ITAsX2M9dSl9fWZ1bmN0aW9uIFpyKGUpe3ZhciB0PWUsbj1lO2lmKGUuYWx0ZXJuYXRlKWZvcig7dC5yZXR1cm47KXQ9dC5yZXR1cm47ZWxzZXtlPXQ7ZG8gdD1lLHQuZmxhZ3MmNDA5OCYmKG49dC5yZXR1cm4pLGU9dC5yZXR1cm47d2hpbGUoZSl9cmV0dXJuIHQudGFnPT09Mz9uOm51bGx9ZnVuY3Rpb24gJHkoZSl7aWYoZS50YWc9PT0xMyl7dmFyIHQ9ZS5tZW1vaXplZFN0YXRlO2lmKHQ9PT1udWxsJiYoZT1lLmFsdGVybmF0ZSxlIT09bnVsbCYmKHQ9ZS5tZW1vaXplZFN0YXRlKSksdCE9PW51bGwpcmV0dXJuIHQuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBwbShlKXtpZihacihlKSE9PWUpdGhyb3cgRXJyb3IoRigxODgpKX1mdW5jdGlvbiB4YihlKXt2YXIgdD1lLmFsdGVybmF0ZTtpZighdCl7aWYodD1acihlKSx0PT09bnVsbCl0aHJvdyBFcnJvcihGKDE4OCkpO3JldHVybiB0IT09ZT9udWxsOmV9Zm9yKHZhciBuPWUscj10Ozspe3ZhciBvPW4ucmV0dXJuO2lmKG89PT1udWxsKWJyZWFrO3ZhciBpPW8uYWx0ZXJuYXRlO2lmKGk9PT1udWxsKXtpZihyPW8ucmV0dXJuLHIhPT1udWxsKXtuPXI7Y29udGludWV9YnJlYWt9aWYoby5jaGlsZD09PWkuY2hpbGQpe2ZvcihpPW8uY2hpbGQ7aTspe2lmKGk9PT1uKXJldHVybiBwbShvKSxlO2lmKGk9PT1yKXJldHVybiBwbShvKSx0O2k9aS5zaWJsaW5nfXRocm93IEVycm9yKEYoMTg4KSl9aWYobi5yZXR1cm4hPT1yLnJldHVybiluPW8scj1pO2Vsc2V7Zm9yKHZhciBzPSExLGE9by5jaGlsZDthOyl7aWYoYT09PW4pe3M9ITAsbj1vLHI9aTticmVha31pZihhPT09cil7cz0hMCxyPW8sbj1pO2JyZWFrfWE9YS5zaWJsaW5nfWlmKCFzKXtmb3IoYT1pLmNoaWxkO2E7KXtpZihhPT09bil7cz0hMCxuPWkscj1vO2JyZWFrfWlmKGE9PT1yKXtzPSEwLHI9aSxuPW87YnJlYWt9YT1hLnNpYmxpbmd9aWYoIXMpdGhyb3cgRXJyb3IoRigxODkpKX19aWYobi5hbHRlcm5hdGUhPT1yKXRocm93IEVycm9yKEYoMTkwKSl9aWYobi50YWchPT0zKXRocm93IEVycm9yKEYoMTg4KSk7cmV0dXJuIG4uc3RhdGVOb2RlLmN1cnJlbnQ9PT1uP2U6dH1mdW5jdGlvbiBPeShlKXtyZXR1cm4gZT14YihlKSxlIT09bnVsbD9NeShlKTpudWxsfWZ1bmN0aW9uIE15KGUpe2lmKGUudGFnPT09NXx8ZS50YWc9PT02KXJldHVybiBlO2ZvcihlPWUuY2hpbGQ7ZSE9PW51bGw7KXt2YXIgdD1NeShlKTtpZih0IT09bnVsbClyZXR1cm4gdDtlPWUuc2libGluZ31yZXR1cm4gbnVsbH12YXIgX3k9RnQudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxtbT1GdC51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxDYj1GdC51bnN0YWJsZV9zaG91bGRZaWVsZCxiYj1GdC51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsVWU9RnQudW5zdGFibGVfbm93LGtiPUZ0LnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLGNmPUZ0LnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LE55PUZ0LnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LE9hPUZ0LnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEViPUZ0LnVuc3RhYmxlX0xvd1ByaW9yaXR5LEl5PUZ0LnVuc3RhYmxlX0lkbGVQcmlvcml0eSxWbD1udWxsLE5uPW51bGw7ZnVuY3Rpb24gUmIoZSl7aWYoTm4mJnR5cGVvZiBObi5vbkNvbW1pdEZpYmVyUm9vdD09ImZ1bmN0aW9uIil0cnl7Tm4ub25Db21taXRGaWJlclJvb3QoVmwsZSx2b2lkIDAsKGUuY3VycmVudC5mbGFncyYxMjgpPT09MTI4KX1jYXRjaHt9fXZhciB5bj1NYXRoLmNsejMyP01hdGguY2x6MzI6JGIsVGI9TWF0aC5sb2csUGI9TWF0aC5MTjI7ZnVuY3Rpb24gJGIoZSl7cmV0dXJuIGU+Pj49MCxlPT09MD8zMjozMS0oVGIoZSkvUGJ8MCl8MH12YXIgQXM9NjQsenM9NDE5NDMwNDtmdW5jdGlvbiB4aShlKXtzd2l0Y2goZSYtZSl7Y2FzZSAxOnJldHVybiAxO2Nhc2UgMjpyZXR1cm4gMjtjYXNlIDQ6cmV0dXJuIDQ7Y2FzZSA4OnJldHVybiA4O2Nhc2UgMTY6cmV0dXJuIDE2O2Nhc2UgMzI6cmV0dXJuIDMyO2Nhc2UgNjQ6Y2FzZSAxMjg6Y2FzZSAyNTY6Y2FzZSA1MTI6Y2FzZSAxMDI0OmNhc2UgMjA0ODpjYXNlIDQwOTY6Y2FzZSA4MTkyOmNhc2UgMTYzODQ6Y2FzZSAzMjc2ODpjYXNlIDY1NTM2OmNhc2UgMTMxMDcyOmNhc2UgMjYyMTQ0OmNhc2UgNTI0Mjg4OmNhc2UgMTA0ODU3NjpjYXNlIDIwOTcxNTI6cmV0dXJuIGUmNDE5NDI0MDtjYXNlIDQxOTQzMDQ6Y2FzZSA4Mzg4NjA4OmNhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpjYXNlIDY3MTA4ODY0OnJldHVybiBlJjEzMDAyMzQyNDtjYXNlIDEzNDIxNzcyODpyZXR1cm4gMTM0MjE3NzI4O2Nhc2UgMjY4NDM1NDU2OnJldHVybiAyNjg0MzU0NTY7Y2FzZSA1MzY4NzA5MTI6cmV0dXJuIDUzNjg3MDkxMjtjYXNlIDEwNzM3NDE4MjQ6cmV0dXJuIDEwNzM3NDE4MjQ7ZGVmYXVsdDpyZXR1cm4gZX19ZnVuY3Rpb24gTWEoZSx0KXt2YXIgbj1lLnBlbmRpbmdMYW5lcztpZihuPT09MClyZXR1cm4gMDt2YXIgcj0wLG89ZS5zdXNwZW5kZWRMYW5lcyxpPWUucGluZ2VkTGFuZXMscz1uJjI2ODQzNTQ1NTtpZihzIT09MCl7dmFyIGE9cyZ+bzthIT09MD9yPXhpKGEpOihpJj1zLGkhPT0wJiYocj14aShpKSkpfWVsc2Ugcz1uJn5vLHMhPT0wP3I9eGkocyk6aSE9PTAmJihyPXhpKGkpKTtpZihyPT09MClyZXR1cm4gMDtpZih0IT09MCYmdCE9PXImJiEodCZvKSYmKG89ciYtcixpPXQmLXQsbz49aXx8bz09PTE2JiYoaSY0MTk0MjQwKSE9PTApKXJldHVybiB0O2lmKHImNCYmKHJ8PW4mMTYpLHQ9ZS5lbnRhbmdsZWRMYW5lcyx0IT09MClmb3IoZT1lLmVudGFuZ2xlbWVudHMsdCY9cjswPHQ7KW49MzEteW4odCksbz0xPDxuLHJ8PWVbbl0sdCY9fm87cmV0dXJuIHJ9ZnVuY3Rpb24gT2IoZSx0KXtzd2l0Y2goZSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDQ6cmV0dXJuIHQrMjUwO2Nhc2UgODpjYXNlIDE2OmNhc2UgMzI6Y2FzZSA2NDpjYXNlIDEyODpjYXNlIDI1NjpjYXNlIDUxMjpjYXNlIDEwMjQ6Y2FzZSAyMDQ4OmNhc2UgNDA5NjpjYXNlIDgxOTI6Y2FzZSAxNjM4NDpjYXNlIDMyNzY4OmNhc2UgNjU1MzY6Y2FzZSAxMzEwNzI6Y2FzZSAyNjIxNDQ6Y2FzZSA1MjQyODg6Y2FzZSAxMDQ4NTc2OmNhc2UgMjA5NzE1MjpyZXR1cm4gdCs1ZTM7Y2FzZSA0MTk0MzA0OmNhc2UgODM4ODYwODpjYXNlIDE2Nzc3MjE2OmNhc2UgMzM1NTQ0MzI6Y2FzZSA2NzEwODg2NDpyZXR1cm4tMTtjYXNlIDEzNDIxNzcyODpjYXNlIDI2ODQzNTQ1NjpjYXNlIDUzNjg3MDkxMjpjYXNlIDEwNzM3NDE4MjQ6cmV0dXJuLTE7ZGVmYXVsdDpyZXR1cm4tMX19ZnVuY3Rpb24gTWIoZSx0KXtmb3IodmFyIG49ZS5zdXNwZW5kZWRMYW5lcyxyPWUucGluZ2VkTGFuZXMsbz1lLmV4cGlyYXRpb25UaW1lcyxpPWUucGVuZGluZ0xhbmVzOzA8aTspe3ZhciBzPTMxLXluKGkpLGE9MTw8cyxsPW9bc107bD09PS0xPyghKGEmbil8fGEmcikmJihvW3NdPU9iKGEsdCkpOmw8PXQmJihlLmV4cGlyZWRMYW5lc3w9YSksaSY9fmF9fWZ1bmN0aW9uIE5jKGUpe3JldHVybiBlPWUucGVuZGluZ0xhbmVzJi0xMDczNzQxODI1LGUhPT0wP2U6ZSYxMDczNzQxODI0PzEwNzM3NDE4MjQ6MH1mdW5jdGlvbiBBeSgpe3ZhciBlPUFzO3JldHVybiBBczw8PTEsIShBcyY0MTk0MjQwKSYmKEFzPTY0KSxlfWZ1bmN0aW9uICR1KGUpe2Zvcih2YXIgdD1bXSxuPTA7MzE+bjtuKyspdC5wdXNoKGUpO3JldHVybiB0fWZ1bmN0aW9uIHhzKGUsdCxuKXtlLnBlbmRpbmdMYW5lc3w9dCx0IT09NTM2ODcwOTEyJiYoZS5zdXNwZW5kZWRMYW5lcz0wLGUucGluZ2VkTGFuZXM9MCksZT1lLmV2ZW50VGltZXMsdD0zMS15bih0KSxlW3RdPW59ZnVuY3Rpb24gX2IoZSx0KXt2YXIgbj1lLnBlbmRpbmdMYW5lcyZ+dDtlLnBlbmRpbmdMYW5lcz10LGUuc3VzcGVuZGVkTGFuZXM9MCxlLnBpbmdlZExhbmVzPTAsZS5leHBpcmVkTGFuZXMmPXQsZS5tdXRhYmxlUmVhZExhbmVzJj10LGUuZW50YW5nbGVkTGFuZXMmPXQsdD1lLmVudGFuZ2xlbWVudHM7dmFyIHI9ZS5ldmVudFRpbWVzO2ZvcihlPWUuZXhwaXJhdGlvblRpbWVzOzA8bjspe3ZhciBvPTMxLXluKG4pLGk9MTw8bzt0W29dPTAscltvXT0tMSxlW29dPS0xLG4mPX5pfX1mdW5jdGlvbiBkZihlLHQpe3ZhciBuPWUuZW50YW5nbGVkTGFuZXN8PXQ7Zm9yKGU9ZS5lbnRhbmdsZW1lbnRzO247KXt2YXIgcj0zMS15bihuKSxvPTE8PHI7byZ0fGVbcl0mdCYmKGVbcl18PXQpLG4mPX5vfX12YXIgQ2U9MDtmdW5jdGlvbiB6eShlKXtyZXR1cm4gZSY9LWUsMTxlPzQ8ZT9lJjI2ODQzNTQ1NT8xNjo1MzY4NzA5MTI6NDoxfXZhciBMeSxmZixqeSxEeSxGeSxJYz0hMSxMcz1bXSxmcj1udWxsLHByPW51bGwsbXI9bnVsbCxHaT1uZXcgTWFwLFFpPW5ldyBNYXAsYXI9W10sTmI9Im1vdXNlZG93biBtb3VzZXVwIHRvdWNoY2FuY2VsIHRvdWNoZW5kIHRvdWNoc3RhcnQgYXV4Y2xpY2sgZGJsY2xpY2sgcG9pbnRlcmNhbmNlbCBwb2ludGVyZG93biBwb2ludGVydXAgZHJhZ2VuZCBkcmFnc3RhcnQgZHJvcCBjb21wb3NpdGlvbmVuZCBjb21wb3NpdGlvbnN0YXJ0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXQgdGV4dElucHV0IGNvcHkgY3V0IHBhc3RlIGNsaWNrIGNoYW5nZSBjb250ZXh0bWVudSByZXNldCBzdWJtaXQiLnNwbGl0KCIgIik7ZnVuY3Rpb24gaG0oZSx0KXtzd2l0Y2goZSl7Y2FzZSJmb2N1c2luIjpjYXNlImZvY3Vzb3V0Ijpmcj1udWxsO2JyZWFrO2Nhc2UiZHJhZ2VudGVyIjpjYXNlImRyYWdsZWF2ZSI6cHI9bnVsbDticmVhaztjYXNlIm1vdXNlb3ZlciI6Y2FzZSJtb3VzZW91dCI6bXI9bnVsbDticmVhaztjYXNlInBvaW50ZXJvdmVyIjpjYXNlInBvaW50ZXJvdXQiOkdpLmRlbGV0ZSh0LnBvaW50ZXJJZCk7YnJlYWs7Y2FzZSJnb3Rwb2ludGVyY2FwdHVyZSI6Y2FzZSJsb3N0cG9pbnRlcmNhcHR1cmUiOlFpLmRlbGV0ZSh0LnBvaW50ZXJJZCl9fWZ1bmN0aW9uIHNpKGUsdCxuLHIsbyxpKXtyZXR1cm4gZT09PW51bGx8fGUubmF0aXZlRXZlbnQhPT1pPyhlPXtibG9ja2VkT246dCxkb21FdmVudE5hbWU6bixldmVudFN5c3RlbUZsYWdzOnIsbmF0aXZlRXZlbnQ6aSx0YXJnZXRDb250YWluZXJzOltvXX0sdCE9PW51bGwmJih0PWJzKHQpLHQhPT1udWxsJiZmZih0KSksZSk6KGUuZXZlbnRTeXN0ZW1GbGFnc3w9cix0PWUudGFyZ2V0Q29udGFpbmVycyxvIT09bnVsbCYmdC5pbmRleE9mKG8pPT09LTEmJnQucHVzaChvKSxlKX1mdW5jdGlvbiBJYihlLHQsbixyLG8pe3N3aXRjaCh0KXtjYXNlImZvY3VzaW4iOnJldHVybiBmcj1zaShmcixlLHQsbixyLG8pLCEwO2Nhc2UiZHJhZ2VudGVyIjpyZXR1cm4gcHI9c2kocHIsZSx0LG4scixvKSwhMDtjYXNlIm1vdXNlb3ZlciI6cmV0dXJuIG1yPXNpKG1yLGUsdCxuLHIsbyksITA7Y2FzZSJwb2ludGVyb3ZlciI6dmFyIGk9by5wb2ludGVySWQ7cmV0dXJuIEdpLnNldChpLHNpKEdpLmdldChpKXx8bnVsbCxlLHQsbixyLG8pKSwhMDtjYXNlImdvdHBvaW50ZXJjYXB0dXJlIjpyZXR1cm4gaT1vLnBvaW50ZXJJZCxRaS5zZXQoaSxzaShRaS5nZXQoaSl8fG51bGwsZSx0LG4scixvKSksITB9cmV0dXJuITF9ZnVuY3Rpb24gQnkoZSl7dmFyIHQ9enIoZS50YXJnZXQpO2lmKHQhPT1udWxsKXt2YXIgbj1acih0KTtpZihuIT09bnVsbCl7aWYodD1uLnRhZyx0PT09MTMpe2lmKHQ9JHkobiksdCE9PW51bGwpe2UuYmxvY2tlZE9uPXQsRnkoZS5wcmlvcml0eSxmdW5jdGlvbigpe2p5KG4pfSk7cmV0dXJufX1lbHNlIGlmKHQ9PT0zJiZuLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKXtlLmJsb2NrZWRPbj1uLnRhZz09PTM/bi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO3JldHVybn19fWUuYmxvY2tlZE9uPW51bGx9ZnVuY3Rpb24gbGEoZSl7aWYoZS5ibG9ja2VkT24hPT1udWxsKXJldHVybiExO2Zvcih2YXIgdD1lLnRhcmdldENvbnRhaW5lcnM7MDx0Lmxlbmd0aDspe3ZhciBuPUFjKGUuZG9tRXZlbnROYW1lLGUuZXZlbnRTeXN0ZW1GbGFncyx0WzBdLGUubmF0aXZlRXZlbnQpO2lmKG49PT1udWxsKXtuPWUubmF0aXZlRXZlbnQ7dmFyIHI9bmV3IG4uY29uc3RydWN0b3Iobi50eXBlLG4pOyRjPXIsbi50YXJnZXQuZGlzcGF0Y2hFdmVudChyKSwkYz1udWxsfWVsc2UgcmV0dXJuIHQ9YnMobiksdCE9PW51bGwmJmZmKHQpLGUuYmxvY2tlZE9uPW4sITE7dC5zaGlmdCgpfXJldHVybiEwfWZ1bmN0aW9uIGdtKGUsdCxuKXtsYShlKSYmbi5kZWxldGUodCl9ZnVuY3Rpb24gQWIoKXtJYz0hMSxmciE9PW51bGwmJmxhKGZyKSYmKGZyPW51bGwpLHByIT09bnVsbCYmbGEocHIpJiYocHI9bnVsbCksbXIhPT1udWxsJiZsYShtcikmJihtcj1udWxsKSxHaS5mb3JFYWNoKGdtKSxRaS5mb3JFYWNoKGdtKX1mdW5jdGlvbiBhaShlLHQpe2UuYmxvY2tlZE9uPT09dCYmKGUuYmxvY2tlZE9uPW51bGwsSWN8fChJYz0hMCxGdC51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKEZ0LnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEFiKSkpfWZ1bmN0aW9uIFhpKGUpe2Z1bmN0aW9uIHQobyl7cmV0dXJuIGFpKG8sZSl9aWYoMDxMcy5sZW5ndGgpe2FpKExzWzBdLGUpO2Zvcih2YXIgbj0xO248THMubGVuZ3RoO24rKyl7dmFyIHI9THNbbl07ci5ibG9ja2VkT249PT1lJiYoci5ibG9ja2VkT249bnVsbCl9fWZvcihmciE9PW51bGwmJmFpKGZyLGUpLHByIT09bnVsbCYmYWkocHIsZSksbXIhPT1udWxsJiZhaShtcixlKSxHaS5mb3JFYWNoKHQpLFFpLmZvckVhY2godCksbj0wO248YXIubGVuZ3RoO24rKylyPWFyW25dLHIuYmxvY2tlZE9uPT09ZSYmKHIuYmxvY2tlZE9uPW51bGwpO2Zvcig7MDxhci5sZW5ndGgmJihuPWFyWzBdLG4uYmxvY2tlZE9uPT09bnVsbCk7KUJ5KG4pLG4uYmxvY2tlZE9uPT09bnVsbCYmYXIuc2hpZnQoKX12YXIgUG89bnIuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsX2E9ITA7ZnVuY3Rpb24gemIoZSx0LG4scil7dmFyIG89Q2UsaT1Qby50cmFuc2l0aW9uO1BvLnRyYW5zaXRpb249bnVsbDt0cnl7Q2U9MSxwZihlLHQsbixyKX1maW5hbGx5e0NlPW8sUG8udHJhbnNpdGlvbj1pfX1mdW5jdGlvbiBMYihlLHQsbixyKXt2YXIgbz1DZSxpPVBvLnRyYW5zaXRpb247UG8udHJhbnNpdGlvbj1udWxsO3RyeXtDZT00LHBmKGUsdCxuLHIpfWZpbmFsbHl7Q2U9byxQby50cmFuc2l0aW9uPWl9fWZ1bmN0aW9uIHBmKGUsdCxuLHIpe2lmKF9hKXt2YXIgbz1BYyhlLHQsbixyKTtpZihvPT09bnVsbClEdShlLHQscixOYSxuKSxobShlLHIpO2Vsc2UgaWYoSWIobyxlLHQsbixyKSlyLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgaWYoaG0oZSxyKSx0JjQmJi0xPE5iLmluZGV4T2YoZSkpe2Zvcig7byE9PW51bGw7KXt2YXIgaT1icyhvKTtpZihpIT09bnVsbCYmTHkoaSksaT1BYyhlLHQsbixyKSxpPT09bnVsbCYmRHUoZSx0LHIsTmEsbiksaT09PW8pYnJlYWs7bz1pfW8hPT1udWxsJiZyLnN0b3BQcm9wYWdhdGlvbigpfWVsc2UgRHUoZSx0LHIsbnVsbCxuKX19dmFyIE5hPW51bGw7ZnVuY3Rpb24gQWMoZSx0LG4scil7aWYoTmE9bnVsbCxlPXVmKHIpLGU9enIoZSksZSE9PW51bGwpaWYodD1acihlKSx0PT09bnVsbCllPW51bGw7ZWxzZSBpZihuPXQudGFnLG49PT0xMyl7aWYoZT0keSh0KSxlIT09bnVsbClyZXR1cm4gZTtlPW51bGx9ZWxzZSBpZihuPT09Myl7aWYodC5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZClyZXR1cm4gdC50YWc9PT0zP3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDtlPW51bGx9ZWxzZSB0IT09ZSYmKGU9bnVsbCk7cmV0dXJuIE5hPWUsbnVsbH1mdW5jdGlvbiBXeShlKXtzd2l0Y2goZSl7Y2FzZSJjYW5jZWwiOmNhc2UiY2xpY2siOmNhc2UiY2xvc2UiOmNhc2UiY29udGV4dG1lbnUiOmNhc2UiY29weSI6Y2FzZSJjdXQiOmNhc2UiYXV4Y2xpY2siOmNhc2UiZGJsY2xpY2siOmNhc2UiZHJhZ2VuZCI6Y2FzZSJkcmFnc3RhcnQiOmNhc2UiZHJvcCI6Y2FzZSJmb2N1c2luIjpjYXNlImZvY3Vzb3V0IjpjYXNlImlucHV0IjpjYXNlImludmFsaWQiOmNhc2Uia2V5ZG93biI6Y2FzZSJrZXlwcmVzcyI6Y2FzZSJrZXl1cCI6Y2FzZSJtb3VzZWRvd24iOmNhc2UibW91c2V1cCI6Y2FzZSJwYXN0ZSI6Y2FzZSJwYXVzZSI6Y2FzZSJwbGF5IjpjYXNlInBvaW50ZXJjYW5jZWwiOmNhc2UicG9pbnRlcmRvd24iOmNhc2UicG9pbnRlcnVwIjpjYXNlInJhdGVjaGFuZ2UiOmNhc2UicmVzZXQiOmNhc2UicmVzaXplIjpjYXNlInNlZWtlZCI6Y2FzZSJzdWJtaXQiOmNhc2UidG91Y2hjYW5jZWwiOmNhc2UidG91Y2hlbmQiOmNhc2UidG91Y2hzdGFydCI6Y2FzZSJ2b2x1bWVjaGFuZ2UiOmNhc2UiY2hhbmdlIjpjYXNlInNlbGVjdGlvbmNoYW5nZSI6Y2FzZSJ0ZXh0SW5wdXQiOmNhc2UiY29tcG9zaXRpb25zdGFydCI6Y2FzZSJjb21wb3NpdGlvbmVuZCI6Y2FzZSJjb21wb3NpdGlvbnVwZGF0ZSI6Y2FzZSJiZWZvcmVibHVyIjpjYXNlImFmdGVyYmx1ciI6Y2FzZSJiZWZvcmVpbnB1dCI6Y2FzZSJibHVyIjpjYXNlImZ1bGxzY3JlZW5jaGFuZ2UiOmNhc2UiZm9jdXMiOmNhc2UiaGFzaGNoYW5nZSI6Y2FzZSJwb3BzdGF0ZSI6Y2FzZSJzZWxlY3QiOmNhc2Uic2VsZWN0c3RhcnQiOnJldHVybiAxO2Nhc2UiZHJhZyI6Y2FzZSJkcmFnZW50ZXIiOmNhc2UiZHJhZ2V4aXQiOmNhc2UiZHJhZ2xlYXZlIjpjYXNlImRyYWdvdmVyIjpjYXNlIm1vdXNlbW92ZSI6Y2FzZSJtb3VzZW91dCI6Y2FzZSJtb3VzZW92ZXIiOmNhc2UicG9pbnRlcm1vdmUiOmNhc2UicG9pbnRlcm91dCI6Y2FzZSJwb2ludGVyb3ZlciI6Y2FzZSJzY3JvbGwiOmNhc2UidG9nZ2xlIjpjYXNlInRvdWNobW92ZSI6Y2FzZSJ3aGVlbCI6Y2FzZSJtb3VzZWVudGVyIjpjYXNlIm1vdXNlbGVhdmUiOmNhc2UicG9pbnRlcmVudGVyIjpjYXNlInBvaW50ZXJsZWF2ZSI6cmV0dXJuIDQ7Y2FzZSJtZXNzYWdlIjpzd2l0Y2goa2IoKSl7Y2FzZSBjZjpyZXR1cm4gMTtjYXNlIE55OnJldHVybiA0O2Nhc2UgT2E6Y2FzZSBFYjpyZXR1cm4gMTY7Y2FzZSBJeTpyZXR1cm4gNTM2ODcwOTEyO2RlZmF1bHQ6cmV0dXJuIDE2fWRlZmF1bHQ6cmV0dXJuIDE2fX12YXIgY3I9bnVsbCxtZj1udWxsLHVhPW51bGw7ZnVuY3Rpb24gVXkoKXtpZih1YSlyZXR1cm4gdWE7dmFyIGUsdD1tZixuPXQubGVuZ3RoLHIsbz0idmFsdWUiaW4gY3I/Y3IudmFsdWU6Y3IudGV4dENvbnRlbnQsaT1vLmxlbmd0aDtmb3IoZT0wO2U8biYmdFtlXT09PW9bZV07ZSsrKTt2YXIgcz1uLWU7Zm9yKHI9MTtyPD1zJiZ0W24tcl09PT1vW2ktcl07cisrKTtyZXR1cm4gdWE9by5zbGljZShlLDE8cj8xLXI6dm9pZCAwKX1mdW5jdGlvbiBjYShlKXt2YXIgdD1lLmtleUNvZGU7cmV0dXJuImNoYXJDb2RlImluIGU/KGU9ZS5jaGFyQ29kZSxlPT09MCYmdD09PTEzJiYoZT0xMykpOmU9dCxlPT09MTAmJihlPTEzKSwzMjw9ZXx8ZT09PTEzP2U6MH1mdW5jdGlvbiBqcygpe3JldHVybiEwfWZ1bmN0aW9uIHltKCl7cmV0dXJuITF9ZnVuY3Rpb24gWXQoZSl7ZnVuY3Rpb24gdChuLHIsbyxpLHMpe3RoaXMuX3JlYWN0TmFtZT1uLHRoaXMuX3RhcmdldEluc3Q9byx0aGlzLnR5cGU9cix0aGlzLm5hdGl2ZUV2ZW50PWksdGhpcy50YXJnZXQ9cyx0aGlzLmN1cnJlbnRUYXJnZXQ9bnVsbDtmb3IodmFyIGEgaW4gZSllLmhhc093blByb3BlcnR5KGEpJiYobj1lW2FdLHRoaXNbYV09bj9uKGkpOmlbYV0pO3JldHVybiB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0oaS5kZWZhdWx0UHJldmVudGVkIT1udWxsP2kuZGVmYXVsdFByZXZlbnRlZDppLnJldHVyblZhbHVlPT09ITEpP2pzOnltLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9eW0sdGhpc31yZXR1cm4gTGUodC5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBuPXRoaXMubmF0aXZlRXZlbnQ7biYmKG4ucHJldmVudERlZmF1bHQ/bi5wcmV2ZW50RGVmYXVsdCgpOnR5cGVvZiBuLnJldHVyblZhbHVlIT0idW5rbm93biImJihuLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1qcyl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBuPXRoaXMubmF0aXZlRXZlbnQ7biYmKG4uc3RvcFByb3BhZ2F0aW9uP24uc3RvcFByb3BhZ2F0aW9uKCk6dHlwZW9mIG4uY2FuY2VsQnViYmxlIT0idW5rbm93biImJihuLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1qcyl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt9LGlzUGVyc2lzdGVudDpqc30pLHR9dmFyIFhvPXtldmVudFBoYXNlOjAsYnViYmxlczowLGNhbmNlbGFibGU6MCx0aW1lU3RhbXA6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOjAsaXNUcnVzdGVkOjB9LGhmPVl0KFhvKSxDcz1MZSh7fSxYbyx7dmlldzowLGRldGFpbDowfSksamI9WXQoQ3MpLE91LE11LGxpLEtsPUxlKHt9LENzLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOmdmLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbGF0ZWRUYXJnZXQ9PT12b2lkIDA/ZS5mcm9tRWxlbWVudD09PWUuc3JjRWxlbWVudD9lLnRvRWxlbWVudDplLmZyb21FbGVtZW50OmUucmVsYXRlZFRhcmdldH0sbW92ZW1lbnRYOmZ1bmN0aW9uKGUpe3JldHVybiJtb3ZlbWVudFgiaW4gZT9lLm1vdmVtZW50WDooZSE9PWxpJiYobGkmJmUudHlwZT09PSJtb3VzZW1vdmUiPyhPdT1lLnNjcmVlblgtbGkuc2NyZWVuWCxNdT1lLnNjcmVlblktbGkuc2NyZWVuWSk6TXU9T3U9MCxsaT1lKSxPdSl9LG1vdmVtZW50WTpmdW5jdGlvbihlKXtyZXR1cm4ibW92ZW1lbnRZImluIGU/ZS5tb3ZlbWVudFk6TXV9fSksdm09WXQoS2wpLERiPUxlKHt9LEtsLHtkYXRhVHJhbnNmZXI6MH0pLEZiPVl0KERiKSxCYj1MZSh7fSxDcyx7cmVsYXRlZFRhcmdldDowfSksX3U9WXQoQmIpLFdiPUxlKHt9LFhvLHthbmltYXRpb25OYW1lOjAsZWxhcHNlZFRpbWU6MCxwc2V1ZG9FbGVtZW50OjB9KSxVYj1ZdChXYiksSGI9TGUoe30sWG8se2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuImNsaXBib2FyZERhdGEiaW4gZT9lLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSksVmI9WXQoSGIpLEtiPUxlKHt9LFhvLHtkYXRhOjB9KSx3bT1ZdChLYiksWWI9e0VzYzoiRXNjYXBlIixTcGFjZWJhcjoiICIsTGVmdDoiQXJyb3dMZWZ0IixVcDoiQXJyb3dVcCIsUmlnaHQ6IkFycm93UmlnaHQiLERvd246IkFycm93RG93biIsRGVsOiJEZWxldGUiLFdpbjoiT1MiLE1lbnU6IkNvbnRleHRNZW51IixBcHBzOiJDb250ZXh0TWVudSIsU2Nyb2xsOiJTY3JvbGxMb2NrIixNb3pQcmludGFibGVLZXk6IlVuaWRlbnRpZmllZCJ9LEdiPXs4OiJCYWNrc3BhY2UiLDk6IlRhYiIsMTI6IkNsZWFyIiwxMzoiRW50ZXIiLDE2OiJTaGlmdCIsMTc6IkNvbnRyb2wiLDE4OiJBbHQiLDE5OiJQYXVzZSIsMjA6IkNhcHNMb2NrIiwyNzoiRXNjYXBlIiwzMjoiICIsMzM6IlBhZ2VVcCIsMzQ6IlBhZ2VEb3duIiwzNToiRW5kIiwzNjoiSG9tZSIsMzc6IkFycm93TGVmdCIsMzg6IkFycm93VXAiLDM5OiJBcnJvd1JpZ2h0Iiw0MDoiQXJyb3dEb3duIiw0NToiSW5zZXJ0Iiw0NjoiRGVsZXRlIiwxMTI6IkYxIiwxMTM6IkYyIiwxMTQ6IkYzIiwxMTU6IkY0IiwxMTY6IkY1IiwxMTc6IkY2IiwxMTg6IkY3IiwxMTk6IkY4IiwxMjA6IkY5IiwxMjE6IkYxMCIsMTIyOiJGMTEiLDEyMzoiRjEyIiwxNDQ6Ik51bUxvY2siLDE0NToiU2Nyb2xsTG9jayIsMjI0OiJNZXRhIn0sUWI9e0FsdDoiYWx0S2V5IixDb250cm9sOiJjdHJsS2V5IixNZXRhOiJtZXRhS2V5IixTaGlmdDoic2hpZnRLZXkifTtmdW5jdGlvbiBYYihlKXt2YXIgdD10aGlzLm5hdGl2ZUV2ZW50O3JldHVybiB0LmdldE1vZGlmaWVyU3RhdGU/dC5nZXRNb2RpZmllclN0YXRlKGUpOihlPVFiW2VdKT8hIXRbZV06ITF9ZnVuY3Rpb24gZ2YoKXtyZXR1cm4gWGJ9dmFyIHFiPUxlKHt9LENzLHtrZXk6ZnVuY3Rpb24oZSl7aWYoZS5rZXkpe3ZhciB0PVliW2Uua2V5XXx8ZS5rZXk7aWYodCE9PSJVbmlkZW50aWZpZWQiKXJldHVybiB0fXJldHVybiBlLnR5cGU9PT0ia2V5cHJlc3MiPyhlPWNhKGUpLGU9PT0xMz8iRW50ZXIiOlN0cmluZy5mcm9tQ2hhckNvZGUoZSkpOmUudHlwZT09PSJrZXlkb3duInx8ZS50eXBlPT09ImtleXVwIj9HYltlLmtleUNvZGVdfHwiVW5pZGVudGlmaWVkIjoiIn0sY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6Z2YsY2hhckNvZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHlwZT09PSJrZXlwcmVzcyI/Y2EoZSk6MH0sa2V5Q29kZTpmdW5jdGlvbihlKXtyZXR1cm4gZS50eXBlPT09ImtleWRvd24ifHxlLnR5cGU9PT0ia2V5dXAiP2Uua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihlKXtyZXR1cm4gZS50eXBlPT09ImtleXByZXNzIj9jYShlKTplLnR5cGU9PT0ia2V5ZG93biJ8fGUudHlwZT09PSJrZXl1cCI/ZS5rZXlDb2RlOjB9fSksWmI9WXQocWIpLEpiPUxlKHt9LEtsLHtwb2ludGVySWQ6MCx3aWR0aDowLGhlaWdodDowLHByZXNzdXJlOjAsdGFuZ2VudGlhbFByZXNzdXJlOjAsdGlsdFg6MCx0aWx0WTowLHR3aXN0OjAscG9pbnRlclR5cGU6MCxpc1ByaW1hcnk6MH0pLFNtPVl0KEpiKSxlaz1MZSh7fSxDcyx7dG91Y2hlczowLHRhcmdldFRvdWNoZXM6MCxjaGFuZ2VkVG91Y2hlczowLGFsdEtleTowLG1ldGFLZXk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxnZXRNb2RpZmllclN0YXRlOmdmfSksdGs9WXQoZWspLG5rPUxlKHt9LFhvLHtwcm9wZXJ0eU5hbWU6MCxlbGFwc2VkVGltZTowLHBzZXVkb0VsZW1lbnQ6MH0pLHJrPVl0KG5rKSxvaz1MZSh7fSxLbCx7ZGVsdGFYOmZ1bmN0aW9uKGUpe3JldHVybiJkZWx0YVgiaW4gZT9lLmRlbHRhWDoid2hlZWxEZWx0YVgiaW4gZT8tZS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oZSl7cmV0dXJuImRlbHRhWSJpbiBlP2UuZGVsdGFZOiJ3aGVlbERlbHRhWSJpbiBlPy1lLndoZWVsRGVsdGFZOiJ3aGVlbERlbHRhImluIGU/LWUud2hlZWxEZWx0YTowfSxkZWx0YVo6MCxkZWx0YU1vZGU6MH0pLGlrPVl0KG9rKSxzaz1bOSwxMywyNywzMl0seWY9UW4mJiJDb21wb3NpdGlvbkV2ZW50ImluIHdpbmRvdyxQaT1udWxsO1FuJiYiZG9jdW1lbnRNb2RlImluIGRvY3VtZW50JiYoUGk9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgYWs9UW4mJiJUZXh0RXZlbnQiaW4gd2luZG93JiYhUGksSHk9UW4mJigheWZ8fFBpJiY4PFBpJiYxMT49UGkpLHhtPSIgIixDbT0hMTtmdW5jdGlvbiBWeShlLHQpe3N3aXRjaChlKXtjYXNlImtleXVwIjpyZXR1cm4gc2suaW5kZXhPZih0LmtleUNvZGUpIT09LTE7Y2FzZSJrZXlkb3duIjpyZXR1cm4gdC5rZXlDb2RlIT09MjI5O2Nhc2Uia2V5cHJlc3MiOmNhc2UibW91c2Vkb3duIjpjYXNlImZvY3Vzb3V0IjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBLeShlKXtyZXR1cm4gZT1lLmRldGFpbCx0eXBlb2YgZT09Im9iamVjdCImJiJkYXRhImluIGU/ZS5kYXRhOm51bGx9dmFyIGZvPSExO2Z1bmN0aW9uIGxrKGUsdCl7c3dpdGNoKGUpe2Nhc2UiY29tcG9zaXRpb25lbmQiOnJldHVybiBLeSh0KTtjYXNlImtleXByZXNzIjpyZXR1cm4gdC53aGljaCE9PTMyP251bGw6KENtPSEwLHhtKTtjYXNlInRleHRJbnB1dCI6cmV0dXJuIGU9dC5kYXRhLGU9PT14bSYmQ20/bnVsbDplO2RlZmF1bHQ6cmV0dXJuIG51bGx9fWZ1bmN0aW9uIHVrKGUsdCl7aWYoZm8pcmV0dXJuIGU9PT0iY29tcG9zaXRpb25lbmQifHwheWYmJlZ5KGUsdCk/KGU9VXkoKSx1YT1tZj1jcj1udWxsLGZvPSExLGUpOm51bGw7c3dpdGNoKGUpe2Nhc2UicGFzdGUiOnJldHVybiBudWxsO2Nhc2Uia2V5cHJlc3MiOmlmKCEodC5jdHJsS2V5fHx0LmFsdEtleXx8dC5tZXRhS2V5KXx8dC5jdHJsS2V5JiZ0LmFsdEtleSl7aWYodC5jaGFyJiYxPHQuY2hhci5sZW5ndGgpcmV0dXJuIHQuY2hhcjtpZih0LndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHQud2hpY2gpfXJldHVybiBudWxsO2Nhc2UiY29tcG9zaXRpb25lbmQiOnJldHVybiBIeSYmdC5sb2NhbGUhPT0ia28iP251bGw6dC5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fXZhciBjaz17Y29sb3I6ITAsZGF0ZTohMCxkYXRldGltZTohMCwiZGF0ZXRpbWUtbG9jYWwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07ZnVuY3Rpb24gYm0oZSl7dmFyIHQ9ZSYmZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09ImlucHV0Ij8hIWNrW2UudHlwZV06dD09PSJ0ZXh0YXJlYSJ9ZnVuY3Rpb24gWXkoZSx0LG4scil7a3kociksdD1JYSh0LCJvbkNoYW5nZSIpLDA8dC5sZW5ndGgmJihuPW5ldyBoZigib25DaGFuZ2UiLCJjaGFuZ2UiLG51bGwsbixyKSxlLnB1c2goe2V2ZW50Om4sbGlzdGVuZXJzOnR9KSl9dmFyICRpPW51bGwscWk9bnVsbDtmdW5jdGlvbiBkayhlKXtvdihlLDApfWZ1bmN0aW9uIFlsKGUpe3ZhciB0PWhvKGUpO2lmKHl5KHQpKXJldHVybiBlfWZ1bmN0aW9uIGZrKGUsdCl7aWYoZT09PSJjaGFuZ2UiKXJldHVybiB0fXZhciBHeT0hMTtpZihRbil7dmFyIE51O2lmKFFuKXt2YXIgSXU9Im9uaW5wdXQiaW4gZG9jdW1lbnQ7aWYoIUl1KXt2YXIga209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7a20uc2V0QXR0cmlidXRlKCJvbmlucHV0IiwicmV0dXJuOyIpLEl1PXR5cGVvZiBrbS5vbmlucHV0PT0iZnVuY3Rpb24ifU51PUl1fWVsc2UgTnU9ITE7R3k9TnUmJighZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9kZSl9ZnVuY3Rpb24gRW0oKXskaSYmKCRpLmRldGFjaEV2ZW50KCJvbnByb3BlcnR5Y2hhbmdlIixReSkscWk9JGk9bnVsbCl9ZnVuY3Rpb24gUXkoZSl7aWYoZS5wcm9wZXJ0eU5hbWU9PT0idmFsdWUiJiZZbChxaSkpe3ZhciB0PVtdO1l5KHQscWksZSx1ZihlKSksUHkoZGssdCl9fWZ1bmN0aW9uIHBrKGUsdCxuKXtlPT09ImZvY3VzaW4iPyhFbSgpLCRpPXQscWk9biwkaS5hdHRhY2hFdmVudCgib25wcm9wZXJ0eWNoYW5nZSIsUXkpKTplPT09ImZvY3Vzb3V0IiYmRW0oKX1mdW5jdGlvbiBtayhlKXtpZihlPT09InNlbGVjdGlvbmNoYW5nZSJ8fGU9PT0ia2V5dXAifHxlPT09ImtleWRvd24iKXJldHVybiBZbChxaSl9ZnVuY3Rpb24gaGsoZSx0KXtpZihlPT09ImNsaWNrIilyZXR1cm4gWWwodCl9ZnVuY3Rpb24gZ2soZSx0KXtpZihlPT09ImlucHV0Inx8ZT09PSJjaGFuZ2UiKXJldHVybiBZbCh0KX1mdW5jdGlvbiB5ayhlLHQpe3JldHVybiBlPT09dCYmKGUhPT0wfHwxL2U9PT0xL3QpfHxlIT09ZSYmdCE9PXR9dmFyIHduPXR5cGVvZiBPYmplY3QuaXM9PSJmdW5jdGlvbiI/T2JqZWN0LmlzOnlrO2Z1bmN0aW9uIFppKGUsdCl7aWYod24oZSx0KSlyZXR1cm4hMDtpZih0eXBlb2YgZSE9Im9iamVjdCJ8fGU9PT1udWxsfHx0eXBlb2YgdCE9Im9iamVjdCJ8fHQ9PT1udWxsKXJldHVybiExO3ZhciBuPU9iamVjdC5rZXlzKGUpLHI9T2JqZWN0LmtleXModCk7aWYobi5sZW5ndGghPT1yLmxlbmd0aClyZXR1cm4hMTtmb3Iocj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdO2lmKCF5Yy5jYWxsKHQsbyl8fCF3bihlW29dLHRbb10pKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIFJtKGUpe2Zvcig7ZSYmZS5maXJzdENoaWxkOyllPWUuZmlyc3RDaGlsZDtyZXR1cm4gZX1mdW5jdGlvbiBUbShlLHQpe3ZhciBuPVJtKGUpO2U9MDtmb3IodmFyIHI7bjspe2lmKG4ubm9kZVR5cGU9PT0zKXtpZihyPWUrbi50ZXh0Q29udGVudC5sZW5ndGgsZTw9dCYmcj49dClyZXR1cm57bm9kZTpuLG9mZnNldDp0LWV9O2U9cn1lOntmb3IoO247KXtpZihuLm5leHRTaWJsaW5nKXtuPW4ubmV4dFNpYmxpbmc7YnJlYWsgZX1uPW4ucGFyZW50Tm9kZX1uPXZvaWQgMH1uPVJtKG4pfX1mdW5jdGlvbiBYeShlLHQpe3JldHVybiBlJiZ0P2U9PT10PyEwOmUmJmUubm9kZVR5cGU9PT0zPyExOnQmJnQubm9kZVR5cGU9PT0zP1h5KGUsdC5wYXJlbnROb2RlKToiY29udGFpbnMiaW4gZT9lLmNvbnRhaW5zKHQpOmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSYxNik6ITE6ITF9ZnVuY3Rpb24gcXkoKXtmb3IodmFyIGU9d2luZG93LHQ9VGEoKTt0IGluc3RhbmNlb2YgZS5IVE1MSUZyYW1lRWxlbWVudDspe3RyeXt2YXIgbj10eXBlb2YgdC5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWY9PSJzdHJpbmcifWNhdGNoe249ITF9aWYobillPXQuY29udGVudFdpbmRvdztlbHNlIGJyZWFrO3Q9VGEoZS5kb2N1bWVudCl9cmV0dXJuIHR9ZnVuY3Rpb24gdmYoZSl7dmFyIHQ9ZSYmZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiB0JiYodD09PSJpbnB1dCImJihlLnR5cGU9PT0idGV4dCJ8fGUudHlwZT09PSJzZWFyY2gifHxlLnR5cGU9PT0idGVsInx8ZS50eXBlPT09InVybCJ8fGUudHlwZT09PSJwYXNzd29yZCIpfHx0PT09InRleHRhcmVhInx8ZS5jb250ZW50RWRpdGFibGU9PT0idHJ1ZSIpfWZ1bmN0aW9uIHZrKGUpe3ZhciB0PXF5KCksbj1lLmZvY3VzZWRFbGVtLHI9ZS5zZWxlY3Rpb25SYW5nZTtpZih0IT09biYmbiYmbi5vd25lckRvY3VtZW50JiZYeShuLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LG4pKXtpZihyIT09bnVsbCYmdmYobikpe2lmKHQ9ci5zdGFydCxlPXIuZW5kLGU9PT12b2lkIDAmJihlPXQpLCJzZWxlY3Rpb25TdGFydCJpbiBuKW4uc2VsZWN0aW9uU3RhcnQ9dCxuLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihlLG4udmFsdWUubGVuZ3RoKTtlbHNlIGlmKGU9KHQ9bi5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJnQuZGVmYXVsdFZpZXd8fHdpbmRvdyxlLmdldFNlbGVjdGlvbil7ZT1lLmdldFNlbGVjdGlvbigpO3ZhciBvPW4udGV4dENvbnRlbnQubGVuZ3RoLGk9TWF0aC5taW4oci5zdGFydCxvKTtyPXIuZW5kPT09dm9pZCAwP2k6TWF0aC5taW4oci5lbmQsbyksIWUuZXh0ZW5kJiZpPnImJihvPXIscj1pLGk9byksbz1UbShuLGkpO3ZhciBzPVRtKG4scik7byYmcyYmKGUucmFuZ2VDb3VudCE9PTF8fGUuYW5jaG9yTm9kZSE9PW8ubm9kZXx8ZS5hbmNob3JPZmZzZXQhPT1vLm9mZnNldHx8ZS5mb2N1c05vZGUhPT1zLm5vZGV8fGUuZm9jdXNPZmZzZXQhPT1zLm9mZnNldCkmJih0PXQuY3JlYXRlUmFuZ2UoKSx0LnNldFN0YXJ0KG8ubm9kZSxvLm9mZnNldCksZS5yZW1vdmVBbGxSYW5nZXMoKSxpPnI/KGUuYWRkUmFuZ2UodCksZS5leHRlbmQocy5ub2RlLHMub2Zmc2V0KSk6KHQuc2V0RW5kKHMubm9kZSxzLm9mZnNldCksZS5hZGRSYW5nZSh0KSkpfX1mb3IodD1bXSxlPW47ZT1lLnBhcmVudE5vZGU7KWUubm9kZVR5cGU9PT0xJiZ0LnB1c2goe2VsZW1lbnQ6ZSxsZWZ0OmUuc2Nyb2xsTGVmdCx0b3A6ZS5zY3JvbGxUb3B9KTtmb3IodHlwZW9mIG4uZm9jdXM9PSJmdW5jdGlvbiImJm4uZm9jdXMoKSxuPTA7bjx0Lmxlbmd0aDtuKyspZT10W25dLGUuZWxlbWVudC5zY3JvbGxMZWZ0PWUubGVmdCxlLmVsZW1lbnQuc2Nyb2xsVG9wPWUudG9wfX12YXIgd2s9UW4mJiJkb2N1bWVudE1vZGUiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUscG89bnVsbCx6Yz1udWxsLE9pPW51bGwsTGM9ITE7ZnVuY3Rpb24gUG0oZSx0LG4pe3ZhciByPW4ud2luZG93PT09bj9uLmRvY3VtZW50Om4ubm9kZVR5cGU9PT05P246bi5vd25lckRvY3VtZW50O0xjfHxwbz09bnVsbHx8cG8hPT1UYShyKXx8KHI9cG8sInNlbGVjdGlvblN0YXJ0ImluIHImJnZmKHIpP3I9e3N0YXJ0OnIuc2VsZWN0aW9uU3RhcnQsZW5kOnIuc2VsZWN0aW9uRW5kfToocj0oci5vd25lckRvY3VtZW50JiZyLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdykuZ2V0U2VsZWN0aW9uKCkscj17YW5jaG9yTm9kZTpyLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OnIuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpyLmZvY3VzTm9kZSxmb2N1c09mZnNldDpyLmZvY3VzT2Zmc2V0fSksT2kmJlppKE9pLHIpfHwoT2k9cixyPUlhKHpjLCJvblNlbGVjdCIpLDA8ci5sZW5ndGgmJih0PW5ldyBoZigib25TZWxlY3QiLCJzZWxlY3QiLG51bGwsdCxuKSxlLnB1c2goe2V2ZW50OnQsbGlzdGVuZXJzOnJ9KSx0LnRhcmdldD1wbykpKX1mdW5jdGlvbiBEcyhlLHQpe3ZhciBuPXt9O3JldHVybiBuW2UudG9Mb3dlckNhc2UoKV09dC50b0xvd2VyQ2FzZSgpLG5bIldlYmtpdCIrZV09IndlYmtpdCIrdCxuWyJNb3oiK2VdPSJtb3oiK3Qsbn12YXIgbW89e2FuaW1hdGlvbmVuZDpEcygiQW5pbWF0aW9uIiwiQW5pbWF0aW9uRW5kIiksYW5pbWF0aW9uaXRlcmF0aW9uOkRzKCJBbmltYXRpb24iLCJBbmltYXRpb25JdGVyYXRpb24iKSxhbmltYXRpb25zdGFydDpEcygiQW5pbWF0aW9uIiwiQW5pbWF0aW9uU3RhcnQiKSx0cmFuc2l0aW9uZW5kOkRzKCJUcmFuc2l0aW9uIiwiVHJhbnNpdGlvbkVuZCIpfSxBdT17fSxaeT17fTtRbiYmKFp5PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLnN0eWxlLCJBbmltYXRpb25FdmVudCJpbiB3aW5kb3d8fChkZWxldGUgbW8uYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixkZWxldGUgbW8uYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixkZWxldGUgbW8uYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSwiVHJhbnNpdGlvbkV2ZW50ImluIHdpbmRvd3x8ZGVsZXRlIG1vLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7ZnVuY3Rpb24gR2woZSl7aWYoQXVbZV0pcmV0dXJuIEF1W2VdO2lmKCFtb1tlXSlyZXR1cm4gZTt2YXIgdD1tb1tlXSxuO2ZvcihuIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShuKSYmbiBpbiBaeSlyZXR1cm4gQXVbZV09dFtuXTtyZXR1cm4gZX12YXIgSnk9R2woImFuaW1hdGlvbmVuZCIpLGV2PUdsKCJhbmltYXRpb25pdGVyYXRpb24iKSx0dj1HbCgiYW5pbWF0aW9uc3RhcnQiKSxudj1HbCgidHJhbnNpdGlvbmVuZCIpLHJ2PW5ldyBNYXAsJG09ImFib3J0IGF1eENsaWNrIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGdvdFBvaW50ZXJDYXB0dXJlIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IGxvc3RQb2ludGVyQ2FwdHVyZSBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwb2ludGVyQ2FuY2VsIHBvaW50ZXJEb3duIHBvaW50ZXJNb3ZlIHBvaW50ZXJPdXQgcG9pbnRlck92ZXIgcG9pbnRlclVwIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b3VjaENhbmNlbCB0b3VjaEVuZCB0b3VjaFN0YXJ0IHZvbHVtZUNoYW5nZSBzY3JvbGwgdG9nZ2xlIHRvdWNoTW92ZSB3YWl0aW5nIHdoZWVsIi5zcGxpdCgiICIpO2Z1bmN0aW9uIGtyKGUsdCl7cnYuc2V0KGUsdCkscXIodCxbZV0pfWZvcih2YXIgenU9MDt6dTwkbS5sZW5ndGg7enUrKyl7dmFyIEx1PSRtW3p1XSxTaz1MdS50b0xvd2VyQ2FzZSgpLHhrPUx1WzBdLnRvVXBwZXJDYXNlKCkrTHUuc2xpY2UoMSk7a3IoU2ssIm9uIit4ayl9a3IoSnksIm9uQW5pbWF0aW9uRW5kIik7a3IoZXYsIm9uQW5pbWF0aW9uSXRlcmF0aW9uIik7a3IodHYsIm9uQW5pbWF0aW9uU3RhcnQiKTtrcigiZGJsY2xpY2siLCJvbkRvdWJsZUNsaWNrIik7a3IoImZvY3VzaW4iLCJvbkZvY3VzIik7a3IoImZvY3Vzb3V0Iiwib25CbHVyIik7a3IobnYsIm9uVHJhbnNpdGlvbkVuZCIpO05vKCJvbk1vdXNlRW50ZXIiLFsibW91c2VvdXQiLCJtb3VzZW92ZXIiXSk7Tm8oIm9uTW91c2VMZWF2ZSIsWyJtb3VzZW91dCIsIm1vdXNlb3ZlciJdKTtObygib25Qb2ludGVyRW50ZXIiLFsicG9pbnRlcm91dCIsInBvaW50ZXJvdmVyIl0pO05vKCJvblBvaW50ZXJMZWF2ZSIsWyJwb2ludGVyb3V0IiwicG9pbnRlcm92ZXIiXSk7cXIoIm9uQ2hhbmdlIiwiY2hhbmdlIGNsaWNrIGZvY3VzaW4gZm9jdXNvdXQgaW5wdXQga2V5ZG93biBrZXl1cCBzZWxlY3Rpb25jaGFuZ2UiLnNwbGl0KCIgIikpO3FyKCJvblNlbGVjdCIsImZvY3Vzb3V0IGNvbnRleHRtZW51IGRyYWdlbmQgZm9jdXNpbiBrZXlkb3duIGtleXVwIG1vdXNlZG93biBtb3VzZXVwIHNlbGVjdGlvbmNoYW5nZSIuc3BsaXQoIiAiKSk7cXIoIm9uQmVmb3JlSW5wdXQiLFsiY29tcG9zaXRpb25lbmQiLCJrZXlwcmVzcyIsInRleHRJbnB1dCIsInBhc3RlIl0pO3FyKCJvbkNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd24iLnNwbGl0KCIgIikpO3FyKCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvbnN0YXJ0IGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duIi5zcGxpdCgiICIpKTtxcigib25Db21wb3NpdGlvblVwZGF0ZSIsImNvbXBvc2l0aW9udXBkYXRlIGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duIi5zcGxpdCgiICIpKTt2YXIgQ2k9ImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2UgcmVzaXplIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VzcGVuZCB0aW1ldXBkYXRlIHZvbHVtZWNoYW5nZSB3YWl0aW5nIi5zcGxpdCgiICIpLENrPW5ldyBTZXQoImNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHRvZ2dsZSIuc3BsaXQoIiAiKS5jb25jYXQoQ2kpKTtmdW5jdGlvbiBPbShlLHQsbil7dmFyIHI9ZS50eXBlfHwidW5rbm93bi1ldmVudCI7ZS5jdXJyZW50VGFyZ2V0PW4sU2Iocix0LHZvaWQgMCxlKSxlLmN1cnJlbnRUYXJnZXQ9bnVsbH1mdW5jdGlvbiBvdihlLHQpe3Q9KHQmNCkhPT0wO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dLG89ci5ldmVudDtyPXIubGlzdGVuZXJzO2U6e3ZhciBpPXZvaWQgMDtpZih0KWZvcih2YXIgcz1yLmxlbmd0aC0xOzA8PXM7cy0tKXt2YXIgYT1yW3NdLGw9YS5pbnN0YW5jZSx1PWEuY3VycmVudFRhcmdldDtpZihhPWEubGlzdGVuZXIsbCE9PWkmJm8uaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBlO09tKG8sYSx1KSxpPWx9ZWxzZSBmb3Iocz0wO3M8ci5sZW5ndGg7cysrKXtpZihhPXJbc10sbD1hLmluc3RhbmNlLHU9YS5jdXJyZW50VGFyZ2V0LGE9YS5saXN0ZW5lcixsIT09aSYmby5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGU7T20obyxhLHUpLGk9bH19fWlmKCRhKXRocm93IGU9X2MsJGE9ITEsX2M9bnVsbCxlfWZ1bmN0aW9uIFBlKGUsdCl7dmFyIG49dFtXY107bj09PXZvaWQgMCYmKG49dFtXY109bmV3IFNldCk7dmFyIHI9ZSsiX19idWJibGUiO24uaGFzKHIpfHwoaXYodCxlLDIsITEpLG4uYWRkKHIpKX1mdW5jdGlvbiBqdShlLHQsbil7dmFyIHI9MDt0JiYocnw9NCksaXYobixlLHIsdCl9dmFyIEZzPSJfcmVhY3RMaXN0ZW5pbmciK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO2Z1bmN0aW9uIEppKGUpe2lmKCFlW0ZzXSl7ZVtGc109ITAsZnkuZm9yRWFjaChmdW5jdGlvbihuKXtuIT09InNlbGVjdGlvbmNoYW5nZSImJihDay5oYXMobil8fGp1KG4sITEsZSksanUobiwhMCxlKSl9KTt2YXIgdD1lLm5vZGVUeXBlPT09OT9lOmUub3duZXJEb2N1bWVudDt0PT09bnVsbHx8dFtGc118fCh0W0ZzXT0hMCxqdSgic2VsZWN0aW9uY2hhbmdlIiwhMSx0KSl9fWZ1bmN0aW9uIGl2KGUsdCxuLHIpe3N3aXRjaChXeSh0KSl7Y2FzZSAxOnZhciBvPXpiO2JyZWFrO2Nhc2UgNDpvPUxiO2JyZWFrO2RlZmF1bHQ6bz1wZn1uPW8uYmluZChudWxsLHQsbixlKSxvPXZvaWQgMCwhTWN8fHQhPT0idG91Y2hzdGFydCImJnQhPT0idG91Y2htb3ZlIiYmdCE9PSJ3aGVlbCJ8fChvPSEwKSxyP28hPT12b2lkIDA/ZS5hZGRFdmVudExpc3RlbmVyKHQsbix7Y2FwdHVyZTohMCxwYXNzaXZlOm99KTplLmFkZEV2ZW50TGlzdGVuZXIodCxuLCEwKTpvIT09dm9pZCAwP2UuYWRkRXZlbnRMaXN0ZW5lcih0LG4se3Bhc3NpdmU6b30pOmUuYWRkRXZlbnRMaXN0ZW5lcih0LG4sITEpfWZ1bmN0aW9uIER1KGUsdCxuLHIsbyl7dmFyIGk9cjtpZighKHQmMSkmJiEodCYyKSYmciE9PW51bGwpZTpmb3IoOzspe2lmKHI9PT1udWxsKXJldHVybjt2YXIgcz1yLnRhZztpZihzPT09M3x8cz09PTQpe3ZhciBhPXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aWYoYT09PW98fGEubm9kZVR5cGU9PT04JiZhLnBhcmVudE5vZGU9PT1vKWJyZWFrO2lmKHM9PT00KWZvcihzPXIucmV0dXJuO3MhPT1udWxsOyl7dmFyIGw9cy50YWc7aWYoKGw9PT0zfHxsPT09NCkmJihsPXMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sbD09PW98fGwubm9kZVR5cGU9PT04JiZsLnBhcmVudE5vZGU9PT1vKSlyZXR1cm47cz1zLnJldHVybn1mb3IoO2EhPT1udWxsOyl7aWYocz16cihhKSxzPT09bnVsbClyZXR1cm47aWYobD1zLnRhZyxsPT09NXx8bD09PTYpe3I9aT1zO2NvbnRpbnVlIGV9YT1hLnBhcmVudE5vZGV9fXI9ci5yZXR1cm59UHkoZnVuY3Rpb24oKXt2YXIgdT1pLGM9dWYobiksZD1bXTtlOnt2YXIgbT1ydi5nZXQoZSk7aWYobSE9PXZvaWQgMCl7dmFyIHY9aGYsdz1lO3N3aXRjaChlKXtjYXNlImtleXByZXNzIjppZihjYShuKT09PTApYnJlYWsgZTtjYXNlImtleWRvd24iOmNhc2Uia2V5dXAiOnY9WmI7YnJlYWs7Y2FzZSJmb2N1c2luIjp3PSJmb2N1cyIsdj1fdTticmVhaztjYXNlImZvY3Vzb3V0Ijp3PSJibHVyIix2PV91O2JyZWFrO2Nhc2UiYmVmb3JlYmx1ciI6Y2FzZSJhZnRlcmJsdXIiOnY9X3U7YnJlYWs7Y2FzZSJjbGljayI6aWYobi5idXR0b249PT0yKWJyZWFrIGU7Y2FzZSJhdXhjbGljayI6Y2FzZSJkYmxjbGljayI6Y2FzZSJtb3VzZWRvd24iOmNhc2UibW91c2Vtb3ZlIjpjYXNlIm1vdXNldXAiOmNhc2UibW91c2VvdXQiOmNhc2UibW91c2VvdmVyIjpjYXNlImNvbnRleHRtZW51Ijp2PXZtO2JyZWFrO2Nhc2UiZHJhZyI6Y2FzZSJkcmFnZW5kIjpjYXNlImRyYWdlbnRlciI6Y2FzZSJkcmFnZXhpdCI6Y2FzZSJkcmFnbGVhdmUiOmNhc2UiZHJhZ292ZXIiOmNhc2UiZHJhZ3N0YXJ0IjpjYXNlImRyb3AiOnY9RmI7YnJlYWs7Y2FzZSJ0b3VjaGNhbmNlbCI6Y2FzZSJ0b3VjaGVuZCI6Y2FzZSJ0b3VjaG1vdmUiOmNhc2UidG91Y2hzdGFydCI6dj10azticmVhaztjYXNlIEp5OmNhc2UgZXY6Y2FzZSB0djp2PVViO2JyZWFrO2Nhc2UgbnY6dj1yazticmVhaztjYXNlInNjcm9sbCI6dj1qYjticmVhaztjYXNlIndoZWVsIjp2PWlrO2JyZWFrO2Nhc2UiY29weSI6Y2FzZSJjdXQiOmNhc2UicGFzdGUiOnY9VmI7YnJlYWs7Y2FzZSJnb3Rwb2ludGVyY2FwdHVyZSI6Y2FzZSJsb3N0cG9pbnRlcmNhcHR1cmUiOmNhc2UicG9pbnRlcmNhbmNlbCI6Y2FzZSJwb2ludGVyZG93biI6Y2FzZSJwb2ludGVybW92ZSI6Y2FzZSJwb2ludGVyb3V0IjpjYXNlInBvaW50ZXJvdmVyIjpjYXNlInBvaW50ZXJ1cCI6dj1TbX12YXIgUz0odCY0KSE9PTAseD0hUyYmZT09PSJzY3JvbGwiLGg9Uz9tIT09bnVsbD9tKyJDYXB0dXJlIjpudWxsOm07Uz1bXTtmb3IodmFyIGc9dSxmO2chPT1udWxsOyl7Zj1nO3ZhciB5PWYuc3RhdGVOb2RlO2lmKGYudGFnPT09NSYmeSE9PW51bGwmJihmPXksaCE9PW51bGwmJih5PVlpKGcsaCkseSE9bnVsbCYmUy5wdXNoKGVzKGcseSxmKSkpKSx4KWJyZWFrO2c9Zy5yZXR1cm59MDxTLmxlbmd0aCYmKG09bmV3IHYobSx3LG51bGwsbixjKSxkLnB1c2goe2V2ZW50Om0sbGlzdGVuZXJzOlN9KSl9fWlmKCEodCY3KSl7ZTp7aWYobT1lPT09Im1vdXNlb3ZlciJ8fGU9PT0icG9pbnRlcm92ZXIiLHY9ZT09PSJtb3VzZW91dCJ8fGU9PT0icG9pbnRlcm91dCIsbSYmbiE9PSRjJiYodz1uLnJlbGF0ZWRUYXJnZXR8fG4uZnJvbUVsZW1lbnQpJiYoenIodyl8fHdbWG5dKSlicmVhayBlO2lmKCh2fHxtKSYmKG09Yy53aW5kb3c9PT1jP2M6KG09Yy5vd25lckRvY3VtZW50KT9tLmRlZmF1bHRWaWV3fHxtLnBhcmVudFdpbmRvdzp3aW5kb3csdj8odz1uLnJlbGF0ZWRUYXJnZXR8fG4udG9FbGVtZW50LHY9dSx3PXc/enIodyk6bnVsbCx3IT09bnVsbCYmKHg9WnIodyksdyE9PXh8fHcudGFnIT09NSYmdy50YWchPT02KSYmKHc9bnVsbCkpOih2PW51bGwsdz11KSx2IT09dykpe2lmKFM9dm0seT0ib25Nb3VzZUxlYXZlIixoPSJvbk1vdXNlRW50ZXIiLGc9Im1vdXNlIiwoZT09PSJwb2ludGVyb3V0Inx8ZT09PSJwb2ludGVyb3ZlciIpJiYoUz1TbSx5PSJvblBvaW50ZXJMZWF2ZSIsaD0ib25Qb2ludGVyRW50ZXIiLGc9InBvaW50ZXIiKSx4PXY9PW51bGw/bTpobyh2KSxmPXc9PW51bGw/bTpobyh3KSxtPW5ldyBTKHksZysibGVhdmUiLHYsbixjKSxtLnRhcmdldD14LG0ucmVsYXRlZFRhcmdldD1mLHk9bnVsbCx6cihjKT09PXUmJihTPW5ldyBTKGgsZysiZW50ZXIiLHcsbixjKSxTLnRhcmdldD1mLFMucmVsYXRlZFRhcmdldD14LHk9UykseD15LHYmJncpdDp7Zm9yKFM9dixoPXcsZz0wLGY9UztmO2Y9b28oZikpZysrO2ZvcihmPTAseT1oO3k7eT1vbyh5KSlmKys7Zm9yKDswPGctZjspUz1vbyhTKSxnLS07Zm9yKDswPGYtZzspaD1vbyhoKSxmLS07Zm9yKDtnLS07KXtpZihTPT09aHx8aCE9PW51bGwmJlM9PT1oLmFsdGVybmF0ZSlicmVhayB0O1M9b28oUyksaD1vbyhoKX1TPW51bGx9ZWxzZSBTPW51bGw7diE9PW51bGwmJk1tKGQsbSx2LFMsITEpLHchPT1udWxsJiZ4IT09bnVsbCYmTW0oZCx4LHcsUywhMCl9fWU6e2lmKG09dT9obyh1KTp3aW5kb3csdj1tLm5vZGVOYW1lJiZtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksdj09PSJzZWxlY3QifHx2PT09ImlucHV0IiYmbS50eXBlPT09ImZpbGUiKXZhciBiPWZrO2Vsc2UgaWYoYm0obSkpaWYoR3kpYj1naztlbHNle2I9bWs7dmFyIEU9cGt9ZWxzZSh2PW0ubm9kZU5hbWUpJiZ2LnRvTG93ZXJDYXNlKCk9PT0iaW5wdXQiJiYobS50eXBlPT09ImNoZWNrYm94Inx8bS50eXBlPT09InJhZGlvIikmJihiPWhrKTtpZihiJiYoYj1iKGUsdSkpKXtZeShkLGIsbixjKTticmVhayBlfUUmJkUoZSxtLHUpLGU9PT0iZm9jdXNvdXQiJiYoRT1tLl93cmFwcGVyU3RhdGUpJiZFLmNvbnRyb2xsZWQmJm0udHlwZT09PSJudW1iZXIiJiZrYyhtLCJudW1iZXIiLG0udmFsdWUpfXN3aXRjaChFPXU/aG8odSk6d2luZG93LGUpe2Nhc2UiZm9jdXNpbiI6KGJtKEUpfHxFLmNvbnRlbnRFZGl0YWJsZT09PSJ0cnVlIikmJihwbz1FLHpjPXUsT2k9bnVsbCk7YnJlYWs7Y2FzZSJmb2N1c291dCI6T2k9emM9cG89bnVsbDticmVhaztjYXNlIm1vdXNlZG93biI6TGM9ITA7YnJlYWs7Y2FzZSJjb250ZXh0bWVudSI6Y2FzZSJtb3VzZXVwIjpjYXNlImRyYWdlbmQiOkxjPSExLFBtKGQsbixjKTticmVhaztjYXNlInNlbGVjdGlvbmNoYW5nZSI6aWYod2spYnJlYWs7Y2FzZSJrZXlkb3duIjpjYXNlImtleXVwIjpQbShkLG4sYyl9dmFyIFI7aWYoeWYpZTp7c3dpdGNoKGUpe2Nhc2UiY29tcG9zaXRpb25zdGFydCI6dmFyIFA9Im9uQ29tcG9zaXRpb25TdGFydCI7YnJlYWsgZTtjYXNlImNvbXBvc2l0aW9uZW5kIjpQPSJvbkNvbXBvc2l0aW9uRW5kIjticmVhayBlO2Nhc2UiY29tcG9zaXRpb251cGRhdGUiOlA9Im9uQ29tcG9zaXRpb25VcGRhdGUiO2JyZWFrIGV9UD12b2lkIDB9ZWxzZSBmbz9WeShlLG4pJiYoUD0ib25Db21wb3NpdGlvbkVuZCIpOmU9PT0ia2V5ZG93biImJm4ua2V5Q29kZT09PTIyOSYmKFA9Im9uQ29tcG9zaXRpb25TdGFydCIpO1AmJihIeSYmbi5sb2NhbGUhPT0ia28iJiYoZm98fFAhPT0ib25Db21wb3NpdGlvblN0YXJ0Ij9QPT09Im9uQ29tcG9zaXRpb25FbmQiJiZmbyYmKFI9VXkoKSk6KGNyPWMsbWY9InZhbHVlImluIGNyP2NyLnZhbHVlOmNyLnRleHRDb250ZW50LGZvPSEwKSksRT1JYSh1LFApLDA8RS5sZW5ndGgmJihQPW5ldyB3bShQLGUsbnVsbCxuLGMpLGQucHVzaCh7ZXZlbnQ6UCxsaXN0ZW5lcnM6RX0pLFI/UC5kYXRhPVI6KFI9S3kobiksUiE9PW51bGwmJihQLmRhdGE9UikpKSksKFI9YWs/bGsoZSxuKTp1ayhlLG4pKSYmKHU9SWEodSwib25CZWZvcmVJbnB1dCIpLDA8dS5sZW5ndGgmJihjPW5ldyB3bSgib25CZWZvcmVJbnB1dCIsImJlZm9yZWlucHV0IixudWxsLG4sYyksZC5wdXNoKHtldmVudDpjLGxpc3RlbmVyczp1fSksYy5kYXRhPVIpKX1vdihkLHQpfSl9ZnVuY3Rpb24gZXMoZSx0LG4pe3JldHVybntpbnN0YW5jZTplLGxpc3RlbmVyOnQsY3VycmVudFRhcmdldDpufX1mdW5jdGlvbiBJYShlLHQpe2Zvcih2YXIgbj10KyJDYXB0dXJlIixyPVtdO2UhPT1udWxsOyl7dmFyIG89ZSxpPW8uc3RhdGVOb2RlO28udGFnPT09NSYmaSE9PW51bGwmJihvPWksaT1ZaShlLG4pLGkhPW51bGwmJnIudW5zaGlmdChlcyhlLGksbykpLGk9WWkoZSx0KSxpIT1udWxsJiZyLnB1c2goZXMoZSxpLG8pKSksZT1lLnJldHVybn1yZXR1cm4gcn1mdW5jdGlvbiBvbyhlKXtpZihlPT09bnVsbClyZXR1cm4gbnVsbDtkbyBlPWUucmV0dXJuO3doaWxlKGUmJmUudGFnIT09NSk7cmV0dXJuIGV8fG51bGx9ZnVuY3Rpb24gTW0oZSx0LG4scixvKXtmb3IodmFyIGk9dC5fcmVhY3ROYW1lLHM9W107biE9PW51bGwmJm4hPT1yOyl7dmFyIGE9bixsPWEuYWx0ZXJuYXRlLHU9YS5zdGF0ZU5vZGU7aWYobCE9PW51bGwmJmw9PT1yKWJyZWFrO2EudGFnPT09NSYmdSE9PW51bGwmJihhPXUsbz8obD1ZaShuLGkpLGwhPW51bGwmJnMudW5zaGlmdChlcyhuLGwsYSkpKTpvfHwobD1ZaShuLGkpLGwhPW51bGwmJnMucHVzaChlcyhuLGwsYSkpKSksbj1uLnJldHVybn1zLmxlbmd0aCE9PTAmJmUucHVzaCh7ZXZlbnQ6dCxsaXN0ZW5lcnM6c30pfXZhciBiaz0vXHJcbj8vZyxraz0vXHUwMDAwfFx1RkZGRC9nO2Z1bmN0aW9uIF9tKGUpe3JldHVybih0eXBlb2YgZT09InN0cmluZyI/ZToiIitlKS5yZXBsYWNlKGJrLGAKYCkucmVwbGFjZShraywiIil9ZnVuY3Rpb24gQnMoZSx0LG4pe2lmKHQ9X20odCksX20oZSkhPT10JiZuKXRocm93IEVycm9yKEYoNDI1KSl9ZnVuY3Rpb24gQWEoKXt9dmFyIGpjPW51bGwsRGM9bnVsbDtmdW5jdGlvbiBGYyhlLHQpe3JldHVybiBlPT09InRleHRhcmVhInx8ZT09PSJub3NjcmlwdCJ8fHR5cGVvZiB0LmNoaWxkcmVuPT0ic3RyaW5nInx8dHlwZW9mIHQuY2hpbGRyZW49PSJudW1iZXIifHx0eXBlb2YgdC5kYW5nZXJvdXNseVNldElubmVySFRNTD09Im9iamVjdCImJnQuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwhPT1udWxsJiZ0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCE9bnVsbH12YXIgQmM9dHlwZW9mIHNldFRpbWVvdXQ9PSJmdW5jdGlvbiI/c2V0VGltZW91dDp2b2lkIDAsRWs9dHlwZW9mIGNsZWFyVGltZW91dD09ImZ1bmN0aW9uIj9jbGVhclRpbWVvdXQ6dm9pZCAwLE5tPXR5cGVvZiBQcm9taXNlPT0iZnVuY3Rpb24iP1Byb21pc2U6dm9pZCAwLFJrPXR5cGVvZiBxdWV1ZU1pY3JvdGFzaz09ImZ1bmN0aW9uIj9xdWV1ZU1pY3JvdGFzazp0eXBlb2YgTm08InUiP2Z1bmN0aW9uKGUpe3JldHVybiBObS5yZXNvbHZlKG51bGwpLnRoZW4oZSkuY2F0Y2goVGspfTpCYztmdW5jdGlvbiBUayhlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZX0pfWZ1bmN0aW9uIEZ1KGUsdCl7dmFyIG49dCxyPTA7ZG97dmFyIG89bi5uZXh0U2libGluZztpZihlLnJlbW92ZUNoaWxkKG4pLG8mJm8ubm9kZVR5cGU9PT04KWlmKG49by5kYXRhLG49PT0iLyQiKXtpZihyPT09MCl7ZS5yZW1vdmVDaGlsZChvKSxYaSh0KTtyZXR1cm59ci0tfWVsc2UgbiE9PSIkIiYmbiE9PSIkPyImJm4hPT0iJCEifHxyKys7bj1vfXdoaWxlKG4pO1hpKHQpfWZ1bmN0aW9uIGhyKGUpe2Zvcig7ZSE9bnVsbDtlPWUubmV4dFNpYmxpbmcpe3ZhciB0PWUubm9kZVR5cGU7aWYodD09PTF8fHQ9PT0zKWJyZWFrO2lmKHQ9PT04KXtpZih0PWUuZGF0YSx0PT09IiQifHx0PT09IiQhInx8dD09PSIkPyIpYnJlYWs7aWYodD09PSIvJCIpcmV0dXJuIG51bGx9fXJldHVybiBlfWZ1bmN0aW9uIEltKGUpe2U9ZS5wcmV2aW91c1NpYmxpbmc7Zm9yKHZhciB0PTA7ZTspe2lmKGUubm9kZVR5cGU9PT04KXt2YXIgbj1lLmRhdGE7aWYobj09PSIkInx8bj09PSIkISJ8fG49PT0iJD8iKXtpZih0PT09MClyZXR1cm4gZTt0LS19ZWxzZSBuPT09Ii8kIiYmdCsrfWU9ZS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIHFvPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLE1uPSJfX3JlYWN0RmliZXIkIitxbyx0cz0iX19yZWFjdFByb3BzJCIrcW8sWG49Il9fcmVhY3RDb250YWluZXIkIitxbyxXYz0iX19yZWFjdEV2ZW50cyQiK3FvLFBrPSJfX3JlYWN0TGlzdGVuZXJzJCIrcW8sJGs9Il9fcmVhY3RIYW5kbGVzJCIrcW87ZnVuY3Rpb24genIoZSl7dmFyIHQ9ZVtNbl07aWYodClyZXR1cm4gdDtmb3IodmFyIG49ZS5wYXJlbnROb2RlO247KXtpZih0PW5bWG5dfHxuW01uXSl7aWYobj10LmFsdGVybmF0ZSx0LmNoaWxkIT09bnVsbHx8biE9PW51bGwmJm4uY2hpbGQhPT1udWxsKWZvcihlPUltKGUpO2UhPT1udWxsOyl7aWYobj1lW01uXSlyZXR1cm4gbjtlPUltKGUpfXJldHVybiB0fWU9bixuPWUucGFyZW50Tm9kZX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBicyhlKXtyZXR1cm4gZT1lW01uXXx8ZVtYbl0sIWV8fGUudGFnIT09NSYmZS50YWchPT02JiZlLnRhZyE9PTEzJiZlLnRhZyE9PTM/bnVsbDplfWZ1bmN0aW9uIGhvKGUpe2lmKGUudGFnPT09NXx8ZS50YWc9PT02KXJldHVybiBlLnN0YXRlTm9kZTt0aHJvdyBFcnJvcihGKDMzKSl9ZnVuY3Rpb24gUWwoZSl7cmV0dXJuIGVbdHNdfHxudWxsfXZhciBVYz1bXSxnbz0tMTtmdW5jdGlvbiBFcihlKXtyZXR1cm57Y3VycmVudDplfX1mdW5jdGlvbiAkZShlKXswPmdvfHwoZS5jdXJyZW50PVVjW2dvXSxVY1tnb109bnVsbCxnby0tKX1mdW5jdGlvbiBUZShlLHQpe2dvKyssVWNbZ29dPWUuY3VycmVudCxlLmN1cnJlbnQ9dH12YXIgQ3I9e30sbXQ9RXIoQ3IpLEV0PUVyKCExKSxVcj1DcjtmdW5jdGlvbiBJbyhlLHQpe3ZhciBuPWUudHlwZS5jb250ZXh0VHlwZXM7aWYoIW4pcmV0dXJuIENyO3ZhciByPWUuc3RhdGVOb2RlO2lmKHImJnIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD09PXQpcmV0dXJuIHIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7dmFyIG89e30saTtmb3IoaSBpbiBuKW9baV09dFtpXTtyZXR1cm4gciYmKGU9ZS5zdGF0ZU5vZGUsZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PXQsZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1vKSxvfWZ1bmN0aW9uIFJ0KGUpe3JldHVybiBlPWUuY2hpbGRDb250ZXh0VHlwZXMsZSE9bnVsbH1mdW5jdGlvbiB6YSgpeyRlKEV0KSwkZShtdCl9ZnVuY3Rpb24gQW0oZSx0LG4pe2lmKG10LmN1cnJlbnQhPT1Dcil0aHJvdyBFcnJvcihGKDE2OCkpO1RlKG10LHQpLFRlKEV0LG4pfWZ1bmN0aW9uIHN2KGUsdCxuKXt2YXIgcj1lLnN0YXRlTm9kZTtpZih0PXQuY2hpbGRDb250ZXh0VHlwZXMsdHlwZW9mIHIuZ2V0Q2hpbGRDb250ZXh0IT0iZnVuY3Rpb24iKXJldHVybiBuO3I9ci5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIG8gaW4gcilpZighKG8gaW4gdCkpdGhyb3cgRXJyb3IoRigxMDgscGIoZSl8fCJVbmtub3duIixvKSk7cmV0dXJuIExlKHt9LG4scil9ZnVuY3Rpb24gTGEoZSl7cmV0dXJuIGU9KGU9ZS5zdGF0ZU5vZGUpJiZlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0fHxDcixVcj1tdC5jdXJyZW50LFRlKG10LGUpLFRlKEV0LEV0LmN1cnJlbnQpLCEwfWZ1bmN0aW9uIHptKGUsdCxuKXt2YXIgcj1lLnN0YXRlTm9kZTtpZighcil0aHJvdyBFcnJvcihGKDE2OSkpO24/KGU9c3YoZSx0LFVyKSxyLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWUsJGUoRXQpLCRlKG10KSxUZShtdCxlKSk6JGUoRXQpLFRlKEV0LG4pfXZhciBCbj1udWxsLFhsPSExLEJ1PSExO2Z1bmN0aW9uIGF2KGUpe0JuPT09bnVsbD9Cbj1bZV06Qm4ucHVzaChlKX1mdW5jdGlvbiBPayhlKXtYbD0hMCxhdihlKX1mdW5jdGlvbiBScigpe2lmKCFCdSYmQm4hPT1udWxsKXtCdT0hMDt2YXIgZT0wLHQ9Q2U7dHJ5e3ZhciBuPUJuO2ZvcihDZT0xO2U8bi5sZW5ndGg7ZSsrKXt2YXIgcj1uW2VdO2RvIHI9cighMCk7d2hpbGUociE9PW51bGwpfUJuPW51bGwsWGw9ITF9Y2F0Y2gobyl7dGhyb3cgQm4hPT1udWxsJiYoQm49Qm4uc2xpY2UoZSsxKSksX3koY2YsUnIpLG99ZmluYWxseXtDZT10LEJ1PSExfX1yZXR1cm4gbnVsbH12YXIgeW89W10sdm89MCxqYT1udWxsLERhPTAsWHQ9W10scXQ9MCxIcj1udWxsLFduPTEsVW49IiI7ZnVuY3Rpb24gT3IoZSx0KXt5b1t2bysrXT1EYSx5b1t2bysrXT1qYSxqYT1lLERhPXR9ZnVuY3Rpb24gbHYoZSx0LG4pe1h0W3F0KytdPVduLFh0W3F0KytdPVVuLFh0W3F0KytdPUhyLEhyPWU7dmFyIHI9V247ZT1Vbjt2YXIgbz0zMi15bihyKS0xO3ImPX4oMTw8byksbis9MTt2YXIgaT0zMi15bih0KStvO2lmKDMwPGkpe3ZhciBzPW8tbyU1O2k9KHImKDE8PHMpLTEpLnRvU3RyaW5nKDMyKSxyPj49cyxvLT1zLFduPTE8PDMyLXluKHQpK298bjw8b3xyLFVuPWkrZX1lbHNlIFduPTE8PGl8bjw8b3xyLFVuPWV9ZnVuY3Rpb24gd2YoZSl7ZS5yZXR1cm4hPT1udWxsJiYoT3IoZSwxKSxsdihlLDEsMCkpfWZ1bmN0aW9uIFNmKGUpe2Zvcig7ZT09PWphOylqYT15b1stLXZvXSx5b1t2b109bnVsbCxEYT15b1stLXZvXSx5b1t2b109bnVsbDtmb3IoO2U9PT1IcjspSHI9WHRbLS1xdF0sWHRbcXRdPW51bGwsVW49WHRbLS1xdF0sWHRbcXRdPW51bGwsV249WHRbLS1xdF0sWHRbcXRdPW51bGx9dmFyIGp0PW51bGwsQXQ9bnVsbCxfZT0hMSxobj1udWxsO2Z1bmN0aW9uIHV2KGUsdCl7dmFyIG49WnQoNSxudWxsLG51bGwsMCk7bi5lbGVtZW50VHlwZT0iREVMRVRFRCIsbi5zdGF0ZU5vZGU9dCxuLnJldHVybj1lLHQ9ZS5kZWxldGlvbnMsdD09PW51bGw/KGUuZGVsZXRpb25zPVtuXSxlLmZsYWdzfD0xNik6dC5wdXNoKG4pfWZ1bmN0aW9uIExtKGUsdCl7c3dpdGNoKGUudGFnKXtjYXNlIDU6dmFyIG49ZS50eXBlO3JldHVybiB0PXQubm9kZVR5cGUhPT0xfHxuLnRvTG93ZXJDYXNlKCkhPT10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk/bnVsbDp0LHQhPT1udWxsPyhlLnN0YXRlTm9kZT10LGp0PWUsQXQ9aHIodC5maXJzdENoaWxkKSwhMCk6ITE7Y2FzZSA2OnJldHVybiB0PWUucGVuZGluZ1Byb3BzPT09IiJ8fHQubm9kZVR5cGUhPT0zP251bGw6dCx0IT09bnVsbD8oZS5zdGF0ZU5vZGU9dCxqdD1lLEF0PW51bGwsITApOiExO2Nhc2UgMTM6cmV0dXJuIHQ9dC5ub2RlVHlwZSE9PTg/bnVsbDp0LHQhPT1udWxsPyhuPUhyIT09bnVsbD97aWQ6V24sb3ZlcmZsb3c6VW59Om51bGwsZS5tZW1vaXplZFN0YXRlPXtkZWh5ZHJhdGVkOnQsdHJlZUNvbnRleHQ6bixyZXRyeUxhbmU6MTA3Mzc0MTgyNH0sbj1adCgxOCxudWxsLG51bGwsMCksbi5zdGF0ZU5vZGU9dCxuLnJldHVybj1lLGUuY2hpbGQ9bixqdD1lLEF0PW51bGwsITApOiExO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIEhjKGUpe3JldHVybihlLm1vZGUmMSkhPT0wJiYoZS5mbGFncyYxMjgpPT09MH1mdW5jdGlvbiBWYyhlKXtpZihfZSl7dmFyIHQ9QXQ7aWYodCl7dmFyIG49dDtpZighTG0oZSx0KSl7aWYoSGMoZSkpdGhyb3cgRXJyb3IoRig0MTgpKTt0PWhyKG4ubmV4dFNpYmxpbmcpO3ZhciByPWp0O3QmJkxtKGUsdCk/dXYocixuKTooZS5mbGFncz1lLmZsYWdzJi00MDk3fDIsX2U9ITEsanQ9ZSl9fWVsc2V7aWYoSGMoZSkpdGhyb3cgRXJyb3IoRig0MTgpKTtlLmZsYWdzPWUuZmxhZ3MmLTQwOTd8MixfZT0hMSxqdD1lfX19ZnVuY3Rpb24gam0oZSl7Zm9yKGU9ZS5yZXR1cm47ZSE9PW51bGwmJmUudGFnIT09NSYmZS50YWchPT0zJiZlLnRhZyE9PTEzOyllPWUucmV0dXJuO2p0PWV9ZnVuY3Rpb24gV3MoZSl7aWYoZSE9PWp0KXJldHVybiExO2lmKCFfZSlyZXR1cm4gam0oZSksX2U9ITAsITE7dmFyIHQ7aWYoKHQ9ZS50YWchPT0zKSYmISh0PWUudGFnIT09NSkmJih0PWUudHlwZSx0PXQhPT0iaGVhZCImJnQhPT0iYm9keSImJiFGYyhlLnR5cGUsZS5tZW1vaXplZFByb3BzKSksdCYmKHQ9QXQpKXtpZihIYyhlKSl0aHJvdyBjdigpLEVycm9yKEYoNDE4KSk7Zm9yKDt0Oyl1dihlLHQpLHQ9aHIodC5uZXh0U2libGluZyl9aWYoam0oZSksZS50YWc9PT0xMyl7aWYoZT1lLm1lbW9pemVkU3RhdGUsZT1lIT09bnVsbD9lLmRlaHlkcmF0ZWQ6bnVsbCwhZSl0aHJvdyBFcnJvcihGKDMxNykpO2U6e2ZvcihlPWUubmV4dFNpYmxpbmcsdD0wO2U7KXtpZihlLm5vZGVUeXBlPT09OCl7dmFyIG49ZS5kYXRhO2lmKG49PT0iLyQiKXtpZih0PT09MCl7QXQ9aHIoZS5uZXh0U2libGluZyk7YnJlYWsgZX10LS19ZWxzZSBuIT09IiQiJiZuIT09IiQhIiYmbiE9PSIkPyJ8fHQrK31lPWUubmV4dFNpYmxpbmd9QXQ9bnVsbH19ZWxzZSBBdD1qdD9ocihlLnN0YXRlTm9kZS5uZXh0U2libGluZyk6bnVsbDtyZXR1cm4hMH1mdW5jdGlvbiBjdigpe2Zvcih2YXIgZT1BdDtlOyllPWhyKGUubmV4dFNpYmxpbmcpfWZ1bmN0aW9uIEFvKCl7QXQ9anQ9bnVsbCxfZT0hMX1mdW5jdGlvbiB4ZihlKXtobj09PW51bGw/aG49W2VdOmhuLnB1c2goZSl9dmFyIE1rPW5yLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO2Z1bmN0aW9uIHVpKGUsdCxuKXtpZihlPW4ucmVmLGUhPT1udWxsJiZ0eXBlb2YgZSE9ImZ1bmN0aW9uIiYmdHlwZW9mIGUhPSJvYmplY3QiKXtpZihuLl9vd25lcil7aWYobj1uLl9vd25lcixuKXtpZihuLnRhZyE9PTEpdGhyb3cgRXJyb3IoRigzMDkpKTt2YXIgcj1uLnN0YXRlTm9kZX1pZighcil0aHJvdyBFcnJvcihGKDE0NyxlKSk7dmFyIG89cixpPSIiK2U7cmV0dXJuIHQhPT1udWxsJiZ0LnJlZiE9PW51bGwmJnR5cGVvZiB0LnJlZj09ImZ1bmN0aW9uIiYmdC5yZWYuX3N0cmluZ1JlZj09PWk/dC5yZWY6KHQ9ZnVuY3Rpb24ocyl7dmFyIGE9by5yZWZzO3M9PT1udWxsP2RlbGV0ZSBhW2ldOmFbaV09c30sdC5fc3RyaW5nUmVmPWksdCl9aWYodHlwZW9mIGUhPSJzdHJpbmciKXRocm93IEVycm9yKEYoMjg0KSk7aWYoIW4uX293bmVyKXRocm93IEVycm9yKEYoMjkwLGUpKX1yZXR1cm4gZX1mdW5jdGlvbiBVcyhlLHQpe3Rocm93IGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLEVycm9yKEYoMzEsZT09PSJbb2JqZWN0IE9iamVjdF0iPyJvYmplY3Qgd2l0aCBrZXlzIHsiK09iamVjdC5rZXlzKHQpLmpvaW4oIiwgIikrIn0iOmUpKX1mdW5jdGlvbiBEbShlKXt2YXIgdD1lLl9pbml0O3JldHVybiB0KGUuX3BheWxvYWQpfWZ1bmN0aW9uIGR2KGUpe2Z1bmN0aW9uIHQoaCxnKXtpZihlKXt2YXIgZj1oLmRlbGV0aW9ucztmPT09bnVsbD8oaC5kZWxldGlvbnM9W2ddLGguZmxhZ3N8PTE2KTpmLnB1c2goZyl9fWZ1bmN0aW9uIG4oaCxnKXtpZighZSlyZXR1cm4gbnVsbDtmb3IoO2chPT1udWxsOyl0KGgsZyksZz1nLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gcihoLGcpe2ZvcihoPW5ldyBNYXA7ZyE9PW51bGw7KWcua2V5IT09bnVsbD9oLnNldChnLmtleSxnKTpoLnNldChnLmluZGV4LGcpLGc9Zy5zaWJsaW5nO3JldHVybiBofWZ1bmN0aW9uIG8oaCxnKXtyZXR1cm4gaD13cihoLGcpLGguaW5kZXg9MCxoLnNpYmxpbmc9bnVsbCxofWZ1bmN0aW9uIGkoaCxnLGYpe3JldHVybiBoLmluZGV4PWYsZT8oZj1oLmFsdGVybmF0ZSxmIT09bnVsbD8oZj1mLmluZGV4LGY8Zz8oaC5mbGFnc3w9MixnKTpmKTooaC5mbGFnc3w9MixnKSk6KGguZmxhZ3N8PTEwNDg1NzYsZyl9ZnVuY3Rpb24gcyhoKXtyZXR1cm4gZSYmaC5hbHRlcm5hdGU9PT1udWxsJiYoaC5mbGFnc3w9MiksaH1mdW5jdGlvbiBhKGgsZyxmLHkpe3JldHVybiBnPT09bnVsbHx8Zy50YWchPT02PyhnPUd1KGYsaC5tb2RlLHkpLGcucmV0dXJuPWgsZyk6KGc9byhnLGYpLGcucmV0dXJuPWgsZyl9ZnVuY3Rpb24gbChoLGcsZix5KXt2YXIgYj1mLnR5cGU7cmV0dXJuIGI9PT1jbz9jKGgsZyxmLnByb3BzLmNoaWxkcmVuLHksZi5rZXkpOmchPT1udWxsJiYoZy5lbGVtZW50VHlwZT09PWJ8fHR5cGVvZiBiPT0ib2JqZWN0IiYmYiE9PW51bGwmJmIuJCR0eXBlb2Y9PT1pciYmRG0oYik9PT1nLnR5cGUpPyh5PW8oZyxmLnByb3BzKSx5LnJlZj11aShoLGcsZikseS5yZXR1cm49aCx5KTooeT15YShmLnR5cGUsZi5rZXksZi5wcm9wcyxudWxsLGgubW9kZSx5KSx5LnJlZj11aShoLGcsZikseS5yZXR1cm49aCx5KX1mdW5jdGlvbiB1KGgsZyxmLHkpe3JldHVybiBnPT09bnVsbHx8Zy50YWchPT00fHxnLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Zi5jb250YWluZXJJbmZvfHxnLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWYuaW1wbGVtZW50YXRpb24/KGc9UXUoZixoLm1vZGUseSksZy5yZXR1cm49aCxnKTooZz1vKGcsZi5jaGlsZHJlbnx8W10pLGcucmV0dXJuPWgsZyl9ZnVuY3Rpb24gYyhoLGcsZix5LGIpe3JldHVybiBnPT09bnVsbHx8Zy50YWchPT03PyhnPUJyKGYsaC5tb2RlLHksYiksZy5yZXR1cm49aCxnKTooZz1vKGcsZiksZy5yZXR1cm49aCxnKX1mdW5jdGlvbiBkKGgsZyxmKXtpZih0eXBlb2YgZz09InN0cmluZyImJmchPT0iInx8dHlwZW9mIGc9PSJudW1iZXIiKXJldHVybiBnPUd1KCIiK2csaC5tb2RlLGYpLGcucmV0dXJuPWgsZztpZih0eXBlb2YgZz09Im9iamVjdCImJmchPT1udWxsKXtzd2l0Y2goZy4kJHR5cGVvZil7Y2FzZSBfczpyZXR1cm4gZj15YShnLnR5cGUsZy5rZXksZy5wcm9wcyxudWxsLGgubW9kZSxmKSxmLnJlZj11aShoLG51bGwsZyksZi5yZXR1cm49aCxmO2Nhc2UgdW86cmV0dXJuIGc9UXUoZyxoLm1vZGUsZiksZy5yZXR1cm49aCxnO2Nhc2UgaXI6dmFyIHk9Zy5faW5pdDtyZXR1cm4gZChoLHkoZy5fcGF5bG9hZCksZil9aWYoU2koZyl8fG9pKGcpKXJldHVybiBnPUJyKGcsaC5tb2RlLGYsbnVsbCksZy5yZXR1cm49aCxnO1VzKGgsZyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbShoLGcsZix5KXt2YXIgYj1nIT09bnVsbD9nLmtleTpudWxsO2lmKHR5cGVvZiBmPT0ic3RyaW5nIiYmZiE9PSIifHx0eXBlb2YgZj09Im51bWJlciIpcmV0dXJuIGIhPT1udWxsP251bGw6YShoLGcsIiIrZix5KTtpZih0eXBlb2YgZj09Im9iamVjdCImJmYhPT1udWxsKXtzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBfczpyZXR1cm4gZi5rZXk9PT1iP2woaCxnLGYseSk6bnVsbDtjYXNlIHVvOnJldHVybiBmLmtleT09PWI/dShoLGcsZix5KTpudWxsO2Nhc2UgaXI6cmV0dXJuIGI9Zi5faW5pdCxtKGgsZyxiKGYuX3BheWxvYWQpLHkpfWlmKFNpKGYpfHxvaShmKSlyZXR1cm4gYiE9PW51bGw/bnVsbDpjKGgsZyxmLHksbnVsbCk7VXMoaCxmKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiB2KGgsZyxmLHksYil7aWYodHlwZW9mIHk9PSJzdHJpbmciJiZ5IT09IiJ8fHR5cGVvZiB5PT0ibnVtYmVyIilyZXR1cm4gaD1oLmdldChmKXx8bnVsbCxhKGcsaCwiIit5LGIpO2lmKHR5cGVvZiB5PT0ib2JqZWN0IiYmeSE9PW51bGwpe3N3aXRjaCh5LiQkdHlwZW9mKXtjYXNlIF9zOnJldHVybiBoPWguZ2V0KHkua2V5PT09bnVsbD9mOnkua2V5KXx8bnVsbCxsKGcsaCx5LGIpO2Nhc2UgdW86cmV0dXJuIGg9aC5nZXQoeS5rZXk9PT1udWxsP2Y6eS5rZXkpfHxudWxsLHUoZyxoLHksYik7Y2FzZSBpcjp2YXIgRT15Ll9pbml0O3JldHVybiB2KGgsZyxmLEUoeS5fcGF5bG9hZCksYil9aWYoU2koeSl8fG9pKHkpKXJldHVybiBoPWguZ2V0KGYpfHxudWxsLGMoZyxoLHksYixudWxsKTtVcyhnLHkpfXJldHVybiBudWxsfWZ1bmN0aW9uIHcoaCxnLGYseSl7Zm9yKHZhciBiPW51bGwsRT1udWxsLFI9ZyxQPWc9MCxJPW51bGw7UiE9PW51bGwmJlA8Zi5sZW5ndGg7UCsrKXtSLmluZGV4PlA/KEk9UixSPW51bGwpOkk9Ui5zaWJsaW5nO3ZhciBwPW0oaCxSLGZbUF0seSk7aWYocD09PW51bGwpe1I9PT1udWxsJiYoUj1JKTticmVha31lJiZSJiZwLmFsdGVybmF0ZT09PW51bGwmJnQoaCxSKSxnPWkocCxnLFApLEU9PT1udWxsP2I9cDpFLnNpYmxpbmc9cCxFPXAsUj1JfWlmKFA9PT1mLmxlbmd0aClyZXR1cm4gbihoLFIpLF9lJiZPcihoLFApLGI7aWYoUj09PW51bGwpe2Zvcig7UDxmLmxlbmd0aDtQKyspUj1kKGgsZltQXSx5KSxSIT09bnVsbCYmKGc9aShSLGcsUCksRT09PW51bGw/Yj1SOkUuc2libGluZz1SLEU9Uik7cmV0dXJuIF9lJiZPcihoLFApLGJ9Zm9yKFI9cihoLFIpO1A8Zi5sZW5ndGg7UCsrKUk9dihSLGgsUCxmW1BdLHkpLEkhPT1udWxsJiYoZSYmSS5hbHRlcm5hdGUhPT1udWxsJiZSLmRlbGV0ZShJLmtleT09PW51bGw/UDpJLmtleSksZz1pKEksZyxQKSxFPT09bnVsbD9iPUk6RS5zaWJsaW5nPUksRT1JKTtyZXR1cm4gZSYmUi5mb3JFYWNoKGZ1bmN0aW9uKCQpe3JldHVybiB0KGgsJCl9KSxfZSYmT3IoaCxQKSxifWZ1bmN0aW9uIFMoaCxnLGYseSl7dmFyIGI9b2koZik7aWYodHlwZW9mIGIhPSJmdW5jdGlvbiIpdGhyb3cgRXJyb3IoRigxNTApKTtpZihmPWIuY2FsbChmKSxmPT1udWxsKXRocm93IEVycm9yKEYoMTUxKSk7Zm9yKHZhciBFPWI9bnVsbCxSPWcsUD1nPTAsST1udWxsLHA9Zi5uZXh0KCk7UiE9PW51bGwmJiFwLmRvbmU7UCsrLHA9Zi5uZXh0KCkpe1IuaW5kZXg+UD8oST1SLFI9bnVsbCk6ST1SLnNpYmxpbmc7dmFyICQ9bShoLFIscC52YWx1ZSx5KTtpZigkPT09bnVsbCl7Uj09PW51bGwmJihSPUkpO2JyZWFrfWUmJlImJiQuYWx0ZXJuYXRlPT09bnVsbCYmdChoLFIpLGc9aSgkLGcsUCksRT09PW51bGw/Yj0kOkUuc2libGluZz0kLEU9JCxSPUl9aWYocC5kb25lKXJldHVybiBuKGgsUiksX2UmJk9yKGgsUCksYjtpZihSPT09bnVsbCl7Zm9yKDshcC5kb25lO1ArKyxwPWYubmV4dCgpKXA9ZChoLHAudmFsdWUseSkscCE9PW51bGwmJihnPWkocCxnLFApLEU9PT1udWxsP2I9cDpFLnNpYmxpbmc9cCxFPXApO3JldHVybiBfZSYmT3IoaCxQKSxifWZvcihSPXIoaCxSKTshcC5kb25lO1ArKyxwPWYubmV4dCgpKXA9dihSLGgsUCxwLnZhbHVlLHkpLHAhPT1udWxsJiYoZSYmcC5hbHRlcm5hdGUhPT1udWxsJiZSLmRlbGV0ZShwLmtleT09PW51bGw/UDpwLmtleSksZz1pKHAsZyxQKSxFPT09bnVsbD9iPXA6RS5zaWJsaW5nPXAsRT1wKTtyZXR1cm4gZSYmUi5mb3JFYWNoKGZ1bmN0aW9uKEwpe3JldHVybiB0KGgsTCl9KSxfZSYmT3IoaCxQKSxifWZ1bmN0aW9uIHgoaCxnLGYseSl7aWYodHlwZW9mIGY9PSJvYmplY3QiJiZmIT09bnVsbCYmZi50eXBlPT09Y28mJmYua2V5PT09bnVsbCYmKGY9Zi5wcm9wcy5jaGlsZHJlbiksdHlwZW9mIGY9PSJvYmplY3QiJiZmIT09bnVsbCl7c3dpdGNoKGYuJCR0eXBlb2Ype2Nhc2UgX3M6ZTp7Zm9yKHZhciBiPWYua2V5LEU9ZztFIT09bnVsbDspe2lmKEUua2V5PT09Yil7aWYoYj1mLnR5cGUsYj09PWNvKXtpZihFLnRhZz09PTcpe24oaCxFLnNpYmxpbmcpLGc9byhFLGYucHJvcHMuY2hpbGRyZW4pLGcucmV0dXJuPWgsaD1nO2JyZWFrIGV9fWVsc2UgaWYoRS5lbGVtZW50VHlwZT09PWJ8fHR5cGVvZiBiPT0ib2JqZWN0IiYmYiE9PW51bGwmJmIuJCR0eXBlb2Y9PT1pciYmRG0oYik9PT1FLnR5cGUpe24oaCxFLnNpYmxpbmcpLGc9byhFLGYucHJvcHMpLGcucmVmPXVpKGgsRSxmKSxnLnJldHVybj1oLGg9ZzticmVhayBlfW4oaCxFKTticmVha31lbHNlIHQoaCxFKTtFPUUuc2libGluZ31mLnR5cGU9PT1jbz8oZz1CcihmLnByb3BzLmNoaWxkcmVuLGgubW9kZSx5LGYua2V5KSxnLnJldHVybj1oLGg9Zyk6KHk9eWEoZi50eXBlLGYua2V5LGYucHJvcHMsbnVsbCxoLm1vZGUseSkseS5yZWY9dWkoaCxnLGYpLHkucmV0dXJuPWgsaD15KX1yZXR1cm4gcyhoKTtjYXNlIHVvOmU6e2ZvcihFPWYua2V5O2chPT1udWxsOyl7aWYoZy5rZXk9PT1FKWlmKGcudGFnPT09NCYmZy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmZy5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1mLmltcGxlbWVudGF0aW9uKXtuKGgsZy5zaWJsaW5nKSxnPW8oZyxmLmNoaWxkcmVufHxbXSksZy5yZXR1cm49aCxoPWc7YnJlYWsgZX1lbHNle24oaCxnKTticmVha31lbHNlIHQoaCxnKTtnPWcuc2libGluZ31nPVF1KGYsaC5tb2RlLHkpLGcucmV0dXJuPWgsaD1nfXJldHVybiBzKGgpO2Nhc2UgaXI6cmV0dXJuIEU9Zi5faW5pdCx4KGgsZyxFKGYuX3BheWxvYWQpLHkpfWlmKFNpKGYpKXJldHVybiB3KGgsZyxmLHkpO2lmKG9pKGYpKXJldHVybiBTKGgsZyxmLHkpO1VzKGgsZil9cmV0dXJuIHR5cGVvZiBmPT0ic3RyaW5nIiYmZiE9PSIifHx0eXBlb2YgZj09Im51bWJlciI/KGY9IiIrZixnIT09bnVsbCYmZy50YWc9PT02PyhuKGgsZy5zaWJsaW5nKSxnPW8oZyxmKSxnLnJldHVybj1oLGg9Zyk6KG4oaCxnKSxnPUd1KGYsaC5tb2RlLHkpLGcucmV0dXJuPWgsaD1nKSxzKGgpKTpuKGgsZyl9cmV0dXJuIHh9dmFyIHpvPWR2KCEwKSxmdj1kdighMSksRmE9RXIobnVsbCksQmE9bnVsbCx3bz1udWxsLENmPW51bGw7ZnVuY3Rpb24gYmYoKXtDZj13bz1CYT1udWxsfWZ1bmN0aW9uIGtmKGUpe3ZhciB0PUZhLmN1cnJlbnQ7JGUoRmEpLGUuX2N1cnJlbnRWYWx1ZT10fWZ1bmN0aW9uIEtjKGUsdCxuKXtmb3IoO2UhPT1udWxsOyl7dmFyIHI9ZS5hbHRlcm5hdGU7aWYoKGUuY2hpbGRMYW5lcyZ0KSE9PXQ/KGUuY2hpbGRMYW5lc3w9dCxyIT09bnVsbCYmKHIuY2hpbGRMYW5lc3w9dCkpOnIhPT1udWxsJiYoci5jaGlsZExhbmVzJnQpIT09dCYmKHIuY2hpbGRMYW5lc3w9dCksZT09PW4pYnJlYWs7ZT1lLnJldHVybn19ZnVuY3Rpb24gJG8oZSx0KXtCYT1lLENmPXdvPW51bGwsZT1lLmRlcGVuZGVuY2llcyxlIT09bnVsbCYmZS5maXJzdENvbnRleHQhPT1udWxsJiYoZS5sYW5lcyZ0JiYoa3Q9ITApLGUuZmlyc3RDb250ZXh0PW51bGwpfWZ1bmN0aW9uIHRuKGUpe3ZhciB0PWUuX2N1cnJlbnRWYWx1ZTtpZihDZiE9PWUpaWYoZT17Y29udGV4dDplLG1lbW9pemVkVmFsdWU6dCxuZXh0Om51bGx9LHdvPT09bnVsbCl7aWYoQmE9PT1udWxsKXRocm93IEVycm9yKEYoMzA4KSk7d289ZSxCYS5kZXBlbmRlbmNpZXM9e2xhbmVzOjAsZmlyc3RDb250ZXh0OmV9fWVsc2Ugd289d28ubmV4dD1lO3JldHVybiB0fXZhciBMcj1udWxsO2Z1bmN0aW9uIEVmKGUpe0xyPT09bnVsbD9Mcj1bZV06THIucHVzaChlKX1mdW5jdGlvbiBwdihlLHQsbixyKXt2YXIgbz10LmludGVybGVhdmVkO3JldHVybiBvPT09bnVsbD8obi5uZXh0PW4sRWYodCkpOihuLm5leHQ9by5uZXh0LG8ubmV4dD1uKSx0LmludGVybGVhdmVkPW4scW4oZSxyKX1mdW5jdGlvbiBxbihlLHQpe2UubGFuZXN8PXQ7dmFyIG49ZS5hbHRlcm5hdGU7Zm9yKG4hPT1udWxsJiYobi5sYW5lc3w9dCksbj1lLGU9ZS5yZXR1cm47ZSE9PW51bGw7KWUuY2hpbGRMYW5lc3w9dCxuPWUuYWx0ZXJuYXRlLG4hPT1udWxsJiYobi5jaGlsZExhbmVzfD10KSxuPWUsZT1lLnJldHVybjtyZXR1cm4gbi50YWc9PT0zP24uc3RhdGVOb2RlOm51bGx9dmFyIHNyPSExO2Z1bmN0aW9uIFJmKGUpe2UudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTplLm1lbW9pemVkU3RhdGUsZmlyc3RCYXNlVXBkYXRlOm51bGwsbGFzdEJhc2VVcGRhdGU6bnVsbCxzaGFyZWQ6e3BlbmRpbmc6bnVsbCxpbnRlcmxlYXZlZDpudWxsLGxhbmVzOjB9LGVmZmVjdHM6bnVsbH19ZnVuY3Rpb24gbXYoZSx0KXtlPWUudXBkYXRlUXVldWUsdC51cGRhdGVRdWV1ZT09PWUmJih0LnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6ZS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmUuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmUubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmUuc2hhcmVkLGVmZmVjdHM6ZS5lZmZlY3RzfSl9ZnVuY3Rpb24gSG4oZSx0KXtyZXR1cm57ZXZlbnRUaW1lOmUsbGFuZTp0LHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19ZnVuY3Rpb24gZ3IoZSx0LG4pe3ZhciByPWUudXBkYXRlUXVldWU7aWYocj09PW51bGwpcmV0dXJuIG51bGw7aWYocj1yLnNoYXJlZCxnZSYyKXt2YXIgbz1yLnBlbmRpbmc7cmV0dXJuIG89PT1udWxsP3QubmV4dD10Oih0Lm5leHQ9by5uZXh0LG8ubmV4dD10KSxyLnBlbmRpbmc9dCxxbihlLG4pfXJldHVybiBvPXIuaW50ZXJsZWF2ZWQsbz09PW51bGw/KHQubmV4dD10LEVmKHIpKToodC5uZXh0PW8ubmV4dCxvLm5leHQ9dCksci5pbnRlcmxlYXZlZD10LHFuKGUsbil9ZnVuY3Rpb24gZGEoZSx0LG4pe2lmKHQ9dC51cGRhdGVRdWV1ZSx0IT09bnVsbCYmKHQ9dC5zaGFyZWQsKG4mNDE5NDI0MCkhPT0wKSl7dmFyIHI9dC5sYW5lcztyJj1lLnBlbmRpbmdMYW5lcyxufD1yLHQubGFuZXM9bixkZihlLG4pfX1mdW5jdGlvbiBGbShlLHQpe3ZhciBuPWUudXBkYXRlUXVldWUscj1lLmFsdGVybmF0ZTtpZihyIT09bnVsbCYmKHI9ci51cGRhdGVRdWV1ZSxuPT09cikpe3ZhciBvPW51bGwsaT1udWxsO2lmKG49bi5maXJzdEJhc2VVcGRhdGUsbiE9PW51bGwpe2Rve3ZhciBzPXtldmVudFRpbWU6bi5ldmVudFRpbWUsbGFuZTpuLmxhbmUsdGFnOm4udGFnLHBheWxvYWQ6bi5wYXlsb2FkLGNhbGxiYWNrOm4uY2FsbGJhY2ssbmV4dDpudWxsfTtpPT09bnVsbD9vPWk9czppPWkubmV4dD1zLG49bi5uZXh0fXdoaWxlKG4hPT1udWxsKTtpPT09bnVsbD9vPWk9dDppPWkubmV4dD10fWVsc2Ugbz1pPXQ7bj17YmFzZVN0YXRlOnIuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTpvLGxhc3RCYXNlVXBkYXRlOmksc2hhcmVkOnIuc2hhcmVkLGVmZmVjdHM6ci5lZmZlY3RzfSxlLnVwZGF0ZVF1ZXVlPW47cmV0dXJufWU9bi5sYXN0QmFzZVVwZGF0ZSxlPT09bnVsbD9uLmZpcnN0QmFzZVVwZGF0ZT10OmUubmV4dD10LG4ubGFzdEJhc2VVcGRhdGU9dH1mdW5jdGlvbiBXYShlLHQsbixyKXt2YXIgbz1lLnVwZGF0ZVF1ZXVlO3NyPSExO3ZhciBpPW8uZmlyc3RCYXNlVXBkYXRlLHM9by5sYXN0QmFzZVVwZGF0ZSxhPW8uc2hhcmVkLnBlbmRpbmc7aWYoYSE9PW51bGwpe28uc2hhcmVkLnBlbmRpbmc9bnVsbDt2YXIgbD1hLHU9bC5uZXh0O2wubmV4dD1udWxsLHM9PT1udWxsP2k9dTpzLm5leHQ9dSxzPWw7dmFyIGM9ZS5hbHRlcm5hdGU7YyE9PW51bGwmJihjPWMudXBkYXRlUXVldWUsYT1jLmxhc3RCYXNlVXBkYXRlLGEhPT1zJiYoYT09PW51bGw/Yy5maXJzdEJhc2VVcGRhdGU9dTphLm5leHQ9dSxjLmxhc3RCYXNlVXBkYXRlPWwpKX1pZihpIT09bnVsbCl7dmFyIGQ9by5iYXNlU3RhdGU7cz0wLGM9dT1sPW51bGwsYT1pO2Rve3ZhciBtPWEubGFuZSx2PWEuZXZlbnRUaW1lO2lmKChyJm0pPT09bSl7YyE9PW51bGwmJihjPWMubmV4dD17ZXZlbnRUaW1lOnYsbGFuZTowLHRhZzphLnRhZyxwYXlsb2FkOmEucGF5bG9hZCxjYWxsYmFjazphLmNhbGxiYWNrLG5leHQ6bnVsbH0pO2U6e3ZhciB3PWUsUz1hO3N3aXRjaChtPXQsdj1uLFMudGFnKXtjYXNlIDE6aWYodz1TLnBheWxvYWQsdHlwZW9mIHc9PSJmdW5jdGlvbiIpe2Q9dy5jYWxsKHYsZCxtKTticmVhayBlfWQ9dzticmVhayBlO2Nhc2UgMzp3LmZsYWdzPXcuZmxhZ3MmLTY1NTM3fDEyODtjYXNlIDA6aWYodz1TLnBheWxvYWQsbT10eXBlb2Ygdz09ImZ1bmN0aW9uIj93LmNhbGwodixkLG0pOncsbT09bnVsbClicmVhayBlO2Q9TGUoe30sZCxtKTticmVhayBlO2Nhc2UgMjpzcj0hMH19YS5jYWxsYmFjayE9PW51bGwmJmEubGFuZSE9PTAmJihlLmZsYWdzfD02NCxtPW8uZWZmZWN0cyxtPT09bnVsbD9vLmVmZmVjdHM9W2FdOm0ucHVzaChhKSl9ZWxzZSB2PXtldmVudFRpbWU6dixsYW5lOm0sdGFnOmEudGFnLHBheWxvYWQ6YS5wYXlsb2FkLGNhbGxiYWNrOmEuY2FsbGJhY2ssbmV4dDpudWxsfSxjPT09bnVsbD8odT1jPXYsbD1kKTpjPWMubmV4dD12LHN8PW07aWYoYT1hLm5leHQsYT09PW51bGwpe2lmKGE9by5zaGFyZWQucGVuZGluZyxhPT09bnVsbClicmVhazttPWEsYT1tLm5leHQsbS5uZXh0PW51bGwsby5sYXN0QmFzZVVwZGF0ZT1tLG8uc2hhcmVkLnBlbmRpbmc9bnVsbH19d2hpbGUoITApO2lmKGM9PT1udWxsJiYobD1kKSxvLmJhc2VTdGF0ZT1sLG8uZmlyc3RCYXNlVXBkYXRlPXUsby5sYXN0QmFzZVVwZGF0ZT1jLHQ9by5zaGFyZWQuaW50ZXJsZWF2ZWQsdCE9PW51bGwpe289dDtkbyBzfD1vLmxhbmUsbz1vLm5leHQ7d2hpbGUobyE9PXQpfWVsc2UgaT09PW51bGwmJihvLnNoYXJlZC5sYW5lcz0wKTtLcnw9cyxlLmxhbmVzPXMsZS5tZW1vaXplZFN0YXRlPWR9fWZ1bmN0aW9uIEJtKGUsdCxuKXtpZihlPXQuZWZmZWN0cyx0LmVmZmVjdHM9bnVsbCxlIT09bnVsbClmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKXt2YXIgcj1lW3RdLG89ci5jYWxsYmFjaztpZihvIT09bnVsbCl7aWYoci5jYWxsYmFjaz1udWxsLHI9bix0eXBlb2YgbyE9ImZ1bmN0aW9uIil0aHJvdyBFcnJvcihGKDE5MSxvKSk7by5jYWxsKHIpfX19dmFyIGtzPXt9LEluPUVyKGtzKSxucz1FcihrcykscnM9RXIoa3MpO2Z1bmN0aW9uIGpyKGUpe2lmKGU9PT1rcyl0aHJvdyBFcnJvcihGKDE3NCkpO3JldHVybiBlfWZ1bmN0aW9uIFRmKGUsdCl7c3dpdGNoKFRlKHJzLHQpLFRlKG5zLGUpLFRlKEluLGtzKSxlPXQubm9kZVR5cGUsZSl7Y2FzZSA5OmNhc2UgMTE6dD0odD10LmRvY3VtZW50RWxlbWVudCk/dC5uYW1lc3BhY2VVUkk6UmMobnVsbCwiIik7YnJlYWs7ZGVmYXVsdDplPWU9PT04P3QucGFyZW50Tm9kZTp0LHQ9ZS5uYW1lc3BhY2VVUkl8fG51bGwsZT1lLnRhZ05hbWUsdD1SYyh0LGUpfSRlKEluKSxUZShJbix0KX1mdW5jdGlvbiBMbygpeyRlKEluKSwkZShucyksJGUocnMpfWZ1bmN0aW9uIGh2KGUpe2pyKHJzLmN1cnJlbnQpO3ZhciB0PWpyKEluLmN1cnJlbnQpLG49UmModCxlLnR5cGUpO3QhPT1uJiYoVGUobnMsZSksVGUoSW4sbikpfWZ1bmN0aW9uIFBmKGUpe25zLmN1cnJlbnQ9PT1lJiYoJGUoSW4pLCRlKG5zKSl9dmFyIEFlPUVyKDApO2Z1bmN0aW9uIFVhKGUpe2Zvcih2YXIgdD1lO3QhPT1udWxsOyl7aWYodC50YWc9PT0xMyl7dmFyIG49dC5tZW1vaXplZFN0YXRlO2lmKG4hPT1udWxsJiYobj1uLmRlaHlkcmF0ZWQsbj09PW51bGx8fG4uZGF0YT09PSIkPyJ8fG4uZGF0YT09PSIkISIpKXJldHVybiB0fWVsc2UgaWYodC50YWc9PT0xOSYmdC5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyIT09dm9pZCAwKXtpZih0LmZsYWdzJjEyOClyZXR1cm4gdH1lbHNlIGlmKHQuY2hpbGQhPT1udWxsKXt0LmNoaWxkLnJldHVybj10LHQ9dC5jaGlsZDtjb250aW51ZX1pZih0PT09ZSlicmVhaztmb3IoO3Quc2libGluZz09PW51bGw7KXtpZih0LnJldHVybj09PW51bGx8fHQucmV0dXJuPT09ZSlyZXR1cm4gbnVsbDt0PXQucmV0dXJufXQuc2libGluZy5yZXR1cm49dC5yZXR1cm4sdD10LnNpYmxpbmd9cmV0dXJuIG51bGx9dmFyIFd1PVtdO2Z1bmN0aW9uICRmKCl7Zm9yKHZhciBlPTA7ZTxXdS5sZW5ndGg7ZSsrKVd1W2VdLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7V3UubGVuZ3RoPTB9dmFyIGZhPW5yLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsVXU9bnIuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsVnI9MCx6ZT1udWxsLFhlPW51bGwsSmU9bnVsbCxIYT0hMSxNaT0hMSxvcz0wLF9rPTA7ZnVuY3Rpb24gbHQoKXt0aHJvdyBFcnJvcihGKDMyMSkpfWZ1bmN0aW9uIE9mKGUsdCl7aWYodD09PW51bGwpcmV0dXJuITE7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aCYmbjxlLmxlbmd0aDtuKyspaWYoIXduKGVbbl0sdFtuXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gTWYoZSx0LG4scixvLGkpe2lmKFZyPWksemU9dCx0Lm1lbW9pemVkU3RhdGU9bnVsbCx0LnVwZGF0ZVF1ZXVlPW51bGwsdC5sYW5lcz0wLGZhLmN1cnJlbnQ9ZT09PW51bGx8fGUubWVtb2l6ZWRTdGF0ZT09PW51bGw/ems6TGssZT1uKHIsbyksTWkpe2k9MDtkb3tpZihNaT0hMSxvcz0wLDI1PD1pKXRocm93IEVycm9yKEYoMzAxKSk7aSs9MSxKZT1YZT1udWxsLHQudXBkYXRlUXVldWU9bnVsbCxmYS5jdXJyZW50PWprLGU9bihyLG8pfXdoaWxlKE1pKX1pZihmYS5jdXJyZW50PVZhLHQ9WGUhPT1udWxsJiZYZS5uZXh0IT09bnVsbCxWcj0wLEplPVhlPXplPW51bGwsSGE9ITEsdCl0aHJvdyBFcnJvcihGKDMwMCkpO3JldHVybiBlfWZ1bmN0aW9uIF9mKCl7dmFyIGU9b3MhPT0wO3JldHVybiBvcz0wLGV9ZnVuY3Rpb24gVG4oKXt2YXIgZT17bWVtb2l6ZWRTdGF0ZTpudWxsLGJhc2VTdGF0ZTpudWxsLGJhc2VRdWV1ZTpudWxsLHF1ZXVlOm51bGwsbmV4dDpudWxsfTtyZXR1cm4gSmU9PT1udWxsP3plLm1lbW9pemVkU3RhdGU9SmU9ZTpKZT1KZS5uZXh0PWUsSmV9ZnVuY3Rpb24gbm4oKXtpZihYZT09PW51bGwpe3ZhciBlPXplLmFsdGVybmF0ZTtlPWUhPT1udWxsP2UubWVtb2l6ZWRTdGF0ZTpudWxsfWVsc2UgZT1YZS5uZXh0O3ZhciB0PUplPT09bnVsbD96ZS5tZW1vaXplZFN0YXRlOkplLm5leHQ7aWYodCE9PW51bGwpSmU9dCxYZT1lO2Vsc2V7aWYoZT09PW51bGwpdGhyb3cgRXJyb3IoRigzMTApKTtYZT1lLGU9e21lbW9pemVkU3RhdGU6WGUubWVtb2l6ZWRTdGF0ZSxiYXNlU3RhdGU6WGUuYmFzZVN0YXRlLGJhc2VRdWV1ZTpYZS5iYXNlUXVldWUscXVldWU6WGUucXVldWUsbmV4dDpudWxsfSxKZT09PW51bGw/emUubWVtb2l6ZWRTdGF0ZT1KZT1lOkplPUplLm5leHQ9ZX1yZXR1cm4gSmV9ZnVuY3Rpb24gaXMoZSx0KXtyZXR1cm4gdHlwZW9mIHQ9PSJmdW5jdGlvbiI/dChlKTp0fWZ1bmN0aW9uIEh1KGUpe3ZhciB0PW5uKCksbj10LnF1ZXVlO2lmKG49PT1udWxsKXRocm93IEVycm9yKEYoMzExKSk7bi5sYXN0UmVuZGVyZWRSZWR1Y2VyPWU7dmFyIHI9WGUsbz1yLmJhc2VRdWV1ZSxpPW4ucGVuZGluZztpZihpIT09bnVsbCl7aWYobyE9PW51bGwpe3ZhciBzPW8ubmV4dDtvLm5leHQ9aS5uZXh0LGkubmV4dD1zfXIuYmFzZVF1ZXVlPW89aSxuLnBlbmRpbmc9bnVsbH1pZihvIT09bnVsbCl7aT1vLm5leHQscj1yLmJhc2VTdGF0ZTt2YXIgYT1zPW51bGwsbD1udWxsLHU9aTtkb3t2YXIgYz11LmxhbmU7aWYoKFZyJmMpPT09YylsIT09bnVsbCYmKGw9bC5uZXh0PXtsYW5lOjAsYWN0aW9uOnUuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6dS5oYXNFYWdlclN0YXRlLGVhZ2VyU3RhdGU6dS5lYWdlclN0YXRlLG5leHQ6bnVsbH0pLHI9dS5oYXNFYWdlclN0YXRlP3UuZWFnZXJTdGF0ZTplKHIsdS5hY3Rpb24pO2Vsc2V7dmFyIGQ9e2xhbmU6YyxhY3Rpb246dS5hY3Rpb24saGFzRWFnZXJTdGF0ZTp1Lmhhc0VhZ2VyU3RhdGUsZWFnZXJTdGF0ZTp1LmVhZ2VyU3RhdGUsbmV4dDpudWxsfTtsPT09bnVsbD8oYT1sPWQscz1yKTpsPWwubmV4dD1kLHplLmxhbmVzfD1jLEtyfD1jfXU9dS5uZXh0fXdoaWxlKHUhPT1udWxsJiZ1IT09aSk7bD09PW51bGw/cz1yOmwubmV4dD1hLHduKHIsdC5tZW1vaXplZFN0YXRlKXx8KGt0PSEwKSx0Lm1lbW9pemVkU3RhdGU9cix0LmJhc2VTdGF0ZT1zLHQuYmFzZVF1ZXVlPWwsbi5sYXN0UmVuZGVyZWRTdGF0ZT1yfWlmKGU9bi5pbnRlcmxlYXZlZCxlIT09bnVsbCl7bz1lO2RvIGk9by5sYW5lLHplLmxhbmVzfD1pLEtyfD1pLG89by5uZXh0O3doaWxlKG8hPT1lKX1lbHNlIG89PT1udWxsJiYobi5sYW5lcz0wKTtyZXR1cm5bdC5tZW1vaXplZFN0YXRlLG4uZGlzcGF0Y2hdfWZ1bmN0aW9uIFZ1KGUpe3ZhciB0PW5uKCksbj10LnF1ZXVlO2lmKG49PT1udWxsKXRocm93IEVycm9yKEYoMzExKSk7bi5sYXN0UmVuZGVyZWRSZWR1Y2VyPWU7dmFyIHI9bi5kaXNwYXRjaCxvPW4ucGVuZGluZyxpPXQubWVtb2l6ZWRTdGF0ZTtpZihvIT09bnVsbCl7bi5wZW5kaW5nPW51bGw7dmFyIHM9bz1vLm5leHQ7ZG8gaT1lKGkscy5hY3Rpb24pLHM9cy5uZXh0O3doaWxlKHMhPT1vKTt3bihpLHQubWVtb2l6ZWRTdGF0ZSl8fChrdD0hMCksdC5tZW1vaXplZFN0YXRlPWksdC5iYXNlUXVldWU9PT1udWxsJiYodC5iYXNlU3RhdGU9aSksbi5sYXN0UmVuZGVyZWRTdGF0ZT1pfXJldHVybltpLHJdfWZ1bmN0aW9uIGd2KCl7fWZ1bmN0aW9uIHl2KGUsdCl7dmFyIG49emUscj1ubigpLG89dCgpLGk9IXduKHIubWVtb2l6ZWRTdGF0ZSxvKTtpZihpJiYoci5tZW1vaXplZFN0YXRlPW8sa3Q9ITApLHI9ci5xdWV1ZSxOZihTdi5iaW5kKG51bGwsbixyLGUpLFtlXSksci5nZXRTbmFwc2hvdCE9PXR8fGl8fEplIT09bnVsbCYmSmUubWVtb2l6ZWRTdGF0ZS50YWcmMSl7aWYobi5mbGFnc3w9MjA0OCxzcyg5LHd2LmJpbmQobnVsbCxuLHIsbyx0KSx2b2lkIDAsbnVsbCksZXQ9PT1udWxsKXRocm93IEVycm9yKEYoMzQ5KSk7VnImMzB8fHZ2KG4sdCxvKX1yZXR1cm4gb31mdW5jdGlvbiB2dihlLHQsbil7ZS5mbGFnc3w9MTYzODQsZT17Z2V0U25hcHNob3Q6dCx2YWx1ZTpufSx0PXplLnVwZGF0ZVF1ZXVlLHQ9PT1udWxsPyh0PXtsYXN0RWZmZWN0Om51bGwsc3RvcmVzOm51bGx9LHplLnVwZGF0ZVF1ZXVlPXQsdC5zdG9yZXM9W2VdKToobj10LnN0b3JlcyxuPT09bnVsbD90LnN0b3Jlcz1bZV06bi5wdXNoKGUpKX1mdW5jdGlvbiB3dihlLHQsbixyKXt0LnZhbHVlPW4sdC5nZXRTbmFwc2hvdD1yLHh2KHQpJiZDdihlKX1mdW5jdGlvbiBTdihlLHQsbil7cmV0dXJuIG4oZnVuY3Rpb24oKXt4dih0KSYmQ3YoZSl9KX1mdW5jdGlvbiB4dihlKXt2YXIgdD1lLmdldFNuYXBzaG90O2U9ZS52YWx1ZTt0cnl7dmFyIG49dCgpO3JldHVybiF3bihlLG4pfWNhdGNoe3JldHVybiEwfX1mdW5jdGlvbiBDdihlKXt2YXIgdD1xbihlLDEpO3QhPT1udWxsJiZ2bih0LGUsMSwtMSl9ZnVuY3Rpb24gV20oZSl7dmFyIHQ9VG4oKTtyZXR1cm4gdHlwZW9mIGU9PSJmdW5jdGlvbiImJihlPWUoKSksdC5tZW1vaXplZFN0YXRlPXQuYmFzZVN0YXRlPWUsZT17cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6MCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6aXMsbGFzdFJlbmRlcmVkU3RhdGU6ZX0sdC5xdWV1ZT1lLGU9ZS5kaXNwYXRjaD1Bay5iaW5kKG51bGwsemUsZSksW3QubWVtb2l6ZWRTdGF0ZSxlXX1mdW5jdGlvbiBzcyhlLHQsbixyKXtyZXR1cm4gZT17dGFnOmUsY3JlYXRlOnQsZGVzdHJveTpuLGRlcHM6cixuZXh0Om51bGx9LHQ9emUudXBkYXRlUXVldWUsdD09PW51bGw/KHQ9e2xhc3RFZmZlY3Q6bnVsbCxzdG9yZXM6bnVsbH0semUudXBkYXRlUXVldWU9dCx0Lmxhc3RFZmZlY3Q9ZS5uZXh0PWUpOihuPXQubGFzdEVmZmVjdCxuPT09bnVsbD90Lmxhc3RFZmZlY3Q9ZS5uZXh0PWU6KHI9bi5uZXh0LG4ubmV4dD1lLGUubmV4dD1yLHQubGFzdEVmZmVjdD1lKSksZX1mdW5jdGlvbiBidigpe3JldHVybiBubigpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gcGEoZSx0LG4scil7dmFyIG89VG4oKTt6ZS5mbGFnc3w9ZSxvLm1lbW9pemVkU3RhdGU9c3MoMXx0LG4sdm9pZCAwLHI9PT12b2lkIDA/bnVsbDpyKX1mdW5jdGlvbiBxbChlLHQsbixyKXt2YXIgbz1ubigpO3I9cj09PXZvaWQgMD9udWxsOnI7dmFyIGk9dm9pZCAwO2lmKFhlIT09bnVsbCl7dmFyIHM9WGUubWVtb2l6ZWRTdGF0ZTtpZihpPXMuZGVzdHJveSxyIT09bnVsbCYmT2YocixzLmRlcHMpKXtvLm1lbW9pemVkU3RhdGU9c3ModCxuLGkscik7cmV0dXJufX16ZS5mbGFnc3w9ZSxvLm1lbW9pemVkU3RhdGU9c3MoMXx0LG4saSxyKX1mdW5jdGlvbiBVbShlLHQpe3JldHVybiBwYSg4MzkwNjU2LDgsZSx0KX1mdW5jdGlvbiBOZihlLHQpe3JldHVybiBxbCgyMDQ4LDgsZSx0KX1mdW5jdGlvbiBrdihlLHQpe3JldHVybiBxbCg0LDIsZSx0KX1mdW5jdGlvbiBFdihlLHQpe3JldHVybiBxbCg0LDQsZSx0KX1mdW5jdGlvbiBSdihlLHQpe2lmKHR5cGVvZiB0PT0iZnVuY3Rpb24iKXJldHVybiBlPWUoKSx0KGUpLGZ1bmN0aW9uKCl7dChudWxsKX07aWYodCE9bnVsbClyZXR1cm4gZT1lKCksdC5jdXJyZW50PWUsZnVuY3Rpb24oKXt0LmN1cnJlbnQ9bnVsbH19ZnVuY3Rpb24gVHYoZSx0LG4pe3JldHVybiBuPW4hPW51bGw/bi5jb25jYXQoW2VdKTpudWxsLHFsKDQsNCxSdi5iaW5kKG51bGwsdCxlKSxuKX1mdW5jdGlvbiBJZigpe31mdW5jdGlvbiBQdihlLHQpe3ZhciBuPW5uKCk7dD10PT09dm9pZCAwP251bGw6dDt2YXIgcj1uLm1lbW9pemVkU3RhdGU7cmV0dXJuIHIhPT1udWxsJiZ0IT09bnVsbCYmT2YodCxyWzFdKT9yWzBdOihuLm1lbW9pemVkU3RhdGU9W2UsdF0sZSl9ZnVuY3Rpb24gJHYoZSx0KXt2YXIgbj1ubigpO3Q9dD09PXZvaWQgMD9udWxsOnQ7dmFyIHI9bi5tZW1vaXplZFN0YXRlO3JldHVybiByIT09bnVsbCYmdCE9PW51bGwmJk9mKHQsclsxXSk/clswXTooZT1lKCksbi5tZW1vaXplZFN0YXRlPVtlLHRdLGUpfWZ1bmN0aW9uIE92KGUsdCxuKXtyZXR1cm4gVnImMjE/KHduKG4sdCl8fChuPUF5KCksemUubGFuZXN8PW4sS3J8PW4sZS5iYXNlU3RhdGU9ITApLHQpOihlLmJhc2VTdGF0ZSYmKGUuYmFzZVN0YXRlPSExLGt0PSEwKSxlLm1lbW9pemVkU3RhdGU9bil9ZnVuY3Rpb24gTmsoZSx0KXt2YXIgbj1DZTtDZT1uIT09MCYmND5uP246NCxlKCEwKTt2YXIgcj1VdS50cmFuc2l0aW9uO1V1LnRyYW5zaXRpb249e307dHJ5e2UoITEpLHQoKX1maW5hbGx5e0NlPW4sVXUudHJhbnNpdGlvbj1yfX1mdW5jdGlvbiBNdigpe3JldHVybiBubigpLm1lbW9pemVkU3RhdGV9ZnVuY3Rpb24gSWsoZSx0LG4pe3ZhciByPXZyKGUpO2lmKG49e2xhbmU6cixhY3Rpb246bixoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9LF92KGUpKU52KHQsbik7ZWxzZSBpZihuPXB2KGUsdCxuLHIpLG4hPT1udWxsKXt2YXIgbz15dCgpO3ZuKG4sZSxyLG8pLEl2KG4sdCxyKX19ZnVuY3Rpb24gQWsoZSx0LG4pe3ZhciByPXZyKGUpLG89e2xhbmU6cixhY3Rpb246bixoYXNFYWdlclN0YXRlOiExLGVhZ2VyU3RhdGU6bnVsbCxuZXh0Om51bGx9O2lmKF92KGUpKU52KHQsbyk7ZWxzZXt2YXIgaT1lLmFsdGVybmF0ZTtpZihlLmxhbmVzPT09MCYmKGk9PT1udWxsfHxpLmxhbmVzPT09MCkmJihpPXQubGFzdFJlbmRlcmVkUmVkdWNlcixpIT09bnVsbCkpdHJ5e3ZhciBzPXQubGFzdFJlbmRlcmVkU3RhdGUsYT1pKHMsbik7aWYoby5oYXNFYWdlclN0YXRlPSEwLG8uZWFnZXJTdGF0ZT1hLHduKGEscykpe3ZhciBsPXQuaW50ZXJsZWF2ZWQ7bD09PW51bGw/KG8ubmV4dD1vLEVmKHQpKTooby5uZXh0PWwubmV4dCxsLm5leHQ9byksdC5pbnRlcmxlYXZlZD1vO3JldHVybn19Y2F0Y2h7fWZpbmFsbHl7fW49cHYoZSx0LG8sciksbiE9PW51bGwmJihvPXl0KCksdm4obixlLHIsbyksSXYobix0LHIpKX19ZnVuY3Rpb24gX3YoZSl7dmFyIHQ9ZS5hbHRlcm5hdGU7cmV0dXJuIGU9PT16ZXx8dCE9PW51bGwmJnQ9PT16ZX1mdW5jdGlvbiBOdihlLHQpe01pPUhhPSEwO3ZhciBuPWUucGVuZGluZztuPT09bnVsbD90Lm5leHQ9dDoodC5uZXh0PW4ubmV4dCxuLm5leHQ9dCksZS5wZW5kaW5nPXR9ZnVuY3Rpb24gSXYoZSx0LG4pe2lmKG4mNDE5NDI0MCl7dmFyIHI9dC5sYW5lcztyJj1lLnBlbmRpbmdMYW5lcyxufD1yLHQubGFuZXM9bixkZihlLG4pfX12YXIgVmE9e3JlYWRDb250ZXh0OnRuLHVzZUNhbGxiYWNrOmx0LHVzZUNvbnRleHQ6bHQsdXNlRWZmZWN0Omx0LHVzZUltcGVyYXRpdmVIYW5kbGU6bHQsdXNlSW5zZXJ0aW9uRWZmZWN0Omx0LHVzZUxheW91dEVmZmVjdDpsdCx1c2VNZW1vOmx0LHVzZVJlZHVjZXI6bHQsdXNlUmVmOmx0LHVzZVN0YXRlOmx0LHVzZURlYnVnVmFsdWU6bHQsdXNlRGVmZXJyZWRWYWx1ZTpsdCx1c2VUcmFuc2l0aW9uOmx0LHVzZU11dGFibGVTb3VyY2U6bHQsdXNlU3luY0V4dGVybmFsU3RvcmU6bHQsdXNlSWQ6bHQsdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfSx6az17cmVhZENvbnRleHQ6dG4sdXNlQ2FsbGJhY2s6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gVG4oKS5tZW1vaXplZFN0YXRlPVtlLHQ9PT12b2lkIDA/bnVsbDp0XSxlfSx1c2VDb250ZXh0OnRuLHVzZUVmZmVjdDpVbSx1c2VJbXBlcmF0aXZlSGFuZGxlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbj1uIT1udWxsP24uY29uY2F0KFtlXSk6bnVsbCxwYSg0MTk0MzA4LDQsUnYuYmluZChudWxsLHQsZSksbil9LHVzZUxheW91dEVmZmVjdDpmdW5jdGlvbihlLHQpe3JldHVybiBwYSg0MTk0MzA4LDQsZSx0KX0sdXNlSW5zZXJ0aW9uRWZmZWN0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHBhKDQsMixlLHQpfSx1c2VNZW1vOmZ1bmN0aW9uKGUsdCl7dmFyIG49VG4oKTtyZXR1cm4gdD10PT09dm9pZCAwP251bGw6dCxlPWUoKSxuLm1lbW9pemVkU3RhdGU9W2UsdF0sZX0sdXNlUmVkdWNlcjpmdW5jdGlvbihlLHQsbil7dmFyIHI9VG4oKTtyZXR1cm4gdD1uIT09dm9pZCAwP24odCk6dCxyLm1lbW9pemVkU3RhdGU9ci5iYXNlU3RhdGU9dCxlPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjplLGxhc3RSZW5kZXJlZFN0YXRlOnR9LHIucXVldWU9ZSxlPWUuZGlzcGF0Y2g9SWsuYmluZChudWxsLHplLGUpLFtyLm1lbW9pemVkU3RhdGUsZV19LHVzZVJlZjpmdW5jdGlvbihlKXt2YXIgdD1UbigpO3JldHVybiBlPXtjdXJyZW50OmV9LHQubWVtb2l6ZWRTdGF0ZT1lfSx1c2VTdGF0ZTpXbSx1c2VEZWJ1Z1ZhbHVlOklmLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIFRuKCkubWVtb2l6ZWRTdGF0ZT1lfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9V20oITEpLHQ9ZVswXTtyZXR1cm4gZT1Oay5iaW5kKG51bGwsZVsxXSksVG4oKS5tZW1vaXplZFN0YXRlPWUsW3QsZV19LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oKXt9LHVzZVN5bmNFeHRlcm5hbFN0b3JlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj16ZSxvPVRuKCk7aWYoX2Upe2lmKG49PT12b2lkIDApdGhyb3cgRXJyb3IoRig0MDcpKTtuPW4oKX1lbHNle2lmKG49dCgpLGV0PT09bnVsbCl0aHJvdyBFcnJvcihGKDM0OSkpO1ZyJjMwfHx2dihyLHQsbil9by5tZW1vaXplZFN0YXRlPW47dmFyIGk9e3ZhbHVlOm4sZ2V0U25hcHNob3Q6dH07cmV0dXJuIG8ucXVldWU9aSxVbShTdi5iaW5kKG51bGwscixpLGUpLFtlXSksci5mbGFnc3w9MjA0OCxzcyg5LHd2LmJpbmQobnVsbCxyLGksbix0KSx2b2lkIDAsbnVsbCksbn0sdXNlSWQ6ZnVuY3Rpb24oKXt2YXIgZT1UbigpLHQ9ZXQuaWRlbnRpZmllclByZWZpeDtpZihfZSl7dmFyIG49VW4scj1XbjtuPShyJn4oMTw8MzIteW4ociktMSkpLnRvU3RyaW5nKDMyKStuLHQ9IjoiK3QrIlIiK24sbj1vcysrLDA8biYmKHQrPSJIIituLnRvU3RyaW5nKDMyKSksdCs9IjoifWVsc2Ugbj1faysrLHQ9IjoiK3QrInIiK24udG9TdHJpbmcoMzIpKyI6IjtyZXR1cm4gZS5tZW1vaXplZFN0YXRlPXR9LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sTGs9e3JlYWRDb250ZXh0OnRuLHVzZUNhbGxiYWNrOlB2LHVzZUNvbnRleHQ6dG4sdXNlRWZmZWN0Ok5mLHVzZUltcGVyYXRpdmVIYW5kbGU6VHYsdXNlSW5zZXJ0aW9uRWZmZWN0Omt2LHVzZUxheW91dEVmZmVjdDpFdix1c2VNZW1vOiR2LHVzZVJlZHVjZXI6SHUsdXNlUmVmOmJ2LHVzZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIEh1KGlzKX0sdXNlRGVidWdWYWx1ZTpJZix1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PW5uKCk7cmV0dXJuIE92KHQsWGUubWVtb2l6ZWRTdGF0ZSxlKX0sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBlPUh1KGlzKVswXSx0PW5uKCkubWVtb2l6ZWRTdGF0ZTtyZXR1cm5bZSx0XX0sdXNlTXV0YWJsZVNvdXJjZTpndix1c2VTeW5jRXh0ZXJuYWxTdG9yZTp5dix1c2VJZDpNdix1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LGprPXtyZWFkQ29udGV4dDp0bix1c2VDYWxsYmFjazpQdix1c2VDb250ZXh0OnRuLHVzZUVmZmVjdDpOZix1c2VJbXBlcmF0aXZlSGFuZGxlOlR2LHVzZUluc2VydGlvbkVmZmVjdDprdix1c2VMYXlvdXRFZmZlY3Q6RXYsdXNlTWVtbzokdix1c2VSZWR1Y2VyOlZ1LHVzZVJlZjpidix1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBWdShpcyl9LHVzZURlYnVnVmFsdWU6SWYsdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1ubigpO3JldHVybiBYZT09PW51bGw/dC5tZW1vaXplZFN0YXRlPWU6T3YodCxYZS5tZW1vaXplZFN0YXRlLGUpfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9VnUoaXMpWzBdLHQ9bm4oKS5tZW1vaXplZFN0YXRlO3JldHVybltlLHRdfSx1c2VNdXRhYmxlU291cmNlOmd2LHVzZVN5bmNFeHRlcm5hbFN0b3JlOnl2LHVzZUlkOk12LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX07ZnVuY3Rpb24gZm4oZSx0KXtpZihlJiZlLmRlZmF1bHRQcm9wcyl7dD1MZSh7fSx0KSxlPWUuZGVmYXVsdFByb3BzO2Zvcih2YXIgbiBpbiBlKXRbbl09PT12b2lkIDAmJih0W25dPWVbbl0pO3JldHVybiB0fXJldHVybiB0fWZ1bmN0aW9uIFljKGUsdCxuLHIpe3Q9ZS5tZW1vaXplZFN0YXRlLG49bihyLHQpLG49bj09bnVsbD90OkxlKHt9LHQsbiksZS5tZW1vaXplZFN0YXRlPW4sZS5sYW5lcz09PTAmJihlLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1uKX12YXIgWmw9e2lzTW91bnRlZDpmdW5jdGlvbihlKXtyZXR1cm4oZT1lLl9yZWFjdEludGVybmFscyk/WnIoZSk9PT1lOiExfSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oZSx0LG4pe2U9ZS5fcmVhY3RJbnRlcm5hbHM7dmFyIHI9eXQoKSxvPXZyKGUpLGk9SG4ocixvKTtpLnBheWxvYWQ9dCxuIT1udWxsJiYoaS5jYWxsYmFjaz1uKSx0PWdyKGUsaSxvKSx0IT09bnVsbCYmKHZuKHQsZSxvLHIpLGRhKHQsZSxvKSl9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oZSx0LG4pe2U9ZS5fcmVhY3RJbnRlcm5hbHM7dmFyIHI9eXQoKSxvPXZyKGUpLGk9SG4ocixvKTtpLnRhZz0xLGkucGF5bG9hZD10LG4hPW51bGwmJihpLmNhbGxiYWNrPW4pLHQ9Z3IoZSxpLG8pLHQhPT1udWxsJiYodm4odCxlLG8sciksZGEodCxlLG8pKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGUsdCl7ZT1lLl9yZWFjdEludGVybmFsczt2YXIgbj15dCgpLHI9dnIoZSksbz1IbihuLHIpO28udGFnPTIsdCE9bnVsbCYmKG8uY2FsbGJhY2s9dCksdD1ncihlLG8sciksdCE9PW51bGwmJih2bih0LGUscixuKSxkYSh0LGUscikpfX07ZnVuY3Rpb24gSG0oZSx0LG4scixvLGkscyl7cmV0dXJuIGU9ZS5zdGF0ZU5vZGUsdHlwZW9mIGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPT0iZnVuY3Rpb24iP2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKHIsaSxzKTp0LnByb3RvdHlwZSYmdC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IVppKG4scil8fCFaaShvLGkpOiEwfWZ1bmN0aW9uIEF2KGUsdCxuKXt2YXIgcj0hMSxvPUNyLGk9dC5jb250ZXh0VHlwZTtyZXR1cm4gdHlwZW9mIGk9PSJvYmplY3QiJiZpIT09bnVsbD9pPXRuKGkpOihvPVJ0KHQpP1VyOm10LmN1cnJlbnQscj10LmNvbnRleHRUeXBlcyxpPShyPXIhPW51bGwpP0lvKGUsbyk6Q3IpLHQ9bmV3IHQobixpKSxlLm1lbW9pemVkU3RhdGU9dC5zdGF0ZSE9PW51bGwmJnQuc3RhdGUhPT12b2lkIDA/dC5zdGF0ZTpudWxsLHQudXBkYXRlcj1abCxlLnN0YXRlTm9kZT10LHQuX3JlYWN0SW50ZXJuYWxzPWUsciYmKGU9ZS5zdGF0ZU5vZGUsZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PW8sZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1pKSx0fWZ1bmN0aW9uIFZtKGUsdCxuLHIpe2U9dC5zdGF0ZSx0eXBlb2YgdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzPT0iZnVuY3Rpb24iJiZ0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobixyKSx0eXBlb2YgdC5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcz09ImZ1bmN0aW9uIiYmdC5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuLHIpLHQuc3RhdGUhPT1lJiZabC5lbnF1ZXVlUmVwbGFjZVN0YXRlKHQsdC5zdGF0ZSxudWxsKX1mdW5jdGlvbiBHYyhlLHQsbixyKXt2YXIgbz1lLnN0YXRlTm9kZTtvLnByb3BzPW4sby5zdGF0ZT1lLm1lbW9pemVkU3RhdGUsby5yZWZzPXt9LFJmKGUpO3ZhciBpPXQuY29udGV4dFR5cGU7dHlwZW9mIGk9PSJvYmplY3QiJiZpIT09bnVsbD9vLmNvbnRleHQ9dG4oaSk6KGk9UnQodCk/VXI6bXQuY3VycmVudCxvLmNvbnRleHQ9SW8oZSxpKSksby5zdGF0ZT1lLm1lbW9pemVkU3RhdGUsaT10LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyx0eXBlb2YgaT09ImZ1bmN0aW9uIiYmKFljKGUsdCxpLG4pLG8uc3RhdGU9ZS5tZW1vaXplZFN0YXRlKSx0eXBlb2YgdC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9PSJmdW5jdGlvbiJ8fHR5cGVvZiBvLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT0iZnVuY3Rpb24ifHx0eXBlb2Ygby5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IT0iZnVuY3Rpb24iJiZ0eXBlb2Ygby5jb21wb25lbnRXaWxsTW91bnQhPSJmdW5jdGlvbiJ8fCh0PW8uc3RhdGUsdHlwZW9mIG8uY29tcG9uZW50V2lsbE1vdW50PT0iZnVuY3Rpb24iJiZvLmNvbXBvbmVudFdpbGxNb3VudCgpLHR5cGVvZiBvLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ9PSJmdW5jdGlvbiImJm8uVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLHQhPT1vLnN0YXRlJiZabC5lbnF1ZXVlUmVwbGFjZVN0YXRlKG8sby5zdGF0ZSxudWxsKSxXYShlLG4sbyxyKSxvLnN0YXRlPWUubWVtb2l6ZWRTdGF0ZSksdHlwZW9mIG8uY29tcG9uZW50RGlkTW91bnQ9PSJmdW5jdGlvbiImJihlLmZsYWdzfD00MTk0MzA4KX1mdW5jdGlvbiBqbyhlLHQpe3RyeXt2YXIgbj0iIixyPXQ7ZG8gbis9ZmIocikscj1yLnJldHVybjt3aGlsZShyKTt2YXIgbz1ufWNhdGNoKGkpe289YApFcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBgK2kubWVzc2FnZStgCmAraS5zdGFja31yZXR1cm57dmFsdWU6ZSxzb3VyY2U6dCxzdGFjazpvLGRpZ2VzdDpudWxsfX1mdW5jdGlvbiBLdShlLHQsbil7cmV0dXJue3ZhbHVlOmUsc291cmNlOm51bGwsc3RhY2s6bj8/bnVsbCxkaWdlc3Q6dD8/bnVsbH19ZnVuY3Rpb24gUWMoZSx0KXt0cnl7Y29uc29sZS5lcnJvcih0LnZhbHVlKX1jYXRjaChuKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgbn0pfX12YXIgRGs9dHlwZW9mIFdlYWtNYXA9PSJmdW5jdGlvbiI/V2Vha01hcDpNYXA7ZnVuY3Rpb24genYoZSx0LG4pe249SG4oLTEsbiksbi50YWc9MyxuLnBheWxvYWQ9e2VsZW1lbnQ6bnVsbH07dmFyIHI9dC52YWx1ZTtyZXR1cm4gbi5jYWxsYmFjaz1mdW5jdGlvbigpe1lhfHwoWWE9ITAsaWQ9ciksUWMoZSx0KX0sbn1mdW5jdGlvbiBMdihlLHQsbil7bj1IbigtMSxuKSxuLnRhZz0zO3ZhciByPWUudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7aWYodHlwZW9mIHI9PSJmdW5jdGlvbiIpe3ZhciBvPXQudmFsdWU7bi5wYXlsb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIobyl9LG4uY2FsbGJhY2s9ZnVuY3Rpb24oKXtRYyhlLHQpfX12YXIgaT1lLnN0YXRlTm9kZTtyZXR1cm4gaSE9PW51bGwmJnR5cGVvZiBpLmNvbXBvbmVudERpZENhdGNoPT0iZnVuY3Rpb24iJiYobi5jYWxsYmFjaz1mdW5jdGlvbigpe1FjKGUsdCksdHlwZW9mIHIhPSJmdW5jdGlvbiImJih5cj09PW51bGw/eXI9bmV3IFNldChbdGhpc10pOnlyLmFkZCh0aGlzKSk7dmFyIHM9dC5zdGFjazt0aGlzLmNvbXBvbmVudERpZENhdGNoKHQudmFsdWUse2NvbXBvbmVudFN0YWNrOnMhPT1udWxsP3M6IiJ9KX0pLG59ZnVuY3Rpb24gS20oZSx0LG4pe3ZhciByPWUucGluZ0NhY2hlO2lmKHI9PT1udWxsKXtyPWUucGluZ0NhY2hlPW5ldyBEazt2YXIgbz1uZXcgU2V0O3Iuc2V0KHQsbyl9ZWxzZSBvPXIuZ2V0KHQpLG89PT12b2lkIDAmJihvPW5ldyBTZXQsci5zZXQodCxvKSk7by5oYXMobil8fChvLmFkZChuKSxlPUprLmJpbmQobnVsbCxlLHQsbiksdC50aGVuKGUsZSkpfWZ1bmN0aW9uIFltKGUpe2Rve3ZhciB0O2lmKCh0PWUudGFnPT09MTMpJiYodD1lLm1lbW9pemVkU3RhdGUsdD10IT09bnVsbD90LmRlaHlkcmF0ZWQhPT1udWxsOiEwKSx0KXJldHVybiBlO2U9ZS5yZXR1cm59d2hpbGUoZSE9PW51bGwpO3JldHVybiBudWxsfWZ1bmN0aW9uIEdtKGUsdCxuLHIsbyl7cmV0dXJuIGUubW9kZSYxPyhlLmZsYWdzfD02NTUzNixlLmxhbmVzPW8sZSk6KGU9PT10P2UuZmxhZ3N8PTY1NTM2OihlLmZsYWdzfD0xMjgsbi5mbGFnc3w9MTMxMDcyLG4uZmxhZ3MmPS01MjgwNSxuLnRhZz09PTEmJihuLmFsdGVybmF0ZT09PW51bGw/bi50YWc9MTc6KHQ9SG4oLTEsMSksdC50YWc9MixncihuLHQsMSkpKSxuLmxhbmVzfD0xKSxlKX12YXIgRms9bnIuUmVhY3RDdXJyZW50T3duZXIsa3Q9ITE7ZnVuY3Rpb24gZ3QoZSx0LG4scil7dC5jaGlsZD1lPT09bnVsbD9mdih0LG51bGwsbixyKTp6byh0LGUuY2hpbGQsbixyKX1mdW5jdGlvbiBRbShlLHQsbixyLG8pe249bi5yZW5kZXI7dmFyIGk9dC5yZWY7cmV0dXJuICRvKHQsbykscj1NZihlLHQsbixyLGksbyksbj1fZigpLGUhPT1udWxsJiYha3Q/KHQudXBkYXRlUXVldWU9ZS51cGRhdGVRdWV1ZSx0LmZsYWdzJj0tMjA1MyxlLmxhbmVzJj1+byxabihlLHQsbykpOihfZSYmbiYmd2YodCksdC5mbGFnc3w9MSxndChlLHQscixvKSx0LmNoaWxkKX1mdW5jdGlvbiBYbShlLHQsbixyLG8pe2lmKGU9PT1udWxsKXt2YXIgaT1uLnR5cGU7cmV0dXJuIHR5cGVvZiBpPT0iZnVuY3Rpb24iJiYhV2YoaSkmJmkuZGVmYXVsdFByb3BzPT09dm9pZCAwJiZuLmNvbXBhcmU9PT1udWxsJiZuLmRlZmF1bHRQcm9wcz09PXZvaWQgMD8odC50YWc9MTUsdC50eXBlPWksanYoZSx0LGkscixvKSk6KGU9eWEobi50eXBlLG51bGwscix0LHQubW9kZSxvKSxlLnJlZj10LnJlZixlLnJldHVybj10LHQuY2hpbGQ9ZSl9aWYoaT1lLmNoaWxkLCEoZS5sYW5lcyZvKSl7dmFyIHM9aS5tZW1vaXplZFByb3BzO2lmKG49bi5jb21wYXJlLG49biE9PW51bGw/bjpaaSxuKHMscikmJmUucmVmPT09dC5yZWYpcmV0dXJuIFpuKGUsdCxvKX1yZXR1cm4gdC5mbGFnc3w9MSxlPXdyKGksciksZS5yZWY9dC5yZWYsZS5yZXR1cm49dCx0LmNoaWxkPWV9ZnVuY3Rpb24ganYoZSx0LG4scixvKXtpZihlIT09bnVsbCl7dmFyIGk9ZS5tZW1vaXplZFByb3BzO2lmKFppKGkscikmJmUucmVmPT09dC5yZWYpaWYoa3Q9ITEsdC5wZW5kaW5nUHJvcHM9cj1pLChlLmxhbmVzJm8pIT09MCllLmZsYWdzJjEzMTA3MiYmKGt0PSEwKTtlbHNlIHJldHVybiB0LmxhbmVzPWUubGFuZXMsWm4oZSx0LG8pfXJldHVybiBYYyhlLHQsbixyLG8pfWZ1bmN0aW9uIER2KGUsdCxuKXt2YXIgcj10LnBlbmRpbmdQcm9wcyxvPXIuY2hpbGRyZW4saT1lIT09bnVsbD9lLm1lbW9pemVkU3RhdGU6bnVsbDtpZihyLm1vZGU9PT0iaGlkZGVuIilpZighKHQubW9kZSYxKSl0Lm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczowLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9LFRlKHhvLE10KSxNdHw9bjtlbHNle2lmKCEobiYxMDczNzQxODI0KSlyZXR1cm4gZT1pIT09bnVsbD9pLmJhc2VMYW5lc3xuOm4sdC5sYW5lcz10LmNoaWxkTGFuZXM9MTA3Mzc0MTgyNCx0Lm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczplLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9LHQudXBkYXRlUXVldWU9bnVsbCxUZSh4byxNdCksTXR8PWUsbnVsbDt0Lm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczowLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9LHI9aSE9PW51bGw/aS5iYXNlTGFuZXM6bixUZSh4byxNdCksTXR8PXJ9ZWxzZSBpIT09bnVsbD8ocj1pLmJhc2VMYW5lc3xuLHQubWVtb2l6ZWRTdGF0ZT1udWxsKTpyPW4sVGUoeG8sTXQpLE10fD1yO3JldHVybiBndChlLHQsbyxuKSx0LmNoaWxkfWZ1bmN0aW9uIEZ2KGUsdCl7dmFyIG49dC5yZWY7KGU9PT1udWxsJiZuIT09bnVsbHx8ZSE9PW51bGwmJmUucmVmIT09bikmJih0LmZsYWdzfD01MTIsdC5mbGFnc3w9MjA5NzE1Mil9ZnVuY3Rpb24gWGMoZSx0LG4scixvKXt2YXIgaT1SdChuKT9VcjptdC5jdXJyZW50O3JldHVybiBpPUlvKHQsaSksJG8odCxvKSxuPU1mKGUsdCxuLHIsaSxvKSxyPV9mKCksZSE9PW51bGwmJiFrdD8odC51cGRhdGVRdWV1ZT1lLnVwZGF0ZVF1ZXVlLHQuZmxhZ3MmPS0yMDUzLGUubGFuZXMmPX5vLFpuKGUsdCxvKSk6KF9lJiZyJiZ3Zih0KSx0LmZsYWdzfD0xLGd0KGUsdCxuLG8pLHQuY2hpbGQpfWZ1bmN0aW9uIHFtKGUsdCxuLHIsbyl7aWYoUnQobikpe3ZhciBpPSEwO0xhKHQpfWVsc2UgaT0hMTtpZigkbyh0LG8pLHQuc3RhdGVOb2RlPT09bnVsbCltYShlLHQpLEF2KHQsbixyKSxHYyh0LG4scixvKSxyPSEwO2Vsc2UgaWYoZT09PW51bGwpe3ZhciBzPXQuc3RhdGVOb2RlLGE9dC5tZW1vaXplZFByb3BzO3MucHJvcHM9YTt2YXIgbD1zLmNvbnRleHQsdT1uLmNvbnRleHRUeXBlO3R5cGVvZiB1PT0ib2JqZWN0IiYmdSE9PW51bGw/dT10bih1KToodT1SdChuKT9VcjptdC5jdXJyZW50LHU9SW8odCx1KSk7dmFyIGM9bi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsZD10eXBlb2YgYz09ImZ1bmN0aW9uInx8dHlwZW9mIHMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU9PSJmdW5jdGlvbiI7ZHx8dHlwZW9mIHMuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMhPSJmdW5jdGlvbiImJnR5cGVvZiBzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMhPSJmdW5jdGlvbiJ8fChhIT09cnx8bCE9PXUpJiZWbSh0LHMscix1KSxzcj0hMTt2YXIgbT10Lm1lbW9pemVkU3RhdGU7cy5zdGF0ZT1tLFdhKHQscixzLG8pLGw9dC5tZW1vaXplZFN0YXRlLGEhPT1yfHxtIT09bHx8RXQuY3VycmVudHx8c3I/KHR5cGVvZiBjPT0iZnVuY3Rpb24iJiYoWWModCxuLGMsciksbD10Lm1lbW9pemVkU3RhdGUpLChhPXNyfHxIbSh0LG4sYSxyLG0sbCx1KSk/KGR8fHR5cGVvZiBzLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQhPSJmdW5jdGlvbiImJnR5cGVvZiBzLmNvbXBvbmVudFdpbGxNb3VudCE9ImZ1bmN0aW9uInx8KHR5cGVvZiBzLmNvbXBvbmVudFdpbGxNb3VudD09ImZ1bmN0aW9uIiYmcy5jb21wb25lbnRXaWxsTW91bnQoKSx0eXBlb2Ygcy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50PT0iZnVuY3Rpb24iJiZzLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksdHlwZW9mIHMuY29tcG9uZW50RGlkTW91bnQ9PSJmdW5jdGlvbiImJih0LmZsYWdzfD00MTk0MzA4KSk6KHR5cGVvZiBzLmNvbXBvbmVudERpZE1vdW50PT0iZnVuY3Rpb24iJiYodC5mbGFnc3w9NDE5NDMwOCksdC5tZW1vaXplZFByb3BzPXIsdC5tZW1vaXplZFN0YXRlPWwpLHMucHJvcHM9cixzLnN0YXRlPWwscy5jb250ZXh0PXUscj1hKToodHlwZW9mIHMuY29tcG9uZW50RGlkTW91bnQ9PSJmdW5jdGlvbiImJih0LmZsYWdzfD00MTk0MzA4KSxyPSExKX1lbHNle3M9dC5zdGF0ZU5vZGUsbXYoZSx0KSxhPXQubWVtb2l6ZWRQcm9wcyx1PXQudHlwZT09PXQuZWxlbWVudFR5cGU/YTpmbih0LnR5cGUsYSkscy5wcm9wcz11LGQ9dC5wZW5kaW5nUHJvcHMsbT1zLmNvbnRleHQsbD1uLmNvbnRleHRUeXBlLHR5cGVvZiBsPT0ib2JqZWN0IiYmbCE9PW51bGw/bD10bihsKToobD1SdChuKT9VcjptdC5jdXJyZW50LGw9SW8odCxsKSk7dmFyIHY9bi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7KGM9dHlwZW9mIHY9PSJmdW5jdGlvbiJ8fHR5cGVvZiBzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlPT0iZnVuY3Rpb24iKXx8dHlwZW9mIHMuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMhPSJmdW5jdGlvbiImJnR5cGVvZiBzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMhPSJmdW5jdGlvbiJ8fChhIT09ZHx8bSE9PWwpJiZWbSh0LHMscixsKSxzcj0hMSxtPXQubWVtb2l6ZWRTdGF0ZSxzLnN0YXRlPW0sV2EodCxyLHMsbyk7dmFyIHc9dC5tZW1vaXplZFN0YXRlO2EhPT1kfHxtIT09d3x8RXQuY3VycmVudHx8c3I/KHR5cGVvZiB2PT0iZnVuY3Rpb24iJiYoWWModCxuLHYsciksdz10Lm1lbW9pemVkU3RhdGUpLCh1PXNyfHxIbSh0LG4sdSxyLG0sdyxsKXx8ITEpPyhjfHx0eXBlb2Ygcy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSE9ImZ1bmN0aW9uIiYmdHlwZW9mIHMuY29tcG9uZW50V2lsbFVwZGF0ZSE9ImZ1bmN0aW9uInx8KHR5cGVvZiBzLmNvbXBvbmVudFdpbGxVcGRhdGU9PSJmdW5jdGlvbiImJnMuY29tcG9uZW50V2lsbFVwZGF0ZShyLHcsbCksdHlwZW9mIHMuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU9PSJmdW5jdGlvbiImJnMuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUocix3LGwpKSx0eXBlb2Ygcy5jb21wb25lbnREaWRVcGRhdGU9PSJmdW5jdGlvbiImJih0LmZsYWdzfD00KSx0eXBlb2Ygcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZT09ImZ1bmN0aW9uIiYmKHQuZmxhZ3N8PTEwMjQpKToodHlwZW9mIHMuY29tcG9uZW50RGlkVXBkYXRlIT0iZnVuY3Rpb24ifHxhPT09ZS5tZW1vaXplZFByb3BzJiZtPT09ZS5tZW1vaXplZFN0YXRlfHwodC5mbGFnc3w9NCksdHlwZW9mIHMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUhPSJmdW5jdGlvbiJ8fGE9PT1lLm1lbW9pemVkUHJvcHMmJm09PT1lLm1lbW9pemVkU3RhdGV8fCh0LmZsYWdzfD0xMDI0KSx0Lm1lbW9pemVkUHJvcHM9cix0Lm1lbW9pemVkU3RhdGU9dykscy5wcm9wcz1yLHMuc3RhdGU9dyxzLmNvbnRleHQ9bCxyPXUpOih0eXBlb2Ygcy5jb21wb25lbnREaWRVcGRhdGUhPSJmdW5jdGlvbiJ8fGE9PT1lLm1lbW9pemVkUHJvcHMmJm09PT1lLm1lbW9pemVkU3RhdGV8fCh0LmZsYWdzfD00KSx0eXBlb2Ygcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSE9ImZ1bmN0aW9uInx8YT09PWUubWVtb2l6ZWRQcm9wcyYmbT09PWUubWVtb2l6ZWRTdGF0ZXx8KHQuZmxhZ3N8PTEwMjQpLHI9ITEpfXJldHVybiBxYyhlLHQsbixyLGksbyl9ZnVuY3Rpb24gcWMoZSx0LG4scixvLGkpe0Z2KGUsdCk7dmFyIHM9KHQuZmxhZ3MmMTI4KSE9PTA7aWYoIXImJiFzKXJldHVybiBvJiZ6bSh0LG4sITEpLFpuKGUsdCxpKTtyPXQuc3RhdGVOb2RlLEZrLmN1cnJlbnQ9dDt2YXIgYT1zJiZ0eXBlb2Ygbi5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IhPSJmdW5jdGlvbiI/bnVsbDpyLnJlbmRlcigpO3JldHVybiB0LmZsYWdzfD0xLGUhPT1udWxsJiZzPyh0LmNoaWxkPXpvKHQsZS5jaGlsZCxudWxsLGkpLHQuY2hpbGQ9em8odCxudWxsLGEsaSkpOmd0KGUsdCxhLGkpLHQubWVtb2l6ZWRTdGF0ZT1yLnN0YXRlLG8mJnptKHQsbiwhMCksdC5jaGlsZH1mdW5jdGlvbiBCdihlKXt2YXIgdD1lLnN0YXRlTm9kZTt0LnBlbmRpbmdDb250ZXh0P0FtKGUsdC5wZW5kaW5nQ29udGV4dCx0LnBlbmRpbmdDb250ZXh0IT09dC5jb250ZXh0KTp0LmNvbnRleHQmJkFtKGUsdC5jb250ZXh0LCExKSxUZihlLHQuY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gWm0oZSx0LG4scixvKXtyZXR1cm4gQW8oKSx4ZihvKSx0LmZsYWdzfD0yNTYsZ3QoZSx0LG4sciksdC5jaGlsZH12YXIgWmM9e2RlaHlkcmF0ZWQ6bnVsbCx0cmVlQ29udGV4dDpudWxsLHJldHJ5TGFuZTowfTtmdW5jdGlvbiBKYyhlKXtyZXR1cm57YmFzZUxhbmVzOmUsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH19ZnVuY3Rpb24gV3YoZSx0LG4pe3ZhciByPXQucGVuZGluZ1Byb3BzLG89QWUuY3VycmVudCxpPSExLHM9KHQuZmxhZ3MmMTI4KSE9PTAsYTtpZigoYT1zKXx8KGE9ZSE9PW51bGwmJmUubWVtb2l6ZWRTdGF0ZT09PW51bGw/ITE6KG8mMikhPT0wKSxhPyhpPSEwLHQuZmxhZ3MmPS0xMjkpOihlPT09bnVsbHx8ZS5tZW1vaXplZFN0YXRlIT09bnVsbCkmJihvfD0xKSxUZShBZSxvJjEpLGU9PT1udWxsKXJldHVybiBWYyh0KSxlPXQubWVtb2l6ZWRTdGF0ZSxlIT09bnVsbCYmKGU9ZS5kZWh5ZHJhdGVkLGUhPT1udWxsKT8odC5tb2RlJjE/ZS5kYXRhPT09IiQhIj90LmxhbmVzPTg6dC5sYW5lcz0xMDczNzQxODI0OnQubGFuZXM9MSxudWxsKToocz1yLmNoaWxkcmVuLGU9ci5mYWxsYmFjayxpPyhyPXQubW9kZSxpPXQuY2hpbGQscz17bW9kZToiaGlkZGVuIixjaGlsZHJlbjpzfSwhKHImMSkmJmkhPT1udWxsPyhpLmNoaWxkTGFuZXM9MCxpLnBlbmRpbmdQcm9wcz1zKTppPXR1KHMsciwwLG51bGwpLGU9QnIoZSxyLG4sbnVsbCksaS5yZXR1cm49dCxlLnJldHVybj10LGkuc2libGluZz1lLHQuY2hpbGQ9aSx0LmNoaWxkLm1lbW9pemVkU3RhdGU9SmMobiksdC5tZW1vaXplZFN0YXRlPVpjLGUpOkFmKHQscykpO2lmKG89ZS5tZW1vaXplZFN0YXRlLG8hPT1udWxsJiYoYT1vLmRlaHlkcmF0ZWQsYSE9PW51bGwpKXJldHVybiBCayhlLHQscyxyLGEsbyxuKTtpZihpKXtpPXIuZmFsbGJhY2sscz10Lm1vZGUsbz1lLmNoaWxkLGE9by5zaWJsaW5nO3ZhciBsPXttb2RlOiJoaWRkZW4iLGNoaWxkcmVuOnIuY2hpbGRyZW59O3JldHVybiEocyYxKSYmdC5jaGlsZCE9PW8/KHI9dC5jaGlsZCxyLmNoaWxkTGFuZXM9MCxyLnBlbmRpbmdQcm9wcz1sLHQuZGVsZXRpb25zPW51bGwpOihyPXdyKG8sbCksci5zdWJ0cmVlRmxhZ3M9by5zdWJ0cmVlRmxhZ3MmMTQ2ODAwNjQpLGEhPT1udWxsP2k9d3IoYSxpKTooaT1CcihpLHMsbixudWxsKSxpLmZsYWdzfD0yKSxpLnJldHVybj10LHIucmV0dXJuPXQsci5zaWJsaW5nPWksdC5jaGlsZD1yLHI9aSxpPXQuY2hpbGQscz1lLmNoaWxkLm1lbW9pemVkU3RhdGUscz1zPT09bnVsbD9KYyhuKTp7YmFzZUxhbmVzOnMuYmFzZUxhbmVzfG4sY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6cy50cmFuc2l0aW9uc30saS5tZW1vaXplZFN0YXRlPXMsaS5jaGlsZExhbmVzPWUuY2hpbGRMYW5lcyZ+bix0Lm1lbW9pemVkU3RhdGU9WmMscn1yZXR1cm4gaT1lLmNoaWxkLGU9aS5zaWJsaW5nLHI9d3IoaSx7bW9kZToidmlzaWJsZSIsY2hpbGRyZW46ci5jaGlsZHJlbn0pLCEodC5tb2RlJjEpJiYoci5sYW5lcz1uKSxyLnJldHVybj10LHIuc2libGluZz1udWxsLGUhPT1udWxsJiYobj10LmRlbGV0aW9ucyxuPT09bnVsbD8odC5kZWxldGlvbnM9W2VdLHQuZmxhZ3N8PTE2KTpuLnB1c2goZSkpLHQuY2hpbGQ9cix0Lm1lbW9pemVkU3RhdGU9bnVsbCxyfWZ1bmN0aW9uIEFmKGUsdCl7cmV0dXJuIHQ9dHUoe21vZGU6InZpc2libGUiLGNoaWxkcmVuOnR9LGUubW9kZSwwLG51bGwpLHQucmV0dXJuPWUsZS5jaGlsZD10fWZ1bmN0aW9uIEhzKGUsdCxuLHIpe3JldHVybiByIT09bnVsbCYmeGYociksem8odCxlLmNoaWxkLG51bGwsbiksZT1BZih0LHQucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxlLmZsYWdzfD0yLHQubWVtb2l6ZWRTdGF0ZT1udWxsLGV9ZnVuY3Rpb24gQmsoZSx0LG4scixvLGkscyl7aWYobilyZXR1cm4gdC5mbGFncyYyNTY/KHQuZmxhZ3MmPS0yNTcscj1LdShFcnJvcihGKDQyMikpKSxIcyhlLHQscyxyKSk6dC5tZW1vaXplZFN0YXRlIT09bnVsbD8odC5jaGlsZD1lLmNoaWxkLHQuZmxhZ3N8PTEyOCxudWxsKTooaT1yLmZhbGxiYWNrLG89dC5tb2RlLHI9dHUoe21vZGU6InZpc2libGUiLGNoaWxkcmVuOnIuY2hpbGRyZW59LG8sMCxudWxsKSxpPUJyKGksbyxzLG51bGwpLGkuZmxhZ3N8PTIsci5yZXR1cm49dCxpLnJldHVybj10LHIuc2libGluZz1pLHQuY2hpbGQ9cix0Lm1vZGUmMSYmem8odCxlLmNoaWxkLG51bGwscyksdC5jaGlsZC5tZW1vaXplZFN0YXRlPUpjKHMpLHQubWVtb2l6ZWRTdGF0ZT1aYyxpKTtpZighKHQubW9kZSYxKSlyZXR1cm4gSHMoZSx0LHMsbnVsbCk7aWYoby5kYXRhPT09IiQhIil7aWYocj1vLm5leHRTaWJsaW5nJiZvLm5leHRTaWJsaW5nLmRhdGFzZXQscil2YXIgYT1yLmRnc3Q7cmV0dXJuIHI9YSxpPUVycm9yKEYoNDE5KSkscj1LdShpLHIsdm9pZCAwKSxIcyhlLHQscyxyKX1pZihhPShzJmUuY2hpbGRMYW5lcykhPT0wLGt0fHxhKXtpZihyPWV0LHIhPT1udWxsKXtzd2l0Y2gocyYtcyl7Y2FzZSA0Om89MjticmVhaztjYXNlIDE2Om89ODticmVhaztjYXNlIDY0OmNhc2UgMTI4OmNhc2UgMjU2OmNhc2UgNTEyOmNhc2UgMTAyNDpjYXNlIDIwNDg6Y2FzZSA0MDk2OmNhc2UgODE5MjpjYXNlIDE2Mzg0OmNhc2UgMzI3Njg6Y2FzZSA2NTUzNjpjYXNlIDEzMTA3MjpjYXNlIDI2MjE0NDpjYXNlIDUyNDI4ODpjYXNlIDEwNDg1NzY6Y2FzZSAyMDk3MTUyOmNhc2UgNDE5NDMwNDpjYXNlIDgzODg2MDg6Y2FzZSAxNjc3NzIxNjpjYXNlIDMzNTU0NDMyOmNhc2UgNjcxMDg4NjQ6bz0zMjticmVhaztjYXNlIDUzNjg3MDkxMjpvPTI2ODQzNTQ1NjticmVhaztkZWZhdWx0Om89MH1vPW8mKHIuc3VzcGVuZGVkTGFuZXN8cyk/MDpvLG8hPT0wJiZvIT09aS5yZXRyeUxhbmUmJihpLnJldHJ5TGFuZT1vLHFuKGUsbyksdm4ocixlLG8sLTEpKX1yZXR1cm4gQmYoKSxyPUt1KEVycm9yKEYoNDIxKSkpLEhzKGUsdCxzLHIpfXJldHVybiBvLmRhdGE9PT0iJD8iPyh0LmZsYWdzfD0xMjgsdC5jaGlsZD1lLmNoaWxkLHQ9ZUUuYmluZChudWxsLGUpLG8uX3JlYWN0UmV0cnk9dCxudWxsKTooZT1pLnRyZWVDb250ZXh0LEF0PWhyKG8ubmV4dFNpYmxpbmcpLGp0PXQsX2U9ITAsaG49bnVsbCxlIT09bnVsbCYmKFh0W3F0KytdPVduLFh0W3F0KytdPVVuLFh0W3F0KytdPUhyLFduPWUuaWQsVW49ZS5vdmVyZmxvdyxIcj10KSx0PUFmKHQsci5jaGlsZHJlbiksdC5mbGFnc3w9NDA5Nix0KX1mdW5jdGlvbiBKbShlLHQsbil7ZS5sYW5lc3w9dDt2YXIgcj1lLmFsdGVybmF0ZTtyIT09bnVsbCYmKHIubGFuZXN8PXQpLEtjKGUucmV0dXJuLHQsbil9ZnVuY3Rpb24gWXUoZSx0LG4scixvKXt2YXIgaT1lLm1lbW9pemVkU3RhdGU7aT09PW51bGw/ZS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczp0LHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6cix0YWlsOm4sdGFpbE1vZGU6b306KGkuaXNCYWNrd2FyZHM9dCxpLnJlbmRlcmluZz1udWxsLGkucmVuZGVyaW5nU3RhcnRUaW1lPTAsaS5sYXN0PXIsaS50YWlsPW4saS50YWlsTW9kZT1vKX1mdW5jdGlvbiBVdihlLHQsbil7dmFyIHI9dC5wZW5kaW5nUHJvcHMsbz1yLnJldmVhbE9yZGVyLGk9ci50YWlsO2lmKGd0KGUsdCxyLmNoaWxkcmVuLG4pLHI9QWUuY3VycmVudCxyJjIpcj1yJjF8Mix0LmZsYWdzfD0xMjg7ZWxzZXtpZihlIT09bnVsbCYmZS5mbGFncyYxMjgpZTpmb3IoZT10LmNoaWxkO2UhPT1udWxsOyl7aWYoZS50YWc9PT0xMyllLm1lbW9pemVkU3RhdGUhPT1udWxsJiZKbShlLG4sdCk7ZWxzZSBpZihlLnRhZz09PTE5KUptKGUsbix0KTtlbHNlIGlmKGUuY2hpbGQhPT1udWxsKXtlLmNoaWxkLnJldHVybj1lLGU9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09dClicmVhayBlO2Zvcig7ZS5zaWJsaW5nPT09bnVsbDspe2lmKGUucmV0dXJuPT09bnVsbHx8ZS5yZXR1cm49PT10KWJyZWFrIGU7ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuLGU9ZS5zaWJsaW5nfXImPTF9aWYoVGUoQWUsciksISh0Lm1vZGUmMSkpdC5tZW1vaXplZFN0YXRlPW51bGw7ZWxzZSBzd2l0Y2gobyl7Y2FzZSJmb3J3YXJkcyI6Zm9yKG49dC5jaGlsZCxvPW51bGw7biE9PW51bGw7KWU9bi5hbHRlcm5hdGUsZSE9PW51bGwmJlVhKGUpPT09bnVsbCYmKG89biksbj1uLnNpYmxpbmc7bj1vLG49PT1udWxsPyhvPXQuY2hpbGQsdC5jaGlsZD1udWxsKToobz1uLnNpYmxpbmcsbi5zaWJsaW5nPW51bGwpLFl1KHQsITEsbyxuLGkpO2JyZWFrO2Nhc2UiYmFja3dhcmRzIjpmb3Iobj1udWxsLG89dC5jaGlsZCx0LmNoaWxkPW51bGw7byE9PW51bGw7KXtpZihlPW8uYWx0ZXJuYXRlLGUhPT1udWxsJiZVYShlKT09PW51bGwpe3QuY2hpbGQ9bzticmVha31lPW8uc2libGluZyxvLnNpYmxpbmc9bixuPW8sbz1lfVl1KHQsITAsbixudWxsLGkpO2JyZWFrO2Nhc2UidG9nZXRoZXIiOll1KHQsITEsbnVsbCxudWxsLHZvaWQgMCk7YnJlYWs7ZGVmYXVsdDp0Lm1lbW9pemVkU3RhdGU9bnVsbH1yZXR1cm4gdC5jaGlsZH1mdW5jdGlvbiBtYShlLHQpeyEodC5tb2RlJjEpJiZlIT09bnVsbCYmKGUuYWx0ZXJuYXRlPW51bGwsdC5hbHRlcm5hdGU9bnVsbCx0LmZsYWdzfD0yKX1mdW5jdGlvbiBabihlLHQsbil7aWYoZSE9PW51bGwmJih0LmRlcGVuZGVuY2llcz1lLmRlcGVuZGVuY2llcyksS3J8PXQubGFuZXMsIShuJnQuY2hpbGRMYW5lcykpcmV0dXJuIG51bGw7aWYoZSE9PW51bGwmJnQuY2hpbGQhPT1lLmNoaWxkKXRocm93IEVycm9yKEYoMTUzKSk7aWYodC5jaGlsZCE9PW51bGwpe2ZvcihlPXQuY2hpbGQsbj13cihlLGUucGVuZGluZ1Byb3BzKSx0LmNoaWxkPW4sbi5yZXR1cm49dDtlLnNpYmxpbmchPT1udWxsOyllPWUuc2libGluZyxuPW4uc2libGluZz13cihlLGUucGVuZGluZ1Byb3BzKSxuLnJldHVybj10O24uc2libGluZz1udWxsfXJldHVybiB0LmNoaWxkfWZ1bmN0aW9uIFdrKGUsdCxuKXtzd2l0Y2godC50YWcpe2Nhc2UgMzpCdih0KSxBbygpO2JyZWFrO2Nhc2UgNTpodih0KTticmVhaztjYXNlIDE6UnQodC50eXBlKSYmTGEodCk7YnJlYWs7Y2FzZSA0OlRmKHQsdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7YnJlYWs7Y2FzZSAxMDp2YXIgcj10LnR5cGUuX2NvbnRleHQsbz10Lm1lbW9pemVkUHJvcHMudmFsdWU7VGUoRmEsci5fY3VycmVudFZhbHVlKSxyLl9jdXJyZW50VmFsdWU9bzticmVhaztjYXNlIDEzOmlmKHI9dC5tZW1vaXplZFN0YXRlLHIhPT1udWxsKXJldHVybiByLmRlaHlkcmF0ZWQhPT1udWxsPyhUZShBZSxBZS5jdXJyZW50JjEpLHQuZmxhZ3N8PTEyOCxudWxsKTpuJnQuY2hpbGQuY2hpbGRMYW5lcz9XdihlLHQsbik6KFRlKEFlLEFlLmN1cnJlbnQmMSksZT1abihlLHQsbiksZSE9PW51bGw/ZS5zaWJsaW5nOm51bGwpO1RlKEFlLEFlLmN1cnJlbnQmMSk7YnJlYWs7Y2FzZSAxOTppZihyPShuJnQuY2hpbGRMYW5lcykhPT0wLGUuZmxhZ3MmMTI4KXtpZihyKXJldHVybiBVdihlLHQsbik7dC5mbGFnc3w9MTI4fWlmKG89dC5tZW1vaXplZFN0YXRlLG8hPT1udWxsJiYoby5yZW5kZXJpbmc9bnVsbCxvLnRhaWw9bnVsbCxvLmxhc3RFZmZlY3Q9bnVsbCksVGUoQWUsQWUuY3VycmVudCkscilicmVhaztyZXR1cm4gbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIHQubGFuZXM9MCxEdihlLHQsbil9cmV0dXJuIFpuKGUsdCxuKX12YXIgSHYsZWQsVnYsS3Y7SHY9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dC5jaGlsZDtuIT09bnVsbDspe2lmKG4udGFnPT09NXx8bi50YWc9PT02KWUuYXBwZW5kQ2hpbGQobi5zdGF0ZU5vZGUpO2Vsc2UgaWYobi50YWchPT00JiZuLmNoaWxkIT09bnVsbCl7bi5jaGlsZC5yZXR1cm49bixuPW4uY2hpbGQ7Y29udGludWV9aWYobj09PXQpYnJlYWs7Zm9yKDtuLnNpYmxpbmc9PT1udWxsOyl7aWYobi5yZXR1cm49PT1udWxsfHxuLnJldHVybj09PXQpcmV0dXJuO249bi5yZXR1cm59bi5zaWJsaW5nLnJldHVybj1uLnJldHVybixuPW4uc2libGluZ319O2VkPWZ1bmN0aW9uKCl7fTtWdj1mdW5jdGlvbihlLHQsbixyKXt2YXIgbz1lLm1lbW9pemVkUHJvcHM7aWYobyE9PXIpe2U9dC5zdGF0ZU5vZGUsanIoSW4uY3VycmVudCk7dmFyIGk9bnVsbDtzd2l0Y2gobil7Y2FzZSJpbnB1dCI6bz1DYyhlLG8pLHI9Q2MoZSxyKSxpPVtdO2JyZWFrO2Nhc2Uic2VsZWN0IjpvPUxlKHt9LG8se3ZhbHVlOnZvaWQgMH0pLHI9TGUoe30scix7dmFsdWU6dm9pZCAwfSksaT1bXTticmVhaztjYXNlInRleHRhcmVhIjpvPUVjKGUsbykscj1FYyhlLHIpLGk9W107YnJlYWs7ZGVmYXVsdDp0eXBlb2Ygby5vbkNsaWNrIT0iZnVuY3Rpb24iJiZ0eXBlb2Ygci5vbkNsaWNrPT0iZnVuY3Rpb24iJiYoZS5vbmNsaWNrPUFhKX1UYyhuLHIpO3ZhciBzO249bnVsbDtmb3IodSBpbiBvKWlmKCFyLmhhc093blByb3BlcnR5KHUpJiZvLmhhc093blByb3BlcnR5KHUpJiZvW3VdIT1udWxsKWlmKHU9PT0ic3R5bGUiKXt2YXIgYT1vW3VdO2ZvcihzIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShzKSYmKG58fChuPXt9KSxuW3NdPSIiKX1lbHNlIHUhPT0iZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiJiZ1IT09ImNoaWxkcmVuIiYmdSE9PSJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciJiZ1IT09InN1cHByZXNzSHlkcmF0aW9uV2FybmluZyImJnUhPT0iYXV0b0ZvY3VzIiYmKFZpLmhhc093blByb3BlcnR5KHUpP2l8fChpPVtdKTooaT1pfHxbXSkucHVzaCh1LG51bGwpKTtmb3IodSBpbiByKXt2YXIgbD1yW3VdO2lmKGE9byE9bnVsbD9vW3VdOnZvaWQgMCxyLmhhc093blByb3BlcnR5KHUpJiZsIT09YSYmKGwhPW51bGx8fGEhPW51bGwpKWlmKHU9PT0ic3R5bGUiKWlmKGEpe2ZvcihzIGluIGEpIWEuaGFzT3duUHJvcGVydHkocyl8fGwmJmwuaGFzT3duUHJvcGVydHkocyl8fChufHwobj17fSksbltzXT0iIik7Zm9yKHMgaW4gbClsLmhhc093blByb3BlcnR5KHMpJiZhW3NdIT09bFtzXSYmKG58fChuPXt9KSxuW3NdPWxbc10pfWVsc2Ugbnx8KGl8fChpPVtdKSxpLnB1c2godSxuKSksbj1sO2Vsc2UgdT09PSJkYW5nZXJvdXNseVNldElubmVySFRNTCI/KGw9bD9sLl9faHRtbDp2b2lkIDAsYT1hP2EuX19odG1sOnZvaWQgMCxsIT1udWxsJiZhIT09bCYmKGk9aXx8W10pLnB1c2godSxsKSk6dT09PSJjaGlsZHJlbiI/dHlwZW9mIGwhPSJzdHJpbmciJiZ0eXBlb2YgbCE9Im51bWJlciJ8fChpPWl8fFtdKS5wdXNoKHUsIiIrbCk6dSE9PSJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciJiZ1IT09InN1cHByZXNzSHlkcmF0aW9uV2FybmluZyImJihWaS5oYXNPd25Qcm9wZXJ0eSh1KT8obCE9bnVsbCYmdT09PSJvblNjcm9sbCImJlBlKCJzY3JvbGwiLGUpLGl8fGE9PT1sfHwoaT1bXSkpOihpPWl8fFtdKS5wdXNoKHUsbCkpfW4mJihpPWl8fFtdKS5wdXNoKCJzdHlsZSIsbik7dmFyIHU9aTsodC51cGRhdGVRdWV1ZT11KSYmKHQuZmxhZ3N8PTQpfX07S3Y9ZnVuY3Rpb24oZSx0LG4scil7biE9PXImJih0LmZsYWdzfD00KX07ZnVuY3Rpb24gY2koZSx0KXtpZighX2Upc3dpdGNoKGUudGFpbE1vZGUpe2Nhc2UiaGlkZGVuIjp0PWUudGFpbDtmb3IodmFyIG49bnVsbDt0IT09bnVsbDspdC5hbHRlcm5hdGUhPT1udWxsJiYobj10KSx0PXQuc2libGluZztuPT09bnVsbD9lLnRhaWw9bnVsbDpuLnNpYmxpbmc9bnVsbDticmVhaztjYXNlImNvbGxhcHNlZCI6bj1lLnRhaWw7Zm9yKHZhciByPW51bGw7biE9PW51bGw7KW4uYWx0ZXJuYXRlIT09bnVsbCYmKHI9biksbj1uLnNpYmxpbmc7cj09PW51bGw/dHx8ZS50YWlsPT09bnVsbD9lLnRhaWw9bnVsbDplLnRhaWwuc2libGluZz1udWxsOnIuc2libGluZz1udWxsfX1mdW5jdGlvbiB1dChlKXt2YXIgdD1lLmFsdGVybmF0ZSE9PW51bGwmJmUuYWx0ZXJuYXRlLmNoaWxkPT09ZS5jaGlsZCxuPTAscj0wO2lmKHQpZm9yKHZhciBvPWUuY2hpbGQ7byE9PW51bGw7KW58PW8ubGFuZXN8by5jaGlsZExhbmVzLHJ8PW8uc3VidHJlZUZsYWdzJjE0NjgwMDY0LHJ8PW8uZmxhZ3MmMTQ2ODAwNjQsby5yZXR1cm49ZSxvPW8uc2libGluZztlbHNlIGZvcihvPWUuY2hpbGQ7byE9PW51bGw7KW58PW8ubGFuZXN8by5jaGlsZExhbmVzLHJ8PW8uc3VidHJlZUZsYWdzLHJ8PW8uZmxhZ3Msby5yZXR1cm49ZSxvPW8uc2libGluZztyZXR1cm4gZS5zdWJ0cmVlRmxhZ3N8PXIsZS5jaGlsZExhbmVzPW4sdH1mdW5jdGlvbiBVayhlLHQsbil7dmFyIHI9dC5wZW5kaW5nUHJvcHM7c3dpdGNoKFNmKHQpLHQudGFnKXtjYXNlIDI6Y2FzZSAxNjpjYXNlIDE1OmNhc2UgMDpjYXNlIDExOmNhc2UgNzpjYXNlIDg6Y2FzZSAxMjpjYXNlIDk6Y2FzZSAxNDpyZXR1cm4gdXQodCksbnVsbDtjYXNlIDE6cmV0dXJuIFJ0KHQudHlwZSkmJnphKCksdXQodCksbnVsbDtjYXNlIDM6cmV0dXJuIHI9dC5zdGF0ZU5vZGUsTG8oKSwkZShFdCksJGUobXQpLCRmKCksci5wZW5kaW5nQ29udGV4dCYmKHIuY29udGV4dD1yLnBlbmRpbmdDb250ZXh0LHIucGVuZGluZ0NvbnRleHQ9bnVsbCksKGU9PT1udWxsfHxlLmNoaWxkPT09bnVsbCkmJihXcyh0KT90LmZsYWdzfD00OmU9PT1udWxsfHxlLm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkJiYhKHQuZmxhZ3MmMjU2KXx8KHQuZmxhZ3N8PTEwMjQsaG4hPT1udWxsJiYobGQoaG4pLGhuPW51bGwpKSksZWQoZSx0KSx1dCh0KSxudWxsO2Nhc2UgNTpQZih0KTt2YXIgbz1qcihycy5jdXJyZW50KTtpZihuPXQudHlwZSxlIT09bnVsbCYmdC5zdGF0ZU5vZGUhPW51bGwpVnYoZSx0LG4scixvKSxlLnJlZiE9PXQucmVmJiYodC5mbGFnc3w9NTEyLHQuZmxhZ3N8PTIwOTcxNTIpO2Vsc2V7aWYoIXIpe2lmKHQuc3RhdGVOb2RlPT09bnVsbCl0aHJvdyBFcnJvcihGKDE2NikpO3JldHVybiB1dCh0KSxudWxsfWlmKGU9anIoSW4uY3VycmVudCksV3ModCkpe3I9dC5zdGF0ZU5vZGUsbj10LnR5cGU7dmFyIGk9dC5tZW1vaXplZFByb3BzO3N3aXRjaChyW01uXT10LHJbdHNdPWksZT0odC5tb2RlJjEpIT09MCxuKXtjYXNlImRpYWxvZyI6UGUoImNhbmNlbCIsciksUGUoImNsb3NlIixyKTticmVhaztjYXNlImlmcmFtZSI6Y2FzZSJvYmplY3QiOmNhc2UiZW1iZWQiOlBlKCJsb2FkIixyKTticmVhaztjYXNlInZpZGVvIjpjYXNlImF1ZGlvIjpmb3Iobz0wO288Q2kubGVuZ3RoO28rKylQZShDaVtvXSxyKTticmVhaztjYXNlInNvdXJjZSI6UGUoImVycm9yIixyKTticmVhaztjYXNlImltZyI6Y2FzZSJpbWFnZSI6Y2FzZSJsaW5rIjpQZSgiZXJyb3IiLHIpLFBlKCJsb2FkIixyKTticmVhaztjYXNlImRldGFpbHMiOlBlKCJ0b2dnbGUiLHIpO2JyZWFrO2Nhc2UiaW5wdXQiOmxtKHIsaSksUGUoImludmFsaWQiLHIpO2JyZWFrO2Nhc2Uic2VsZWN0IjpyLl93cmFwcGVyU3RhdGU9e3dhc011bHRpcGxlOiEhaS5tdWx0aXBsZX0sUGUoImludmFsaWQiLHIpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOmNtKHIsaSksUGUoImludmFsaWQiLHIpfVRjKG4saSksbz1udWxsO2Zvcih2YXIgcyBpbiBpKWlmKGkuaGFzT3duUHJvcGVydHkocykpe3ZhciBhPWlbc107cz09PSJjaGlsZHJlbiI/dHlwZW9mIGE9PSJzdHJpbmciP3IudGV4dENvbnRlbnQhPT1hJiYoaS5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmchPT0hMCYmQnMoci50ZXh0Q29udGVudCxhLGUpLG89WyJjaGlsZHJlbiIsYV0pOnR5cGVvZiBhPT0ibnVtYmVyIiYmci50ZXh0Q29udGVudCE9PSIiK2EmJihpLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyE9PSEwJiZCcyhyLnRleHRDb250ZW50LGEsZSksbz1bImNoaWxkcmVuIiwiIithXSk6VmkuaGFzT3duUHJvcGVydHkocykmJmEhPW51bGwmJnM9PT0ib25TY3JvbGwiJiZQZSgic2Nyb2xsIixyKX1zd2l0Y2gobil7Y2FzZSJpbnB1dCI6TnMociksdW0ocixpLCEwKTticmVhaztjYXNlInRleHRhcmVhIjpOcyhyKSxkbShyKTticmVhaztjYXNlInNlbGVjdCI6Y2FzZSJvcHRpb24iOmJyZWFrO2RlZmF1bHQ6dHlwZW9mIGkub25DbGljaz09ImZ1bmN0aW9uIiYmKHIub25jbGljaz1BYSl9cj1vLHQudXBkYXRlUXVldWU9cixyIT09bnVsbCYmKHQuZmxhZ3N8PTQpfWVsc2V7cz1vLm5vZGVUeXBlPT09OT9vOm8ub3duZXJEb2N1bWVudCxlPT09Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiJiYoZT1TeShuKSksZT09PSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj9uPT09InNjcmlwdCI/KGU9cy5jcmVhdGVFbGVtZW50KCJkaXYiKSxlLmlubmVySFRNTD0iPHNjcmlwdD48XC9zY3JpcHQ+IixlPWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKSk6dHlwZW9mIHIuaXM9PSJzdHJpbmciP2U9cy5jcmVhdGVFbGVtZW50KG4se2lzOnIuaXN9KTooZT1zLmNyZWF0ZUVsZW1lbnQobiksbj09PSJzZWxlY3QiJiYocz1lLHIubXVsdGlwbGU/cy5tdWx0aXBsZT0hMDpyLnNpemUmJihzLnNpemU9ci5zaXplKSkpOmU9cy5jcmVhdGVFbGVtZW50TlMoZSxuKSxlW01uXT10LGVbdHNdPXIsSHYoZSx0LCExLCExKSx0LnN0YXRlTm9kZT1lO2U6e3N3aXRjaChzPVBjKG4sciksbil7Y2FzZSJkaWFsb2ciOlBlKCJjYW5jZWwiLGUpLFBlKCJjbG9zZSIsZSksbz1yO2JyZWFrO2Nhc2UiaWZyYW1lIjpjYXNlIm9iamVjdCI6Y2FzZSJlbWJlZCI6UGUoImxvYWQiLGUpLG89cjticmVhaztjYXNlInZpZGVvIjpjYXNlImF1ZGlvIjpmb3Iobz0wO288Q2kubGVuZ3RoO28rKylQZShDaVtvXSxlKTtvPXI7YnJlYWs7Y2FzZSJzb3VyY2UiOlBlKCJlcnJvciIsZSksbz1yO2JyZWFrO2Nhc2UiaW1nIjpjYXNlImltYWdlIjpjYXNlImxpbmsiOlBlKCJlcnJvciIsZSksUGUoImxvYWQiLGUpLG89cjticmVhaztjYXNlImRldGFpbHMiOlBlKCJ0b2dnbGUiLGUpLG89cjticmVhaztjYXNlImlucHV0IjpsbShlLHIpLG89Q2MoZSxyKSxQZSgiaW52YWxpZCIsZSk7YnJlYWs7Y2FzZSJvcHRpb24iOm89cjticmVhaztjYXNlInNlbGVjdCI6ZS5fd3JhcHBlclN0YXRlPXt3YXNNdWx0aXBsZTohIXIubXVsdGlwbGV9LG89TGUoe30scix7dmFsdWU6dm9pZCAwfSksUGUoImludmFsaWQiLGUpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOmNtKGUsciksbz1FYyhlLHIpLFBlKCJpbnZhbGlkIixlKTticmVhaztkZWZhdWx0Om89cn1UYyhuLG8pLGE9bztmb3IoaSBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoaSkpe3ZhciBsPWFbaV07aT09PSJzdHlsZSI/YnkoZSxsKTppPT09ImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIj8obD1sP2wuX19odG1sOnZvaWQgMCxsIT1udWxsJiZ4eShlLGwpKTppPT09ImNoaWxkcmVuIj90eXBlb2YgbD09InN0cmluZyI/KG4hPT0idGV4dGFyZWEifHxsIT09IiIpJiZLaShlLGwpOnR5cGVvZiBsPT0ibnVtYmVyIiYmS2koZSwiIitsKTppIT09InN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyImJmkhPT0ic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiYmaSE9PSJhdXRvRm9jdXMiJiYoVmkuaGFzT3duUHJvcGVydHkoaSk/bCE9bnVsbCYmaT09PSJvblNjcm9sbCImJlBlKCJzY3JvbGwiLGUpOmwhPW51bGwmJm9mKGUsaSxsLHMpKX1zd2l0Y2gobil7Y2FzZSJpbnB1dCI6TnMoZSksdW0oZSxyLCExKTticmVhaztjYXNlInRleHRhcmVhIjpOcyhlKSxkbShlKTticmVhaztjYXNlIm9wdGlvbiI6ci52YWx1ZSE9bnVsbCYmZS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiIit4cihyLnZhbHVlKSk7YnJlYWs7Y2FzZSJzZWxlY3QiOmUubXVsdGlwbGU9ISFyLm11bHRpcGxlLGk9ci52YWx1ZSxpIT1udWxsP0VvKGUsISFyLm11bHRpcGxlLGksITEpOnIuZGVmYXVsdFZhbHVlIT1udWxsJiZFbyhlLCEhci5tdWx0aXBsZSxyLmRlZmF1bHRWYWx1ZSwhMCk7YnJlYWs7ZGVmYXVsdDp0eXBlb2Ygby5vbkNsaWNrPT0iZnVuY3Rpb24iJiYoZS5vbmNsaWNrPUFhKX1zd2l0Y2gobil7Y2FzZSJidXR0b24iOmNhc2UiaW5wdXQiOmNhc2Uic2VsZWN0IjpjYXNlInRleHRhcmVhIjpyPSEhci5hdXRvRm9jdXM7YnJlYWsgZTtjYXNlImltZyI6cj0hMDticmVhayBlO2RlZmF1bHQ6cj0hMX19ciYmKHQuZmxhZ3N8PTQpfXQucmVmIT09bnVsbCYmKHQuZmxhZ3N8PTUxMix0LmZsYWdzfD0yMDk3MTUyKX1yZXR1cm4gdXQodCksbnVsbDtjYXNlIDY6aWYoZSYmdC5zdGF0ZU5vZGUhPW51bGwpS3YoZSx0LGUubWVtb2l6ZWRQcm9wcyxyKTtlbHNle2lmKHR5cGVvZiByIT0ic3RyaW5nIiYmdC5zdGF0ZU5vZGU9PT1udWxsKXRocm93IEVycm9yKEYoMTY2KSk7aWYobj1qcihycy5jdXJyZW50KSxqcihJbi5jdXJyZW50KSxXcyh0KSl7aWYocj10LnN0YXRlTm9kZSxuPXQubWVtb2l6ZWRQcm9wcyxyW01uXT10LChpPXIubm9kZVZhbHVlIT09bikmJihlPWp0LGUhPT1udWxsKSlzd2l0Y2goZS50YWcpe2Nhc2UgMzpCcyhyLm5vZGVWYWx1ZSxuLChlLm1vZGUmMSkhPT0wKTticmVhaztjYXNlIDU6ZS5tZW1vaXplZFByb3BzLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyE9PSEwJiZCcyhyLm5vZGVWYWx1ZSxuLChlLm1vZGUmMSkhPT0wKX1pJiYodC5mbGFnc3w9NCl9ZWxzZSByPShuLm5vZGVUeXBlPT09OT9uOm4ub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUocikscltNbl09dCx0LnN0YXRlTm9kZT1yfXJldHVybiB1dCh0KSxudWxsO2Nhc2UgMTM6aWYoJGUoQWUpLHI9dC5tZW1vaXplZFN0YXRlLGU9PT1udWxsfHxlLm1lbW9pemVkU3RhdGUhPT1udWxsJiZlLm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZCE9PW51bGwpe2lmKF9lJiZBdCE9PW51bGwmJnQubW9kZSYxJiYhKHQuZmxhZ3MmMTI4KSljdigpLEFvKCksdC5mbGFnc3w9OTg1NjAsaT0hMTtlbHNlIGlmKGk9V3ModCksciE9PW51bGwmJnIuZGVoeWRyYXRlZCE9PW51bGwpe2lmKGU9PT1udWxsKXtpZighaSl0aHJvdyBFcnJvcihGKDMxOCkpO2lmKGk9dC5tZW1vaXplZFN0YXRlLGk9aSE9PW51bGw/aS5kZWh5ZHJhdGVkOm51bGwsIWkpdGhyb3cgRXJyb3IoRigzMTcpKTtpW01uXT10fWVsc2UgQW8oKSwhKHQuZmxhZ3MmMTI4KSYmKHQubWVtb2l6ZWRTdGF0ZT1udWxsKSx0LmZsYWdzfD00O3V0KHQpLGk9ITF9ZWxzZSBobiE9PW51bGwmJihsZChobiksaG49bnVsbCksaT0hMDtpZighaSlyZXR1cm4gdC5mbGFncyY2NTUzNj90Om51bGx9cmV0dXJuIHQuZmxhZ3MmMTI4Pyh0LmxhbmVzPW4sdCk6KHI9ciE9PW51bGwsciE9PShlIT09bnVsbCYmZS5tZW1vaXplZFN0YXRlIT09bnVsbCkmJnImJih0LmNoaWxkLmZsYWdzfD04MTkyLHQubW9kZSYxJiYoZT09PW51bGx8fEFlLmN1cnJlbnQmMT9xZT09PTAmJihxZT0zKTpCZigpKSksdC51cGRhdGVRdWV1ZSE9PW51bGwmJih0LmZsYWdzfD00KSx1dCh0KSxudWxsKTtjYXNlIDQ6cmV0dXJuIExvKCksZWQoZSx0KSxlPT09bnVsbCYmSmkodC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksdXQodCksbnVsbDtjYXNlIDEwOnJldHVybiBrZih0LnR5cGUuX2NvbnRleHQpLHV0KHQpLG51bGw7Y2FzZSAxNzpyZXR1cm4gUnQodC50eXBlKSYmemEoKSx1dCh0KSxudWxsO2Nhc2UgMTk6aWYoJGUoQWUpLGk9dC5tZW1vaXplZFN0YXRlLGk9PT1udWxsKXJldHVybiB1dCh0KSxudWxsO2lmKHI9KHQuZmxhZ3MmMTI4KSE9PTAscz1pLnJlbmRlcmluZyxzPT09bnVsbClpZihyKWNpKGksITEpO2Vsc2V7aWYocWUhPT0wfHxlIT09bnVsbCYmZS5mbGFncyYxMjgpZm9yKGU9dC5jaGlsZDtlIT09bnVsbDspe2lmKHM9VWEoZSkscyE9PW51bGwpe2Zvcih0LmZsYWdzfD0xMjgsY2koaSwhMSkscj1zLnVwZGF0ZVF1ZXVlLHIhPT1udWxsJiYodC51cGRhdGVRdWV1ZT1yLHQuZmxhZ3N8PTQpLHQuc3VidHJlZUZsYWdzPTAscj1uLG49dC5jaGlsZDtuIT09bnVsbDspaT1uLGU9cixpLmZsYWdzJj0xNDY4MDA2NixzPWkuYWx0ZXJuYXRlLHM9PT1udWxsPyhpLmNoaWxkTGFuZXM9MCxpLmxhbmVzPWUsaS5jaGlsZD1udWxsLGkuc3VidHJlZUZsYWdzPTAsaS5tZW1vaXplZFByb3BzPW51bGwsaS5tZW1vaXplZFN0YXRlPW51bGwsaS51cGRhdGVRdWV1ZT1udWxsLGkuZGVwZW5kZW5jaWVzPW51bGwsaS5zdGF0ZU5vZGU9bnVsbCk6KGkuY2hpbGRMYW5lcz1zLmNoaWxkTGFuZXMsaS5sYW5lcz1zLmxhbmVzLGkuY2hpbGQ9cy5jaGlsZCxpLnN1YnRyZWVGbGFncz0wLGkuZGVsZXRpb25zPW51bGwsaS5tZW1vaXplZFByb3BzPXMubWVtb2l6ZWRQcm9wcyxpLm1lbW9pemVkU3RhdGU9cy5tZW1vaXplZFN0YXRlLGkudXBkYXRlUXVldWU9cy51cGRhdGVRdWV1ZSxpLnR5cGU9cy50eXBlLGU9cy5kZXBlbmRlbmNpZXMsaS5kZXBlbmRlbmNpZXM9ZT09PW51bGw/bnVsbDp7bGFuZXM6ZS5sYW5lcyxmaXJzdENvbnRleHQ6ZS5maXJzdENvbnRleHR9KSxuPW4uc2libGluZztyZXR1cm4gVGUoQWUsQWUuY3VycmVudCYxfDIpLHQuY2hpbGR9ZT1lLnNpYmxpbmd9aS50YWlsIT09bnVsbCYmVWUoKT5EbyYmKHQuZmxhZ3N8PTEyOCxyPSEwLGNpKGksITEpLHQubGFuZXM9NDE5NDMwNCl9ZWxzZXtpZighcilpZihlPVVhKHMpLGUhPT1udWxsKXtpZih0LmZsYWdzfD0xMjgscj0hMCxuPWUudXBkYXRlUXVldWUsbiE9PW51bGwmJih0LnVwZGF0ZVF1ZXVlPW4sdC5mbGFnc3w9NCksY2koaSwhMCksaS50YWlsPT09bnVsbCYmaS50YWlsTW9kZT09PSJoaWRkZW4iJiYhcy5hbHRlcm5hdGUmJiFfZSlyZXR1cm4gdXQodCksbnVsbH1lbHNlIDIqVWUoKS1pLnJlbmRlcmluZ1N0YXJ0VGltZT5EbyYmbiE9PTEwNzM3NDE4MjQmJih0LmZsYWdzfD0xMjgscj0hMCxjaShpLCExKSx0LmxhbmVzPTQxOTQzMDQpO2kuaXNCYWNrd2FyZHM/KHMuc2libGluZz10LmNoaWxkLHQuY2hpbGQ9cyk6KG49aS5sYXN0LG4hPT1udWxsP24uc2libGluZz1zOnQuY2hpbGQ9cyxpLmxhc3Q9cyl9cmV0dXJuIGkudGFpbCE9PW51bGw/KHQ9aS50YWlsLGkucmVuZGVyaW5nPXQsaS50YWlsPXQuc2libGluZyxpLnJlbmRlcmluZ1N0YXJ0VGltZT1VZSgpLHQuc2libGluZz1udWxsLG49QWUuY3VycmVudCxUZShBZSxyP24mMXwyOm4mMSksdCk6KHV0KHQpLG51bGwpO2Nhc2UgMjI6Y2FzZSAyMzpyZXR1cm4gRmYoKSxyPXQubWVtb2l6ZWRTdGF0ZSE9PW51bGwsZSE9PW51bGwmJmUubWVtb2l6ZWRTdGF0ZSE9PW51bGwhPT1yJiYodC5mbGFnc3w9ODE5MiksciYmdC5tb2RlJjE/TXQmMTA3Mzc0MTgyNCYmKHV0KHQpLHQuc3VidHJlZUZsYWdzJjYmJih0LmZsYWdzfD04MTkyKSk6dXQodCksbnVsbDtjYXNlIDI0OnJldHVybiBudWxsO2Nhc2UgMjU6cmV0dXJuIG51bGx9dGhyb3cgRXJyb3IoRigxNTYsdC50YWcpKX1mdW5jdGlvbiBIayhlLHQpe3N3aXRjaChTZih0KSx0LnRhZyl7Y2FzZSAxOnJldHVybiBSdCh0LnR5cGUpJiZ6YSgpLGU9dC5mbGFncyxlJjY1NTM2Pyh0LmZsYWdzPWUmLTY1NTM3fDEyOCx0KTpudWxsO2Nhc2UgMzpyZXR1cm4gTG8oKSwkZShFdCksJGUobXQpLCRmKCksZT10LmZsYWdzLGUmNjU1MzYmJiEoZSYxMjgpPyh0LmZsYWdzPWUmLTY1NTM3fDEyOCx0KTpudWxsO2Nhc2UgNTpyZXR1cm4gUGYodCksbnVsbDtjYXNlIDEzOmlmKCRlKEFlKSxlPXQubWVtb2l6ZWRTdGF0ZSxlIT09bnVsbCYmZS5kZWh5ZHJhdGVkIT09bnVsbCl7aWYodC5hbHRlcm5hdGU9PT1udWxsKXRocm93IEVycm9yKEYoMzQwKSk7QW8oKX1yZXR1cm4gZT10LmZsYWdzLGUmNjU1MzY/KHQuZmxhZ3M9ZSYtNjU1Mzd8MTI4LHQpOm51bGw7Y2FzZSAxOTpyZXR1cm4gJGUoQWUpLG51bGw7Y2FzZSA0OnJldHVybiBMbygpLG51bGw7Y2FzZSAxMDpyZXR1cm4ga2YodC50eXBlLl9jb250ZXh0KSxudWxsO2Nhc2UgMjI6Y2FzZSAyMzpyZXR1cm4gRmYoKSxudWxsO2Nhc2UgMjQ6cmV0dXJuIG51bGw7ZGVmYXVsdDpyZXR1cm4gbnVsbH19dmFyIFZzPSExLGR0PSExLFZrPXR5cGVvZiBXZWFrU2V0PT0iZnVuY3Rpb24iP1dlYWtTZXQ6U2V0LEs9bnVsbDtmdW5jdGlvbiBTbyhlLHQpe3ZhciBuPWUucmVmO2lmKG4hPT1udWxsKWlmKHR5cGVvZiBuPT0iZnVuY3Rpb24iKXRyeXtuKG51bGwpfWNhdGNoKHIpe0JlKGUsdCxyKX1lbHNlIG4uY3VycmVudD1udWxsfWZ1bmN0aW9uIHRkKGUsdCxuKXt0cnl7bigpfWNhdGNoKHIpe0JlKGUsdCxyKX19dmFyIGVoPSExO2Z1bmN0aW9uIEtrKGUsdCl7aWYoamM9X2EsZT1xeSgpLHZmKGUpKXtpZigic2VsZWN0aW9uU3RhcnQiaW4gZSl2YXIgbj17c3RhcnQ6ZS5zZWxlY3Rpb25TdGFydCxlbmQ6ZS5zZWxlY3Rpb25FbmR9O2Vsc2UgZTp7bj0obj1lLm93bmVyRG9jdW1lbnQpJiZuLmRlZmF1bHRWaWV3fHx3aW5kb3c7dmFyIHI9bi5nZXRTZWxlY3Rpb24mJm4uZ2V0U2VsZWN0aW9uKCk7aWYociYmci5yYW5nZUNvdW50IT09MCl7bj1yLmFuY2hvck5vZGU7dmFyIG89ci5hbmNob3JPZmZzZXQsaT1yLmZvY3VzTm9kZTtyPXIuZm9jdXNPZmZzZXQ7dHJ5e24ubm9kZVR5cGUsaS5ub2RlVHlwZX1jYXRjaHtuPW51bGw7YnJlYWsgZX12YXIgcz0wLGE9LTEsbD0tMSx1PTAsYz0wLGQ9ZSxtPW51bGw7dDpmb3IoOzspe2Zvcih2YXIgdjtkIT09bnx8byE9PTAmJmQubm9kZVR5cGUhPT0zfHwoYT1zK28pLGQhPT1pfHxyIT09MCYmZC5ub2RlVHlwZSE9PTN8fChsPXMrciksZC5ub2RlVHlwZT09PTMmJihzKz1kLm5vZGVWYWx1ZS5sZW5ndGgpLCh2PWQuZmlyc3RDaGlsZCkhPT1udWxsOyltPWQsZD12O2Zvcig7Oyl7aWYoZD09PWUpYnJlYWsgdDtpZihtPT09biYmKyt1PT09byYmKGE9cyksbT09PWkmJisrYz09PXImJihsPXMpLCh2PWQubmV4dFNpYmxpbmcpIT09bnVsbClicmVhaztkPW0sbT1kLnBhcmVudE5vZGV9ZD12fW49YT09PS0xfHxsPT09LTE/bnVsbDp7c3RhcnQ6YSxlbmQ6bH19ZWxzZSBuPW51bGx9bj1ufHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBuPW51bGw7Zm9yKERjPXtmb2N1c2VkRWxlbTplLHNlbGVjdGlvblJhbmdlOm59LF9hPSExLEs9dDtLIT09bnVsbDspaWYodD1LLGU9dC5jaGlsZCwodC5zdWJ0cmVlRmxhZ3MmMTAyOCkhPT0wJiZlIT09bnVsbCllLnJldHVybj10LEs9ZTtlbHNlIGZvcig7SyE9PW51bGw7KXt0PUs7dHJ5e3ZhciB3PXQuYWx0ZXJuYXRlO2lmKHQuZmxhZ3MmMTAyNClzd2l0Y2godC50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6YnJlYWs7Y2FzZSAxOmlmKHchPT1udWxsKXt2YXIgUz13Lm1lbW9pemVkUHJvcHMseD13Lm1lbW9pemVkU3RhdGUsaD10LnN0YXRlTm9kZSxnPWguZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUodC5lbGVtZW50VHlwZT09PXQudHlwZT9TOmZuKHQudHlwZSxTKSx4KTtoLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPWd9YnJlYWs7Y2FzZSAzOnZhciBmPXQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zi5ub2RlVHlwZT09PTE/Zi50ZXh0Q29udGVudD0iIjpmLm5vZGVUeXBlPT09OSYmZi5kb2N1bWVudEVsZW1lbnQmJmYucmVtb3ZlQ2hpbGQoZi5kb2N1bWVudEVsZW1lbnQpO2JyZWFrO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihGKDE2MykpfX1jYXRjaCh5KXtCZSh0LHQucmV0dXJuLHkpfWlmKGU9dC5zaWJsaW5nLGUhPT1udWxsKXtlLnJldHVybj10LnJldHVybixLPWU7YnJlYWt9Sz10LnJldHVybn1yZXR1cm4gdz1laCxlaD0hMSx3fWZ1bmN0aW9uIF9pKGUsdCxuKXt2YXIgcj10LnVwZGF0ZVF1ZXVlO2lmKHI9ciE9PW51bGw/ci5sYXN0RWZmZWN0Om51bGwsciE9PW51bGwpe3ZhciBvPXI9ci5uZXh0O2Rve2lmKChvLnRhZyZlKT09PWUpe3ZhciBpPW8uZGVzdHJveTtvLmRlc3Ryb3k9dm9pZCAwLGkhPT12b2lkIDAmJnRkKHQsbixpKX1vPW8ubmV4dH13aGlsZShvIT09cil9fWZ1bmN0aW9uIEpsKGUsdCl7aWYodD10LnVwZGF0ZVF1ZXVlLHQ9dCE9PW51bGw/dC5sYXN0RWZmZWN0Om51bGwsdCE9PW51bGwpe3ZhciBuPXQ9dC5uZXh0O2Rve2lmKChuLnRhZyZlKT09PWUpe3ZhciByPW4uY3JlYXRlO24uZGVzdHJveT1yKCl9bj1uLm5leHR9d2hpbGUobiE9PXQpfX1mdW5jdGlvbiBuZChlKXt2YXIgdD1lLnJlZjtpZih0IT09bnVsbCl7dmFyIG49ZS5zdGF0ZU5vZGU7c3dpdGNoKGUudGFnKXtjYXNlIDU6ZT1uO2JyZWFrO2RlZmF1bHQ6ZT1ufXR5cGVvZiB0PT0iZnVuY3Rpb24iP3QoZSk6dC5jdXJyZW50PWV9fWZ1bmN0aW9uIFl2KGUpe3ZhciB0PWUuYWx0ZXJuYXRlO3QhPT1udWxsJiYoZS5hbHRlcm5hdGU9bnVsbCxZdih0KSksZS5jaGlsZD1udWxsLGUuZGVsZXRpb25zPW51bGwsZS5zaWJsaW5nPW51bGwsZS50YWc9PT01JiYodD1lLnN0YXRlTm9kZSx0IT09bnVsbCYmKGRlbGV0ZSB0W01uXSxkZWxldGUgdFt0c10sZGVsZXRlIHRbV2NdLGRlbGV0ZSB0W1BrXSxkZWxldGUgdFska10pKSxlLnN0YXRlTm9kZT1udWxsLGUucmV0dXJuPW51bGwsZS5kZXBlbmRlbmNpZXM9bnVsbCxlLm1lbW9pemVkUHJvcHM9bnVsbCxlLm1lbW9pemVkU3RhdGU9bnVsbCxlLnBlbmRpbmdQcm9wcz1udWxsLGUuc3RhdGVOb2RlPW51bGwsZS51cGRhdGVRdWV1ZT1udWxsfWZ1bmN0aW9uIEd2KGUpe3JldHVybiBlLnRhZz09PTV8fGUudGFnPT09M3x8ZS50YWc9PT00fWZ1bmN0aW9uIHRoKGUpe2U6Zm9yKDs7KXtmb3IoO2Uuc2libGluZz09PW51bGw7KXtpZihlLnJldHVybj09PW51bGx8fEd2KGUucmV0dXJuKSlyZXR1cm4gbnVsbDtlPWUucmV0dXJufWZvcihlLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuLGU9ZS5zaWJsaW5nO2UudGFnIT09NSYmZS50YWchPT02JiZlLnRhZyE9PTE4Oyl7aWYoZS5mbGFncyYyfHxlLmNoaWxkPT09bnVsbHx8ZS50YWc9PT00KWNvbnRpbnVlIGU7ZS5jaGlsZC5yZXR1cm49ZSxlPWUuY2hpbGR9aWYoIShlLmZsYWdzJjIpKXJldHVybiBlLnN0YXRlTm9kZX19ZnVuY3Rpb24gcmQoZSx0LG4pe3ZhciByPWUudGFnO2lmKHI9PT01fHxyPT09NillPWUuc3RhdGVOb2RlLHQ/bi5ub2RlVHlwZT09PTg/bi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHQpOm4uaW5zZXJ0QmVmb3JlKGUsdCk6KG4ubm9kZVR5cGU9PT04Pyh0PW4ucGFyZW50Tm9kZSx0Lmluc2VydEJlZm9yZShlLG4pKToodD1uLHQuYXBwZW5kQ2hpbGQoZSkpLG49bi5fcmVhY3RSb290Q29udGFpbmVyLG4hPW51bGx8fHQub25jbGljayE9PW51bGx8fCh0Lm9uY2xpY2s9QWEpKTtlbHNlIGlmKHIhPT00JiYoZT1lLmNoaWxkLGUhPT1udWxsKSlmb3IocmQoZSx0LG4pLGU9ZS5zaWJsaW5nO2UhPT1udWxsOylyZChlLHQsbiksZT1lLnNpYmxpbmd9ZnVuY3Rpb24gb2QoZSx0LG4pe3ZhciByPWUudGFnO2lmKHI9PT01fHxyPT09NillPWUuc3RhdGVOb2RlLHQ/bi5pbnNlcnRCZWZvcmUoZSx0KTpuLmFwcGVuZENoaWxkKGUpO2Vsc2UgaWYociE9PTQmJihlPWUuY2hpbGQsZSE9PW51bGwpKWZvcihvZChlLHQsbiksZT1lLnNpYmxpbmc7ZSE9PW51bGw7KW9kKGUsdCxuKSxlPWUuc2libGluZ312YXIgcnQ9bnVsbCxwbj0hMTtmdW5jdGlvbiBvcihlLHQsbil7Zm9yKG49bi5jaGlsZDtuIT09bnVsbDspUXYoZSx0LG4pLG49bi5zaWJsaW5nfWZ1bmN0aW9uIFF2KGUsdCxuKXtpZihObiYmdHlwZW9mIE5uLm9uQ29tbWl0RmliZXJVbm1vdW50PT0iZnVuY3Rpb24iKXRyeXtObi5vbkNvbW1pdEZpYmVyVW5tb3VudChWbCxuKX1jYXRjaHt9c3dpdGNoKG4udGFnKXtjYXNlIDU6ZHR8fFNvKG4sdCk7Y2FzZSA2OnZhciByPXJ0LG89cG47cnQ9bnVsbCxvcihlLHQsbikscnQ9cixwbj1vLHJ0IT09bnVsbCYmKHBuPyhlPXJ0LG49bi5zdGF0ZU5vZGUsZS5ub2RlVHlwZT09PTg/ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pOmUucmVtb3ZlQ2hpbGQobikpOnJ0LnJlbW92ZUNoaWxkKG4uc3RhdGVOb2RlKSk7YnJlYWs7Y2FzZSAxODpydCE9PW51bGwmJihwbj8oZT1ydCxuPW4uc3RhdGVOb2RlLGUubm9kZVR5cGU9PT04P0Z1KGUucGFyZW50Tm9kZSxuKTplLm5vZGVUeXBlPT09MSYmRnUoZSxuKSxYaShlKSk6RnUocnQsbi5zdGF0ZU5vZGUpKTticmVhaztjYXNlIDQ6cj1ydCxvPXBuLHJ0PW4uc3RhdGVOb2RlLmNvbnRhaW5lckluZm8scG49ITAsb3IoZSx0LG4pLHJ0PXIscG49bzticmVhaztjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6aWYoIWR0JiYocj1uLnVwZGF0ZVF1ZXVlLHIhPT1udWxsJiYocj1yLmxhc3RFZmZlY3QsciE9PW51bGwpKSl7bz1yPXIubmV4dDtkb3t2YXIgaT1vLHM9aS5kZXN0cm95O2k9aS50YWcscyE9PXZvaWQgMCYmKGkmMnx8aSY0KSYmdGQobix0LHMpLG89by5uZXh0fXdoaWxlKG8hPT1yKX1vcihlLHQsbik7YnJlYWs7Y2FzZSAxOmlmKCFkdCYmKFNvKG4sdCkscj1uLnN0YXRlTm9kZSx0eXBlb2Ygci5jb21wb25lbnRXaWxsVW5tb3VudD09ImZ1bmN0aW9uIikpdHJ5e3IucHJvcHM9bi5tZW1vaXplZFByb3BzLHIuc3RhdGU9bi5tZW1vaXplZFN0YXRlLHIuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChhKXtCZShuLHQsYSl9b3IoZSx0LG4pO2JyZWFrO2Nhc2UgMjE6b3IoZSx0LG4pO2JyZWFrO2Nhc2UgMjI6bi5tb2RlJjE/KGR0PShyPWR0KXx8bi5tZW1vaXplZFN0YXRlIT09bnVsbCxvcihlLHQsbiksZHQ9cik6b3IoZSx0LG4pO2JyZWFrO2RlZmF1bHQ6b3IoZSx0LG4pfX1mdW5jdGlvbiBuaChlKXt2YXIgdD1lLnVwZGF0ZVF1ZXVlO2lmKHQhPT1udWxsKXtlLnVwZGF0ZVF1ZXVlPW51bGw7dmFyIG49ZS5zdGF0ZU5vZGU7bj09PW51bGwmJihuPWUuc3RhdGVOb2RlPW5ldyBWayksdC5mb3JFYWNoKGZ1bmN0aW9uKHIpe3ZhciBvPXRFLmJpbmQobnVsbCxlLHIpO24uaGFzKHIpfHwobi5hZGQociksci50aGVuKG8sbykpfSl9fWZ1bmN0aW9uIGRuKGUsdCl7dmFyIG49dC5kZWxldGlvbnM7aWYobiE9PW51bGwpZm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBvPW5bcl07dHJ5e3ZhciBpPWUscz10LGE9cztlOmZvcig7YSE9PW51bGw7KXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpydD1hLnN0YXRlTm9kZSxwbj0hMTticmVhayBlO2Nhc2UgMzpydD1hLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLHBuPSEwO2JyZWFrIGU7Y2FzZSA0OnJ0PWEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8scG49ITA7YnJlYWsgZX1hPWEucmV0dXJufWlmKHJ0PT09bnVsbCl0aHJvdyBFcnJvcihGKDE2MCkpO1F2KGkscyxvKSxydD1udWxsLHBuPSExO3ZhciBsPW8uYWx0ZXJuYXRlO2whPT1udWxsJiYobC5yZXR1cm49bnVsbCksby5yZXR1cm49bnVsbH1jYXRjaCh1KXtCZShvLHQsdSl9fWlmKHQuc3VidHJlZUZsYWdzJjEyODU0KWZvcih0PXQuY2hpbGQ7dCE9PW51bGw7KVh2KHQsZSksdD10LnNpYmxpbmd9ZnVuY3Rpb24gWHYoZSx0KXt2YXIgbj1lLmFsdGVybmF0ZSxyPWUuZmxhZ3M7c3dpdGNoKGUudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6aWYoZG4odCxlKSxFbihlKSxyJjQpe3RyeXtfaSgzLGUsZS5yZXR1cm4pLEpsKDMsZSl9Y2F0Y2goUyl7QmUoZSxlLnJldHVybixTKX10cnl7X2koNSxlLGUucmV0dXJuKX1jYXRjaChTKXtCZShlLGUucmV0dXJuLFMpfX1icmVhaztjYXNlIDE6ZG4odCxlKSxFbihlKSxyJjUxMiYmbiE9PW51bGwmJlNvKG4sbi5yZXR1cm4pO2JyZWFrO2Nhc2UgNTppZihkbih0LGUpLEVuKGUpLHImNTEyJiZuIT09bnVsbCYmU28obixuLnJldHVybiksZS5mbGFncyYzMil7dmFyIG89ZS5zdGF0ZU5vZGU7dHJ5e0tpKG8sIiIpfWNhdGNoKFMpe0JlKGUsZS5yZXR1cm4sUyl9fWlmKHImNCYmKG89ZS5zdGF0ZU5vZGUsbyE9bnVsbCkpe3ZhciBpPWUubWVtb2l6ZWRQcm9wcyxzPW4hPT1udWxsP24ubWVtb2l6ZWRQcm9wczppLGE9ZS50eXBlLGw9ZS51cGRhdGVRdWV1ZTtpZihlLnVwZGF0ZVF1ZXVlPW51bGwsbCE9PW51bGwpdHJ5e2E9PT0iaW5wdXQiJiZpLnR5cGU9PT0icmFkaW8iJiZpLm5hbWUhPW51bGwmJnZ5KG8saSksUGMoYSxzKTt2YXIgdT1QYyhhLGkpO2ZvcihzPTA7czxsLmxlbmd0aDtzKz0yKXt2YXIgYz1sW3NdLGQ9bFtzKzFdO2M9PT0ic3R5bGUiP2J5KG8sZCk6Yz09PSJkYW5nZXJvdXNseVNldElubmVySFRNTCI/eHkobyxkKTpjPT09ImNoaWxkcmVuIj9LaShvLGQpOm9mKG8sYyxkLHUpfXN3aXRjaChhKXtjYXNlImlucHV0IjpiYyhvLGkpO2JyZWFrO2Nhc2UidGV4dGFyZWEiOnd5KG8saSk7YnJlYWs7Y2FzZSJzZWxlY3QiOnZhciBtPW8uX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtvLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFpLm11bHRpcGxlO3ZhciB2PWkudmFsdWU7diE9bnVsbD9FbyhvLCEhaS5tdWx0aXBsZSx2LCExKTptIT09ISFpLm11bHRpcGxlJiYoaS5kZWZhdWx0VmFsdWUhPW51bGw/RW8obywhIWkubXVsdGlwbGUsaS5kZWZhdWx0VmFsdWUsITApOkVvKG8sISFpLm11bHRpcGxlLGkubXVsdGlwbGU/W106IiIsITEpKX1vW3RzXT1pfWNhdGNoKFMpe0JlKGUsZS5yZXR1cm4sUyl9fWJyZWFrO2Nhc2UgNjppZihkbih0LGUpLEVuKGUpLHImNCl7aWYoZS5zdGF0ZU5vZGU9PT1udWxsKXRocm93IEVycm9yKEYoMTYyKSk7bz1lLnN0YXRlTm9kZSxpPWUubWVtb2l6ZWRQcm9wczt0cnl7by5ub2RlVmFsdWU9aX1jYXRjaChTKXtCZShlLGUucmV0dXJuLFMpfX1icmVhaztjYXNlIDM6aWYoZG4odCxlKSxFbihlKSxyJjQmJm4hPT1udWxsJiZuLm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKXRyeXtYaSh0LmNvbnRhaW5lckluZm8pfWNhdGNoKFMpe0JlKGUsZS5yZXR1cm4sUyl9YnJlYWs7Y2FzZSA0OmRuKHQsZSksRW4oZSk7YnJlYWs7Y2FzZSAxMzpkbih0LGUpLEVuKGUpLG89ZS5jaGlsZCxvLmZsYWdzJjgxOTImJihpPW8ubWVtb2l6ZWRTdGF0ZSE9PW51bGwsby5zdGF0ZU5vZGUuaXNIaWRkZW49aSwhaXx8by5hbHRlcm5hdGUhPT1udWxsJiZvLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlIT09bnVsbHx8KGpmPVVlKCkpKSxyJjQmJm5oKGUpO2JyZWFrO2Nhc2UgMjI6aWYoYz1uIT09bnVsbCYmbi5tZW1vaXplZFN0YXRlIT09bnVsbCxlLm1vZGUmMT8oZHQ9KHU9ZHQpfHxjLGRuKHQsZSksZHQ9dSk6ZG4odCxlKSxFbihlKSxyJjgxOTIpe2lmKHU9ZS5tZW1vaXplZFN0YXRlIT09bnVsbCwoZS5zdGF0ZU5vZGUuaXNIaWRkZW49dSkmJiFjJiZlLm1vZGUmMSlmb3IoSz1lLGM9ZS5jaGlsZDtjIT09bnVsbDspe2ZvcihkPUs9YztLIT09bnVsbDspe3N3aXRjaChtPUssdj1tLmNoaWxkLG0udGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6X2koNCxtLG0ucmV0dXJuKTticmVhaztjYXNlIDE6U28obSxtLnJldHVybik7dmFyIHc9bS5zdGF0ZU5vZGU7aWYodHlwZW9mIHcuY29tcG9uZW50V2lsbFVubW91bnQ9PSJmdW5jdGlvbiIpe3I9bSxuPW0ucmV0dXJuO3RyeXt0PXIsdy5wcm9wcz10Lm1lbW9pemVkUHJvcHMsdy5zdGF0ZT10Lm1lbW9pemVkU3RhdGUsdy5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKFMpe0JlKHIsbixTKX19YnJlYWs7Y2FzZSA1OlNvKG0sbS5yZXR1cm4pO2JyZWFrO2Nhc2UgMjI6aWYobS5tZW1vaXplZFN0YXRlIT09bnVsbCl7b2goZCk7Y29udGludWV9fXYhPT1udWxsPyh2LnJldHVybj1tLEs9dik6b2goZCl9Yz1jLnNpYmxpbmd9ZTpmb3IoYz1udWxsLGQ9ZTs7KXtpZihkLnRhZz09PTUpe2lmKGM9PT1udWxsKXtjPWQ7dHJ5e289ZC5zdGF0ZU5vZGUsdT8oaT1vLnN0eWxlLHR5cGVvZiBpLnNldFByb3BlcnR5PT0iZnVuY3Rpb24iP2kuc2V0UHJvcGVydHkoImRpc3BsYXkiLCJub25lIiwiaW1wb3J0YW50Iik6aS5kaXNwbGF5PSJub25lIik6KGE9ZC5zdGF0ZU5vZGUsbD1kLm1lbW9pemVkUHJvcHMuc3R5bGUscz1sIT1udWxsJiZsLmhhc093blByb3BlcnR5KCJkaXNwbGF5Iik/bC5kaXNwbGF5Om51bGwsYS5zdHlsZS5kaXNwbGF5PUN5KCJkaXNwbGF5IixzKSl9Y2F0Y2goUyl7QmUoZSxlLnJldHVybixTKX19fWVsc2UgaWYoZC50YWc9PT02KXtpZihjPT09bnVsbCl0cnl7ZC5zdGF0ZU5vZGUubm9kZVZhbHVlPXU/IiI6ZC5tZW1vaXplZFByb3BzfWNhdGNoKFMpe0JlKGUsZS5yZXR1cm4sUyl9fWVsc2UgaWYoKGQudGFnIT09MjImJmQudGFnIT09MjN8fGQubWVtb2l6ZWRTdGF0ZT09PW51bGx8fGQ9PT1lKSYmZC5jaGlsZCE9PW51bGwpe2QuY2hpbGQucmV0dXJuPWQsZD1kLmNoaWxkO2NvbnRpbnVlfWlmKGQ9PT1lKWJyZWFrIGU7Zm9yKDtkLnNpYmxpbmc9PT1udWxsOyl7aWYoZC5yZXR1cm49PT1udWxsfHxkLnJldHVybj09PWUpYnJlYWsgZTtjPT09ZCYmKGM9bnVsbCksZD1kLnJldHVybn1jPT09ZCYmKGM9bnVsbCksZC5zaWJsaW5nLnJldHVybj1kLnJldHVybixkPWQuc2libGluZ319YnJlYWs7Y2FzZSAxOTpkbih0LGUpLEVuKGUpLHImNCYmbmgoZSk7YnJlYWs7Y2FzZSAyMTpicmVhaztkZWZhdWx0OmRuKHQsZSksRW4oZSl9fWZ1bmN0aW9uIEVuKGUpe3ZhciB0PWUuZmxhZ3M7aWYodCYyKXt0cnl7ZTp7Zm9yKHZhciBuPWUucmV0dXJuO24hPT1udWxsOyl7aWYoR3Yobikpe3ZhciByPW47YnJlYWsgZX1uPW4ucmV0dXJufXRocm93IEVycm9yKEYoMTYwKSl9c3dpdGNoKHIudGFnKXtjYXNlIDU6dmFyIG89ci5zdGF0ZU5vZGU7ci5mbGFncyYzMiYmKEtpKG8sIiIpLHIuZmxhZ3MmPS0zMyk7dmFyIGk9dGgoZSk7b2QoZSxpLG8pO2JyZWFrO2Nhc2UgMzpjYXNlIDQ6dmFyIHM9ci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxhPXRoKGUpO3JkKGUsYSxzKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKEYoMTYxKSl9fWNhdGNoKGwpe0JlKGUsZS5yZXR1cm4sbCl9ZS5mbGFncyY9LTN9dCY0MDk2JiYoZS5mbGFncyY9LTQwOTcpfWZ1bmN0aW9uIFlrKGUsdCxuKXtLPWUscXYoZSl9ZnVuY3Rpb24gcXYoZSx0LG4pe2Zvcih2YXIgcj0oZS5tb2RlJjEpIT09MDtLIT09bnVsbDspe3ZhciBvPUssaT1vLmNoaWxkO2lmKG8udGFnPT09MjImJnIpe3ZhciBzPW8ubWVtb2l6ZWRTdGF0ZSE9PW51bGx8fFZzO2lmKCFzKXt2YXIgYT1vLmFsdGVybmF0ZSxsPWEhPT1udWxsJiZhLm1lbW9pemVkU3RhdGUhPT1udWxsfHxkdDthPVZzO3ZhciB1PWR0O2lmKFZzPXMsKGR0PWwpJiYhdSlmb3IoSz1vO0shPT1udWxsOylzPUssbD1zLmNoaWxkLHMudGFnPT09MjImJnMubWVtb2l6ZWRTdGF0ZSE9PW51bGw/aWgobyk6bCE9PW51bGw/KGwucmV0dXJuPXMsSz1sKTppaChvKTtmb3IoO2khPT1udWxsOylLPWkscXYoaSksaT1pLnNpYmxpbmc7Sz1vLFZzPWEsZHQ9dX1yaChlKX1lbHNlIG8uc3VidHJlZUZsYWdzJjg3NzImJmkhPT1udWxsPyhpLnJldHVybj1vLEs9aSk6cmgoZSl9fWZ1bmN0aW9uIHJoKGUpe2Zvcig7SyE9PW51bGw7KXt2YXIgdD1LO2lmKHQuZmxhZ3MmODc3Mil7dmFyIG49dC5hbHRlcm5hdGU7dHJ5e2lmKHQuZmxhZ3MmODc3Milzd2l0Y2godC50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6ZHR8fEpsKDUsdCk7YnJlYWs7Y2FzZSAxOnZhciByPXQuc3RhdGVOb2RlO2lmKHQuZmxhZ3MmNCYmIWR0KWlmKG49PT1udWxsKXIuY29tcG9uZW50RGlkTW91bnQoKTtlbHNle3ZhciBvPXQuZWxlbWVudFR5cGU9PT10LnR5cGU/bi5tZW1vaXplZFByb3BzOmZuKHQudHlwZSxuLm1lbW9pemVkUHJvcHMpO3IuY29tcG9uZW50RGlkVXBkYXRlKG8sbi5tZW1vaXplZFN0YXRlLHIuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpfXZhciBpPXQudXBkYXRlUXVldWU7aSE9PW51bGwmJkJtKHQsaSxyKTticmVhaztjYXNlIDM6dmFyIHM9dC51cGRhdGVRdWV1ZTtpZihzIT09bnVsbCl7aWYobj1udWxsLHQuY2hpbGQhPT1udWxsKXN3aXRjaCh0LmNoaWxkLnRhZyl7Y2FzZSA1Om49dC5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOm49dC5jaGlsZC5zdGF0ZU5vZGV9Qm0odCxzLG4pfWJyZWFrO2Nhc2UgNTp2YXIgYT10LnN0YXRlTm9kZTtpZihuPT09bnVsbCYmdC5mbGFncyY0KXtuPWE7dmFyIGw9dC5tZW1vaXplZFByb3BzO3N3aXRjaCh0LnR5cGUpe2Nhc2UiYnV0dG9uIjpjYXNlImlucHV0IjpjYXNlInNlbGVjdCI6Y2FzZSJ0ZXh0YXJlYSI6bC5hdXRvRm9jdXMmJm4uZm9jdXMoKTticmVhaztjYXNlImltZyI6bC5zcmMmJihuLnNyYz1sLnNyYyl9fWJyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7Y2FzZSAxMjpicmVhaztjYXNlIDEzOmlmKHQubWVtb2l6ZWRTdGF0ZT09PW51bGwpe3ZhciB1PXQuYWx0ZXJuYXRlO2lmKHUhPT1udWxsKXt2YXIgYz11Lm1lbW9pemVkU3RhdGU7aWYoYyE9PW51bGwpe3ZhciBkPWMuZGVoeWRyYXRlZDtkIT09bnVsbCYmWGkoZCl9fX1icmVhaztjYXNlIDE5OmNhc2UgMTc6Y2FzZSAyMTpjYXNlIDIyOmNhc2UgMjM6Y2FzZSAyNTpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKEYoMTYzKSl9ZHR8fHQuZmxhZ3MmNTEyJiZuZCh0KX1jYXRjaChtKXtCZSh0LHQucmV0dXJuLG0pfX1pZih0PT09ZSl7Sz1udWxsO2JyZWFrfWlmKG49dC5zaWJsaW5nLG4hPT1udWxsKXtuLnJldHVybj10LnJldHVybixLPW47YnJlYWt9Sz10LnJldHVybn19ZnVuY3Rpb24gb2goZSl7Zm9yKDtLIT09bnVsbDspe3ZhciB0PUs7aWYodD09PWUpe0s9bnVsbDticmVha312YXIgbj10LnNpYmxpbmc7aWYobiE9PW51bGwpe24ucmV0dXJuPXQucmV0dXJuLEs9bjticmVha31LPXQucmV0dXJufX1mdW5jdGlvbiBpaChlKXtmb3IoO0shPT1udWxsOyl7dmFyIHQ9Szt0cnl7c3dpdGNoKHQudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnZhciBuPXQucmV0dXJuO3RyeXtKbCg0LHQpfWNhdGNoKGwpe0JlKHQsbixsKX1icmVhaztjYXNlIDE6dmFyIHI9dC5zdGF0ZU5vZGU7aWYodHlwZW9mIHIuY29tcG9uZW50RGlkTW91bnQ9PSJmdW5jdGlvbiIpe3ZhciBvPXQucmV0dXJuO3RyeXtyLmNvbXBvbmVudERpZE1vdW50KCl9Y2F0Y2gobCl7QmUodCxvLGwpfX12YXIgaT10LnJldHVybjt0cnl7bmQodCl9Y2F0Y2gobCl7QmUodCxpLGwpfWJyZWFrO2Nhc2UgNTp2YXIgcz10LnJldHVybjt0cnl7bmQodCl9Y2F0Y2gobCl7QmUodCxzLGwpfX19Y2F0Y2gobCl7QmUodCx0LnJldHVybixsKX1pZih0PT09ZSl7Sz1udWxsO2JyZWFrfXZhciBhPXQuc2libGluZztpZihhIT09bnVsbCl7YS5yZXR1cm49dC5yZXR1cm4sSz1hO2JyZWFrfUs9dC5yZXR1cm59fXZhciBHaz1NYXRoLmNlaWwsS2E9bnIuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcix6Zj1uci5SZWFjdEN1cnJlbnRPd25lcixKdD1uci5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxnZT0wLGV0PW51bGwsR2U9bnVsbCxzdD0wLE10PTAseG89RXIoMCkscWU9MCxhcz1udWxsLEtyPTAsZXU9MCxMZj0wLE5pPW51bGwsYnQ9bnVsbCxqZj0wLERvPTEvMCxGbj1udWxsLFlhPSExLGlkPW51bGwseXI9bnVsbCxLcz0hMSxkcj1udWxsLEdhPTAsSWk9MCxzZD1udWxsLGhhPS0xLGdhPTA7ZnVuY3Rpb24geXQoKXtyZXR1cm4gZ2UmNj9VZSgpOmhhIT09LTE/aGE6aGE9VWUoKX1mdW5jdGlvbiB2cihlKXtyZXR1cm4gZS5tb2RlJjE/Z2UmMiYmc3QhPT0wP3N0Ji1zdDpNay50cmFuc2l0aW9uIT09bnVsbD8oZ2E9PT0wJiYoZ2E9QXkoKSksZ2EpOihlPUNlLGUhPT0wfHwoZT13aW5kb3cuZXZlbnQsZT1lPT09dm9pZCAwPzE2Old5KGUudHlwZSkpLGUpOjF9ZnVuY3Rpb24gdm4oZSx0LG4scil7aWYoNTA8SWkpdGhyb3cgSWk9MCxzZD1udWxsLEVycm9yKEYoMTg1KSk7eHMoZSxuLHIpLCghKGdlJjIpfHxlIT09ZXQpJiYoZT09PWV0JiYoIShnZSYyKSYmKGV1fD1uKSxxZT09PTQmJmxyKGUsc3QpKSxUdChlLHIpLG49PT0xJiZnZT09PTAmJiEodC5tb2RlJjEpJiYoRG89VWUoKSs1MDAsWGwmJlJyKCkpKX1mdW5jdGlvbiBUdChlLHQpe3ZhciBuPWUuY2FsbGJhY2tOb2RlO01iKGUsdCk7dmFyIHI9TWEoZSxlPT09ZXQ/c3Q6MCk7aWYocj09PTApbiE9PW51bGwmJm1tKG4pLGUuY2FsbGJhY2tOb2RlPW51bGwsZS5jYWxsYmFja1ByaW9yaXR5PTA7ZWxzZSBpZih0PXImLXIsZS5jYWxsYmFja1ByaW9yaXR5IT09dCl7aWYobiE9bnVsbCYmbW0obiksdD09PTEpZS50YWc9PT0wP09rKHNoLmJpbmQobnVsbCxlKSk6YXYoc2guYmluZChudWxsLGUpKSxSayhmdW5jdGlvbigpeyEoZ2UmNikmJlJyKCl9KSxuPW51bGw7ZWxzZXtzd2l0Y2goenkocikpe2Nhc2UgMTpuPWNmO2JyZWFrO2Nhc2UgNDpuPU55O2JyZWFrO2Nhc2UgMTY6bj1PYTticmVhaztjYXNlIDUzNjg3MDkxMjpuPUl5O2JyZWFrO2RlZmF1bHQ6bj1PYX1uPWkwKG4sWnYuYmluZChudWxsLGUpKX1lLmNhbGxiYWNrUHJpb3JpdHk9dCxlLmNhbGxiYWNrTm9kZT1ufX1mdW5jdGlvbiBadihlLHQpe2lmKGhhPS0xLGdhPTAsZ2UmNil0aHJvdyBFcnJvcihGKDMyNykpO3ZhciBuPWUuY2FsbGJhY2tOb2RlO2lmKE9vKCkmJmUuY2FsbGJhY2tOb2RlIT09bilyZXR1cm4gbnVsbDt2YXIgcj1NYShlLGU9PT1ldD9zdDowKTtpZihyPT09MClyZXR1cm4gbnVsbDtpZihyJjMwfHxyJmUuZXhwaXJlZExhbmVzfHx0KXQ9UWEoZSxyKTtlbHNle3Q9cjt2YXIgbz1nZTtnZXw9Mjt2YXIgaT1lMCgpOyhldCE9PWV8fHN0IT09dCkmJihGbj1udWxsLERvPVVlKCkrNTAwLEZyKGUsdCkpO2RvIHRyeXtxaygpO2JyZWFrfWNhdGNoKGEpe0p2KGUsYSl9d2hpbGUoITApO2JmKCksS2EuY3VycmVudD1pLGdlPW8sR2UhPT1udWxsP3Q9MDooZXQ9bnVsbCxzdD0wLHQ9cWUpfWlmKHQhPT0wKXtpZih0PT09MiYmKG89TmMoZSksbyE9PTAmJihyPW8sdD1hZChlLG8pKSksdD09PTEpdGhyb3cgbj1hcyxGcihlLDApLGxyKGUsciksVHQoZSxVZSgpKSxuO2lmKHQ9PT02KWxyKGUscik7ZWxzZXtpZihvPWUuY3VycmVudC5hbHRlcm5hdGUsIShyJjMwKSYmIVFrKG8pJiYodD1RYShlLHIpLHQ9PT0yJiYoaT1OYyhlKSxpIT09MCYmKHI9aSx0PWFkKGUsaSkpKSx0PT09MSkpdGhyb3cgbj1hcyxGcihlLDApLGxyKGUsciksVHQoZSxVZSgpKSxuO3N3aXRjaChlLmZpbmlzaGVkV29yaz1vLGUuZmluaXNoZWRMYW5lcz1yLHQpe2Nhc2UgMDpjYXNlIDE6dGhyb3cgRXJyb3IoRigzNDUpKTtjYXNlIDI6TXIoZSxidCxGbik7YnJlYWs7Y2FzZSAzOmlmKGxyKGUsciksKHImMTMwMDIzNDI0KT09PXImJih0PWpmKzUwMC1VZSgpLDEwPHQpKXtpZihNYShlLDApIT09MClicmVhaztpZihvPWUuc3VzcGVuZGVkTGFuZXMsKG8mcikhPT1yKXt5dCgpLGUucGluZ2VkTGFuZXN8PWUuc3VzcGVuZGVkTGFuZXMmbzticmVha31lLnRpbWVvdXRIYW5kbGU9QmMoTXIuYmluZChudWxsLGUsYnQsRm4pLHQpO2JyZWFrfU1yKGUsYnQsRm4pO2JyZWFrO2Nhc2UgNDppZihscihlLHIpLChyJjQxOTQyNDApPT09cilicmVhaztmb3IodD1lLmV2ZW50VGltZXMsbz0tMTswPHI7KXt2YXIgcz0zMS15bihyKTtpPTE8PHMscz10W3NdLHM+byYmKG89cyksciY9fml9aWYocj1vLHI9VWUoKS1yLHI9KDEyMD5yPzEyMDo0ODA+cj80ODA6MTA4MD5yPzEwODA6MTkyMD5yPzE5MjA6M2UzPnI/M2UzOjQzMjA+cj80MzIwOjE5NjAqR2soci8xOTYwKSktciwxMDxyKXtlLnRpbWVvdXRIYW5kbGU9QmMoTXIuYmluZChudWxsLGUsYnQsRm4pLHIpO2JyZWFrfU1yKGUsYnQsRm4pO2JyZWFrO2Nhc2UgNTpNcihlLGJ0LEZuKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKEYoMzI5KSl9fX1yZXR1cm4gVHQoZSxVZSgpKSxlLmNhbGxiYWNrTm9kZT09PW4/WnYuYmluZChudWxsLGUpOm51bGx9ZnVuY3Rpb24gYWQoZSx0KXt2YXIgbj1OaTtyZXR1cm4gZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkJiYoRnIoZSx0KS5mbGFnc3w9MjU2KSxlPVFhKGUsdCksZSE9PTImJih0PWJ0LGJ0PW4sdCE9PW51bGwmJmxkKHQpKSxlfWZ1bmN0aW9uIGxkKGUpe2J0PT09bnVsbD9idD1lOmJ0LnB1c2guYXBwbHkoYnQsZSl9ZnVuY3Rpb24gUWsoZSl7Zm9yKHZhciB0PWU7Oyl7aWYodC5mbGFncyYxNjM4NCl7dmFyIG49dC51cGRhdGVRdWV1ZTtpZihuIT09bnVsbCYmKG49bi5zdG9yZXMsbiE9PW51bGwpKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdLGk9by5nZXRTbmFwc2hvdDtvPW8udmFsdWU7dHJ5e2lmKCF3bihpKCksbykpcmV0dXJuITF9Y2F0Y2h7cmV0dXJuITF9fX1pZihuPXQuY2hpbGQsdC5zdWJ0cmVlRmxhZ3MmMTYzODQmJm4hPT1udWxsKW4ucmV0dXJuPXQsdD1uO2Vsc2V7aWYodD09PWUpYnJlYWs7Zm9yKDt0LnNpYmxpbmc9PT1udWxsOyl7aWYodC5yZXR1cm49PT1udWxsfHx0LnJldHVybj09PWUpcmV0dXJuITA7dD10LnJldHVybn10LnNpYmxpbmcucmV0dXJuPXQucmV0dXJuLHQ9dC5zaWJsaW5nfX1yZXR1cm4hMH1mdW5jdGlvbiBscihlLHQpe2Zvcih0Jj1+TGYsdCY9fmV1LGUuc3VzcGVuZGVkTGFuZXN8PXQsZS5waW5nZWRMYW5lcyY9fnQsZT1lLmV4cGlyYXRpb25UaW1lczswPHQ7KXt2YXIgbj0zMS15bih0KSxyPTE8PG47ZVtuXT0tMSx0Jj1+cn19ZnVuY3Rpb24gc2goZSl7aWYoZ2UmNil0aHJvdyBFcnJvcihGKDMyNykpO09vKCk7dmFyIHQ9TWEoZSwwKTtpZighKHQmMSkpcmV0dXJuIFR0KGUsVWUoKSksbnVsbDt2YXIgbj1RYShlLHQpO2lmKGUudGFnIT09MCYmbj09PTIpe3ZhciByPU5jKGUpO3IhPT0wJiYodD1yLG49YWQoZSxyKSl9aWYobj09PTEpdGhyb3cgbj1hcyxGcihlLDApLGxyKGUsdCksVHQoZSxVZSgpKSxuO2lmKG49PT02KXRocm93IEVycm9yKEYoMzQ1KSk7cmV0dXJuIGUuZmluaXNoZWRXb3JrPWUuY3VycmVudC5hbHRlcm5hdGUsZS5maW5pc2hlZExhbmVzPXQsTXIoZSxidCxGbiksVHQoZSxVZSgpKSxudWxsfWZ1bmN0aW9uIERmKGUsdCl7dmFyIG49Z2U7Z2V8PTE7dHJ5e3JldHVybiBlKHQpfWZpbmFsbHl7Z2U9bixnZT09PTAmJihEbz1VZSgpKzUwMCxYbCYmUnIoKSl9fWZ1bmN0aW9uIFlyKGUpe2RyIT09bnVsbCYmZHIudGFnPT09MCYmIShnZSY2KSYmT28oKTt2YXIgdD1nZTtnZXw9MTt2YXIgbj1KdC50cmFuc2l0aW9uLHI9Q2U7dHJ5e2lmKEp0LnRyYW5zaXRpb249bnVsbCxDZT0xLGUpcmV0dXJuIGUoKX1maW5hbGx5e0NlPXIsSnQudHJhbnNpdGlvbj1uLGdlPXQsIShnZSY2KSYmUnIoKX19ZnVuY3Rpb24gRmYoKXtNdD14by5jdXJyZW50LCRlKHhvKX1mdW5jdGlvbiBGcihlLHQpe2UuZmluaXNoZWRXb3JrPW51bGwsZS5maW5pc2hlZExhbmVzPTA7dmFyIG49ZS50aW1lb3V0SGFuZGxlO2lmKG4hPT0tMSYmKGUudGltZW91dEhhbmRsZT0tMSxFayhuKSksR2UhPT1udWxsKWZvcihuPUdlLnJldHVybjtuIT09bnVsbDspe3ZhciByPW47c3dpdGNoKFNmKHIpLHIudGFnKXtjYXNlIDE6cj1yLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMsciE9bnVsbCYmemEoKTticmVhaztjYXNlIDM6TG8oKSwkZShFdCksJGUobXQpLCRmKCk7YnJlYWs7Y2FzZSA1OlBmKHIpO2JyZWFrO2Nhc2UgNDpMbygpO2JyZWFrO2Nhc2UgMTM6JGUoQWUpO2JyZWFrO2Nhc2UgMTk6JGUoQWUpO2JyZWFrO2Nhc2UgMTA6a2Yoci50eXBlLl9jb250ZXh0KTticmVhaztjYXNlIDIyOmNhc2UgMjM6RmYoKX1uPW4ucmV0dXJufWlmKGV0PWUsR2U9ZT13cihlLmN1cnJlbnQsbnVsbCksc3Q9TXQ9dCxxZT0wLGFzPW51bGwsTGY9ZXU9S3I9MCxidD1OaT1udWxsLExyIT09bnVsbCl7Zm9yKHQ9MDt0PExyLmxlbmd0aDt0KyspaWYobj1Mclt0XSxyPW4uaW50ZXJsZWF2ZWQsciE9PW51bGwpe24uaW50ZXJsZWF2ZWQ9bnVsbDt2YXIgbz1yLm5leHQsaT1uLnBlbmRpbmc7aWYoaSE9PW51bGwpe3ZhciBzPWkubmV4dDtpLm5leHQ9byxyLm5leHQ9c31uLnBlbmRpbmc9cn1Mcj1udWxsfXJldHVybiBlfWZ1bmN0aW9uIEp2KGUsdCl7ZG97dmFyIG49R2U7dHJ5e2lmKGJmKCksZmEuY3VycmVudD1WYSxIYSl7Zm9yKHZhciByPXplLm1lbW9pemVkU3RhdGU7ciE9PW51bGw7KXt2YXIgbz1yLnF1ZXVlO28hPT1udWxsJiYoby5wZW5kaW5nPW51bGwpLHI9ci5uZXh0fUhhPSExfWlmKFZyPTAsSmU9WGU9emU9bnVsbCxNaT0hMSxvcz0wLHpmLmN1cnJlbnQ9bnVsbCxuPT09bnVsbHx8bi5yZXR1cm49PT1udWxsKXtxZT0xLGFzPXQsR2U9bnVsbDticmVha31lOnt2YXIgaT1lLHM9bi5yZXR1cm4sYT1uLGw9dDtpZih0PXN0LGEuZmxhZ3N8PTMyNzY4LGwhPT1udWxsJiZ0eXBlb2YgbD09Im9iamVjdCImJnR5cGVvZiBsLnRoZW49PSJmdW5jdGlvbiIpe3ZhciB1PWwsYz1hLGQ9Yy50YWc7aWYoIShjLm1vZGUmMSkmJihkPT09MHx8ZD09PTExfHxkPT09MTUpKXt2YXIgbT1jLmFsdGVybmF0ZTttPyhjLnVwZGF0ZVF1ZXVlPW0udXBkYXRlUXVldWUsYy5tZW1vaXplZFN0YXRlPW0ubWVtb2l6ZWRTdGF0ZSxjLmxhbmVzPW0ubGFuZXMpOihjLnVwZGF0ZVF1ZXVlPW51bGwsYy5tZW1vaXplZFN0YXRlPW51bGwpfXZhciB2PVltKHMpO2lmKHYhPT1udWxsKXt2LmZsYWdzJj0tMjU3LEdtKHYscyxhLGksdCksdi5tb2RlJjEmJkttKGksdSx0KSx0PXYsbD11O3ZhciB3PXQudXBkYXRlUXVldWU7aWYodz09PW51bGwpe3ZhciBTPW5ldyBTZXQ7Uy5hZGQobCksdC51cGRhdGVRdWV1ZT1TfWVsc2Ugdy5hZGQobCk7YnJlYWsgZX1lbHNle2lmKCEodCYxKSl7S20oaSx1LHQpLEJmKCk7YnJlYWsgZX1sPUVycm9yKEYoNDI2KSl9fWVsc2UgaWYoX2UmJmEubW9kZSYxKXt2YXIgeD1ZbShzKTtpZih4IT09bnVsbCl7ISh4LmZsYWdzJjY1NTM2KSYmKHguZmxhZ3N8PTI1NiksR20oeCxzLGEsaSx0KSx4ZihqbyhsLGEpKTticmVhayBlfX1pPWw9am8obCxhKSxxZSE9PTQmJihxZT0yKSxOaT09PW51bGw/Tmk9W2ldOk5pLnB1c2goaSksaT1zO2Rve3N3aXRjaChpLnRhZyl7Y2FzZSAzOmkuZmxhZ3N8PTY1NTM2LHQmPS10LGkubGFuZXN8PXQ7dmFyIGg9enYoaSxsLHQpO0ZtKGksaCk7YnJlYWsgZTtjYXNlIDE6YT1sO3ZhciBnPWkudHlwZSxmPWkuc3RhdGVOb2RlO2lmKCEoaS5mbGFncyYxMjgpJiYodHlwZW9mIGcuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yPT0iZnVuY3Rpb24ifHxmIT09bnVsbCYmdHlwZW9mIGYuY29tcG9uZW50RGlkQ2F0Y2g9PSJmdW5jdGlvbiImJih5cj09PW51bGx8fCF5ci5oYXMoZikpKSl7aS5mbGFnc3w9NjU1MzYsdCY9LXQsaS5sYW5lc3w9dDt2YXIgeT1MdihpLGEsdCk7Rm0oaSx5KTticmVhayBlfX1pPWkucmV0dXJufXdoaWxlKGkhPT1udWxsKX1uMChuKX1jYXRjaChiKXt0PWIsR2U9PT1uJiZuIT09bnVsbCYmKEdlPW49bi5yZXR1cm4pO2NvbnRpbnVlfWJyZWFrfXdoaWxlKCEwKX1mdW5jdGlvbiBlMCgpe3ZhciBlPUthLmN1cnJlbnQ7cmV0dXJuIEthLmN1cnJlbnQ9VmEsZT09PW51bGw/VmE6ZX1mdW5jdGlvbiBCZigpeyhxZT09PTB8fHFlPT09M3x8cWU9PT0yKSYmKHFlPTQpLGV0PT09bnVsbHx8IShLciYyNjg0MzU0NTUpJiYhKGV1JjI2ODQzNTQ1NSl8fGxyKGV0LHN0KX1mdW5jdGlvbiBRYShlLHQpe3ZhciBuPWdlO2dlfD0yO3ZhciByPWUwKCk7KGV0IT09ZXx8c3QhPT10KSYmKEZuPW51bGwsRnIoZSx0KSk7ZG8gdHJ5e1hrKCk7YnJlYWt9Y2F0Y2gobyl7SnYoZSxvKX13aGlsZSghMCk7aWYoYmYoKSxnZT1uLEthLmN1cnJlbnQ9cixHZSE9PW51bGwpdGhyb3cgRXJyb3IoRigyNjEpKTtyZXR1cm4gZXQ9bnVsbCxzdD0wLHFlfWZ1bmN0aW9uIFhrKCl7Zm9yKDtHZSE9PW51bGw7KXQwKEdlKX1mdW5jdGlvbiBxaygpe2Zvcig7R2UhPT1udWxsJiYhQ2IoKTspdDAoR2UpfWZ1bmN0aW9uIHQwKGUpe3ZhciB0PW8wKGUuYWx0ZXJuYXRlLGUsTXQpO2UubWVtb2l6ZWRQcm9wcz1lLnBlbmRpbmdQcm9wcyx0PT09bnVsbD9uMChlKTpHZT10LHpmLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBuMChlKXt2YXIgdD1lO2Rve3ZhciBuPXQuYWx0ZXJuYXRlO2lmKGU9dC5yZXR1cm4sdC5mbGFncyYzMjc2OCl7aWYobj1IayhuLHQpLG4hPT1udWxsKXtuLmZsYWdzJj0zMjc2NyxHZT1uO3JldHVybn1pZihlIT09bnVsbCllLmZsYWdzfD0zMjc2OCxlLnN1YnRyZWVGbGFncz0wLGUuZGVsZXRpb25zPW51bGw7ZWxzZXtxZT02LEdlPW51bGw7cmV0dXJufX1lbHNlIGlmKG49VWsobix0LE10KSxuIT09bnVsbCl7R2U9bjtyZXR1cm59aWYodD10LnNpYmxpbmcsdCE9PW51bGwpe0dlPXQ7cmV0dXJufUdlPXQ9ZX13aGlsZSh0IT09bnVsbCk7cWU9PT0wJiYocWU9NSl9ZnVuY3Rpb24gTXIoZSx0LG4pe3ZhciByPUNlLG89SnQudHJhbnNpdGlvbjt0cnl7SnQudHJhbnNpdGlvbj1udWxsLENlPTEsWmsoZSx0LG4scil9ZmluYWxseXtKdC50cmFuc2l0aW9uPW8sQ2U9cn1yZXR1cm4gbnVsbH1mdW5jdGlvbiBaayhlLHQsbixyKXtkbyBPbygpO3doaWxlKGRyIT09bnVsbCk7aWYoZ2UmNil0aHJvdyBFcnJvcihGKDMyNykpO249ZS5maW5pc2hlZFdvcms7dmFyIG89ZS5maW5pc2hlZExhbmVzO2lmKG49PT1udWxsKXJldHVybiBudWxsO2lmKGUuZmluaXNoZWRXb3JrPW51bGwsZS5maW5pc2hlZExhbmVzPTAsbj09PWUuY3VycmVudCl0aHJvdyBFcnJvcihGKDE3NykpO2UuY2FsbGJhY2tOb2RlPW51bGwsZS5jYWxsYmFja1ByaW9yaXR5PTA7dmFyIGk9bi5sYW5lc3xuLmNoaWxkTGFuZXM7aWYoX2IoZSxpKSxlPT09ZXQmJihHZT1ldD1udWxsLHN0PTApLCEobi5zdWJ0cmVlRmxhZ3MmMjA2NCkmJiEobi5mbGFncyYyMDY0KXx8S3N8fChLcz0hMCxpMChPYSxmdW5jdGlvbigpe3JldHVybiBPbygpLG51bGx9KSksaT0obi5mbGFncyYxNTk5MCkhPT0wLG4uc3VidHJlZUZsYWdzJjE1OTkwfHxpKXtpPUp0LnRyYW5zaXRpb24sSnQudHJhbnNpdGlvbj1udWxsO3ZhciBzPUNlO0NlPTE7dmFyIGE9Z2U7Z2V8PTQsemYuY3VycmVudD1udWxsLEtrKGUsbiksWHYobixlKSx2ayhEYyksX2E9ISFqYyxEYz1qYz1udWxsLGUuY3VycmVudD1uLFlrKG4pLGJiKCksZ2U9YSxDZT1zLEp0LnRyYW5zaXRpb249aX1lbHNlIGUuY3VycmVudD1uO2lmKEtzJiYoS3M9ITEsZHI9ZSxHYT1vKSxpPWUucGVuZGluZ0xhbmVzLGk9PT0wJiYoeXI9bnVsbCksUmIobi5zdGF0ZU5vZGUpLFR0KGUsVWUoKSksdCE9PW51bGwpZm9yKHI9ZS5vblJlY292ZXJhYmxlRXJyb3Isbj0wO248dC5sZW5ndGg7bisrKW89dFtuXSxyKG8udmFsdWUse2NvbXBvbmVudFN0YWNrOm8uc3RhY2ssZGlnZXN0Om8uZGlnZXN0fSk7aWYoWWEpdGhyb3cgWWE9ITEsZT1pZCxpZD1udWxsLGU7cmV0dXJuIEdhJjEmJmUudGFnIT09MCYmT28oKSxpPWUucGVuZGluZ0xhbmVzLGkmMT9lPT09c2Q/SWkrKzooSWk9MCxzZD1lKTpJaT0wLFJyKCksbnVsbH1mdW5jdGlvbiBPbygpe2lmKGRyIT09bnVsbCl7dmFyIGU9enkoR2EpLHQ9SnQudHJhbnNpdGlvbixuPUNlO3RyeXtpZihKdC50cmFuc2l0aW9uPW51bGwsQ2U9MTY+ZT8xNjplLGRyPT09bnVsbCl2YXIgcj0hMTtlbHNle2lmKGU9ZHIsZHI9bnVsbCxHYT0wLGdlJjYpdGhyb3cgRXJyb3IoRigzMzEpKTt2YXIgbz1nZTtmb3IoZ2V8PTQsSz1lLmN1cnJlbnQ7SyE9PW51bGw7KXt2YXIgaT1LLHM9aS5jaGlsZDtpZihLLmZsYWdzJjE2KXt2YXIgYT1pLmRlbGV0aW9ucztpZihhIT09bnVsbCl7Zm9yKHZhciBsPTA7bDxhLmxlbmd0aDtsKyspe3ZhciB1PWFbbF07Zm9yKEs9dTtLIT09bnVsbDspe3ZhciBjPUs7c3dpdGNoKGMudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1Ol9pKDgsYyxpKX12YXIgZD1jLmNoaWxkO2lmKGQhPT1udWxsKWQucmV0dXJuPWMsSz1kO2Vsc2UgZm9yKDtLIT09bnVsbDspe2M9Szt2YXIgbT1jLnNpYmxpbmcsdj1jLnJldHVybjtpZihZdihjKSxjPT09dSl7Sz1udWxsO2JyZWFrfWlmKG0hPT1udWxsKXttLnJldHVybj12LEs9bTticmVha31LPXZ9fX12YXIgdz1pLmFsdGVybmF0ZTtpZih3IT09bnVsbCl7dmFyIFM9dy5jaGlsZDtpZihTIT09bnVsbCl7dy5jaGlsZD1udWxsO2Rve3ZhciB4PVMuc2libGluZztTLnNpYmxpbmc9bnVsbCxTPXh9d2hpbGUoUyE9PW51bGwpfX1LPWl9fWlmKGkuc3VidHJlZUZsYWdzJjIwNjQmJnMhPT1udWxsKXMucmV0dXJuPWksSz1zO2Vsc2UgZTpmb3IoO0shPT1udWxsOyl7aWYoaT1LLGkuZmxhZ3MmMjA0OClzd2l0Y2goaS50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6X2koOSxpLGkucmV0dXJuKX12YXIgaD1pLnNpYmxpbmc7aWYoaCE9PW51bGwpe2gucmV0dXJuPWkucmV0dXJuLEs9aDticmVhayBlfUs9aS5yZXR1cm59fXZhciBnPWUuY3VycmVudDtmb3IoSz1nO0shPT1udWxsOyl7cz1LO3ZhciBmPXMuY2hpbGQ7aWYocy5zdWJ0cmVlRmxhZ3MmMjA2NCYmZiE9PW51bGwpZi5yZXR1cm49cyxLPWY7ZWxzZSBlOmZvcihzPWc7SyE9PW51bGw7KXtpZihhPUssYS5mbGFncyYyMDQ4KXRyeXtzd2l0Y2goYS50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6SmwoOSxhKX19Y2F0Y2goYil7QmUoYSxhLnJldHVybixiKX1pZihhPT09cyl7Sz1udWxsO2JyZWFrIGV9dmFyIHk9YS5zaWJsaW5nO2lmKHkhPT1udWxsKXt5LnJldHVybj1hLnJldHVybixLPXk7YnJlYWsgZX1LPWEucmV0dXJufX1pZihnZT1vLFJyKCksTm4mJnR5cGVvZiBObi5vblBvc3RDb21taXRGaWJlclJvb3Q9PSJmdW5jdGlvbiIpdHJ5e05uLm9uUG9zdENvbW1pdEZpYmVyUm9vdChWbCxlKX1jYXRjaHt9cj0hMH1yZXR1cm4gcn1maW5hbGx5e0NlPW4sSnQudHJhbnNpdGlvbj10fX1yZXR1cm4hMX1mdW5jdGlvbiBhaChlLHQsbil7dD1qbyhuLHQpLHQ9enYoZSx0LDEpLGU9Z3IoZSx0LDEpLHQ9eXQoKSxlIT09bnVsbCYmKHhzKGUsMSx0KSxUdChlLHQpKX1mdW5jdGlvbiBCZShlLHQsbil7aWYoZS50YWc9PT0zKWFoKGUsZSxuKTtlbHNlIGZvcig7dCE9PW51bGw7KXtpZih0LnRhZz09PTMpe2FoKHQsZSxuKTticmVha31lbHNlIGlmKHQudGFnPT09MSl7dmFyIHI9dC5zdGF0ZU5vZGU7aWYodHlwZW9mIHQudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9PSJmdW5jdGlvbiJ8fHR5cGVvZiByLmNvbXBvbmVudERpZENhdGNoPT0iZnVuY3Rpb24iJiYoeXI9PT1udWxsfHwheXIuaGFzKHIpKSl7ZT1qbyhuLGUpLGU9THYodCxlLDEpLHQ9Z3IodCxlLDEpLGU9eXQoKSx0IT09bnVsbCYmKHhzKHQsMSxlKSxUdCh0LGUpKTticmVha319dD10LnJldHVybn19ZnVuY3Rpb24gSmsoZSx0LG4pe3ZhciByPWUucGluZ0NhY2hlO3IhPT1udWxsJiZyLmRlbGV0ZSh0KSx0PXl0KCksZS5waW5nZWRMYW5lc3w9ZS5zdXNwZW5kZWRMYW5lcyZuLGV0PT09ZSYmKHN0Jm4pPT09biYmKHFlPT09NHx8cWU9PT0zJiYoc3QmMTMwMDIzNDI0KT09PXN0JiY1MDA+VWUoKS1qZj9GcihlLDApOkxmfD1uKSxUdChlLHQpfWZ1bmN0aW9uIHIwKGUsdCl7dD09PTAmJihlLm1vZGUmMT8odD16cyx6czw8PTEsISh6cyYxMzAwMjM0MjQpJiYoenM9NDE5NDMwNCkpOnQ9MSk7dmFyIG49eXQoKTtlPXFuKGUsdCksZSE9PW51bGwmJih4cyhlLHQsbiksVHQoZSxuKSl9ZnVuY3Rpb24gZUUoZSl7dmFyIHQ9ZS5tZW1vaXplZFN0YXRlLG49MDt0IT09bnVsbCYmKG49dC5yZXRyeUxhbmUpLHIwKGUsbil9ZnVuY3Rpb24gdEUoZSx0KXt2YXIgbj0wO3N3aXRjaChlLnRhZyl7Y2FzZSAxMzp2YXIgcj1lLnN0YXRlTm9kZSxvPWUubWVtb2l6ZWRTdGF0ZTtvIT09bnVsbCYmKG49by5yZXRyeUxhbmUpO2JyZWFrO2Nhc2UgMTk6cj1lLnN0YXRlTm9kZTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKEYoMzE0KSl9ciE9PW51bGwmJnIuZGVsZXRlKHQpLHIwKGUsbil9dmFyIG8wO28wPWZ1bmN0aW9uKGUsdCxuKXtpZihlIT09bnVsbClpZihlLm1lbW9pemVkUHJvcHMhPT10LnBlbmRpbmdQcm9wc3x8RXQuY3VycmVudClrdD0hMDtlbHNle2lmKCEoZS5sYW5lcyZuKSYmISh0LmZsYWdzJjEyOCkpcmV0dXJuIGt0PSExLFdrKGUsdCxuKTtrdD0hIShlLmZsYWdzJjEzMTA3Mil9ZWxzZSBrdD0hMSxfZSYmdC5mbGFncyYxMDQ4NTc2JiZsdih0LERhLHQuaW5kZXgpO3N3aXRjaCh0LmxhbmVzPTAsdC50YWcpe2Nhc2UgMjp2YXIgcj10LnR5cGU7bWEoZSx0KSxlPXQucGVuZGluZ1Byb3BzO3ZhciBvPUlvKHQsbXQuY3VycmVudCk7JG8odCxuKSxvPU1mKG51bGwsdCxyLGUsbyxuKTt2YXIgaT1fZigpO3JldHVybiB0LmZsYWdzfD0xLHR5cGVvZiBvPT0ib2JqZWN0IiYmbyE9PW51bGwmJnR5cGVvZiBvLnJlbmRlcj09ImZ1bmN0aW9uIiYmby4kJHR5cGVvZj09PXZvaWQgMD8odC50YWc9MSx0Lm1lbW9pemVkU3RhdGU9bnVsbCx0LnVwZGF0ZVF1ZXVlPW51bGwsUnQocik/KGk9ITAsTGEodCkpOmk9ITEsdC5tZW1vaXplZFN0YXRlPW8uc3RhdGUhPT1udWxsJiZvLnN0YXRlIT09dm9pZCAwP28uc3RhdGU6bnVsbCxSZih0KSxvLnVwZGF0ZXI9WmwsdC5zdGF0ZU5vZGU9byxvLl9yZWFjdEludGVybmFscz10LEdjKHQscixlLG4pLHQ9cWMobnVsbCx0LHIsITAsaSxuKSk6KHQudGFnPTAsX2UmJmkmJndmKHQpLGd0KG51bGwsdCxvLG4pLHQ9dC5jaGlsZCksdDtjYXNlIDE2OnI9dC5lbGVtZW50VHlwZTtlOntzd2l0Y2gobWEoZSx0KSxlPXQucGVuZGluZ1Byb3BzLG89ci5faW5pdCxyPW8oci5fcGF5bG9hZCksdC50eXBlPXIsbz10LnRhZz1yRShyKSxlPWZuKHIsZSksbyl7Y2FzZSAwOnQ9WGMobnVsbCx0LHIsZSxuKTticmVhayBlO2Nhc2UgMTp0PXFtKG51bGwsdCxyLGUsbik7YnJlYWsgZTtjYXNlIDExOnQ9UW0obnVsbCx0LHIsZSxuKTticmVhayBlO2Nhc2UgMTQ6dD1YbShudWxsLHQscixmbihyLnR5cGUsZSksbik7YnJlYWsgZX10aHJvdyBFcnJvcihGKDMwNixyLCIiKSl9cmV0dXJuIHQ7Y2FzZSAwOnJldHVybiByPXQudHlwZSxvPXQucGVuZGluZ1Byb3BzLG89dC5lbGVtZW50VHlwZT09PXI/bzpmbihyLG8pLFhjKGUsdCxyLG8sbik7Y2FzZSAxOnJldHVybiByPXQudHlwZSxvPXQucGVuZGluZ1Byb3BzLG89dC5lbGVtZW50VHlwZT09PXI/bzpmbihyLG8pLHFtKGUsdCxyLG8sbik7Y2FzZSAzOmU6e2lmKEJ2KHQpLGU9PT1udWxsKXRocm93IEVycm9yKEYoMzg3KSk7cj10LnBlbmRpbmdQcm9wcyxpPXQubWVtb2l6ZWRTdGF0ZSxvPWkuZWxlbWVudCxtdihlLHQpLFdhKHQscixudWxsLG4pO3ZhciBzPXQubWVtb2l6ZWRTdGF0ZTtpZihyPXMuZWxlbWVudCxpLmlzRGVoeWRyYXRlZClpZihpPXtlbGVtZW50OnIsaXNEZWh5ZHJhdGVkOiExLGNhY2hlOnMuY2FjaGUscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpzLnBlbmRpbmdTdXNwZW5zZUJvdW5kYXJpZXMsdHJhbnNpdGlvbnM6cy50cmFuc2l0aW9uc30sdC51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9aSx0Lm1lbW9pemVkU3RhdGU9aSx0LmZsYWdzJjI1Nil7bz1qbyhFcnJvcihGKDQyMykpLHQpLHQ9Wm0oZSx0LHIsbixvKTticmVhayBlfWVsc2UgaWYociE9PW8pe289am8oRXJyb3IoRig0MjQpKSx0KSx0PVptKGUsdCxyLG4sbyk7YnJlYWsgZX1lbHNlIGZvcihBdD1ocih0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvLmZpcnN0Q2hpbGQpLGp0PXQsX2U9ITAsaG49bnVsbCxuPWZ2KHQsbnVsbCxyLG4pLHQuY2hpbGQ9bjtuOyluLmZsYWdzPW4uZmxhZ3MmLTN8NDA5NixuPW4uc2libGluZztlbHNle2lmKEFvKCkscj09PW8pe3Q9Wm4oZSx0LG4pO2JyZWFrIGV9Z3QoZSx0LHIsbil9dD10LmNoaWxkfXJldHVybiB0O2Nhc2UgNTpyZXR1cm4gaHYodCksZT09PW51bGwmJlZjKHQpLHI9dC50eXBlLG89dC5wZW5kaW5nUHJvcHMsaT1lIT09bnVsbD9lLm1lbW9pemVkUHJvcHM6bnVsbCxzPW8uY2hpbGRyZW4sRmMocixvKT9zPW51bGw6aSE9PW51bGwmJkZjKHIsaSkmJih0LmZsYWdzfD0zMiksRnYoZSx0KSxndChlLHQscyxuKSx0LmNoaWxkO2Nhc2UgNjpyZXR1cm4gZT09PW51bGwmJlZjKHQpLG51bGw7Y2FzZSAxMzpyZXR1cm4gV3YoZSx0LG4pO2Nhc2UgNDpyZXR1cm4gVGYodCx0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxyPXQucGVuZGluZ1Byb3BzLGU9PT1udWxsP3QuY2hpbGQ9em8odCxudWxsLHIsbik6Z3QoZSx0LHIsbiksdC5jaGlsZDtjYXNlIDExOnJldHVybiByPXQudHlwZSxvPXQucGVuZGluZ1Byb3BzLG89dC5lbGVtZW50VHlwZT09PXI/bzpmbihyLG8pLFFtKGUsdCxyLG8sbik7Y2FzZSA3OnJldHVybiBndChlLHQsdC5wZW5kaW5nUHJvcHMsbiksdC5jaGlsZDtjYXNlIDg6cmV0dXJuIGd0KGUsdCx0LnBlbmRpbmdQcm9wcy5jaGlsZHJlbixuKSx0LmNoaWxkO2Nhc2UgMTI6cmV0dXJuIGd0KGUsdCx0LnBlbmRpbmdQcm9wcy5jaGlsZHJlbixuKSx0LmNoaWxkO2Nhc2UgMTA6ZTp7aWYocj10LnR5cGUuX2NvbnRleHQsbz10LnBlbmRpbmdQcm9wcyxpPXQubWVtb2l6ZWRQcm9wcyxzPW8udmFsdWUsVGUoRmEsci5fY3VycmVudFZhbHVlKSxyLl9jdXJyZW50VmFsdWU9cyxpIT09bnVsbClpZih3bihpLnZhbHVlLHMpKXtpZihpLmNoaWxkcmVuPT09by5jaGlsZHJlbiYmIUV0LmN1cnJlbnQpe3Q9Wm4oZSx0LG4pO2JyZWFrIGV9fWVsc2UgZm9yKGk9dC5jaGlsZCxpIT09bnVsbCYmKGkucmV0dXJuPXQpO2khPT1udWxsOyl7dmFyIGE9aS5kZXBlbmRlbmNpZXM7aWYoYSE9PW51bGwpe3M9aS5jaGlsZDtmb3IodmFyIGw9YS5maXJzdENvbnRleHQ7bCE9PW51bGw7KXtpZihsLmNvbnRleHQ9PT1yKXtpZihpLnRhZz09PTEpe2w9SG4oLTEsbiYtbiksbC50YWc9Mjt2YXIgdT1pLnVwZGF0ZVF1ZXVlO2lmKHUhPT1udWxsKXt1PXUuc2hhcmVkO3ZhciBjPXUucGVuZGluZztjPT09bnVsbD9sLm5leHQ9bDoobC5uZXh0PWMubmV4dCxjLm5leHQ9bCksdS5wZW5kaW5nPWx9fWkubGFuZXN8PW4sbD1pLmFsdGVybmF0ZSxsIT09bnVsbCYmKGwubGFuZXN8PW4pLEtjKGkucmV0dXJuLG4sdCksYS5sYW5lc3w9bjticmVha31sPWwubmV4dH19ZWxzZSBpZihpLnRhZz09PTEwKXM9aS50eXBlPT09dC50eXBlP251bGw6aS5jaGlsZDtlbHNlIGlmKGkudGFnPT09MTgpe2lmKHM9aS5yZXR1cm4scz09PW51bGwpdGhyb3cgRXJyb3IoRigzNDEpKTtzLmxhbmVzfD1uLGE9cy5hbHRlcm5hdGUsYSE9PW51bGwmJihhLmxhbmVzfD1uKSxLYyhzLG4sdCkscz1pLnNpYmxpbmd9ZWxzZSBzPWkuY2hpbGQ7aWYocyE9PW51bGwpcy5yZXR1cm49aTtlbHNlIGZvcihzPWk7cyE9PW51bGw7KXtpZihzPT09dCl7cz1udWxsO2JyZWFrfWlmKGk9cy5zaWJsaW5nLGkhPT1udWxsKXtpLnJldHVybj1zLnJldHVybixzPWk7YnJlYWt9cz1zLnJldHVybn1pPXN9Z3QoZSx0LG8uY2hpbGRyZW4sbiksdD10LmNoaWxkfXJldHVybiB0O2Nhc2UgOTpyZXR1cm4gbz10LnR5cGUscj10LnBlbmRpbmdQcm9wcy5jaGlsZHJlbiwkbyh0LG4pLG89dG4obykscj1yKG8pLHQuZmxhZ3N8PTEsZ3QoZSx0LHIsbiksdC5jaGlsZDtjYXNlIDE0OnJldHVybiByPXQudHlwZSxvPWZuKHIsdC5wZW5kaW5nUHJvcHMpLG89Zm4oci50eXBlLG8pLFhtKGUsdCxyLG8sbik7Y2FzZSAxNTpyZXR1cm4ganYoZSx0LHQudHlwZSx0LnBlbmRpbmdQcm9wcyxuKTtjYXNlIDE3OnJldHVybiByPXQudHlwZSxvPXQucGVuZGluZ1Byb3BzLG89dC5lbGVtZW50VHlwZT09PXI/bzpmbihyLG8pLG1hKGUsdCksdC50YWc9MSxSdChyKT8oZT0hMCxMYSh0KSk6ZT0hMSwkbyh0LG4pLEF2KHQscixvKSxHYyh0LHIsbyxuKSxxYyhudWxsLHQsciwhMCxlLG4pO2Nhc2UgMTk6cmV0dXJuIFV2KGUsdCxuKTtjYXNlIDIyOnJldHVybiBEdihlLHQsbil9dGhyb3cgRXJyb3IoRigxNTYsdC50YWcpKX07ZnVuY3Rpb24gaTAoZSx0KXtyZXR1cm4gX3koZSx0KX1mdW5jdGlvbiBuRShlLHQsbixyKXt0aGlzLnRhZz1lLHRoaXMua2V5PW4sdGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpcy5yZXR1cm49dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPXRoaXMuZWxlbWVudFR5cGU9bnVsbCx0aGlzLmluZGV4PTAsdGhpcy5yZWY9bnVsbCx0aGlzLnBlbmRpbmdQcm9wcz10LHRoaXMuZGVwZW5kZW5jaWVzPXRoaXMubWVtb2l6ZWRTdGF0ZT10aGlzLnVwZGF0ZVF1ZXVlPXRoaXMubWVtb2l6ZWRQcm9wcz1udWxsLHRoaXMubW9kZT1yLHRoaXMuc3VidHJlZUZsYWdzPXRoaXMuZmxhZ3M9MCx0aGlzLmRlbGV0aW9ucz1udWxsLHRoaXMuY2hpbGRMYW5lcz10aGlzLmxhbmVzPTAsdGhpcy5hbHRlcm5hdGU9bnVsbH1mdW5jdGlvbiBadChlLHQsbixyKXtyZXR1cm4gbmV3IG5FKGUsdCxuLHIpfWZ1bmN0aW9uIFdmKGUpe3JldHVybiBlPWUucHJvdG90eXBlLCEoIWV8fCFlLmlzUmVhY3RDb21wb25lbnQpfWZ1bmN0aW9uIHJFKGUpe2lmKHR5cGVvZiBlPT0iZnVuY3Rpb24iKXJldHVybiBXZihlKT8xOjA7aWYoZSE9bnVsbCl7aWYoZT1lLiQkdHlwZW9mLGU9PT1hZilyZXR1cm4gMTE7aWYoZT09PWxmKXJldHVybiAxNH1yZXR1cm4gMn1mdW5jdGlvbiB3cihlLHQpe3ZhciBuPWUuYWx0ZXJuYXRlO3JldHVybiBuPT09bnVsbD8obj1adChlLnRhZyx0LGUua2V5LGUubW9kZSksbi5lbGVtZW50VHlwZT1lLmVsZW1lbnRUeXBlLG4udHlwZT1lLnR5cGUsbi5zdGF0ZU5vZGU9ZS5zdGF0ZU5vZGUsbi5hbHRlcm5hdGU9ZSxlLmFsdGVybmF0ZT1uKToobi5wZW5kaW5nUHJvcHM9dCxuLnR5cGU9ZS50eXBlLG4uZmxhZ3M9MCxuLnN1YnRyZWVGbGFncz0wLG4uZGVsZXRpb25zPW51bGwpLG4uZmxhZ3M9ZS5mbGFncyYxNDY4MDA2NCxuLmNoaWxkTGFuZXM9ZS5jaGlsZExhbmVzLG4ubGFuZXM9ZS5sYW5lcyxuLmNoaWxkPWUuY2hpbGQsbi5tZW1vaXplZFByb3BzPWUubWVtb2l6ZWRQcm9wcyxuLm1lbW9pemVkU3RhdGU9ZS5tZW1vaXplZFN0YXRlLG4udXBkYXRlUXVldWU9ZS51cGRhdGVRdWV1ZSx0PWUuZGVwZW5kZW5jaWVzLG4uZGVwZW5kZW5jaWVzPXQ9PT1udWxsP251bGw6e2xhbmVzOnQubGFuZXMsZmlyc3RDb250ZXh0OnQuZmlyc3RDb250ZXh0fSxuLnNpYmxpbmc9ZS5zaWJsaW5nLG4uaW5kZXg9ZS5pbmRleCxuLnJlZj1lLnJlZixufWZ1bmN0aW9uIHlhKGUsdCxuLHIsbyxpKXt2YXIgcz0yO2lmKHI9ZSx0eXBlb2YgZT09ImZ1bmN0aW9uIilXZihlKSYmKHM9MSk7ZWxzZSBpZih0eXBlb2YgZT09InN0cmluZyIpcz01O2Vsc2UgZTpzd2l0Y2goZSl7Y2FzZSBjbzpyZXR1cm4gQnIobi5jaGlsZHJlbixvLGksdCk7Y2FzZSBzZjpzPTgsb3w9ODticmVhaztjYXNlIHZjOnJldHVybiBlPVp0KDEyLG4sdCxvfDIpLGUuZWxlbWVudFR5cGU9dmMsZS5sYW5lcz1pLGU7Y2FzZSB3YzpyZXR1cm4gZT1adCgxMyxuLHQsbyksZS5lbGVtZW50VHlwZT13YyxlLmxhbmVzPWksZTtjYXNlIFNjOnJldHVybiBlPVp0KDE5LG4sdCxvKSxlLmVsZW1lbnRUeXBlPVNjLGUubGFuZXM9aSxlO2Nhc2UgaHk6cmV0dXJuIHR1KG4sbyxpLHQpO2RlZmF1bHQ6aWYodHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbClzd2l0Y2goZS4kJHR5cGVvZil7Y2FzZSBweTpzPTEwO2JyZWFrIGU7Y2FzZSBteTpzPTk7YnJlYWsgZTtjYXNlIGFmOnM9MTE7YnJlYWsgZTtjYXNlIGxmOnM9MTQ7YnJlYWsgZTtjYXNlIGlyOnM9MTYscj1udWxsO2JyZWFrIGV9dGhyb3cgRXJyb3IoRigxMzAsZT09bnVsbD9lOnR5cGVvZiBlLCIiKSl9cmV0dXJuIHQ9WnQocyxuLHQsbyksdC5lbGVtZW50VHlwZT1lLHQudHlwZT1yLHQubGFuZXM9aSx0fWZ1bmN0aW9uIEJyKGUsdCxuLHIpe3JldHVybiBlPVp0KDcsZSxyLHQpLGUubGFuZXM9bixlfWZ1bmN0aW9uIHR1KGUsdCxuLHIpe3JldHVybiBlPVp0KDIyLGUscix0KSxlLmVsZW1lbnRUeXBlPWh5LGUubGFuZXM9bixlLnN0YXRlTm9kZT17aXNIaWRkZW46ITF9LGV9ZnVuY3Rpb24gR3UoZSx0LG4pe3JldHVybiBlPVp0KDYsZSxudWxsLHQpLGUubGFuZXM9bixlfWZ1bmN0aW9uIFF1KGUsdCxuKXtyZXR1cm4gdD1adCg0LGUuY2hpbGRyZW4hPT1udWxsP2UuY2hpbGRyZW46W10sZS5rZXksdCksdC5sYW5lcz1uLHQuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmUuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjplLmltcGxlbWVudGF0aW9ufSx0fWZ1bmN0aW9uIG9FKGUsdCxuLHIsbyl7dGhpcy50YWc9dCx0aGlzLmNvbnRhaW5lckluZm89ZSx0aGlzLmZpbmlzaGVkV29yaz10aGlzLnBpbmdDYWNoZT10aGlzLmN1cnJlbnQ9dGhpcy5wZW5kaW5nQ2hpbGRyZW49bnVsbCx0aGlzLnRpbWVvdXRIYW5kbGU9LTEsdGhpcy5jYWxsYmFja05vZGU9dGhpcy5wZW5kaW5nQ29udGV4dD10aGlzLmNvbnRleHQ9bnVsbCx0aGlzLmNhbGxiYWNrUHJpb3JpdHk9MCx0aGlzLmV2ZW50VGltZXM9JHUoMCksdGhpcy5leHBpcmF0aW9uVGltZXM9JHUoLTEpLHRoaXMuZW50YW5nbGVkTGFuZXM9dGhpcy5maW5pc2hlZExhbmVzPXRoaXMubXV0YWJsZVJlYWRMYW5lcz10aGlzLmV4cGlyZWRMYW5lcz10aGlzLnBpbmdlZExhbmVzPXRoaXMuc3VzcGVuZGVkTGFuZXM9dGhpcy5wZW5kaW5nTGFuZXM9MCx0aGlzLmVudGFuZ2xlbWVudHM9JHUoMCksdGhpcy5pZGVudGlmaWVyUHJlZml4PXIsdGhpcy5vblJlY292ZXJhYmxlRXJyb3I9byx0aGlzLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9bnVsbH1mdW5jdGlvbiBVZihlLHQsbixyLG8saSxzLGEsbCl7cmV0dXJuIGU9bmV3IG9FKGUsdCxuLGEsbCksdD09PTE/KHQ9MSxpPT09ITAmJih0fD04KSk6dD0wLGk9WnQoMyxudWxsLG51bGwsdCksZS5jdXJyZW50PWksaS5zdGF0ZU5vZGU9ZSxpLm1lbW9pemVkU3RhdGU9e2VsZW1lbnQ6cixpc0RlaHlkcmF0ZWQ6bixjYWNoZTpudWxsLHRyYW5zaXRpb25zOm51bGwscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpudWxsfSxSZihpKSxlfWZ1bmN0aW9uIGlFKGUsdCxuKXt2YXIgcj0zPGFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1szXSE9PXZvaWQgMD9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6dW8sa2V5OnI9PW51bGw/bnVsbDoiIityLGNoaWxkcmVuOmUsY29udGFpbmVySW5mbzp0LGltcGxlbWVudGF0aW9uOm59fWZ1bmN0aW9uIHMwKGUpe2lmKCFlKXJldHVybiBDcjtlPWUuX3JlYWN0SW50ZXJuYWxzO2U6e2lmKFpyKGUpIT09ZXx8ZS50YWchPT0xKXRocm93IEVycm9yKEYoMTcwKSk7dmFyIHQ9ZTtkb3tzd2l0Y2godC50YWcpe2Nhc2UgMzp0PXQuc3RhdGVOb2RlLmNvbnRleHQ7YnJlYWsgZTtjYXNlIDE6aWYoUnQodC50eXBlKSl7dD10LnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBlfX10PXQucmV0dXJufXdoaWxlKHQhPT1udWxsKTt0aHJvdyBFcnJvcihGKDE3MSkpfWlmKGUudGFnPT09MSl7dmFyIG49ZS50eXBlO2lmKFJ0KG4pKXJldHVybiBzdihlLG4sdCl9cmV0dXJuIHR9ZnVuY3Rpb24gYTAoZSx0LG4scixvLGkscyxhLGwpe3JldHVybiBlPVVmKG4sciwhMCxlLG8saSxzLGEsbCksZS5jb250ZXh0PXMwKG51bGwpLG49ZS5jdXJyZW50LHI9eXQoKSxvPXZyKG4pLGk9SG4ocixvKSxpLmNhbGxiYWNrPXQ/P251bGwsZ3IobixpLG8pLGUuY3VycmVudC5sYW5lcz1vLHhzKGUsbyxyKSxUdChlLHIpLGV9ZnVuY3Rpb24gbnUoZSx0LG4scil7dmFyIG89dC5jdXJyZW50LGk9eXQoKSxzPXZyKG8pO3JldHVybiBuPXMwKG4pLHQuY29udGV4dD09PW51bGw/dC5jb250ZXh0PW46dC5wZW5kaW5nQ29udGV4dD1uLHQ9SG4oaSxzKSx0LnBheWxvYWQ9e2VsZW1lbnQ6ZX0scj1yPT09dm9pZCAwP251bGw6cixyIT09bnVsbCYmKHQuY2FsbGJhY2s9ciksZT1ncihvLHQscyksZSE9PW51bGwmJih2bihlLG8scyxpKSxkYShlLG8scykpLHN9ZnVuY3Rpb24gWGEoZSl7aWYoZT1lLmN1cnJlbnQsIWUuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGUuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGUuY2hpbGQuc3RhdGVOb2RlO2RlZmF1bHQ6cmV0dXJuIGUuY2hpbGQuc3RhdGVOb2RlfX1mdW5jdGlvbiBsaChlLHQpe2lmKGU9ZS5tZW1vaXplZFN0YXRlLGUhPT1udWxsJiZlLmRlaHlkcmF0ZWQhPT1udWxsKXt2YXIgbj1lLnJldHJ5TGFuZTtlLnJldHJ5TGFuZT1uIT09MCYmbjx0P246dH19ZnVuY3Rpb24gSGYoZSx0KXtsaChlLHQpLChlPWUuYWx0ZXJuYXRlKSYmbGgoZSx0KX1mdW5jdGlvbiBzRSgpe3JldHVybiBudWxsfXZhciBsMD10eXBlb2YgcmVwb3J0RXJyb3I9PSJmdW5jdGlvbiI/cmVwb3J0RXJyb3I6ZnVuY3Rpb24oZSl7Y29uc29sZS5lcnJvcihlKX07ZnVuY3Rpb24gVmYoZSl7dGhpcy5faW50ZXJuYWxSb290PWV9cnUucHJvdG90eXBlLnJlbmRlcj1WZi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX2ludGVybmFsUm9vdDtpZih0PT09bnVsbCl0aHJvdyBFcnJvcihGKDQwOSkpO251KGUsdCxudWxsLG51bGwpfTtydS5wcm90b3R5cGUudW5tb3VudD1WZi5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX2ludGVybmFsUm9vdDtpZihlIT09bnVsbCl7dGhpcy5faW50ZXJuYWxSb290PW51bGw7dmFyIHQ9ZS5jb250YWluZXJJbmZvO1lyKGZ1bmN0aW9uKCl7bnUobnVsbCxlLG51bGwsbnVsbCl9KSx0W1huXT1udWxsfX07ZnVuY3Rpb24gcnUoZSl7dGhpcy5faW50ZXJuYWxSb290PWV9cnUucHJvdG90eXBlLnVuc3RhYmxlX3NjaGVkdWxlSHlkcmF0aW9uPWZ1bmN0aW9uKGUpe2lmKGUpe3ZhciB0PUR5KCk7ZT17YmxvY2tlZE9uOm51bGwsdGFyZ2V0OmUscHJpb3JpdHk6dH07Zm9yKHZhciBuPTA7bjxhci5sZW5ndGgmJnQhPT0wJiZ0PGFyW25dLnByaW9yaXR5O24rKyk7YXIuc3BsaWNlKG4sMCxlKSxuPT09MCYmQnkoZSl9fTtmdW5jdGlvbiBLZihlKXtyZXR1cm4hKCFlfHxlLm5vZGVUeXBlIT09MSYmZS5ub2RlVHlwZSE9PTkmJmUubm9kZVR5cGUhPT0xMSl9ZnVuY3Rpb24gb3UoZSl7cmV0dXJuISghZXx8ZS5ub2RlVHlwZSE9PTEmJmUubm9kZVR5cGUhPT05JiZlLm5vZGVUeXBlIT09MTEmJihlLm5vZGVUeXBlIT09OHx8ZS5ub2RlVmFsdWUhPT0iIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICIpKX1mdW5jdGlvbiB1aCgpe31mdW5jdGlvbiBhRShlLHQsbixyLG8pe2lmKG8pe2lmKHR5cGVvZiByPT0iZnVuY3Rpb24iKXt2YXIgaT1yO3I9ZnVuY3Rpb24oKXt2YXIgdT1YYShzKTtpLmNhbGwodSl9fXZhciBzPWEwKHQscixlLDAsbnVsbCwhMSwhMSwiIix1aCk7cmV0dXJuIGUuX3JlYWN0Um9vdENvbnRhaW5lcj1zLGVbWG5dPXMuY3VycmVudCxKaShlLm5vZGVUeXBlPT09OD9lLnBhcmVudE5vZGU6ZSksWXIoKSxzfWZvcig7bz1lLmxhc3RDaGlsZDspZS5yZW1vdmVDaGlsZChvKTtpZih0eXBlb2Ygcj09ImZ1bmN0aW9uIil7dmFyIGE9cjtyPWZ1bmN0aW9uKCl7dmFyIHU9WGEobCk7YS5jYWxsKHUpfX12YXIgbD1VZihlLDAsITEsbnVsbCxudWxsLCExLCExLCIiLHVoKTtyZXR1cm4gZS5fcmVhY3RSb290Q29udGFpbmVyPWwsZVtYbl09bC5jdXJyZW50LEppKGUubm9kZVR5cGU9PT04P2UucGFyZW50Tm9kZTplKSxZcihmdW5jdGlvbigpe251KHQsbCxuLHIpfSksbH1mdW5jdGlvbiBpdShlLHQsbixyLG8pe3ZhciBpPW4uX3JlYWN0Um9vdENvbnRhaW5lcjtpZihpKXt2YXIgcz1pO2lmKHR5cGVvZiBvPT0iZnVuY3Rpb24iKXt2YXIgYT1vO289ZnVuY3Rpb24oKXt2YXIgbD1YYShzKTthLmNhbGwobCl9fW51KHQscyxlLG8pfWVsc2Ugcz1hRShuLHQsZSxvLHIpO3JldHVybiBYYShzKX1MeT1mdW5jdGlvbihlKXtzd2l0Y2goZS50YWcpe2Nhc2UgMzp2YXIgdD1lLnN0YXRlTm9kZTtpZih0LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpe3ZhciBuPXhpKHQucGVuZGluZ0xhbmVzKTtuIT09MCYmKGRmKHQsbnwxKSxUdCh0LFVlKCkpLCEoZ2UmNikmJihEbz1VZSgpKzUwMCxScigpKSl9YnJlYWs7Y2FzZSAxMzpZcihmdW5jdGlvbigpe3ZhciByPXFuKGUsMSk7aWYociE9PW51bGwpe3ZhciBvPXl0KCk7dm4ocixlLDEsbyl9fSksSGYoZSwxKX19O2ZmPWZ1bmN0aW9uKGUpe2lmKGUudGFnPT09MTMpe3ZhciB0PXFuKGUsMTM0MjE3NzI4KTtpZih0IT09bnVsbCl7dmFyIG49eXQoKTt2bih0LGUsMTM0MjE3NzI4LG4pfUhmKGUsMTM0MjE3NzI4KX19O2p5PWZ1bmN0aW9uKGUpe2lmKGUudGFnPT09MTMpe3ZhciB0PXZyKGUpLG49cW4oZSx0KTtpZihuIT09bnVsbCl7dmFyIHI9eXQoKTt2bihuLGUsdCxyKX1IZihlLHQpfX07RHk9ZnVuY3Rpb24oKXtyZXR1cm4gQ2V9O0Z5PWZ1bmN0aW9uKGUsdCl7dmFyIG49Q2U7dHJ5e3JldHVybiBDZT1lLHQoKX1maW5hbGx5e0NlPW59fTtPYz1mdW5jdGlvbihlLHQsbil7c3dpdGNoKHQpe2Nhc2UiaW5wdXQiOmlmKGJjKGUsbiksdD1uLm5hbWUsbi50eXBlPT09InJhZGlvIiYmdCE9bnVsbCl7Zm9yKG49ZTtuLnBhcmVudE5vZGU7KW49bi5wYXJlbnROb2RlO2ZvcihuPW4ucXVlcnlTZWxlY3RvckFsbCgiaW5wdXRbbmFtZT0iK0pTT04uc3RyaW5naWZ5KCIiK3QpKyddW3R5cGU9InJhZGlvIl0nKSx0PTA7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07aWYociE9PWUmJnIuZm9ybT09PWUuZm9ybSl7dmFyIG89UWwocik7aWYoIW8pdGhyb3cgRXJyb3IoRig5MCkpO3l5KHIpLGJjKHIsbyl9fX1icmVhaztjYXNlInRleHRhcmVhIjp3eShlLG4pO2JyZWFrO2Nhc2Uic2VsZWN0Ijp0PW4udmFsdWUsdCE9bnVsbCYmRW8oZSwhIW4ubXVsdGlwbGUsdCwhMSl9fTtSeT1EZjtUeT1Zcjt2YXIgbEU9e3VzaW5nQ2xpZW50RW50cnlQb2ludDohMSxFdmVudHM6W2JzLGhvLFFsLGt5LEV5LERmXX0sZGk9e2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnpyLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOiIxOC4zLjEiLHJlbmRlcmVyUGFja2FnZU5hbWU6InJlYWN0LWRvbSJ9LHVFPXtidW5kbGVUeXBlOmRpLmJ1bmRsZVR5cGUsdmVyc2lvbjpkaS52ZXJzaW9uLHJlbmRlcmVyUGFja2FnZU5hbWU6ZGkucmVuZGVyZXJQYWNrYWdlTmFtZSxyZW5kZXJlckNvbmZpZzpkaS5yZW5kZXJlckNvbmZpZyxvdmVycmlkZUhvb2tTdGF0ZTpudWxsLG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDpudWxsLG92ZXJyaWRlUHJvcHM6bnVsbCxvdmVycmlkZVByb3BzRGVsZXRlUGF0aDpudWxsLG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOm51bGwsc2V0RXJyb3JIYW5kbGVyOm51bGwsc2V0U3VzcGVuc2VIYW5kbGVyOm51bGwsc2NoZWR1bGVVcGRhdGU6bnVsbCxjdXJyZW50RGlzcGF0Y2hlclJlZjpuci5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGUpe3JldHVybiBlPU95KGUpLGU9PT1udWxsP251bGw6ZS5zdGF0ZU5vZGV9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmRpLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlfHxzRSxmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6bnVsbCxzY2hlZHVsZVJlZnJlc2g6bnVsbCxzY2hlZHVsZVJvb3Q6bnVsbCxzZXRSZWZyZXNoSGFuZGxlcjpudWxsLGdldEN1cnJlbnRGaWJlcjpudWxsLHJlY29uY2lsZXJWZXJzaW9uOiIxOC4zLjEtbmV4dC1mMTMzOGY4MDgwLTIwMjQwNDI2In07aWYodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXzwidSIpe3ZhciBZcz1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIVlzLmlzRGlzYWJsZWQmJllzLnN1cHBvcnRzRmliZXIpdHJ5e1ZsPVlzLmluamVjdCh1RSksTm49WXN9Y2F0Y2h7fX1LdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRD1sRTtLdC5jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oZSx0KXt2YXIgbj0yPGFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06bnVsbDtpZighS2YodCkpdGhyb3cgRXJyb3IoRigyMDApKTtyZXR1cm4gaUUoZSx0LG51bGwsbil9O0t0LmNyZWF0ZVJvb3Q9ZnVuY3Rpb24oZSx0KXtpZighS2YoZSkpdGhyb3cgRXJyb3IoRigyOTkpKTt2YXIgbj0hMSxyPSIiLG89bDA7cmV0dXJuIHQhPW51bGwmJih0LnVuc3RhYmxlX3N0cmljdE1vZGU9PT0hMCYmKG49ITApLHQuaWRlbnRpZmllclByZWZpeCE9PXZvaWQgMCYmKHI9dC5pZGVudGlmaWVyUHJlZml4KSx0Lm9uUmVjb3ZlcmFibGVFcnJvciE9PXZvaWQgMCYmKG89dC5vblJlY292ZXJhYmxlRXJyb3IpKSx0PVVmKGUsMSwhMSxudWxsLG51bGwsbiwhMSxyLG8pLGVbWG5dPXQuY3VycmVudCxKaShlLm5vZGVUeXBlPT09OD9lLnBhcmVudE5vZGU6ZSksbmV3IFZmKHQpfTtLdC5maW5kRE9NTm9kZT1mdW5jdGlvbihlKXtpZihlPT1udWxsKXJldHVybiBudWxsO2lmKGUubm9kZVR5cGU9PT0xKXJldHVybiBlO3ZhciB0PWUuX3JlYWN0SW50ZXJuYWxzO2lmKHQ9PT12b2lkIDApdGhyb3cgdHlwZW9mIGUucmVuZGVyPT0iZnVuY3Rpb24iP0Vycm9yKEYoMTg4KSk6KGU9T2JqZWN0LmtleXMoZSkuam9pbigiLCIpLEVycm9yKEYoMjY4LGUpKSk7cmV0dXJuIGU9T3kodCksZT1lPT09bnVsbD9udWxsOmUuc3RhdGVOb2RlLGV9O0t0LmZsdXNoU3luYz1mdW5jdGlvbihlKXtyZXR1cm4gWXIoZSl9O0t0Lmh5ZHJhdGU9ZnVuY3Rpb24oZSx0LG4pe2lmKCFvdSh0KSl0aHJvdyBFcnJvcihGKDIwMCkpO3JldHVybiBpdShudWxsLGUsdCwhMCxuKX07S3QuaHlkcmF0ZVJvb3Q9ZnVuY3Rpb24oZSx0LG4pe2lmKCFLZihlKSl0aHJvdyBFcnJvcihGKDQwNSkpO3ZhciByPW4hPW51bGwmJm4uaHlkcmF0ZWRTb3VyY2VzfHxudWxsLG89ITEsaT0iIixzPWwwO2lmKG4hPW51bGwmJihuLnVuc3RhYmxlX3N0cmljdE1vZGU9PT0hMCYmKG89ITApLG4uaWRlbnRpZmllclByZWZpeCE9PXZvaWQgMCYmKGk9bi5pZGVudGlmaWVyUHJlZml4KSxuLm9uUmVjb3ZlcmFibGVFcnJvciE9PXZvaWQgMCYmKHM9bi5vblJlY292ZXJhYmxlRXJyb3IpKSx0PWEwKHQsbnVsbCxlLDEsbj8/bnVsbCxvLCExLGkscyksZVtYbl09dC5jdXJyZW50LEppKGUpLHIpZm9yKGU9MDtlPHIubGVuZ3RoO2UrKyluPXJbZV0sbz1uLl9nZXRWZXJzaW9uLG89byhuLl9zb3VyY2UpLHQubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT09bnVsbD90Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W24sb106dC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2gobixvKTtyZXR1cm4gbmV3IHJ1KHQpfTtLdC5yZW5kZXI9ZnVuY3Rpb24oZSx0LG4pe2lmKCFvdSh0KSl0aHJvdyBFcnJvcihGKDIwMCkpO3JldHVybiBpdShudWxsLGUsdCwhMSxuKX07S3QudW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihlKXtpZighb3UoZSkpdGhyb3cgRXJyb3IoRig0MCkpO3JldHVybiBlLl9yZWFjdFJvb3RDb250YWluZXI/KFlyKGZ1bmN0aW9uKCl7aXUobnVsbCxudWxsLGUsITEsZnVuY3Rpb24oKXtlLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbCxlW1huXT1udWxsfSl9KSwhMCk6ITF9O0t0LnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPURmO0t0LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKCFvdShuKSl0aHJvdyBFcnJvcihGKDIwMCkpO2lmKGU9PW51bGx8fGUuX3JlYWN0SW50ZXJuYWxzPT09dm9pZCAwKXRocm93IEVycm9yKEYoMzgpKTtyZXR1cm4gaXUoZSx0LG4sITEscil9O0t0LnZlcnNpb249IjE4LjMuMS1uZXh0LWYxMzM4ZjgwODAtMjAyNDA0MjYiO2Z1bmN0aW9uIHUwKCl7aWYoISh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fPiJ1Inx8dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSE9ImZ1bmN0aW9uIikpdHJ5e19fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSh1MCl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKX19dTAoKSx1eS5leHBvcnRzPUt0O3ZhciBZZj11eS5leHBvcnRzO2NvbnN0IEdzPVJkKFlmKSxjaD17ZGlzYWJsZWQ6ITF9LHFhPUl0LmNyZWF0ZUNvbnRleHQobnVsbCk7dmFyIGMwPWZ1bmN0aW9uKHQpe3JldHVybiB0LnNjcm9sbFRvcH0sYmk9InVubW91bnRlZCIsX3I9ImV4aXRlZCIsTnI9ImVudGVyaW5nIixhbz0iZW50ZXJlZCIsdWQ9ImV4aXRpbmciLGxuPWZ1bmN0aW9uKGUpe3RmKHQsZSk7ZnVuY3Rpb24gdChyLG8pe3ZhciBpO2k9ZS5jYWxsKHRoaXMscixvKXx8dGhpczt2YXIgcz1vLGE9cyYmIXMuaXNNb3VudGluZz9yLmVudGVyOnIuYXBwZWFyLGw7cmV0dXJuIGkuYXBwZWFyU3RhdHVzPW51bGwsci5pbj9hPyhsPV9yLGkuYXBwZWFyU3RhdHVzPU5yKTpsPWFvOnIudW5tb3VudE9uRXhpdHx8ci5tb3VudE9uRW50ZXI/bD1iaTpsPV9yLGkuc3RhdGU9e3N0YXR1czpsfSxpLm5leHRDYWxsYmFjaz1udWxsLGl9dC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9ZnVuY3Rpb24obyxpKXt2YXIgcz1vLmluO3JldHVybiBzJiZpLnN0YXR1cz09PWJpP3tzdGF0dXM6X3J9Om51bGx9O3ZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVTdGF0dXMoITAsdGhpcy5hcHBlYXJTdGF0dXMpfSxuLmNvbXBvbmVudERpZFVwZGF0ZT1mdW5jdGlvbihvKXt2YXIgaT1udWxsO2lmKG8hPT10aGlzLnByb3BzKXt2YXIgcz10aGlzLnN0YXRlLnN0YXR1czt0aGlzLnByb3BzLmluP3MhPT1OciYmcyE9PWFvJiYoaT1Ocik6KHM9PT1Ocnx8cz09PWFvKSYmKGk9dWQpfXRoaXMudXBkYXRlU3RhdHVzKCExLGkpfSxuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKX0sbi5nZXRUaW1lb3V0cz1mdW5jdGlvbigpe3ZhciBvPXRoaXMucHJvcHMudGltZW91dCxpLHMsYTtyZXR1cm4gaT1zPWE9byxvIT1udWxsJiZ0eXBlb2YgbyE9Im51bWJlciImJihpPW8uZXhpdCxzPW8uZW50ZXIsYT1vLmFwcGVhciE9PXZvaWQgMD9vLmFwcGVhcjpzKSx7ZXhpdDppLGVudGVyOnMsYXBwZWFyOmF9fSxuLnVwZGF0ZVN0YXR1cz1mdW5jdGlvbihvLGkpe2lmKG89PT12b2lkIDAmJihvPSExKSxpIT09bnVsbClpZih0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpLGk9PT1Ocil7aWYodGhpcy5wcm9wcy51bm1vdW50T25FeGl0fHx0aGlzLnByb3BzLm1vdW50T25FbnRlcil7dmFyIHM9dGhpcy5wcm9wcy5ub2RlUmVmP3RoaXMucHJvcHMubm9kZVJlZi5jdXJyZW50OkdzLmZpbmRET01Ob2RlKHRoaXMpO3MmJmMwKHMpfXRoaXMucGVyZm9ybUVudGVyKG8pfWVsc2UgdGhpcy5wZXJmb3JtRXhpdCgpO2Vsc2UgdGhpcy5wcm9wcy51bm1vdW50T25FeGl0JiZ0aGlzLnN0YXRlLnN0YXR1cz09PV9yJiZ0aGlzLnNldFN0YXRlKHtzdGF0dXM6Yml9KX0sbi5wZXJmb3JtRW50ZXI9ZnVuY3Rpb24obyl7dmFyIGk9dGhpcyxzPXRoaXMucHJvcHMuZW50ZXIsYT10aGlzLmNvbnRleHQ/dGhpcy5jb250ZXh0LmlzTW91bnRpbmc6byxsPXRoaXMucHJvcHMubm9kZVJlZj9bYV06W0dzLmZpbmRET01Ob2RlKHRoaXMpLGFdLHU9bFswXSxjPWxbMV0sZD10aGlzLmdldFRpbWVvdXRzKCksbT1hP2QuYXBwZWFyOmQuZW50ZXI7aWYoIW8mJiFzfHxjaC5kaXNhYmxlZCl7dGhpcy5zYWZlU2V0U3RhdGUoe3N0YXR1czphb30sZnVuY3Rpb24oKXtpLnByb3BzLm9uRW50ZXJlZCh1KX0pO3JldHVybn10aGlzLnByb3BzLm9uRW50ZXIodSxjKSx0aGlzLnNhZmVTZXRTdGF0ZSh7c3RhdHVzOk5yfSxmdW5jdGlvbigpe2kucHJvcHMub25FbnRlcmluZyh1LGMpLGkub25UcmFuc2l0aW9uRW5kKG0sZnVuY3Rpb24oKXtpLnNhZmVTZXRTdGF0ZSh7c3RhdHVzOmFvfSxmdW5jdGlvbigpe2kucHJvcHMub25FbnRlcmVkKHUsYyl9KX0pfSl9LG4ucGVyZm9ybUV4aXQ9ZnVuY3Rpb24oKXt2YXIgbz10aGlzLGk9dGhpcy5wcm9wcy5leGl0LHM9dGhpcy5nZXRUaW1lb3V0cygpLGE9dGhpcy5wcm9wcy5ub2RlUmVmP3ZvaWQgMDpHcy5maW5kRE9NTm9kZSh0aGlzKTtpZighaXx8Y2guZGlzYWJsZWQpe3RoaXMuc2FmZVNldFN0YXRlKHtzdGF0dXM6X3J9LGZ1bmN0aW9uKCl7by5wcm9wcy5vbkV4aXRlZChhKX0pO3JldHVybn10aGlzLnByb3BzLm9uRXhpdChhKSx0aGlzLnNhZmVTZXRTdGF0ZSh7c3RhdHVzOnVkfSxmdW5jdGlvbigpe28ucHJvcHMub25FeGl0aW5nKGEpLG8ub25UcmFuc2l0aW9uRW5kKHMuZXhpdCxmdW5jdGlvbigpe28uc2FmZVNldFN0YXRlKHtzdGF0dXM6X3J9LGZ1bmN0aW9uKCl7by5wcm9wcy5vbkV4aXRlZChhKX0pfSl9KX0sbi5jYW5jZWxOZXh0Q2FsbGJhY2s9ZnVuY3Rpb24oKXt0aGlzLm5leHRDYWxsYmFjayE9PW51bGwmJih0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwoKSx0aGlzLm5leHRDYWxsYmFjaz1udWxsKX0sbi5zYWZlU2V0U3RhdGU9ZnVuY3Rpb24obyxpKXtpPXRoaXMuc2V0TmV4dENhbGxiYWNrKGkpLHRoaXMuc2V0U3RhdGUobyxpKX0sbi5zZXROZXh0Q2FsbGJhY2s9ZnVuY3Rpb24obyl7dmFyIGk9dGhpcyxzPSEwO3JldHVybiB0aGlzLm5leHRDYWxsYmFjaz1mdW5jdGlvbihhKXtzJiYocz0hMSxpLm5leHRDYWxsYmFjaz1udWxsLG8oYSkpfSx0aGlzLm5leHRDYWxsYmFjay5jYW5jZWw9ZnVuY3Rpb24oKXtzPSExfSx0aGlzLm5leHRDYWxsYmFja30sbi5vblRyYW5zaXRpb25FbmQ9ZnVuY3Rpb24obyxpKXt0aGlzLnNldE5leHRDYWxsYmFjayhpKTt2YXIgcz10aGlzLnByb3BzLm5vZGVSZWY/dGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQ6R3MuZmluZERPTU5vZGUodGhpcyksYT1vPT1udWxsJiYhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtpZighc3x8YSl7c2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywwKTtyZXR1cm59aWYodGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcil7dmFyIGw9dGhpcy5wcm9wcy5ub2RlUmVmP1t0aGlzLm5leHRDYWxsYmFja106W3MsdGhpcy5uZXh0Q2FsbGJhY2tdLHU9bFswXSxjPWxbMV07dGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcih1LGMpfW8hPW51bGwmJnNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssbyl9LG4ucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIG89dGhpcy5zdGF0ZS5zdGF0dXM7aWYobz09PWJpKXJldHVybiBudWxsO3ZhciBpPXRoaXMucHJvcHMscz1pLmNoaWxkcmVuO2kuaW4saS5tb3VudE9uRW50ZXIsaS51bm1vdW50T25FeGl0LGkuYXBwZWFyLGkuZW50ZXIsaS5leGl0LGkudGltZW91dCxpLmFkZEVuZExpc3RlbmVyLGkub25FbnRlcixpLm9uRW50ZXJpbmcsaS5vbkVudGVyZWQsaS5vbkV4aXQsaS5vbkV4aXRpbmcsaS5vbkV4aXRlZCxpLm5vZGVSZWY7dmFyIGE9ZWYoaSxbImNoaWxkcmVuIiwiaW4iLCJtb3VudE9uRW50ZXIiLCJ1bm1vdW50T25FeGl0IiwiYXBwZWFyIiwiZW50ZXIiLCJleGl0IiwidGltZW91dCIsImFkZEVuZExpc3RlbmVyIiwib25FbnRlciIsIm9uRW50ZXJpbmciLCJvbkVudGVyZWQiLCJvbkV4aXQiLCJvbkV4aXRpbmciLCJvbkV4aXRlZCIsIm5vZGVSZWYiXSk7cmV0dXJuIEl0LmNyZWF0ZUVsZW1lbnQocWEuUHJvdmlkZXIse3ZhbHVlOm51bGx9LHR5cGVvZiBzPT0iZnVuY3Rpb24iP3MobyxhKTpJdC5jbG9uZUVsZW1lbnQoSXQuQ2hpbGRyZW4ub25seShzKSxhKSl9LHR9KEl0LkNvbXBvbmVudCk7bG4uY29udGV4dFR5cGU9cWE7bG4ucHJvcFR5cGVzPXt9O2Z1bmN0aW9uIGlvKCl7fWxuLmRlZmF1bHRQcm9wcz17aW46ITEsbW91bnRPbkVudGVyOiExLHVubW91bnRPbkV4aXQ6ITEsYXBwZWFyOiExLGVudGVyOiEwLGV4aXQ6ITAsb25FbnRlcjppbyxvbkVudGVyaW5nOmlvLG9uRW50ZXJlZDppbyxvbkV4aXQ6aW8sb25FeGl0aW5nOmlvLG9uRXhpdGVkOmlvfTtsbi5VTk1PVU5URUQ9Ymk7bG4uRVhJVEVEPV9yO2xuLkVOVEVSSU5HPU5yO2xuLkVOVEVSRUQ9YW87bG4uRVhJVElORz11ZDt2YXIgY0U9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdCYmbiYmbi5zcGxpdCgiICIpLmZvckVhY2goZnVuY3Rpb24ocil7cmV0dXJuIG9iKHQscil9KX0sWHU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdCYmbiYmbi5zcGxpdCgiICIpLmZvckVhY2goZnVuY3Rpb24ocil7cmV0dXJuIGliKHQscil9KX0sR2Y9ZnVuY3Rpb24oZSl7dGYodCxlKTtmdW5jdGlvbiB0KCl7Zm9yKHZhciByLG89YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShvKSxzPTA7czxvO3MrKylpW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gcj1lLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KGkpKXx8dGhpcyxyLmFwcGxpZWRDbGFzc2VzPXthcHBlYXI6e30sZW50ZXI6e30sZXhpdDp7fX0sci5vbkVudGVyPWZ1bmN0aW9uKGEsbCl7dmFyIHU9ci5yZXNvbHZlQXJndW1lbnRzKGEsbCksYz11WzBdLGQ9dVsxXTtyLnJlbW92ZUNsYXNzZXMoYywiZXhpdCIpLHIuYWRkQ2xhc3MoYyxkPyJhcHBlYXIiOiJlbnRlciIsImJhc2UiKSxyLnByb3BzLm9uRW50ZXImJnIucHJvcHMub25FbnRlcihhLGwpfSxyLm9uRW50ZXJpbmc9ZnVuY3Rpb24oYSxsKXt2YXIgdT1yLnJlc29sdmVBcmd1bWVudHMoYSxsKSxjPXVbMF0sZD11WzFdLG09ZD8iYXBwZWFyIjoiZW50ZXIiO3IuYWRkQ2xhc3MoYyxtLCJhY3RpdmUiKSxyLnByb3BzLm9uRW50ZXJpbmcmJnIucHJvcHMub25FbnRlcmluZyhhLGwpfSxyLm9uRW50ZXJlZD1mdW5jdGlvbihhLGwpe3ZhciB1PXIucmVzb2x2ZUFyZ3VtZW50cyhhLGwpLGM9dVswXSxkPXVbMV0sbT1kPyJhcHBlYXIiOiJlbnRlciI7ci5yZW1vdmVDbGFzc2VzKGMsbSksci5hZGRDbGFzcyhjLG0sImRvbmUiKSxyLnByb3BzLm9uRW50ZXJlZCYmci5wcm9wcy5vbkVudGVyZWQoYSxsKX0sci5vbkV4aXQ9ZnVuY3Rpb24oYSl7dmFyIGw9ci5yZXNvbHZlQXJndW1lbnRzKGEpLHU9bFswXTtyLnJlbW92ZUNsYXNzZXModSwiYXBwZWFyIiksci5yZW1vdmVDbGFzc2VzKHUsImVudGVyIiksci5hZGRDbGFzcyh1LCJleGl0IiwiYmFzZSIpLHIucHJvcHMub25FeGl0JiZyLnByb3BzLm9uRXhpdChhKX0sci5vbkV4aXRpbmc9ZnVuY3Rpb24oYSl7dmFyIGw9ci5yZXNvbHZlQXJndW1lbnRzKGEpLHU9bFswXTtyLmFkZENsYXNzKHUsImV4aXQiLCJhY3RpdmUiKSxyLnByb3BzLm9uRXhpdGluZyYmci5wcm9wcy5vbkV4aXRpbmcoYSl9LHIub25FeGl0ZWQ9ZnVuY3Rpb24oYSl7dmFyIGw9ci5yZXNvbHZlQXJndW1lbnRzKGEpLHU9bFswXTtyLnJlbW92ZUNsYXNzZXModSwiZXhpdCIpLHIuYWRkQ2xhc3ModSwiZXhpdCIsImRvbmUiKSxyLnByb3BzLm9uRXhpdGVkJiZyLnByb3BzLm9uRXhpdGVkKGEpfSxyLnJlc29sdmVBcmd1bWVudHM9ZnVuY3Rpb24oYSxsKXtyZXR1cm4gci5wcm9wcy5ub2RlUmVmP1tyLnByb3BzLm5vZGVSZWYuY3VycmVudCxhXTpbYSxsXX0sci5nZXRDbGFzc05hbWVzPWZ1bmN0aW9uKGEpe3ZhciBsPXIucHJvcHMuY2xhc3NOYW1lcyx1PXR5cGVvZiBsPT0ic3RyaW5nIixjPXUmJmw/bCsiLSI6IiIsZD11PyIiK2MrYTpsW2FdLG09dT9kKyItYWN0aXZlIjpsW2ErIkFjdGl2ZSJdLHY9dT9kKyItZG9uZSI6bFthKyJEb25lIl07cmV0dXJue2Jhc2VDbGFzc05hbWU6ZCxhY3RpdmVDbGFzc05hbWU6bSxkb25lQ2xhc3NOYW1lOnZ9fSxyfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLmFkZENsYXNzPWZ1bmN0aW9uKG8saSxzKXt2YXIgYT10aGlzLmdldENsYXNzTmFtZXMoaSlbcysiQ2xhc3NOYW1lIl0sbD10aGlzLmdldENsYXNzTmFtZXMoImVudGVyIiksdT1sLmRvbmVDbGFzc05hbWU7aT09PSJhcHBlYXIiJiZzPT09ImRvbmUiJiZ1JiYoYSs9IiAiK3UpLHM9PT0iYWN0aXZlIiYmbyYmYzAobyksYSYmKHRoaXMuYXBwbGllZENsYXNzZXNbaV1bc109YSxjRShvLGEpKX0sbi5yZW1vdmVDbGFzc2VzPWZ1bmN0aW9uKG8saSl7dmFyIHM9dGhpcy5hcHBsaWVkQ2xhc3Nlc1tpXSxhPXMuYmFzZSxsPXMuYWN0aXZlLHU9cy5kb25lO3RoaXMuYXBwbGllZENsYXNzZXNbaV09e30sYSYmWHUobyxhKSxsJiZYdShvLGwpLHUmJlh1KG8sdSl9LG4ucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIG89dGhpcy5wcm9wcztvLmNsYXNzTmFtZXM7dmFyIGk9ZWYobyxbImNsYXNzTmFtZXMiXSk7cmV0dXJuIEl0LmNyZWF0ZUVsZW1lbnQobG4sQmkoe30saSx7b25FbnRlcjp0aGlzLm9uRW50ZXIsb25FbnRlcmVkOnRoaXMub25FbnRlcmVkLG9uRW50ZXJpbmc6dGhpcy5vbkVudGVyaW5nLG9uRXhpdDp0aGlzLm9uRXhpdCxvbkV4aXRpbmc6dGhpcy5vbkV4aXRpbmcsb25FeGl0ZWQ6dGhpcy5vbkV4aXRlZH0pKX0sdH0oSXQuQ29tcG9uZW50KTtHZi5kZWZhdWx0UHJvcHM9e2NsYXNzTmFtZXM6IiJ9O0dmLnByb3BUeXBlcz17fTtmdW5jdGlvbiBkRShlKXtpZihlPT09dm9pZCAwKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7cmV0dXJuIGV9ZnVuY3Rpb24gUWYoZSx0KXt2YXIgbj1mdW5jdGlvbihpKXtyZXR1cm4gdCYmQy5pc1ZhbGlkRWxlbWVudChpKT90KGkpOml9LHI9T2JqZWN0LmNyZWF0ZShudWxsKTtyZXR1cm4gZSYmQy5DaGlsZHJlbi5tYXAoZSxmdW5jdGlvbihvKXtyZXR1cm4gb30pLmZvckVhY2goZnVuY3Rpb24obyl7cltvLmtleV09bihvKX0pLHJ9ZnVuY3Rpb24gZkUoZSx0KXtlPWV8fHt9LHQ9dHx8e307ZnVuY3Rpb24gbihjKXtyZXR1cm4gYyBpbiB0P3RbY106ZVtjXX12YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpLG89W107Zm9yKHZhciBpIGluIGUpaSBpbiB0P28ubGVuZ3RoJiYocltpXT1vLG89W10pOm8ucHVzaChpKTt2YXIgcyxhPXt9O2Zvcih2YXIgbCBpbiB0KXtpZihyW2xdKWZvcihzPTA7czxyW2xdLmxlbmd0aDtzKyspe3ZhciB1PXJbbF1bc107YVtyW2xdW3NdXT1uKHUpfWFbbF09bihsKX1mb3Iocz0wO3M8by5sZW5ndGg7cysrKWFbb1tzXV09bihvW3NdKTtyZXR1cm4gYX1mdW5jdGlvbiBEcihlLHQsbil7cmV0dXJuIG5bdF0hPW51bGw/blt0XTplLnByb3BzW3RdfWZ1bmN0aW9uIHBFKGUsdCl7cmV0dXJuIFFmKGUuY2hpbGRyZW4sZnVuY3Rpb24obil7cmV0dXJuIEMuY2xvbmVFbGVtZW50KG4se29uRXhpdGVkOnQuYmluZChudWxsLG4pLGluOiEwLGFwcGVhcjpEcihuLCJhcHBlYXIiLGUpLGVudGVyOkRyKG4sImVudGVyIixlKSxleGl0OkRyKG4sImV4aXQiLGUpfSl9KX1mdW5jdGlvbiBtRShlLHQsbil7dmFyIHI9UWYoZS5jaGlsZHJlbiksbz1mRSh0LHIpO3JldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGkpe3ZhciBzPW9baV07aWYoQy5pc1ZhbGlkRWxlbWVudChzKSl7dmFyIGE9aSBpbiB0LGw9aSBpbiByLHU9dFtpXSxjPUMuaXNWYWxpZEVsZW1lbnQodSkmJiF1LnByb3BzLmluO2wmJighYXx8Yyk/b1tpXT1DLmNsb25lRWxlbWVudChzLHtvbkV4aXRlZDpuLmJpbmQobnVsbCxzKSxpbjohMCxleGl0OkRyKHMsImV4aXQiLGUpLGVudGVyOkRyKHMsImVudGVyIixlKX0pOiFsJiZhJiYhYz9vW2ldPUMuY2xvbmVFbGVtZW50KHMse2luOiExfSk6bCYmYSYmQy5pc1ZhbGlkRWxlbWVudCh1KSYmKG9baV09Qy5jbG9uZUVsZW1lbnQocyx7b25FeGl0ZWQ6bi5iaW5kKG51bGwscyksaW46dS5wcm9wcy5pbixleGl0OkRyKHMsImV4aXQiLGUpLGVudGVyOkRyKHMsImVudGVyIixlKX0pKX19KSxvfXZhciBoRT1PYmplY3QudmFsdWVzfHxmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSl9LGdFPXtjb21wb25lbnQ6ImRpdiIsY2hpbGRGYWN0b3J5OmZ1bmN0aW9uKHQpe3JldHVybiB0fX0sc3U9ZnVuY3Rpb24oZSl7dGYodCxlKTtmdW5jdGlvbiB0KHIsbyl7dmFyIGk7aT1lLmNhbGwodGhpcyxyLG8pfHx0aGlzO3ZhciBzPWkuaGFuZGxlRXhpdGVkLmJpbmQoZEUoaSkpO3JldHVybiBpLnN0YXRlPXtjb250ZXh0VmFsdWU6e2lzTW91bnRpbmc6ITB9LGhhbmRsZUV4aXRlZDpzLGZpcnN0UmVuZGVyOiEwfSxpfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dGhpcy5tb3VudGVkPSEwLHRoaXMuc2V0U3RhdGUoe2NvbnRleHRWYWx1ZTp7aXNNb3VudGluZzohMX19KX0sbi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3RoaXMubW91bnRlZD0hMX0sdC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM9ZnVuY3Rpb24obyxpKXt2YXIgcz1pLmNoaWxkcmVuLGE9aS5oYW5kbGVFeGl0ZWQsbD1pLmZpcnN0UmVuZGVyO3JldHVybntjaGlsZHJlbjpsP3BFKG8sYSk6bUUobyxzLGEpLGZpcnN0UmVuZGVyOiExfX0sbi5oYW5kbGVFeGl0ZWQ9ZnVuY3Rpb24obyxpKXt2YXIgcz1RZih0aGlzLnByb3BzLmNoaWxkcmVuKTtvLmtleSBpbiBzfHwoby5wcm9wcy5vbkV4aXRlZCYmby5wcm9wcy5vbkV4aXRlZChpKSx0aGlzLm1vdW50ZWQmJnRoaXMuc2V0U3RhdGUoZnVuY3Rpb24oYSl7dmFyIGw9Qmkoe30sYS5jaGlsZHJlbik7cmV0dXJuIGRlbGV0ZSBsW28ua2V5XSx7Y2hpbGRyZW46bH19KSl9LG4ucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIG89dGhpcy5wcm9wcyxpPW8uY29tcG9uZW50LHM9by5jaGlsZEZhY3RvcnksYT1lZihvLFsiY29tcG9uZW50IiwiY2hpbGRGYWN0b3J5Il0pLGw9dGhpcy5zdGF0ZS5jb250ZXh0VmFsdWUsdT1oRSh0aGlzLnN0YXRlLmNoaWxkcmVuKS5tYXAocyk7cmV0dXJuIGRlbGV0ZSBhLmFwcGVhcixkZWxldGUgYS5lbnRlcixkZWxldGUgYS5leGl0LGk9PT1udWxsP0l0LmNyZWF0ZUVsZW1lbnQocWEuUHJvdmlkZXIse3ZhbHVlOmx9LHUpOkl0LmNyZWF0ZUVsZW1lbnQocWEuUHJvdmlkZXIse3ZhbHVlOmx9LEl0LmNyZWF0ZUVsZW1lbnQoaSxhLHUpKX0sdH0oSXQuQ29tcG9uZW50KTtzdS5wcm9wVHlwZXM9e307c3UuZGVmYXVsdFByb3BzPWdFO2NvbnN0IGQwPWU9PmUuc2Nyb2xsVG9wO2Z1bmN0aW9uIEZvKGUsdCl7Y29uc3R7dGltZW91dDpuLGVhc2luZzpyLHN0eWxlOm89e319PWU7cmV0dXJue2R1cmF0aW9uOm8udHJhbnNpdGlvbkR1cmF0aW9uPz8odHlwZW9mIG49PSJudW1iZXIiP246blt0Lm1vZGVdfHwwKSxlYXNpbmc6by50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24/Pyh0eXBlb2Ygcj09Im9iamVjdCI/clt0Lm1vZGVdOnIpLGRlbGF5Om8udHJhbnNpdGlvbkRlbGF5fX1mdW5jdGlvbiB5RShlKXtyZXR1cm4gY2UoIk11aUNvbGxhcHNlIixlKX1kZSgiTXVpQ29sbGFwc2UiLFsicm9vdCIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsImVudGVyZWQiLCJoaWRkZW4iLCJ3cmFwcGVyIiwid3JhcHBlcklubmVyIl0pO2NvbnN0IHZFPWU9Pntjb25zdHtvcmllbnRhdGlvbjp0LGNsYXNzZXM6bn09ZSxyPXtyb290Olsicm9vdCIsYCR7dH1gXSxlbnRlcmVkOlsiZW50ZXJlZCJdLGhpZGRlbjpbImhpZGRlbiJdLHdyYXBwZXI6WyJ3cmFwcGVyIixgJHt0fWBdLHdyYXBwZXJJbm5lcjpbIndyYXBwZXJJbm5lciIsYCR7dH1gXX07cmV0dXJuIHBlKHIseUUsbil9LHdFPUcoImRpdiIse25hbWU6Ik11aUNvbGxhcHNlIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5yb290LHRbbi5vcmllbnRhdGlvbl0sbi5zdGF0ZT09PSJlbnRlcmVkIiYmdC5lbnRlcmVkLG4uc3RhdGU9PT0iZXhpdGVkIiYmIW4uaW4mJm4uY29sbGFwc2VkU2l6ZT09PSIwcHgiJiZ0LmhpZGRlbl19fSkoeWUoKHt0aGVtZTplfSk9Pih7aGVpZ2h0OjAsb3ZlcmZsb3c6ImhpZGRlbiIsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgiaGVpZ2h0IiksdmFyaWFudHM6W3twcm9wczp7b3JpZW50YXRpb246Imhvcml6b250YWwifSxzdHlsZTp7aGVpZ2h0OiJhdXRvIix3aWR0aDowLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoIndpZHRoIil9fSx7cHJvcHM6e3N0YXRlOiJlbnRlcmVkIn0sc3R5bGU6e2hlaWdodDoiYXV0byIsb3ZlcmZsb3c6InZpc2libGUifX0se3Byb3BzOntzdGF0ZToiZW50ZXJlZCIsb3JpZW50YXRpb246Imhvcml6b250YWwifSxzdHlsZTp7d2lkdGg6ImF1dG8ifX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuc3RhdGU9PT0iZXhpdGVkIiYmIXQuaW4mJnQuY29sbGFwc2VkU2l6ZT09PSIwcHgiLHN0eWxlOnt2aXNpYmlsaXR5OiJoaWRkZW4ifX1dfSkpKSxTRT1HKCJkaXYiLHtuYW1lOiJNdWlDb2xsYXBzZSIsc2xvdDoiV3JhcHBlciIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQud3JhcHBlcn0pKHtkaXNwbGF5OiJmbGV4Iix3aWR0aDoiMTAwJSIsdmFyaWFudHM6W3twcm9wczp7b3JpZW50YXRpb246Imhvcml6b250YWwifSxzdHlsZTp7d2lkdGg6ImF1dG8iLGhlaWdodDoiMTAwJSJ9fV19KSx4RT1HKCJkaXYiLHtuYW1lOiJNdWlDb2xsYXBzZSIsc2xvdDoiV3JhcHBlcklubmVyIixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+dC53cmFwcGVySW5uZXJ9KSh7d2lkdGg6IjEwMCUiLHZhcmlhbnRzOlt7cHJvcHM6e29yaWVudGF0aW9uOiJob3Jpem9udGFsIn0sc3R5bGU6e3dpZHRoOiJhdXRvIixoZWlnaHQ6IjEwMCUifX1dfSksY2Q9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlDb2xsYXBzZSJ9KSx7YWRkRW5kTGlzdGVuZXI6byxjaGlsZHJlbjppLGNsYXNzTmFtZTpzLGNvbGxhcHNlZFNpemU6YT0iMHB4Iixjb21wb25lbnQ6bCxlYXNpbmc6dSxpbjpjLG9uRW50ZXI6ZCxvbkVudGVyZWQ6bSxvbkVudGVyaW5nOnYsb25FeGl0Oncsb25FeGl0ZWQ6UyxvbkV4aXRpbmc6eCxvcmllbnRhdGlvbjpoPSJ2ZXJ0aWNhbCIsc3R5bGU6Zyx0aW1lb3V0OmY9b3kuc3RhbmRhcmQsVHJhbnNpdGlvbkNvbXBvbmVudDp5PWxuLC4uLmJ9PXIsRT17Li4ucixvcmllbnRhdGlvbjpoLGNvbGxhcHNlZFNpemU6YX0sUj12RShFKSxQPVNzKCksST1BcigpLHA9Qy51c2VSZWYobnVsbCksJD1DLnVzZVJlZigpLEw9dHlwZW9mIGE9PSJudW1iZXIiP2Ake2F9cHhgOmEsaj1oPT09Imhvcml6b250YWwiLE49aj8id2lkdGgiOiJoZWlnaHQiLE89Qy51c2VSZWYobnVsbCksTT1RZShuLE8pLF89Vz0+Sj0+e2lmKFcpe2NvbnN0IG9lPU8uY3VycmVudDtKPT09dm9pZCAwP1cob2UpOlcob2UsSil9fSxUPSgpPT5wLmN1cnJlbnQ/cC5jdXJyZW50W2o/ImNsaWVudFdpZHRoIjoiY2xpZW50SGVpZ2h0Il06MCxBPV8oKFcsSik9PntwLmN1cnJlbnQmJmomJihwLmN1cnJlbnQuc3R5bGUucG9zaXRpb249ImFic29sdXRlIiksVy5zdHlsZVtOXT1MLGQmJmQoVyxKKX0pLEQ9XygoVyxKKT0+e2NvbnN0IG9lPVQoKTtwLmN1cnJlbnQmJmomJihwLmN1cnJlbnQuc3R5bGUucG9zaXRpb249IiIpO2NvbnN0e2R1cmF0aW9uOnJlLGVhc2luZzpRfT1Gbyh7c3R5bGU6Zyx0aW1lb3V0OmYsZWFzaW5nOnV9LHttb2RlOiJlbnRlciJ9KTtpZihmPT09ImF1dG8iKXtjb25zdCBlZT1QLnRyYW5zaXRpb25zLmdldEF1dG9IZWlnaHREdXJhdGlvbihvZSk7Vy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb249YCR7ZWV9bXNgLCQuY3VycmVudD1lZX1lbHNlIFcuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPXR5cGVvZiByZT09InN0cmluZyI/cmU6YCR7cmV9bXNgO1cuc3R5bGVbTl09YCR7b2V9cHhgLFcuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uPVEsdiYmdihXLEopfSksQj1fKChXLEopPT57Vy5zdHlsZVtOXT0iYXV0byIsbSYmbShXLEopfSksSD1fKFc9PntXLnN0eWxlW05dPWAke1QoKX1weGAsdyYmdyhXKX0pLFY9XyhTKSxVPV8oVz0+e2NvbnN0IEo9VCgpLHtkdXJhdGlvbjpvZSxlYXNpbmc6cmV9PUZvKHtzdHlsZTpnLHRpbWVvdXQ6ZixlYXNpbmc6dX0se21vZGU6ImV4aXQifSk7aWYoZj09PSJhdXRvIil7Y29uc3QgUT1QLnRyYW5zaXRpb25zLmdldEF1dG9IZWlnaHREdXJhdGlvbihKKTtXLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj1gJHtRfW1zYCwkLmN1cnJlbnQ9UX1lbHNlIFcuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPXR5cGVvZiBvZT09InN0cmluZyI/b2U6YCR7b2V9bXNgO1cuc3R5bGVbTl09TCxXLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbj1yZSx4JiZ4KFcpfSksWD1XPT57Zj09PSJhdXRvIiYmSS5zdGFydCgkLmN1cnJlbnR8fDAsVyksbyYmbyhPLmN1cnJlbnQsVyl9O3JldHVybiBrLmpzeCh5LHtpbjpjLG9uRW50ZXI6QSxvbkVudGVyZWQ6QixvbkVudGVyaW5nOkQsb25FeGl0Okgsb25FeGl0ZWQ6VixvbkV4aXRpbmc6VSxhZGRFbmRMaXN0ZW5lcjpYLG5vZGVSZWY6Tyx0aW1lb3V0OmY9PT0iYXV0byI/bnVsbDpmLC4uLmIsY2hpbGRyZW46KFcsSik9PmsuanN4KHdFLHthczpsLGNsYXNzTmFtZTp0ZShSLnJvb3Qscyx7ZW50ZXJlZDpSLmVudGVyZWQsZXhpdGVkOiFjJiZMPT09IjBweCImJlIuaGlkZGVufVtXXSksc3R5bGU6e1tqPyJtaW5XaWR0aCI6Im1pbkhlaWdodCJdOkwsLi4uZ30scmVmOk0sLi4uSixvd25lclN0YXRlOnsuLi5FLHN0YXRlOld9LGNoaWxkcmVuOmsuanN4KFNFLHtvd25lclN0YXRlOnsuLi5FLHN0YXRlOld9LGNsYXNzTmFtZTpSLndyYXBwZXIscmVmOnAsY2hpbGRyZW46ay5qc3goeEUse293bmVyU3RhdGU6ey4uLkUsc3RhdGU6V30sY2xhc3NOYW1lOlIud3JhcHBlcklubmVyLGNoaWxkcmVuOml9KX0pfSl9KX0pO2NkJiYoY2QubXVpU3VwcG9ydEF1dG89ITApO2Z1bmN0aW9uIENFKGUpe3JldHVybiBjZSgiTXVpUGFwZXIiLGUpfWRlKCJNdWlQYXBlciIsWyJyb290Iiwicm91bmRlZCIsIm91dGxpbmVkIiwiZWxldmF0aW9uIiwiZWxldmF0aW9uMCIsImVsZXZhdGlvbjEiLCJlbGV2YXRpb24yIiwiZWxldmF0aW9uMyIsImVsZXZhdGlvbjQiLCJlbGV2YXRpb241IiwiZWxldmF0aW9uNiIsImVsZXZhdGlvbjciLCJlbGV2YXRpb244IiwiZWxldmF0aW9uOSIsImVsZXZhdGlvbjEwIiwiZWxldmF0aW9uMTEiLCJlbGV2YXRpb24xMiIsImVsZXZhdGlvbjEzIiwiZWxldmF0aW9uMTQiLCJlbGV2YXRpb24xNSIsImVsZXZhdGlvbjE2IiwiZWxldmF0aW9uMTciLCJlbGV2YXRpb24xOCIsImVsZXZhdGlvbjE5IiwiZWxldmF0aW9uMjAiLCJlbGV2YXRpb24yMSIsImVsZXZhdGlvbjIyIiwiZWxldmF0aW9uMjMiLCJlbGV2YXRpb24yNCJdKTtjb25zdCBiRT1lPT57Y29uc3R7c3F1YXJlOnQsZWxldmF0aW9uOm4sdmFyaWFudDpyLGNsYXNzZXM6b309ZSxpPXtyb290Olsicm9vdCIsciwhdCYmInJvdW5kZWQiLHI9PT0iZWxldmF0aW9uIiYmYGVsZXZhdGlvbiR7bn1gXX07cmV0dXJuIHBlKGksQ0Usbyl9LGtFPUcoImRpdiIse25hbWU6Ik11aVBhcGVyIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5yb290LHRbbi52YXJpYW50XSwhbi5zcXVhcmUmJnQucm91bmRlZCxuLnZhcmlhbnQ9PT0iZWxldmF0aW9uIiYmdFtgZWxldmF0aW9uJHtuLmVsZXZhdGlvbn1gXV19fSkoeWUoKHt0aGVtZTplfSk9Pih7YmFja2dyb3VuZENvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuYmFja2dyb3VuZC5wYXBlcixjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLnRleHQucHJpbWFyeSx0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKCJib3gtc2hhZG93IiksdmFyaWFudHM6W3twcm9wczooe293bmVyU3RhdGU6dH0pPT4hdC5zcXVhcmUsc3R5bGU6e2JvcmRlclJhZGl1czplLnNoYXBlLmJvcmRlclJhZGl1c319LHtwcm9wczp7dmFyaWFudDoib3V0bGluZWQifSxzdHlsZTp7Ym9yZGVyOmAxcHggc29saWQgJHsoZS52YXJzfHxlKS5wYWxldHRlLmRpdmlkZXJ9YH19LHtwcm9wczp7dmFyaWFudDoiZWxldmF0aW9uIn0sc3R5bGU6e2JveFNoYWRvdzoidmFyKC0tUGFwZXItc2hhZG93KSIsYmFja2dyb3VuZEltYWdlOiJ2YXIoLS1QYXBlci1vdmVybGF5KSJ9fV19KSkpLFhmPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe3ZhciB2O2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpUGFwZXIifSksbz1TcygpLHtjbGFzc05hbWU6aSxjb21wb25lbnQ6cz0iZGl2IixlbGV2YXRpb246YT0xLHNxdWFyZTpsPSExLHZhcmlhbnQ6dT0iZWxldmF0aW9uIiwuLi5jfT1yLGQ9ey4uLnIsY29tcG9uZW50OnMsZWxldmF0aW9uOmEsc3F1YXJlOmwsdmFyaWFudDp1fSxtPWJFKGQpO3JldHVybiBrLmpzeChrRSx7YXM6cyxvd25lclN0YXRlOmQsY2xhc3NOYW1lOnRlKG0ucm9vdCxpKSxyZWY6biwuLi5jLHN0eWxlOnsuLi51PT09ImVsZXZhdGlvbiImJnsiLS1QYXBlci1zaGFkb3ciOihvLnZhcnN8fG8pLnNoYWRvd3NbYV0sLi4uby52YXJzJiZ7Ii0tUGFwZXItb3ZlcmxheSI6KHY9by52YXJzLm92ZXJsYXlzKT09bnVsbD92b2lkIDA6dlthXX0sLi4uIW8udmFycyYmby5wYWxldHRlLm1vZGU9PT0iZGFyayImJnsiLS1QYXBlci1vdmVybGF5IjpgbGluZWFyLWdyYWRpZW50KCR7ZnQoIiNmZmYiLGhjKGEpKX0sICR7ZnQoIiNmZmYiLGhjKGEpKX0pYH19LC4uLmMuc3R5bGV9fSl9KSxmMD1DLmNyZWF0ZUNvbnRleHQoe30pO2Z1bmN0aW9uIE50KGUsdCl7Y29uc3R7Y2xhc3NOYW1lOm4sZWxlbWVudFR5cGU6cixvd25lclN0YXRlOm8sZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczppLGdldFNsb3RPd25lclN0YXRlOnMsaW50ZXJuYWxGb3J3YXJkZWRQcm9wczphLC4uLmx9PXQse2NvbXBvbmVudDp1LHNsb3RzOmM9e1tlXTp2b2lkIDB9LHNsb3RQcm9wczpkPXtbZV06dm9pZCAwfSwuLi5tfT1pLHY9Y1tlXXx8cix3PXR5KGRbZV0sbykse3Byb3BzOntjb21wb25lbnQ6UywuLi54fSxpbnRlcm5hbFJlZjpofT1leSh7Y2xhc3NOYW1lOm4sLi4ubCxleHRlcm5hbEZvcndhcmRlZFByb3BzOmU9PT0icm9vdCI/bTp2b2lkIDAsZXh0ZXJuYWxTbG90UHJvcHM6d30pLGc9UWUoaCx3PT1udWxsP3ZvaWQgMDp3LnJlZix0LnJlZiksZj1zP3MoeCk6e30seT17Li4ubywuLi5mfSxiPWU9PT0icm9vdCI/U3x8dTpTLEU9bG8odix7Li4uZT09PSJyb290IiYmIXUmJiFjW2VdJiZhLC4uLmUhPT0icm9vdCImJiFjW2VdJiZhLC4uLngsLi4uYiYme2FzOmJ9LHJlZjpnfSx5KTtyZXR1cm4gT2JqZWN0LmtleXMoZikuZm9yRWFjaChSPT57ZGVsZXRlIEVbUl19KSxbdixFXX1mdW5jdGlvbiBFRShlKXtyZXR1cm4gY2UoIk11aUFjY29yZGlvbiIsZSl9Y29uc3QgUXM9ZGUoIk11aUFjY29yZGlvbiIsWyJyb290IiwiaGVhZGluZyIsInJvdW5kZWQiLCJleHBhbmRlZCIsImRpc2FibGVkIiwiZ3V0dGVycyIsInJlZ2lvbiJdKSxSRT1lPT57Y29uc3R7Y2xhc3Nlczp0LHNxdWFyZTpuLGV4cGFuZGVkOnIsZGlzYWJsZWQ6byxkaXNhYmxlR3V0dGVyczppfT1lO3JldHVybiBwZSh7cm9vdDpbInJvb3QiLCFuJiYicm91bmRlZCIsciYmImV4cGFuZGVkIixvJiYiZGlzYWJsZWQiLCFpJiYiZ3V0dGVycyJdLGhlYWRpbmc6WyJoZWFkaW5nIl0scmVnaW9uOlsicmVnaW9uIl19LEVFLHQpfSxURT1HKFhmLHtuYW1lOiJNdWlBY2NvcmRpb24iLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt7W2AmIC4ke1FzLnJlZ2lvbn1gXTp0LnJlZ2lvbn0sdC5yb290LCFuLnNxdWFyZSYmdC5yb3VuZGVkLCFuLmRpc2FibGVHdXR0ZXJzJiZ0Lmd1dHRlcnNdfX0pKHllKCh7dGhlbWU6ZX0pPT57Y29uc3QgdD17ZHVyYXRpb246ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdH07cmV0dXJue3Bvc2l0aW9uOiJyZWxhdGl2ZSIsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZShbIm1hcmdpbiJdLHQpLG92ZXJmbG93QW5jaG9yOiJub25lIiwiJjo6YmVmb3JlIjp7cG9zaXRpb246ImFic29sdXRlIixsZWZ0OjAsdG9wOi0xLHJpZ2h0OjAsaGVpZ2h0OjEsY29udGVudDonIiInLG9wYWNpdHk6MSxiYWNrZ3JvdW5kQ29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5kaXZpZGVyLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoWyJvcGFjaXR5IiwiYmFja2dyb3VuZC1jb2xvciJdLHQpfSwiJjpmaXJzdC1vZi10eXBlIjp7IiY6OmJlZm9yZSI6e2Rpc3BsYXk6Im5vbmUifX0sW2AmLiR7UXMuZXhwYW5kZWR9YF06eyImOjpiZWZvcmUiOntvcGFjaXR5OjB9LCImOmZpcnN0LW9mLXR5cGUiOnttYXJnaW5Ub3A6MH0sIiY6bGFzdC1vZi10eXBlIjp7bWFyZ2luQm90dG9tOjB9LCImICsgJiI6eyImOjpiZWZvcmUiOntkaXNwbGF5OiJub25lIn19fSxbYCYuJHtRcy5kaXNhYmxlZH1gXTp7YmFja2dyb3VuZENvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkQmFja2dyb3VuZH19fSkseWUoKHt0aGVtZTplfSk9Pih7dmFyaWFudHM6W3twcm9wczp0PT4hdC5zcXVhcmUsc3R5bGU6e2JvcmRlclJhZGl1czowLCImOmZpcnN0LW9mLXR5cGUiOntib3JkZXJUb3BMZWZ0UmFkaXVzOihlLnZhcnN8fGUpLnNoYXBlLmJvcmRlclJhZGl1cyxib3JkZXJUb3BSaWdodFJhZGl1czooZS52YXJzfHxlKS5zaGFwZS5ib3JkZXJSYWRpdXN9LCImOmxhc3Qtb2YtdHlwZSI6e2JvcmRlckJvdHRvbUxlZnRSYWRpdXM6KGUudmFyc3x8ZSkuc2hhcGUuYm9yZGVyUmFkaXVzLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOihlLnZhcnN8fGUpLnNoYXBlLmJvcmRlclJhZGl1cywiQHN1cHBvcnRzICgtbXMtaW1lLWFsaWduOiBhdXRvKSI6e2JvcmRlckJvdHRvbUxlZnRSYWRpdXM6MCxib3JkZXJCb3R0b21SaWdodFJhZGl1czowfX19fSx7cHJvcHM6dD0+IXQuZGlzYWJsZUd1dHRlcnMsc3R5bGU6e1tgJi4ke1FzLmV4cGFuZGVkfWBdOnttYXJnaW46IjE2cHggMCJ9fX1dfSkpKSxQRT1HKCJoMyIse25hbWU6Ik11aUFjY29yZGlvbiIsc2xvdDoiSGVhZGluZyIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQuaGVhZGluZ30pKHthbGw6InVuc2V0In0pLHAwPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpQWNjb3JkaW9uIn0pLHtjaGlsZHJlbjpvLGNsYXNzTmFtZTppLGRlZmF1bHRFeHBhbmRlZDpzPSExLGRpc2FibGVkOmE9ITEsZGlzYWJsZUd1dHRlcnM6bD0hMSxleHBhbmRlZDp1LG9uQ2hhbmdlOmMsc3F1YXJlOmQ9ITEsc2xvdHM6bT17fSxzbG90UHJvcHM6dj17fSxUcmFuc2l0aW9uQ29tcG9uZW50OncsVHJhbnNpdGlvblByb3BzOlMsLi4ueH09cixbaCxnXT1rYSh7Y29udHJvbGxlZDp1LGRlZmF1bHQ6cyxuYW1lOiJBY2NvcmRpb24iLHN0YXRlOiJleHBhbmRlZCJ9KSxmPUMudXNlQ2FsbGJhY2soTT0+e2coIWgpLGMmJmMoTSwhaCl9LFtoLGMsZ10pLFt5LC4uLmJdPUMuQ2hpbGRyZW4udG9BcnJheShvKSxFPUMudXNlTWVtbygoKT0+KHtleHBhbmRlZDpoLGRpc2FibGVkOmEsZGlzYWJsZUd1dHRlcnM6bCx0b2dnbGU6Zn0pLFtoLGEsbCxmXSksUj17Li4ucixzcXVhcmU6ZCxkaXNhYmxlZDphLGRpc2FibGVHdXR0ZXJzOmwsZXhwYW5kZWQ6aH0sUD1SRShSKSxJPXt0cmFuc2l0aW9uOncsLi4ubX0scD17dHJhbnNpdGlvbjpTLC4uLnZ9LCQ9e3Nsb3RzOkksc2xvdFByb3BzOnB9LFtMLGpdPU50KCJoZWFkaW5nIix7ZWxlbWVudFR5cGU6UEUsZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczokLGNsYXNzTmFtZTpQLmhlYWRpbmcsb3duZXJTdGF0ZTpSfSksW04sT109TnQoInRyYW5zaXRpb24iLHtlbGVtZW50VHlwZTpjZCxleHRlcm5hbEZvcndhcmRlZFByb3BzOiQsb3duZXJTdGF0ZTpSfSk7cmV0dXJuIGsuanN4cyhURSx7Y2xhc3NOYW1lOnRlKFAucm9vdCxpKSxyZWY6bixvd25lclN0YXRlOlIsc3F1YXJlOmQsLi4ueCxjaGlsZHJlbjpbay5qc3goTCx7Li4uaixjaGlsZHJlbjprLmpzeChmMC5Qcm92aWRlcix7dmFsdWU6RSxjaGlsZHJlbjp5fSl9KSxrLmpzeChOLHtpbjpoLHRpbWVvdXQ6ImF1dG8iLC4uLk8sY2hpbGRyZW46ay5qc3goImRpdiIseyJhcmlhLWxhYmVsbGVkYnkiOnkucHJvcHMuaWQsaWQ6eS5wcm9wc1siYXJpYS1jb250cm9scyJdLHJvbGU6InJlZ2lvbiIsY2xhc3NOYW1lOlAucmVnaW9uLGNoaWxkcmVuOmJ9KX0pXX0pfSk7ZnVuY3Rpb24gJEUoZSl7cmV0dXJuIGNlKCJNdWlBY2NvcmRpb25EZXRhaWxzIixlKX1kZSgiTXVpQWNjb3JkaW9uRGV0YWlscyIsWyJyb290Il0pO2NvbnN0IE9FPWU9Pntjb25zdHtjbGFzc2VzOnR9PWU7cmV0dXJuIHBlKHtyb290Olsicm9vdCJdfSwkRSx0KX0sTUU9RygiZGl2Iix7bmFtZToiTXVpQWNjb3JkaW9uRGV0YWlscyIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucm9vdH0pKHllKCh7dGhlbWU6ZX0pPT4oe3BhZGRpbmc6ZS5zcGFjaW5nKDEsMiwyKX0pKSksbTA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlBY2NvcmRpb25EZXRhaWxzIn0pLHtjbGFzc05hbWU6bywuLi5pfT1yLHM9cixhPU9FKHMpO3JldHVybiBrLmpzeChNRSx7Y2xhc3NOYW1lOnRlKGEucm9vdCxvKSxyZWY6bixvd25lclN0YXRlOnMsLi4uaX0pfSk7Y2xhc3MgWmF7Y29uc3RydWN0b3IoKXt0aSh0aGlzLCJtb3VudEVmZmVjdCIsKCk9Pnt0aGlzLnNob3VsZE1vdW50JiYhdGhpcy5kaWRNb3VudCYmdGhpcy5yZWYuY3VycmVudCE9PW51bGwmJih0aGlzLmRpZE1vdW50PSEwLHRoaXMubW91bnRlZC5yZXNvbHZlKCkpfSk7dGhpcy5yZWY9e2N1cnJlbnQ6bnVsbH0sdGhpcy5tb3VudGVkPW51bGwsdGhpcy5kaWRNb3VudD0hMSx0aGlzLnNob3VsZE1vdW50PSExLHRoaXMuc2V0U2hvdWxkTW91bnQ9bnVsbH1zdGF0aWMgY3JlYXRlKCl7cmV0dXJuIG5ldyBaYX1zdGF0aWMgdXNlKCl7Y29uc3QgdD1xZyhaYS5jcmVhdGUpLmN1cnJlbnQsW24scl09Qy51c2VTdGF0ZSghMSk7cmV0dXJuIHQuc2hvdWxkTW91bnQ9bix0LnNldFNob3VsZE1vdW50PXIsQy51c2VFZmZlY3QodC5tb3VudEVmZmVjdCxbbl0pLHR9bW91bnQoKXtyZXR1cm4gdGhpcy5tb3VudGVkfHwodGhpcy5tb3VudGVkPU5FKCksdGhpcy5zaG91bGRNb3VudD0hMCx0aGlzLnNldFNob3VsZE1vdW50KHRoaXMuc2hvdWxkTW91bnQpKSx0aGlzLm1vdW50ZWR9c3RhcnQoLi4udCl7dGhpcy5tb3VudCgpLnRoZW4oKCk9Pnt2YXIgbjtyZXR1cm4obj10aGlzLnJlZi5jdXJyZW50KT09bnVsbD92b2lkIDA6bi5zdGFydCguLi50KX0pfXN0b3AoLi4udCl7dGhpcy5tb3VudCgpLnRoZW4oKCk9Pnt2YXIgbjtyZXR1cm4obj10aGlzLnJlZi5jdXJyZW50KT09bnVsbD92b2lkIDA6bi5zdG9wKC4uLnQpfSl9cHVsc2F0ZSguLi50KXt0aGlzLm1vdW50KCkudGhlbigoKT0+e3ZhciBuO3JldHVybihuPXRoaXMucmVmLmN1cnJlbnQpPT1udWxsP3ZvaWQgMDpuLnB1bHNhdGUoLi4udCl9KX19ZnVuY3Rpb24gX0UoKXtyZXR1cm4gWmEudXNlKCl9ZnVuY3Rpb24gTkUoKXtsZXQgZSx0O2NvbnN0IG49bmV3IFByb21pc2UoKHIsbyk9PntlPXIsdD1vfSk7cmV0dXJuIG4ucmVzb2x2ZT1lLG4ucmVqZWN0PXQsbn1mdW5jdGlvbiBJRShlKXtjb25zdHtjbGFzc05hbWU6dCxjbGFzc2VzOm4scHVsc2F0ZTpyPSExLHJpcHBsZVg6byxyaXBwbGVZOmkscmlwcGxlU2l6ZTpzLGluOmEsb25FeGl0ZWQ6bCx0aW1lb3V0OnV9PWUsW2MsZF09Qy51c2VTdGF0ZSghMSksbT10ZSh0LG4ucmlwcGxlLG4ucmlwcGxlVmlzaWJsZSxyJiZuLnJpcHBsZVB1bHNhdGUpLHY9e3dpZHRoOnMsaGVpZ2h0OnMsdG9wOi0ocy8yKStpLGxlZnQ6LShzLzIpK299LHc9dGUobi5jaGlsZCxjJiZuLmNoaWxkTGVhdmluZyxyJiZuLmNoaWxkUHVsc2F0ZSk7cmV0dXJuIWEmJiFjJiZkKCEwKSxDLnVzZUVmZmVjdCgoKT0+e2lmKCFhJiZsIT1udWxsKXtjb25zdCBTPXNldFRpbWVvdXQobCx1KTtyZXR1cm4oKT0+e2NsZWFyVGltZW91dChTKX19fSxbbCxhLHVdKSxrLmpzeCgic3BhbiIse2NsYXNzTmFtZTptLHN0eWxlOnYsY2hpbGRyZW46ay5qc3goInNwYW4iLHtjbGFzc05hbWU6d30pfSl9Y29uc3QgR3Q9ZGUoIk11aVRvdWNoUmlwcGxlIixbInJvb3QiLCJyaXBwbGUiLCJyaXBwbGVWaXNpYmxlIiwicmlwcGxlUHVsc2F0ZSIsImNoaWxkIiwiY2hpbGRMZWF2aW5nIiwiY2hpbGRQdWxzYXRlIl0pLGRkPTU1MCxBRT04MCx6RT1CZGAKICAwJSB7CiAgICB0cmFuc2Zvcm06IHNjYWxlKDApOwogICAgb3BhY2l0eTogMC4xOwogIH0KCiAgMTAwJSB7CiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOwogICAgb3BhY2l0eTogMC4zOwogIH0KYCxMRT1CZGAKICAwJSB7CiAgICBvcGFjaXR5OiAxOwogIH0KCiAgMTAwJSB7CiAgICBvcGFjaXR5OiAwOwogIH0KYCxqRT1CZGAKICAwJSB7CiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOwogIH0KCiAgNTAlIHsKICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mik7CiAgfQoKICAxMDAlIHsKICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7CiAgfQpgLERFPUcoInNwYW4iLHtuYW1lOiJNdWlUb3VjaFJpcHBsZSIsc2xvdDoiUm9vdCJ9KSh7b3ZlcmZsb3c6ImhpZGRlbiIscG9pbnRlckV2ZW50czoibm9uZSIscG9zaXRpb246ImFic29sdXRlIix6SW5kZXg6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowLGxlZnQ6MCxib3JkZXJSYWRpdXM6ImluaGVyaXQifSksRkU9RyhJRSx7bmFtZToiTXVpVG91Y2hSaXBwbGUiLHNsb3Q6IlJpcHBsZSJ9KWAKICBvcGFjaXR5OiAwOwogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKCiAgJi4ke0d0LnJpcHBsZVZpc2libGV9IHsKICAgIG9wYWNpdHk6IDAuMzsKICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7CiAgICBhbmltYXRpb24tbmFtZTogJHt6RX07CiAgICBhbmltYXRpb24tZHVyYXRpb246ICR7ZGR9bXM7CiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiAkeyh7dGhlbWU6ZX0pPT5lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXR9OwogIH0KCiAgJi4ke0d0LnJpcHBsZVB1bHNhdGV9IHsKICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogJHsoe3RoZW1lOmV9KT0+ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyfW1zOwogIH0KCiAgJiAuJHtHdC5jaGlsZH0gewogICAgb3BhY2l0eTogMTsKICAgIGRpc3BsYXk6IGJsb2NrOwogICAgd2lkdGg6IDEwMCU7CiAgICBoZWlnaHQ6IDEwMCU7CiAgICBib3JkZXItcmFkaXVzOiA1MCU7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjdXJyZW50Q29sb3I7CiAgfQoKICAmIC4ke0d0LmNoaWxkTGVhdmluZ30gewogICAgb3BhY2l0eTogMDsKICAgIGFuaW1hdGlvbi1uYW1lOiAke0xFfTsKICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogJHtkZH1tczsKICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ICR7KHt0aGVtZTplfSk9PmUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VJbk91dH07CiAgfQoKICAmIC4ke0d0LmNoaWxkUHVsc2F0ZX0gewogICAgcG9zaXRpb246IGFic29sdXRlOwogICAgLyogQG5vZmxpcCAqLwogICAgbGVmdDogMHB4OwogICAgdG9wOiAwOwogICAgYW5pbWF0aW9uLW5hbWU6ICR7akV9OwogICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAyNTAwbXM7CiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiAkeyh7dGhlbWU6ZX0pPT5lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXR9OwogICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7CiAgICBhbmltYXRpb24tZGVsYXk6IDIwMG1zOwogIH0KYCxCRT1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aVRvdWNoUmlwcGxlIn0pLHtjZW50ZXI6bz0hMSxjbGFzc2VzOmk9e30sY2xhc3NOYW1lOnMsLi4uYX09cixbbCx1XT1DLnVzZVN0YXRlKFtdKSxjPUMudXNlUmVmKDApLGQ9Qy51c2VSZWYobnVsbCk7Qy51c2VFZmZlY3QoKCk9PntkLmN1cnJlbnQmJihkLmN1cnJlbnQoKSxkLmN1cnJlbnQ9bnVsbCl9LFtsXSk7Y29uc3QgbT1DLnVzZVJlZighMSksdj1BcigpLHc9Qy51c2VSZWYobnVsbCksUz1DLnVzZVJlZihudWxsKSx4PUMudXNlQ2FsbGJhY2soeT0+e2NvbnN0e3B1bHNhdGU6YixyaXBwbGVYOkUscmlwcGxlWTpSLHJpcHBsZVNpemU6UCxjYjpJfT15O3UocD0+Wy4uLnAsay5qc3goRkUse2NsYXNzZXM6e3JpcHBsZTp0ZShpLnJpcHBsZSxHdC5yaXBwbGUpLHJpcHBsZVZpc2libGU6dGUoaS5yaXBwbGVWaXNpYmxlLEd0LnJpcHBsZVZpc2libGUpLHJpcHBsZVB1bHNhdGU6dGUoaS5yaXBwbGVQdWxzYXRlLEd0LnJpcHBsZVB1bHNhdGUpLGNoaWxkOnRlKGkuY2hpbGQsR3QuY2hpbGQpLGNoaWxkTGVhdmluZzp0ZShpLmNoaWxkTGVhdmluZyxHdC5jaGlsZExlYXZpbmcpLGNoaWxkUHVsc2F0ZTp0ZShpLmNoaWxkUHVsc2F0ZSxHdC5jaGlsZFB1bHNhdGUpfSx0aW1lb3V0OmRkLHB1bHNhdGU6YixyaXBwbGVYOkUscmlwcGxlWTpSLHJpcHBsZVNpemU6UH0sYy5jdXJyZW50KV0pLGMuY3VycmVudCs9MSxkLmN1cnJlbnQ9SX0sW2ldKSxoPUMudXNlQ2FsbGJhY2soKHk9e30sYj17fSxFPSgpPT57fSk9Pntjb25zdHtwdWxzYXRlOlI9ITEsY2VudGVyOlA9b3x8Yi5wdWxzYXRlLGZha2VFbGVtZW50Okk9ITF9PWI7aWYoKHk9PW51bGw/dm9pZCAwOnkudHlwZSk9PT0ibW91c2Vkb3duIiYmbS5jdXJyZW50KXttLmN1cnJlbnQ9ITE7cmV0dXJufSh5PT1udWxsP3ZvaWQgMDp5LnR5cGUpPT09InRvdWNoc3RhcnQiJiYobS5jdXJyZW50PSEwKTtjb25zdCBwPUk/bnVsbDpTLmN1cnJlbnQsJD1wP3AuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6e3dpZHRoOjAsaGVpZ2h0OjAsbGVmdDowLHRvcDowfTtsZXQgTCxqLE47aWYoUHx8eT09PXZvaWQgMHx8eS5jbGllbnRYPT09MCYmeS5jbGllbnRZPT09MHx8IXkuY2xpZW50WCYmIXkudG91Y2hlcylMPU1hdGgucm91bmQoJC53aWR0aC8yKSxqPU1hdGgucm91bmQoJC5oZWlnaHQvMik7ZWxzZXtjb25zdHtjbGllbnRYOk8sY2xpZW50WTpNfT15LnRvdWNoZXMmJnkudG91Y2hlcy5sZW5ndGg+MD95LnRvdWNoZXNbMF06eTtMPU1hdGgucm91bmQoTy0kLmxlZnQpLGo9TWF0aC5yb3VuZChNLSQudG9wKX1pZihQKU49TWF0aC5zcXJ0KCgyKiQud2lkdGgqKjIrJC5oZWlnaHQqKjIpLzMpLE4lMj09PTAmJihOKz0xKTtlbHNle2NvbnN0IE89TWF0aC5tYXgoTWF0aC5hYnMoKHA/cC5jbGllbnRXaWR0aDowKS1MKSxMKSoyKzIsTT1NYXRoLm1heChNYXRoLmFicygocD9wLmNsaWVudEhlaWdodDowKS1qKSxqKSoyKzI7Tj1NYXRoLnNxcnQoTyoqMitNKioyKX15IT1udWxsJiZ5LnRvdWNoZXM/dy5jdXJyZW50PT09bnVsbCYmKHcuY3VycmVudD0oKT0+e3goe3B1bHNhdGU6UixyaXBwbGVYOkwscmlwcGxlWTpqLHJpcHBsZVNpemU6TixjYjpFfSl9LHYuc3RhcnQoQUUsKCk9Pnt3LmN1cnJlbnQmJih3LmN1cnJlbnQoKSx3LmN1cnJlbnQ9bnVsbCl9KSk6eCh7cHVsc2F0ZTpSLHJpcHBsZVg6TCxyaXBwbGVZOmoscmlwcGxlU2l6ZTpOLGNiOkV9KX0sW28seCx2XSksZz1DLnVzZUNhbGxiYWNrKCgpPT57aCh7fSx7cHVsc2F0ZTohMH0pfSxbaF0pLGY9Qy51c2VDYWxsYmFjaygoeSxiKT0+e2lmKHYuY2xlYXIoKSwoeT09bnVsbD92b2lkIDA6eS50eXBlKT09PSJ0b3VjaGVuZCImJncuY3VycmVudCl7dy5jdXJyZW50KCksdy5jdXJyZW50PW51bGwsdi5zdGFydCgwLCgpPT57Zih5LGIpfSk7cmV0dXJufXcuY3VycmVudD1udWxsLHUoRT0+RS5sZW5ndGg+MD9FLnNsaWNlKDEpOkUpLGQuY3VycmVudD1ifSxbdl0pO3JldHVybiBDLnVzZUltcGVyYXRpdmVIYW5kbGUobiwoKT0+KHtwdWxzYXRlOmcsc3RhcnQ6aCxzdG9wOmZ9KSxbZyxoLGZdKSxrLmpzeChERSx7Y2xhc3NOYW1lOnRlKEd0LnJvb3QsaS5yb290LHMpLHJlZjpTLC4uLmEsY2hpbGRyZW46ay5qc3goc3Use2NvbXBvbmVudDpudWxsLGV4aXQ6ITAsY2hpbGRyZW46bH0pfSl9KTtmdW5jdGlvbiBXRShlKXtyZXR1cm4gY2UoIk11aUJ1dHRvbkJhc2UiLGUpfWNvbnN0IFVFPWRlKCJNdWlCdXR0b25CYXNlIixbInJvb3QiLCJkaXNhYmxlZCIsImZvY3VzVmlzaWJsZSJdKSxIRT1lPT57Y29uc3R7ZGlzYWJsZWQ6dCxmb2N1c1Zpc2libGU6bixmb2N1c1Zpc2libGVDbGFzc05hbWU6cixjbGFzc2VzOm99PWUscz1wZSh7cm9vdDpbInJvb3QiLHQmJiJkaXNhYmxlZCIsbiYmImZvY3VzVmlzaWJsZSJdfSxXRSxvKTtyZXR1cm4gbiYmciYmKHMucm9vdCs9YCAke3J9YCksc30sVkU9RygiYnV0dG9uIix7bmFtZToiTXVpQnV0dG9uQmFzZSIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucm9vdH0pKHtkaXNwbGF5OiJpbmxpbmUtZmxleCIsYWxpZ25JdGVtczoiY2VudGVyIixqdXN0aWZ5Q29udGVudDoiY2VudGVyIixwb3NpdGlvbjoicmVsYXRpdmUiLGJveFNpemluZzoiYm9yZGVyLWJveCIsV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6InRyYW5zcGFyZW50IixiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50IixvdXRsaW5lOjAsYm9yZGVyOjAsbWFyZ2luOjAsYm9yZGVyUmFkaXVzOjAscGFkZGluZzowLGN1cnNvcjoicG9pbnRlciIsdXNlclNlbGVjdDoibm9uZSIsdmVydGljYWxBbGlnbjoibWlkZGxlIixNb3pBcHBlYXJhbmNlOiJub25lIixXZWJraXRBcHBlYXJhbmNlOiJub25lIix0ZXh0RGVjb3JhdGlvbjoibm9uZSIsY29sb3I6ImluaGVyaXQiLCImOjotbW96LWZvY3VzLWlubmVyIjp7Ym9yZGVyU3R5bGU6Im5vbmUifSxbYCYuJHtVRS5kaXNhYmxlZH1gXTp7cG9pbnRlckV2ZW50czoibm9uZSIsY3Vyc29yOiJkZWZhdWx0In0sIkBtZWRpYSBwcmludCI6e2NvbG9yQWRqdXN0OiJleGFjdCJ9fSkscWY9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlCdXR0b25CYXNlIn0pLHthY3Rpb246byxjZW50ZXJSaXBwbGU6aT0hMSxjaGlsZHJlbjpzLGNsYXNzTmFtZTphLGNvbXBvbmVudDpsPSJidXR0b24iLGRpc2FibGVkOnU9ITEsZGlzYWJsZVJpcHBsZTpjPSExLGRpc2FibGVUb3VjaFJpcHBsZTpkPSExLGZvY3VzUmlwcGxlOm09ITEsZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOnYsTGlua0NvbXBvbmVudDp3PSJhIixvbkJsdXI6UyxvbkNsaWNrOngsb25Db250ZXh0TWVudTpoLG9uRHJhZ0xlYXZlOmcsb25Gb2N1czpmLG9uRm9jdXNWaXNpYmxlOnksb25LZXlEb3duOmIsb25LZXlVcDpFLG9uTW91c2VEb3duOlIsb25Nb3VzZUxlYXZlOlAsb25Nb3VzZVVwOkksb25Ub3VjaEVuZDpwLG9uVG91Y2hNb3ZlOiQsb25Ub3VjaFN0YXJ0OkwsdGFiSW5kZXg6aj0wLFRvdWNoUmlwcGxlUHJvcHM6Tix0b3VjaFJpcHBsZVJlZjpPLHR5cGU6TSwuLi5ffT1yLFQ9Qy51c2VSZWYobnVsbCksQT1fRSgpLEQ9UWUoQS5yZWYsTyksW0IsSF09Qy51c2VTdGF0ZSghMSk7dSYmQiYmSCghMSksQy51c2VJbXBlcmF0aXZlSGFuZGxlKG8sKCk9Pih7Zm9jdXNWaXNpYmxlOigpPT57SCghMCksVC5jdXJyZW50LmZvY3VzKCl9fSksW10pO2NvbnN0IFY9QS5zaG91bGRNb3VudCYmIWMmJiF1O0MudXNlRWZmZWN0KCgpPT57QiYmbSYmIWMmJkEucHVsc2F0ZSgpfSxbYyxtLEIsQV0pO2Z1bmN0aW9uIFUocSxJZSx4bj1kKXtyZXR1cm4gdXIoU3Q9PihJZSYmSWUoU3QpLHhufHxBW3FdKFN0KSwhMCkpfWNvbnN0IFg9VSgic3RhcnQiLFIpLFc9VSgic3RvcCIsaCksSj1VKCJzdG9wIixnKSxvZT1VKCJzdG9wIixJKSxyZT1VKCJzdG9wIixxPT57QiYmcS5wcmV2ZW50RGVmYXVsdCgpLFAmJlAocSl9KSxRPVUoInN0YXJ0IixMKSxlZT1VKCJzdG9wIixwKSxZPVUoInN0b3AiLCQpLHVlPVUoInN0b3AiLHE9PntFYShxLnRhcmdldCl8fEgoITEpLFMmJlMocSl9LCExKSxpZT11cihxPT57VC5jdXJyZW50fHwoVC5jdXJyZW50PXEuY3VycmVudFRhcmdldCksRWEocS50YXJnZXQpJiYoSCghMCkseSYmeShxKSksZiYmZihxKX0pLGZlPSgpPT57Y29uc3QgcT1ULmN1cnJlbnQ7cmV0dXJuIGwmJmwhPT0iYnV0dG9uIiYmIShxLnRhZ05hbWU9PT0iQSImJnEuaHJlZil9LFplPXVyKHE9PnttJiYhcS5yZXBlYXQmJkImJnEua2V5PT09IiAiJiZBLnN0b3AocSwoKT0+e0Euc3RhcnQocSl9KSxxLnRhcmdldD09PXEuY3VycmVudFRhcmdldCYmZmUoKSYmcS5rZXk9PT0iICImJnEucHJldmVudERlZmF1bHQoKSxiJiZiKHEpLHEudGFyZ2V0PT09cS5jdXJyZW50VGFyZ2V0JiZmZSgpJiZxLmtleT09PSJFbnRlciImJiF1JiYocS5wcmV2ZW50RGVmYXVsdCgpLHgmJngocSkpfSksVmU9dXIocT0+e20mJnEua2V5PT09IiAiJiZCJiYhcS5kZWZhdWx0UHJldmVudGVkJiZBLnN0b3AocSwoKT0+e0EucHVsc2F0ZShxKX0pLEUmJkUocSkseCYmcS50YXJnZXQ9PT1xLmN1cnJlbnRUYXJnZXQmJmZlKCkmJnEua2V5PT09IiAiJiYhcS5kZWZhdWx0UHJldmVudGVkJiZ4KHEpfSk7bGV0IE9lPWw7T2U9PT0iYnV0dG9uIiYmKF8uaHJlZnx8Xy50bykmJihPZT13KTtjb25zdCBOZT17fTtPZT09PSJidXR0b24iPyhOZS50eXBlPU09PT12b2lkIDA/ImJ1dHRvbiI6TSxOZS5kaXNhYmxlZD11KTooIV8uaHJlZiYmIV8udG8mJihOZS5yb2xlPSJidXR0b24iKSx1JiYoTmVbImFyaWEtZGlzYWJsZWQiXT11KSk7Y29uc3QgV2U9UWUobixUKSxoZT17Li4ucixjZW50ZXJSaXBwbGU6aSxjb21wb25lbnQ6bCxkaXNhYmxlZDp1LGRpc2FibGVSaXBwbGU6YyxkaXNhYmxlVG91Y2hSaXBwbGU6ZCxmb2N1c1JpcHBsZTptLHRhYkluZGV4OmosZm9jdXNWaXNpYmxlOkJ9LGh0PUhFKGhlKTtyZXR1cm4gay5qc3hzKFZFLHthczpPZSxjbGFzc05hbWU6dGUoaHQucm9vdCxhKSxvd25lclN0YXRlOmhlLG9uQmx1cjp1ZSxvbkNsaWNrOngsb25Db250ZXh0TWVudTpXLG9uRm9jdXM6aWUsb25LZXlEb3duOlplLG9uS2V5VXA6VmUsb25Nb3VzZURvd246WCxvbk1vdXNlTGVhdmU6cmUsb25Nb3VzZVVwOm9lLG9uRHJhZ0xlYXZlOkosb25Ub3VjaEVuZDplZSxvblRvdWNoTW92ZTpZLG9uVG91Y2hTdGFydDpRLHJlZjpXZSx0YWJJbmRleDp1Py0xOmosdHlwZTpNLC4uLk5lLC4uLl8sY2hpbGRyZW46W3MsVj9rLmpzeChCRSx7cmVmOkQsY2VudGVyOmksLi4uTn0pOm51bGxdfSl9KTtmdW5jdGlvbiBLRShlKXtyZXR1cm4gY2UoIk11aUFjY29yZGlvblN1bW1hcnkiLGUpfWNvbnN0IENvPWRlKCJNdWlBY2NvcmRpb25TdW1tYXJ5IixbInJvb3QiLCJleHBhbmRlZCIsImZvY3VzVmlzaWJsZSIsImRpc2FibGVkIiwiZ3V0dGVycyIsImNvbnRlbnRHdXR0ZXJzIiwiY29udGVudCIsImV4cGFuZEljb25XcmFwcGVyIl0pLFlFPWU9Pntjb25zdHtjbGFzc2VzOnQsZXhwYW5kZWQ6bixkaXNhYmxlZDpyLGRpc2FibGVHdXR0ZXJzOm99PWU7cmV0dXJuIHBlKHtyb290Olsicm9vdCIsbiYmImV4cGFuZGVkIixyJiYiZGlzYWJsZWQiLCFvJiYiZ3V0dGVycyJdLGZvY3VzVmlzaWJsZTpbImZvY3VzVmlzaWJsZSJdLGNvbnRlbnQ6WyJjb250ZW50IixuJiYiZXhwYW5kZWQiLCFvJiYiY29udGVudEd1dHRlcnMiXSxleHBhbmRJY29uV3JhcHBlcjpbImV4cGFuZEljb25XcmFwcGVyIixuJiYiZXhwYW5kZWQiXX0sS0UsdCl9LEdFPUcocWYse25hbWU6Ik11aUFjY29yZGlvblN1bW1hcnkiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT50LnJvb3R9KSh5ZSgoe3RoZW1lOmV9KT0+e2NvbnN0IHQ9e2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3R9O3JldHVybntkaXNwbGF5OiJmbGV4IixtaW5IZWlnaHQ6NDgscGFkZGluZzplLnNwYWNpbmcoMCwyKSx0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKFsibWluLWhlaWdodCIsImJhY2tncm91bmQtY29sb3IiXSx0KSxbYCYuJHtDby5mb2N1c1Zpc2libGV9YF06e2JhY2tncm91bmRDb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmFjdGlvbi5mb2N1c30sW2AmLiR7Q28uZGlzYWJsZWR9YF06e29wYWNpdHk6KGUudmFyc3x8ZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRPcGFjaXR5fSxbYCY6aG92ZXI6bm90KC4ke0NvLmRpc2FibGVkfSlgXTp7Y3Vyc29yOiJwb2ludGVyIn0sdmFyaWFudHM6W3twcm9wczpuPT4hbi5kaXNhYmxlR3V0dGVycyxzdHlsZTp7W2AmLiR7Q28uZXhwYW5kZWR9YF06e21pbkhlaWdodDo2NH19fV19fSkpLFFFPUcoImRpdiIse25hbWU6Ik11aUFjY29yZGlvblN1bW1hcnkiLHNsb3Q6IkNvbnRlbnQiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT50LmNvbnRlbnR9KSh5ZSgoe3RoZW1lOmV9KT0+KHtkaXNwbGF5OiJmbGV4IixmbGV4R3JvdzoxLG1hcmdpbjoiMTJweCAwIix2YXJpYW50czpbe3Byb3BzOnQ9PiF0LmRpc2FibGVHdXR0ZXJzLHN0eWxlOnt0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKFsibWFyZ2luIl0se2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3R9KSxbYCYuJHtDby5leHBhbmRlZH1gXTp7bWFyZ2luOiIyMHB4IDAifX19XX0pKSksWEU9RygiZGl2Iix7bmFtZToiTXVpQWNjb3JkaW9uU3VtbWFyeSIsc2xvdDoiRXhwYW5kSWNvbldyYXBwZXIiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT50LmV4cGFuZEljb25XcmFwcGVyfSkoeWUoKHt0aGVtZTplfSk9Pih7ZGlzcGxheToiZmxleCIsY29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5hY3Rpb24uYWN0aXZlLHRyYW5zZm9ybToicm90YXRlKDBkZWcpIix0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKCJ0cmFuc2Zvcm0iLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXN0fSksW2AmLiR7Q28uZXhwYW5kZWR9YF06e3RyYW5zZm9ybToicm90YXRlKDE4MGRlZykifX0pKSksaDA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlBY2NvcmRpb25TdW1tYXJ5In0pLHtjaGlsZHJlbjpvLGNsYXNzTmFtZTppLGV4cGFuZEljb246cyxmb2N1c1Zpc2libGVDbGFzc05hbWU6YSxvbkNsaWNrOmwsLi4udX09cix7ZGlzYWJsZWQ6Yz0hMSxkaXNhYmxlR3V0dGVyczpkLGV4cGFuZGVkOm0sdG9nZ2xlOnZ9PUMudXNlQ29udGV4dChmMCksdz1oPT57diYmdihoKSxsJiZsKGgpfSxTPXsuLi5yLGV4cGFuZGVkOm0sZGlzYWJsZWQ6YyxkaXNhYmxlR3V0dGVyczpkfSx4PVlFKFMpO3JldHVybiBrLmpzeHMoR0Use2ZvY3VzUmlwcGxlOiExLGRpc2FibGVSaXBwbGU6ITAsZGlzYWJsZWQ6Yyxjb21wb25lbnQ6ImRpdiIsImFyaWEtZXhwYW5kZWQiOm0sY2xhc3NOYW1lOnRlKHgucm9vdCxpKSxmb2N1c1Zpc2libGVDbGFzc05hbWU6dGUoeC5mb2N1c1Zpc2libGUsYSksb25DbGljazp3LHJlZjpuLG93bmVyU3RhdGU6UywuLi51LGNoaWxkcmVuOltrLmpzeChRRSx7Y2xhc3NOYW1lOnguY29udGVudCxvd25lclN0YXRlOlMsY2hpbGRyZW46b30pLHMmJmsuanN4KFhFLHtjbGFzc05hbWU6eC5leHBhbmRJY29uV3JhcHBlcixvd25lclN0YXRlOlMsY2hpbGRyZW46c30pXX0pfSk7ZnVuY3Rpb24gcUUoZSl7cmV0dXJuIHR5cGVvZiBlLm1haW49PSJzdHJpbmcifWZ1bmN0aW9uIFpFKGUsdD1bXSl7aWYoIXFFKGUpKXJldHVybiExO2Zvcihjb25zdCBuIG9mIHQpaWYoIWUuaGFzT3duUHJvcGVydHkobil8fHR5cGVvZiBlW25dIT0ic3RyaW5nIilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBicihlPVtdKXtyZXR1cm4oWyx0XSk9PnQmJlpFKHQsZSl9ZnVuY3Rpb24gSkUoZSl7cmV0dXJuIGNlKCJNdWlJY29uQnV0dG9uIixlKX1jb25zdCBlMj1kZSgiTXVpSWNvbkJ1dHRvbiIsWyJyb290IiwiZGlzYWJsZWQiLCJjb2xvckluaGVyaXQiLCJjb2xvclByaW1hcnkiLCJjb2xvclNlY29uZGFyeSIsImNvbG9yRXJyb3IiLCJjb2xvckluZm8iLCJjb2xvclN1Y2Nlc3MiLCJjb2xvcldhcm5pbmciLCJlZGdlU3RhcnQiLCJlZGdlRW5kIiwic2l6ZVNtYWxsIiwic2l6ZU1lZGl1bSIsInNpemVMYXJnZSJdKSx0Mj1lPT57Y29uc3R7Y2xhc3Nlczp0LGRpc2FibGVkOm4sY29sb3I6cixlZGdlOm8sc2l6ZTppfT1lLHM9e3Jvb3Q6WyJyb290IixuJiYiZGlzYWJsZWQiLHIhPT0iZGVmYXVsdCImJmBjb2xvciR7bmUocil9YCxvJiZgZWRnZSR7bmUobyl9YCxgc2l6ZSR7bmUoaSl9YF19O3JldHVybiBwZShzLEpFLHQpfSxuMj1HKHFmLHtuYW1lOiJNdWlJY29uQnV0dG9uIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5yb290LG4uY29sb3IhPT0iZGVmYXVsdCImJnRbYGNvbG9yJHtuZShuLmNvbG9yKX1gXSxuLmVkZ2UmJnRbYGVkZ2Uke25lKG4uZWRnZSl9YF0sdFtgc2l6ZSR7bmUobi5zaXplKX1gXV19fSkoeWUoKHt0aGVtZTplfSk9Pih7dGV4dEFsaWduOiJjZW50ZXIiLGZsZXg6IjAgMCBhdXRvIixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgyNCkscGFkZGluZzo4LGJvcmRlclJhZGl1czoiNTAlIixjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgiYmFja2dyb3VuZC1jb2xvciIse2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3R9KSx2YXJpYW50czpbe3Byb3BzOnQ9PiF0LmRpc2FibGVSaXBwbGUsc3R5bGU6eyItLUljb25CdXR0b24taG92ZXJCZyI6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZUNoYW5uZWx9IC8gJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5fSlgOmZ0KGUucGFsZXR0ZS5hY3Rpb24uYWN0aXZlLGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSwiJjpob3ZlciI6e2JhY2tncm91bmRDb2xvcjoidmFyKC0tSWNvbkJ1dHRvbi1ob3ZlckJnKSIsIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fX19LHtwcm9wczp7ZWRnZToic3RhcnQifSxzdHlsZTp7bWFyZ2luTGVmdDotMTJ9fSx7cHJvcHM6e2VkZ2U6InN0YXJ0IixzaXplOiJzbWFsbCJ9LHN0eWxlOnttYXJnaW5MZWZ0Oi0zfX0se3Byb3BzOntlZGdlOiJlbmQifSxzdHlsZTp7bWFyZ2luUmlnaHQ6LTEyfX0se3Byb3BzOntlZGdlOiJlbmQiLHNpemU6InNtYWxsIn0sc3R5bGU6e21hcmdpblJpZ2h0Oi0zfX1dfSkpLHllKCh7dGhlbWU6ZX0pPT4oe3ZhcmlhbnRzOlt7cHJvcHM6e2NvbG9yOiJpbmhlcml0In0sc3R5bGU6e2NvbG9yOiJpbmhlcml0In19LC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKGJyKCkpLm1hcCgoW3RdKT0+KHtwcm9wczp7Y29sb3I6dH0sc3R5bGU6e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGVbdF0ubWFpbn19KSksLi4uT2JqZWN0LmVudHJpZXMoZS5wYWxldHRlKS5maWx0ZXIoYnIoKSkubWFwKChbdF0pPT4oe3Byb3BzOntjb2xvcjp0fSxzdHlsZTp7Ii0tSWNvbkJ1dHRvbi1ob3ZlckJnIjplLnZhcnM/YHJnYmEoJHsoZS52YXJzfHxlKS5wYWxldHRlW3RdLm1haW5DaGFubmVsfSAvICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pYDpmdCgoZS52YXJzfHxlKS5wYWxldHRlW3RdLm1haW4sZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpfX0pKSx7cHJvcHM6e3NpemU6InNtYWxsIn0sc3R5bGU6e3BhZGRpbmc6NSxmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxOCl9fSx7cHJvcHM6e3NpemU6ImxhcmdlIn0sc3R5bGU6e3BhZGRpbmc6MTIsZm9udFNpemU6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjgpfX1dLFtgJi4ke2UyLmRpc2FibGVkfWBdOntiYWNrZ3JvdW5kQ29sb3I6InRyYW5zcGFyZW50Iixjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZH19KSkpLFpmPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpSWNvbkJ1dHRvbiJ9KSx7ZWRnZTpvPSExLGNoaWxkcmVuOmksY2xhc3NOYW1lOnMsY29sb3I6YT0iZGVmYXVsdCIsZGlzYWJsZWQ6bD0hMSxkaXNhYmxlRm9jdXNSaXBwbGU6dT0hMSxzaXplOmM9Im1lZGl1bSIsLi4uZH09cixtPXsuLi5yLGVkZ2U6byxjb2xvcjphLGRpc2FibGVkOmwsZGlzYWJsZUZvY3VzUmlwcGxlOnUsc2l6ZTpjfSx2PXQyKG0pO3JldHVybiBrLmpzeChuMix7Y2xhc3NOYW1lOnRlKHYucm9vdCxzKSxjZW50ZXJSaXBwbGU6ITAsZm9jdXNSaXBwbGU6IXUsZGlzYWJsZWQ6bCxyZWY6biwuLi5kLG93bmVyU3RhdGU6bSxjaGlsZHJlbjppfSl9KTtmdW5jdGlvbiByMihlKXtyZXR1cm4gY2UoIk11aVR5cG9ncmFwaHkiLGUpfWRlKCJNdWlUeXBvZ3JhcGh5IixbInJvb3QiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJzdWJ0aXRsZTEiLCJzdWJ0aXRsZTIiLCJib2R5MSIsImJvZHkyIiwiaW5oZXJpdCIsImJ1dHRvbiIsImNhcHRpb24iLCJvdmVybGluZSIsImFsaWduTGVmdCIsImFsaWduUmlnaHQiLCJhbGlnbkNlbnRlciIsImFsaWduSnVzdGlmeSIsIm5vV3JhcCIsImd1dHRlckJvdHRvbSIsInBhcmFncmFwaCJdKTtjb25zdCBvMj17cHJpbWFyeTohMCxzZWNvbmRhcnk6ITAsZXJyb3I6ITAsaW5mbzohMCxzdWNjZXNzOiEwLHdhcm5pbmc6ITAsdGV4dFByaW1hcnk6ITAsdGV4dFNlY29uZGFyeTohMCx0ZXh0RGlzYWJsZWQ6ITB9LGkyPUpDKCksczI9ZT0+e2NvbnN0e2FsaWduOnQsZ3V0dGVyQm90dG9tOm4sbm9XcmFwOnIscGFyYWdyYXBoOm8sdmFyaWFudDppLGNsYXNzZXM6c309ZSxhPXtyb290Olsicm9vdCIsaSxlLmFsaWduIT09ImluaGVyaXQiJiZgYWxpZ24ke25lKHQpfWAsbiYmImd1dHRlckJvdHRvbSIsciYmIm5vV3JhcCIsbyYmInBhcmFncmFwaCJdfTtyZXR1cm4gcGUoYSxyMixzKX0sYTI9Rygic3BhbiIse25hbWU6Ik11aVR5cG9ncmFwaHkiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt0LnJvb3Qsbi52YXJpYW50JiZ0W24udmFyaWFudF0sbi5hbGlnbiE9PSJpbmhlcml0IiYmdFtgYWxpZ24ke25lKG4uYWxpZ24pfWBdLG4ubm9XcmFwJiZ0Lm5vV3JhcCxuLmd1dHRlckJvdHRvbSYmdC5ndXR0ZXJCb3R0b20sbi5wYXJhZ3JhcGgmJnQucGFyYWdyYXBoXX19KSh5ZSgoe3RoZW1lOmV9KT0+e3ZhciB0O3JldHVybnttYXJnaW46MCx2YXJpYW50czpbe3Byb3BzOnt2YXJpYW50OiJpbmhlcml0In0sc3R5bGU6e2ZvbnQ6ImluaGVyaXQiLGxpbmVIZWlnaHQ6ImluaGVyaXQiLGxldHRlclNwYWNpbmc6ImluaGVyaXQifX0sLi4uT2JqZWN0LmVudHJpZXMoZS50eXBvZ3JhcGh5KS5maWx0ZXIoKFtuLHJdKT0+biE9PSJpbmhlcml0IiYmciYmdHlwZW9mIHI9PSJvYmplY3QiKS5tYXAoKFtuLHJdKT0+KHtwcm9wczp7dmFyaWFudDpufSxzdHlsZTpyfSkpLC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKGJyKCkpLm1hcCgoW25dKT0+KHtwcm9wczp7Y29sb3I6bn0sc3R5bGU6e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGVbbl0ubWFpbn19KSksLi4uT2JqZWN0LmVudHJpZXMoKCh0PWUucGFsZXR0ZSk9PW51bGw/dm9pZCAwOnQudGV4dCl8fHt9KS5maWx0ZXIoKFssbl0pPT50eXBlb2Ygbj09InN0cmluZyIpLm1hcCgoW25dKT0+KHtwcm9wczp7Y29sb3I6YHRleHQke25lKG4pfWB9LHN0eWxlOntjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLnRleHRbbl19fSkpLHtwcm9wczooe293bmVyU3RhdGU6bn0pPT5uLmFsaWduIT09ImluaGVyaXQiLHN0eWxlOnt0ZXh0QWxpZ246InZhcigtLVR5cG9ncmFwaHktdGV4dEFsaWduKSJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOm59KT0+bi5ub1dyYXAsc3R5bGU6e292ZXJmbG93OiJoaWRkZW4iLHRleHRPdmVyZmxvdzoiZWxsaXBzaXMiLHdoaXRlU3BhY2U6Im5vd3JhcCJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOm59KT0+bi5ndXR0ZXJCb3R0b20sc3R5bGU6e21hcmdpbkJvdHRvbToiMC4zNWVtIn19LHtwcm9wczooe293bmVyU3RhdGU6bn0pPT5uLnBhcmFncmFwaCxzdHlsZTp7bWFyZ2luQm90dG9tOjE2fX1dfX0pKSxkaD17aDE6ImgxIixoMjoiaDIiLGgzOiJoMyIsaDQ6Img0IixoNToiaDUiLGg2OiJoNiIsc3VidGl0bGUxOiJoNiIsc3VidGl0bGUyOiJoNiIsYm9keTE6InAiLGJvZHkyOiJwIixpbmhlcml0OiJwIn0sZzA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3R7Y29sb3I6ciwuLi5vfT1tZSh7cHJvcHM6dCxuYW1lOiJNdWlUeXBvZ3JhcGh5In0pLGk9IW8yW3JdLHM9aTIoey4uLm8sLi4uaSYme2NvbG9yOnJ9fSkse2FsaWduOmE9ImluaGVyaXQiLGNsYXNzTmFtZTpsLGNvbXBvbmVudDp1LGd1dHRlckJvdHRvbTpjPSExLG5vV3JhcDpkPSExLHBhcmFncmFwaDptPSExLHZhcmlhbnQ6dj0iYm9keTEiLHZhcmlhbnRNYXBwaW5nOnc9ZGgsLi4uU309cyx4PXsuLi5zLGFsaWduOmEsY29sb3I6cixjbGFzc05hbWU6bCxjb21wb25lbnQ6dSxndXR0ZXJCb3R0b206Yyxub1dyYXA6ZCxwYXJhZ3JhcGg6bSx2YXJpYW50OnYsdmFyaWFudE1hcHBpbmc6d30saD11fHwobT8icCI6d1t2XXx8ZGhbdl0pfHwic3BhbiIsZz1zMih4KTtyZXR1cm4gay5qc3goYTIse2FzOmgscmVmOm4sY2xhc3NOYW1lOnRlKGcucm9vdCxsKSwuLi5TLG93bmVyU3RhdGU6eCxzdHlsZTp7Li4uYSE9PSJpbmhlcml0IiYmeyItLVR5cG9ncmFwaHktdGV4dEFsaWduIjphfSwuLi5TLnN0eWxlfX0pfSk7dmFyIFB0PSJ0b3AiLHJuPSJib3R0b20iLG9uPSJyaWdodCIsJHQ9ImxlZnQiLEpmPSJhdXRvIixFcz1bUHQscm4sb24sJHRdLEJvPSJzdGFydCIsbHM9ImVuZCIsbDI9ImNsaXBwaW5nUGFyZW50cyIseTA9InZpZXdwb3J0IixmaT0icG9wcGVyIix1Mj0icmVmZXJlbmNlIixmaD1Fcy5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb25jYXQoW3QrIi0iK0JvLHQrIi0iK2xzXSl9LFtdKSx2MD1bXS5jb25jYXQoRXMsW0pmXSkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY29uY2F0KFt0LHQrIi0iK0JvLHQrIi0iK2xzXSl9LFtdKSxjMj0iYmVmb3JlUmVhZCIsZDI9InJlYWQiLGYyPSJhZnRlclJlYWQiLHAyPSJiZWZvcmVNYWluIixtMj0ibWFpbiIsaDI9ImFmdGVyTWFpbiIsZzI9ImJlZm9yZVdyaXRlIix5Mj0id3JpdGUiLHYyPSJhZnRlcldyaXRlIix3Mj1bYzIsZDIsZjIscDIsbTIsaDIsZzIseTIsdjJdO2Z1bmN0aW9uIExuKGUpe3JldHVybiBlPyhlLm5vZGVOYW1lfHwiIikudG9Mb3dlckNhc2UoKTpudWxsfWZ1bmN0aW9uIEJ0KGUpe2lmKGU9PW51bGwpcmV0dXJuIHdpbmRvdztpZihlLnRvU3RyaW5nKCkhPT0iW29iamVjdCBXaW5kb3ddIil7dmFyIHQ9ZS5vd25lckRvY3VtZW50O3JldHVybiB0JiZ0LmRlZmF1bHRWaWV3fHx3aW5kb3d9cmV0dXJuIGV9ZnVuY3Rpb24gR3IoZSl7dmFyIHQ9QnQoZSkuRWxlbWVudDtyZXR1cm4gZSBpbnN0YW5jZW9mIHR8fGUgaW5zdGFuY2VvZiBFbGVtZW50fWZ1bmN0aW9uIGVuKGUpe3ZhciB0PUJ0KGUpLkhUTUxFbGVtZW50O3JldHVybiBlIGluc3RhbmNlb2YgdHx8ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50fWZ1bmN0aW9uIGVwKGUpe2lmKHR5cGVvZiBTaGFkb3dSb290PiJ1IilyZXR1cm4hMTt2YXIgdD1CdChlKS5TaGFkb3dSb290O3JldHVybiBlIGluc3RhbmNlb2YgdHx8ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3R9ZnVuY3Rpb24gUzIoZSl7dmFyIHQ9ZS5zdGF0ZTtPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciByPXQuc3R5bGVzW25dfHx7fSxvPXQuYXR0cmlidXRlc1tuXXx8e30saT10LmVsZW1lbnRzW25dOyFlbihpKXx8IUxuKGkpfHwoT2JqZWN0LmFzc2lnbihpLnN0eWxlLHIpLE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24ocyl7dmFyIGE9b1tzXTthPT09ITE/aS5yZW1vdmVBdHRyaWJ1dGUocyk6aS5zZXRBdHRyaWJ1dGUocyxhPT09ITA/IiI6YSl9KSl9KX1mdW5jdGlvbiB4MihlKXt2YXIgdD1lLnN0YXRlLG49e3BvcHBlcjp7cG9zaXRpb246dC5vcHRpb25zLnN0cmF0ZWd5LGxlZnQ6IjAiLHRvcDoiMCIsbWFyZ2luOiIwIn0sYXJyb3c6e3Bvc2l0aW9uOiJhYnNvbHV0ZSJ9LHJlZmVyZW5jZTp7fX07cmV0dXJuIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5wb3BwZXIuc3R5bGUsbi5wb3BwZXIpLHQuc3R5bGVzPW4sdC5lbGVtZW50cy5hcnJvdyYmT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLG4uYXJyb3cpLGZ1bmN0aW9uKCl7T2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbihyKXt2YXIgbz10LmVsZW1lbnRzW3JdLGk9dC5hdHRyaWJ1dGVzW3JdfHx7fSxzPU9iamVjdC5rZXlzKHQuc3R5bGVzLmhhc093blByb3BlcnR5KHIpP3Quc3R5bGVzW3JdOm5bcl0pLGE9cy5yZWR1Y2UoZnVuY3Rpb24obCx1KXtyZXR1cm4gbFt1XT0iIixsfSx7fSk7IWVuKG8pfHwhTG4obyl8fChPYmplY3QuYXNzaWduKG8uc3R5bGUsYSksT2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihsKXtvLnJlbW92ZUF0dHJpYnV0ZShsKX0pKX0pfX1jb25zdCBDMj17bmFtZToiYXBwbHlTdHlsZXMiLGVuYWJsZWQ6ITAscGhhc2U6IndyaXRlIixmbjpTMixlZmZlY3Q6eDIscmVxdWlyZXM6WyJjb21wdXRlU3R5bGVzIl19O2Z1bmN0aW9uIEFuKGUpe3JldHVybiBlLnNwbGl0KCItIilbMF19dmFyIFdyPU1hdGgubWF4LEphPU1hdGgubWluLFdvPU1hdGgucm91bmQ7ZnVuY3Rpb24gZmQoKXt2YXIgZT1uYXZpZ2F0b3IudXNlckFnZW50RGF0YTtyZXR1cm4gZSE9bnVsbCYmZS5icmFuZHMmJkFycmF5LmlzQXJyYXkoZS5icmFuZHMpP2UuYnJhbmRzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5icmFuZCsiLyIrdC52ZXJzaW9ufSkuam9pbigiICIpOm5hdmlnYXRvci51c2VyQWdlbnR9ZnVuY3Rpb24gdzAoKXtyZXR1cm4hL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChmZCgpKX1mdW5jdGlvbiBVbyhlLHQsbil7dD09PXZvaWQgMCYmKHQ9ITEpLG49PT12b2lkIDAmJihuPSExKTt2YXIgcj1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG89MSxpPTE7dCYmZW4oZSkmJihvPWUub2Zmc2V0V2lkdGg+MCYmV28oci53aWR0aCkvZS5vZmZzZXRXaWR0aHx8MSxpPWUub2Zmc2V0SGVpZ2h0PjAmJldvKHIuaGVpZ2h0KS9lLm9mZnNldEhlaWdodHx8MSk7dmFyIHM9R3IoZSk/QnQoZSk6d2luZG93LGE9cy52aXN1YWxWaWV3cG9ydCxsPSF3MCgpJiZuLHU9KHIubGVmdCsobCYmYT9hLm9mZnNldExlZnQ6MCkpL28sYz0oci50b3ArKGwmJmE/YS5vZmZzZXRUb3A6MCkpL2ksZD1yLndpZHRoL28sbT1yLmhlaWdodC9pO3JldHVybnt3aWR0aDpkLGhlaWdodDptLHRvcDpjLHJpZ2h0OnUrZCxib3R0b206YyttLGxlZnQ6dSx4OnUseTpjfX1mdW5jdGlvbiB0cChlKXt2YXIgdD1VbyhlKSxuPWUub2Zmc2V0V2lkdGgscj1lLm9mZnNldEhlaWdodDtyZXR1cm4gTWF0aC5hYnModC53aWR0aC1uKTw9MSYmKG49dC53aWR0aCksTWF0aC5hYnModC5oZWlnaHQtcik8PTEmJihyPXQuaGVpZ2h0KSx7eDplLm9mZnNldExlZnQseTplLm9mZnNldFRvcCx3aWR0aDpuLGhlaWdodDpyfX1mdW5jdGlvbiBTMChlLHQpe3ZhciBuPXQuZ2V0Um9vdE5vZGUmJnQuZ2V0Um9vdE5vZGUoKTtpZihlLmNvbnRhaW5zKHQpKXJldHVybiEwO2lmKG4mJmVwKG4pKXt2YXIgcj10O2Rve2lmKHImJmUuaXNTYW1lTm9kZShyKSlyZXR1cm4hMDtyPXIucGFyZW50Tm9kZXx8ci5ob3N0fXdoaWxlKHIpfXJldHVybiExfWZ1bmN0aW9uIEpuKGUpe3JldHVybiBCdChlKS5nZXRDb21wdXRlZFN0eWxlKGUpfWZ1bmN0aW9uIGIyKGUpe3JldHVyblsidGFibGUiLCJ0ZCIsInRoIl0uaW5kZXhPZihMbihlKSk+PTB9ZnVuY3Rpb24gVHIoZSl7cmV0dXJuKChHcihlKT9lLm93bmVyRG9jdW1lbnQ6ZS5kb2N1bWVudCl8fHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50fWZ1bmN0aW9uIGF1KGUpe3JldHVybiBMbihlKT09PSJodG1sIj9lOmUuYXNzaWduZWRTbG90fHxlLnBhcmVudE5vZGV8fChlcChlKT9lLmhvc3Q6bnVsbCl8fFRyKGUpfWZ1bmN0aW9uIHBoKGUpe3JldHVybiFlbihlKXx8Sm4oZSkucG9zaXRpb249PT0iZml4ZWQiP251bGw6ZS5vZmZzZXRQYXJlbnR9ZnVuY3Rpb24gazIoZSl7dmFyIHQ9L2ZpcmVmb3gvaS50ZXN0KGZkKCkpLG49L1RyaWRlbnQvaS50ZXN0KGZkKCkpO2lmKG4mJmVuKGUpKXt2YXIgcj1KbihlKTtpZihyLnBvc2l0aW9uPT09ImZpeGVkIilyZXR1cm4gbnVsbH12YXIgbz1hdShlKTtmb3IoZXAobykmJihvPW8uaG9zdCk7ZW4obykmJlsiaHRtbCIsImJvZHkiXS5pbmRleE9mKExuKG8pKTwwOyl7dmFyIGk9Sm4obyk7aWYoaS50cmFuc2Zvcm0hPT0ibm9uZSJ8fGkucGVyc3BlY3RpdmUhPT0ibm9uZSJ8fGkuY29udGFpbj09PSJwYWludCJ8fFsidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiXS5pbmRleE9mKGkud2lsbENoYW5nZSkhPT0tMXx8dCYmaS53aWxsQ2hhbmdlPT09ImZpbHRlciJ8fHQmJmkuZmlsdGVyJiZpLmZpbHRlciE9PSJub25lIilyZXR1cm4gbztvPW8ucGFyZW50Tm9kZX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBScyhlKXtmb3IodmFyIHQ9QnQoZSksbj1waChlKTtuJiZiMihuKSYmSm4obikucG9zaXRpb249PT0ic3RhdGljIjspbj1waChuKTtyZXR1cm4gbiYmKExuKG4pPT09Imh0bWwifHxMbihuKT09PSJib2R5IiYmSm4obikucG9zaXRpb249PT0ic3RhdGljIik/dDpufHxrMihlKXx8dH1mdW5jdGlvbiBucChlKXtyZXR1cm5bInRvcCIsImJvdHRvbSJdLmluZGV4T2YoZSk+PTA/IngiOiJ5In1mdW5jdGlvbiBBaShlLHQsbil7cmV0dXJuIFdyKGUsSmEodCxuKSl9ZnVuY3Rpb24gRTIoZSx0LG4pe3ZhciByPUFpKGUsdCxuKTtyZXR1cm4gcj5uP246cn1mdW5jdGlvbiB4MCgpe3JldHVybnt0b3A6MCxyaWdodDowLGJvdHRvbTowLGxlZnQ6MH19ZnVuY3Rpb24gQzAoZSl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30seDAoKSxlKX1mdW5jdGlvbiBiMChlLHQpe3JldHVybiB0LnJlZHVjZShmdW5jdGlvbihuLHIpe3JldHVybiBuW3JdPWUsbn0se30pfXZhciBSMj1mdW5jdGlvbih0LG4pe3JldHVybiB0PXR5cGVvZiB0PT0iZnVuY3Rpb24iP3QoT2JqZWN0LmFzc2lnbih7fSxuLnJlY3RzLHtwbGFjZW1lbnQ6bi5wbGFjZW1lbnR9KSk6dCxDMCh0eXBlb2YgdCE9Im51bWJlciI/dDpiMCh0LEVzKSl9O2Z1bmN0aW9uIFQyKGUpe3ZhciB0LG49ZS5zdGF0ZSxyPWUubmFtZSxvPWUub3B0aW9ucyxpPW4uZWxlbWVudHMuYXJyb3cscz1uLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxhPUFuKG4ucGxhY2VtZW50KSxsPW5wKGEpLHU9WyR0LG9uXS5pbmRleE9mKGEpPj0wLGM9dT8iaGVpZ2h0Ijoid2lkdGgiO2lmKCEoIWl8fCFzKSl7dmFyIGQ9UjIoby5wYWRkaW5nLG4pLG09dHAoaSksdj1sPT09InkiP1B0OiR0LHc9bD09PSJ5Ij9ybjpvbixTPW4ucmVjdHMucmVmZXJlbmNlW2NdK24ucmVjdHMucmVmZXJlbmNlW2xdLXNbbF0tbi5yZWN0cy5wb3BwZXJbY10seD1zW2xdLW4ucmVjdHMucmVmZXJlbmNlW2xdLGg9UnMoaSksZz1oP2w9PT0ieSI/aC5jbGllbnRIZWlnaHR8fDA6aC5jbGllbnRXaWR0aHx8MDowLGY9Uy8yLXgvMix5PWRbdl0sYj1nLW1bY10tZFt3XSxFPWcvMi1tW2NdLzIrZixSPUFpKHksRSxiKSxQPWw7bi5tb2RpZmllcnNEYXRhW3JdPSh0PXt9LHRbUF09Uix0LmNlbnRlck9mZnNldD1SLUUsdCl9fWZ1bmN0aW9uIFAyKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1uLmVsZW1lbnQsbz1yPT09dm9pZCAwPyJbZGF0YS1wb3BwZXItYXJyb3ddIjpyO28hPW51bGwmJih0eXBlb2Ygbz09InN0cmluZyImJihvPXQuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IobyksIW8pfHxTMCh0LmVsZW1lbnRzLnBvcHBlcixvKSYmKHQuZWxlbWVudHMuYXJyb3c9bykpfWNvbnN0ICQyPXtuYW1lOiJhcnJvdyIsZW5hYmxlZDohMCxwaGFzZToibWFpbiIsZm46VDIsZWZmZWN0OlAyLHJlcXVpcmVzOlsicG9wcGVyT2Zmc2V0cyJdLHJlcXVpcmVzSWZFeGlzdHM6WyJwcmV2ZW50T3ZlcmZsb3ciXX07ZnVuY3Rpb24gSG8oZSl7cmV0dXJuIGUuc3BsaXQoIi0iKVsxXX12YXIgTzI9e3RvcDoiYXV0byIscmlnaHQ6ImF1dG8iLGJvdHRvbToiYXV0byIsbGVmdDoiYXV0byJ9O2Z1bmN0aW9uIE0yKGUsdCl7dmFyIG49ZS54LHI9ZS55LG89dC5kZXZpY2VQaXhlbFJhdGlvfHwxO3JldHVybnt4OldvKG4qbykvb3x8MCx5OldvKHIqbykvb3x8MH19ZnVuY3Rpb24gbWgoZSl7dmFyIHQsbj1lLnBvcHBlcixyPWUucG9wcGVyUmVjdCxvPWUucGxhY2VtZW50LGk9ZS52YXJpYXRpb24scz1lLm9mZnNldHMsYT1lLnBvc2l0aW9uLGw9ZS5ncHVBY2NlbGVyYXRpb24sdT1lLmFkYXB0aXZlLGM9ZS5yb3VuZE9mZnNldHMsZD1lLmlzRml4ZWQsbT1zLngsdj1tPT09dm9pZCAwPzA6bSx3PXMueSxTPXc9PT12b2lkIDA/MDp3LHg9dHlwZW9mIGM9PSJmdW5jdGlvbiI/Yyh7eDp2LHk6U30pOnt4OnYseTpTfTt2PXgueCxTPXgueTt2YXIgaD1zLmhhc093blByb3BlcnR5KCJ4IiksZz1zLmhhc093blByb3BlcnR5KCJ5IiksZj0kdCx5PVB0LGI9d2luZG93O2lmKHUpe3ZhciBFPVJzKG4pLFI9ImNsaWVudEhlaWdodCIsUD0iY2xpZW50V2lkdGgiO2lmKEU9PT1CdChuKSYmKEU9VHIobiksSm4oRSkucG9zaXRpb24hPT0ic3RhdGljIiYmYT09PSJhYnNvbHV0ZSImJihSPSJzY3JvbGxIZWlnaHQiLFA9InNjcm9sbFdpZHRoIikpLEU9RSxvPT09UHR8fChvPT09JHR8fG89PT1vbikmJmk9PT1scyl7eT1ybjt2YXIgST1kJiZFPT09YiYmYi52aXN1YWxWaWV3cG9ydD9iLnZpc3VhbFZpZXdwb3J0LmhlaWdodDpFW1JdO1MtPUktci5oZWlnaHQsUyo9bD8xOi0xfWlmKG89PT0kdHx8KG89PT1QdHx8bz09PXJuKSYmaT09PWxzKXtmPW9uO3ZhciBwPWQmJkU9PT1iJiZiLnZpc3VhbFZpZXdwb3J0P2IudmlzdWFsVmlld3BvcnQud2lkdGg6RVtQXTt2LT1wLXIud2lkdGgsdio9bD8xOi0xfX12YXIgJD1PYmplY3QuYXNzaWduKHtwb3NpdGlvbjphfSx1JiZPMiksTD1jPT09ITA/TTIoe3g6dix5OlN9LEJ0KG4pKTp7eDp2LHk6U307aWYodj1MLngsUz1MLnksbCl7dmFyIGo7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sJCwoaj17fSxqW3ldPWc/IjAiOiIiLGpbZl09aD8iMCI6IiIsai50cmFuc2Zvcm09KGIuZGV2aWNlUGl4ZWxSYXRpb3x8MSk8PTE/InRyYW5zbGF0ZSgiK3YrInB4LCAiK1MrInB4KSI6InRyYW5zbGF0ZTNkKCIrdisicHgsICIrUysicHgsIDApIixqKSl9cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sJCwodD17fSx0W3ldPWc/UysicHgiOiIiLHRbZl09aD92KyJweCI6IiIsdC50cmFuc2Zvcm09IiIsdCkpfWZ1bmN0aW9uIF8yKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1uLmdwdUFjY2VsZXJhdGlvbixvPXI9PT12b2lkIDA/ITA6cixpPW4uYWRhcHRpdmUscz1pPT09dm9pZCAwPyEwOmksYT1uLnJvdW5kT2Zmc2V0cyxsPWE9PT12b2lkIDA/ITA6YSx1PXtwbGFjZW1lbnQ6QW4odC5wbGFjZW1lbnQpLHZhcmlhdGlvbjpIbyh0LnBsYWNlbWVudCkscG9wcGVyOnQuZWxlbWVudHMucG9wcGVyLHBvcHBlclJlY3Q6dC5yZWN0cy5wb3BwZXIsZ3B1QWNjZWxlcmF0aW9uOm8saXNGaXhlZDp0Lm9wdGlvbnMuc3RyYXRlZ3k9PT0iZml4ZWQifTt0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyE9bnVsbCYmKHQuc3R5bGVzLnBvcHBlcj1PYmplY3QuYXNzaWduKHt9LHQuc3R5bGVzLnBvcHBlcixtaChPYmplY3QuYXNzaWduKHt9LHUse29mZnNldHM6dC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMscG9zaXRpb246dC5vcHRpb25zLnN0cmF0ZWd5LGFkYXB0aXZlOnMscm91bmRPZmZzZXRzOmx9KSkpKSx0Lm1vZGlmaWVyc0RhdGEuYXJyb3chPW51bGwmJih0LnN0eWxlcy5hcnJvdz1PYmplY3QuYXNzaWduKHt9LHQuc3R5bGVzLmFycm93LG1oKE9iamVjdC5hc3NpZ24oe30sdSx7b2Zmc2V0czp0Lm1vZGlmaWVyc0RhdGEuYXJyb3cscG9zaXRpb246ImFic29sdXRlIixhZGFwdGl2ZTohMSxyb3VuZE9mZnNldHM6bH0pKSkpLHQuYXR0cmlidXRlcy5wb3BwZXI9T2JqZWN0LmFzc2lnbih7fSx0LmF0dHJpYnV0ZXMucG9wcGVyLHsiZGF0YS1wb3BwZXItcGxhY2VtZW50Ijp0LnBsYWNlbWVudH0pfWNvbnN0IE4yPXtuYW1lOiJjb21wdXRlU3R5bGVzIixlbmFibGVkOiEwLHBoYXNlOiJiZWZvcmVXcml0ZSIsZm46XzIsZGF0YTp7fX07dmFyIFhzPXtwYXNzaXZlOiEwfTtmdW5jdGlvbiBJMihlKXt2YXIgdD1lLnN0YXRlLG49ZS5pbnN0YW5jZSxyPWUub3B0aW9ucyxvPXIuc2Nyb2xsLGk9bz09PXZvaWQgMD8hMDpvLHM9ci5yZXNpemUsYT1zPT09dm9pZCAwPyEwOnMsbD1CdCh0LmVsZW1lbnRzLnBvcHBlciksdT1bXS5jb25jYXQodC5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSx0LnNjcm9sbFBhcmVudHMucG9wcGVyKTtyZXR1cm4gaSYmdS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2MuYWRkRXZlbnRMaXN0ZW5lcigic2Nyb2xsIixuLnVwZGF0ZSxYcyl9KSxhJiZsLmFkZEV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsbi51cGRhdGUsWHMpLGZ1bmN0aW9uKCl7aSYmdS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigic2Nyb2xsIixuLnVwZGF0ZSxYcyl9KSxhJiZsLnJlbW92ZUV2ZW50TGlzdGVuZXIoInJlc2l6ZSIsbi51cGRhdGUsWHMpfX1jb25zdCBBMj17bmFtZToiZXZlbnRMaXN0ZW5lcnMiLGVuYWJsZWQ6ITAscGhhc2U6IndyaXRlIixmbjpmdW5jdGlvbigpe30sZWZmZWN0OkkyLGRhdGE6e319O3ZhciB6Mj17bGVmdDoicmlnaHQiLHJpZ2h0OiJsZWZ0Iixib3R0b206InRvcCIsdG9wOiJib3R0b20ifTtmdW5jdGlvbiB2YShlKXtyZXR1cm4gZS5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZyxmdW5jdGlvbih0KXtyZXR1cm4gejJbdF19KX12YXIgTDI9e3N0YXJ0OiJlbmQiLGVuZDoic3RhcnQifTtmdW5jdGlvbiBoaChlKXtyZXR1cm4gZS5yZXBsYWNlKC9zdGFydHxlbmQvZyxmdW5jdGlvbih0KXtyZXR1cm4gTDJbdF19KX1mdW5jdGlvbiBycChlKXt2YXIgdD1CdChlKSxuPXQucGFnZVhPZmZzZXQscj10LnBhZ2VZT2Zmc2V0O3JldHVybntzY3JvbGxMZWZ0Om4sc2Nyb2xsVG9wOnJ9fWZ1bmN0aW9uIG9wKGUpe3JldHVybiBVbyhUcihlKSkubGVmdCtycChlKS5zY3JvbGxMZWZ0fWZ1bmN0aW9uIGoyKGUsdCl7dmFyIG49QnQoZSkscj1UcihlKSxvPW4udmlzdWFsVmlld3BvcnQsaT1yLmNsaWVudFdpZHRoLHM9ci5jbGllbnRIZWlnaHQsYT0wLGw9MDtpZihvKXtpPW8ud2lkdGgscz1vLmhlaWdodDt2YXIgdT13MCgpOyh1fHwhdSYmdD09PSJmaXhlZCIpJiYoYT1vLm9mZnNldExlZnQsbD1vLm9mZnNldFRvcCl9cmV0dXJue3dpZHRoOmksaGVpZ2h0OnMseDphK29wKGUpLHk6bH19ZnVuY3Rpb24gRDIoZSl7dmFyIHQsbj1UcihlKSxyPXJwKGUpLG89KHQ9ZS5vd25lckRvY3VtZW50KT09bnVsbD92b2lkIDA6dC5ib2R5LGk9V3Iobi5zY3JvbGxXaWR0aCxuLmNsaWVudFdpZHRoLG8/by5zY3JvbGxXaWR0aDowLG8/by5jbGllbnRXaWR0aDowKSxzPVdyKG4uc2Nyb2xsSGVpZ2h0LG4uY2xpZW50SGVpZ2h0LG8/by5zY3JvbGxIZWlnaHQ6MCxvP28uY2xpZW50SGVpZ2h0OjApLGE9LXIuc2Nyb2xsTGVmdCtvcChlKSxsPS1yLnNjcm9sbFRvcDtyZXR1cm4gSm4ob3x8bikuZGlyZWN0aW9uPT09InJ0bCImJihhKz1XcihuLmNsaWVudFdpZHRoLG8/by5jbGllbnRXaWR0aDowKS1pKSx7d2lkdGg6aSxoZWlnaHQ6cyx4OmEseTpsfX1mdW5jdGlvbiBpcChlKXt2YXIgdD1KbihlKSxuPXQub3ZlcmZsb3cscj10Lm92ZXJmbG93WCxvPXQub3ZlcmZsb3dZO3JldHVybi9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChuK28rcil9ZnVuY3Rpb24gazAoZSl7cmV0dXJuWyJodG1sIiwiYm9keSIsIiNkb2N1bWVudCJdLmluZGV4T2YoTG4oZSkpPj0wP2Uub3duZXJEb2N1bWVudC5ib2R5OmVuKGUpJiZpcChlKT9lOmswKGF1KGUpKX1mdW5jdGlvbiB6aShlLHQpe3ZhciBuO3Q9PT12b2lkIDAmJih0PVtdKTt2YXIgcj1rMChlKSxvPXI9PT0oKG49ZS5vd25lckRvY3VtZW50KT09bnVsbD92b2lkIDA6bi5ib2R5KSxpPUJ0KHIpLHM9bz9baV0uY29uY2F0KGkudmlzdWFsVmlld3BvcnR8fFtdLGlwKHIpP3I6W10pOnIsYT10LmNvbmNhdChzKTtyZXR1cm4gbz9hOmEuY29uY2F0KHppKGF1KHMpKSl9ZnVuY3Rpb24gcGQoZSl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sZSx7bGVmdDplLngsdG9wOmUueSxyaWdodDplLngrZS53aWR0aCxib3R0b206ZS55K2UuaGVpZ2h0fSl9ZnVuY3Rpb24gRjIoZSx0KXt2YXIgbj1VbyhlLCExLHQ9PT0iZml4ZWQiKTtyZXR1cm4gbi50b3A9bi50b3ArZS5jbGllbnRUb3Asbi5sZWZ0PW4ubGVmdCtlLmNsaWVudExlZnQsbi5ib3R0b209bi50b3ArZS5jbGllbnRIZWlnaHQsbi5yaWdodD1uLmxlZnQrZS5jbGllbnRXaWR0aCxuLndpZHRoPWUuY2xpZW50V2lkdGgsbi5oZWlnaHQ9ZS5jbGllbnRIZWlnaHQsbi54PW4ubGVmdCxuLnk9bi50b3Asbn1mdW5jdGlvbiBnaChlLHQsbil7cmV0dXJuIHQ9PT15MD9wZChqMihlLG4pKTpHcih0KT9GMih0LG4pOnBkKEQyKFRyKGUpKSl9ZnVuY3Rpb24gQjIoZSl7dmFyIHQ9emkoYXUoZSkpLG49WyJhYnNvbHV0ZSIsImZpeGVkIl0uaW5kZXhPZihKbihlKS5wb3NpdGlvbik+PTAscj1uJiZlbihlKT9ScyhlKTplO3JldHVybiBHcihyKT90LmZpbHRlcihmdW5jdGlvbihvKXtyZXR1cm4gR3IobykmJlMwKG8scikmJkxuKG8pIT09ImJvZHkifSk6W119ZnVuY3Rpb24gVzIoZSx0LG4scil7dmFyIG89dD09PSJjbGlwcGluZ1BhcmVudHMiP0IyKGUpOltdLmNvbmNhdCh0KSxpPVtdLmNvbmNhdChvLFtuXSkscz1pWzBdLGE9aS5yZWR1Y2UoZnVuY3Rpb24obCx1KXt2YXIgYz1naChlLHUscik7cmV0dXJuIGwudG9wPVdyKGMudG9wLGwudG9wKSxsLnJpZ2h0PUphKGMucmlnaHQsbC5yaWdodCksbC5ib3R0b209SmEoYy5ib3R0b20sbC5ib3R0b20pLGwubGVmdD1XcihjLmxlZnQsbC5sZWZ0KSxsfSxnaChlLHMscikpO3JldHVybiBhLndpZHRoPWEucmlnaHQtYS5sZWZ0LGEuaGVpZ2h0PWEuYm90dG9tLWEudG9wLGEueD1hLmxlZnQsYS55PWEudG9wLGF9ZnVuY3Rpb24gRTAoZSl7dmFyIHQ9ZS5yZWZlcmVuY2Usbj1lLmVsZW1lbnQscj1lLnBsYWNlbWVudCxvPXI/QW4ocik6bnVsbCxpPXI/SG8ocik6bnVsbCxzPXQueCt0LndpZHRoLzItbi53aWR0aC8yLGE9dC55K3QuaGVpZ2h0LzItbi5oZWlnaHQvMixsO3N3aXRjaChvKXtjYXNlIFB0Omw9e3g6cyx5OnQueS1uLmhlaWdodH07YnJlYWs7Y2FzZSBybjpsPXt4OnMseTp0LnkrdC5oZWlnaHR9O2JyZWFrO2Nhc2Ugb246bD17eDp0LngrdC53aWR0aCx5OmF9O2JyZWFrO2Nhc2UgJHQ6bD17eDp0Lngtbi53aWR0aCx5OmF9O2JyZWFrO2RlZmF1bHQ6bD17eDp0LngseTp0Lnl9fXZhciB1PW8/bnAobyk6bnVsbDtpZih1IT1udWxsKXt2YXIgYz11PT09InkiPyJoZWlnaHQiOiJ3aWR0aCI7c3dpdGNoKGkpe2Nhc2UgQm86bFt1XT1sW3VdLSh0W2NdLzItbltjXS8yKTticmVhaztjYXNlIGxzOmxbdV09bFt1XSsodFtjXS8yLW5bY10vMik7YnJlYWt9fXJldHVybiBsfWZ1bmN0aW9uIHVzKGUsdCl7dD09PXZvaWQgMCYmKHQ9e30pO3ZhciBuPXQscj1uLnBsYWNlbWVudCxvPXI9PT12b2lkIDA/ZS5wbGFjZW1lbnQ6cixpPW4uc3RyYXRlZ3kscz1pPT09dm9pZCAwP2Uuc3RyYXRlZ3k6aSxhPW4uYm91bmRhcnksbD1hPT09dm9pZCAwP2wyOmEsdT1uLnJvb3RCb3VuZGFyeSxjPXU9PT12b2lkIDA/eTA6dSxkPW4uZWxlbWVudENvbnRleHQsbT1kPT09dm9pZCAwP2ZpOmQsdj1uLmFsdEJvdW5kYXJ5LHc9dj09PXZvaWQgMD8hMTp2LFM9bi5wYWRkaW5nLHg9Uz09PXZvaWQgMD8wOlMsaD1DMCh0eXBlb2YgeCE9Im51bWJlciI/eDpiMCh4LEVzKSksZz1tPT09Zmk/dTI6ZmksZj1lLnJlY3RzLnBvcHBlcix5PWUuZWxlbWVudHNbdz9nOm1dLGI9VzIoR3IoeSk/eTp5LmNvbnRleHRFbGVtZW50fHxUcihlLmVsZW1lbnRzLnBvcHBlciksbCxjLHMpLEU9VW8oZS5lbGVtZW50cy5yZWZlcmVuY2UpLFI9RTAoe3JlZmVyZW5jZTpFLGVsZW1lbnQ6ZixzdHJhdGVneToiYWJzb2x1dGUiLHBsYWNlbWVudDpvfSksUD1wZChPYmplY3QuYXNzaWduKHt9LGYsUikpLEk9bT09PWZpP1A6RSxwPXt0b3A6Yi50b3AtSS50b3AraC50b3AsYm90dG9tOkkuYm90dG9tLWIuYm90dG9tK2guYm90dG9tLGxlZnQ6Yi5sZWZ0LUkubGVmdCtoLmxlZnQscmlnaHQ6SS5yaWdodC1iLnJpZ2h0K2gucmlnaHR9LCQ9ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtpZihtPT09ZmkmJiQpe3ZhciBMPSRbb107T2JqZWN0LmtleXMocCkuZm9yRWFjaChmdW5jdGlvbihqKXt2YXIgTj1bb24scm5dLmluZGV4T2Yoaik+PTA/MTotMSxPPVtQdCxybl0uaW5kZXhPZihqKT49MD8ieSI6IngiO3Bbal0rPUxbT10qTn0pfXJldHVybiBwfWZ1bmN0aW9uIFUyKGUsdCl7dD09PXZvaWQgMCYmKHQ9e30pO3ZhciBuPXQscj1uLnBsYWNlbWVudCxvPW4uYm91bmRhcnksaT1uLnJvb3RCb3VuZGFyeSxzPW4ucGFkZGluZyxhPW4uZmxpcFZhcmlhdGlvbnMsbD1uLmFsbG93ZWRBdXRvUGxhY2VtZW50cyx1PWw9PT12b2lkIDA/djA6bCxjPUhvKHIpLGQ9Yz9hP2ZoOmZoLmZpbHRlcihmdW5jdGlvbih3KXtyZXR1cm4gSG8odyk9PT1jfSk6RXMsbT1kLmZpbHRlcihmdW5jdGlvbih3KXtyZXR1cm4gdS5pbmRleE9mKHcpPj0wfSk7bS5sZW5ndGg9PT0wJiYobT1kKTt2YXIgdj1tLnJlZHVjZShmdW5jdGlvbih3LFMpe3JldHVybiB3W1NdPXVzKGUse3BsYWNlbWVudDpTLGJvdW5kYXJ5Om8scm9vdEJvdW5kYXJ5OmkscGFkZGluZzpzfSlbQW4oUyldLHd9LHt9KTtyZXR1cm4gT2JqZWN0LmtleXModikuc29ydChmdW5jdGlvbih3LFMpe3JldHVybiB2W3ddLXZbU119KX1mdW5jdGlvbiBIMihlKXtpZihBbihlKT09PUpmKXJldHVybltdO3ZhciB0PXZhKGUpO3JldHVybltoaChlKSx0LGhoKHQpXX1mdW5jdGlvbiBWMihlKXt2YXIgdD1lLnN0YXRlLG49ZS5vcHRpb25zLHI9ZS5uYW1lO2lmKCF0Lm1vZGlmaWVyc0RhdGFbcl0uX3NraXApe2Zvcih2YXIgbz1uLm1haW5BeGlzLGk9bz09PXZvaWQgMD8hMDpvLHM9bi5hbHRBeGlzLGE9cz09PXZvaWQgMD8hMDpzLGw9bi5mYWxsYmFja1BsYWNlbWVudHMsdT1uLnBhZGRpbmcsYz1uLmJvdW5kYXJ5LGQ9bi5yb290Qm91bmRhcnksbT1uLmFsdEJvdW5kYXJ5LHY9bi5mbGlwVmFyaWF0aW9ucyx3PXY9PT12b2lkIDA/ITA6dixTPW4uYWxsb3dlZEF1dG9QbGFjZW1lbnRzLHg9dC5vcHRpb25zLnBsYWNlbWVudCxoPUFuKHgpLGc9aD09PXgsZj1sfHwoZ3x8IXc/W3ZhKHgpXTpIMih4KSkseT1beF0uY29uY2F0KGYpLnJlZHVjZShmdW5jdGlvbihVLFgpe3JldHVybiBVLmNvbmNhdChBbihYKT09PUpmP1UyKHQse3BsYWNlbWVudDpYLGJvdW5kYXJ5OmMscm9vdEJvdW5kYXJ5OmQscGFkZGluZzp1LGZsaXBWYXJpYXRpb25zOncsYWxsb3dlZEF1dG9QbGFjZW1lbnRzOlN9KTpYKX0sW10pLGI9dC5yZWN0cy5yZWZlcmVuY2UsRT10LnJlY3RzLnBvcHBlcixSPW5ldyBNYXAsUD0hMCxJPXlbMF0scD0wO3A8eS5sZW5ndGg7cCsrKXt2YXIgJD15W3BdLEw9QW4oJCksaj1IbygkKT09PUJvLE49W1B0LHJuXS5pbmRleE9mKEwpPj0wLE89Tj8id2lkdGgiOiJoZWlnaHQiLE09dXModCx7cGxhY2VtZW50OiQsYm91bmRhcnk6Yyxyb290Qm91bmRhcnk6ZCxhbHRCb3VuZGFyeTptLHBhZGRpbmc6dX0pLF89Tj9qP29uOiR0Omo/cm46UHQ7YltPXT5FW09dJiYoXz12YShfKSk7dmFyIFQ9dmEoXyksQT1bXTtpZihpJiZBLnB1c2goTVtMXTw9MCksYSYmQS5wdXNoKE1bX108PTAsTVtUXTw9MCksQS5ldmVyeShmdW5jdGlvbihVKXtyZXR1cm4gVX0pKXtJPSQsUD0hMTticmVha31SLnNldCgkLEEpfWlmKFApZm9yKHZhciBEPXc/MzoxLEI9ZnVuY3Rpb24oWCl7dmFyIFc9eS5maW5kKGZ1bmN0aW9uKEope3ZhciBvZT1SLmdldChKKTtpZihvZSlyZXR1cm4gb2Uuc2xpY2UoMCxYKS5ldmVyeShmdW5jdGlvbihyZSl7cmV0dXJuIHJlfSl9KTtpZihXKXJldHVybiBJPVcsImJyZWFrIn0sSD1EO0g+MDtILS0pe3ZhciBWPUIoSCk7aWYoVj09PSJicmVhayIpYnJlYWt9dC5wbGFjZW1lbnQhPT1JJiYodC5tb2RpZmllcnNEYXRhW3JdLl9za2lwPSEwLHQucGxhY2VtZW50PUksdC5yZXNldD0hMCl9fWNvbnN0IEsyPXtuYW1lOiJmbGlwIixlbmFibGVkOiEwLHBoYXNlOiJtYWluIixmbjpWMixyZXF1aXJlc0lmRXhpc3RzOlsib2Zmc2V0Il0sZGF0YTp7X3NraXA6ITF9fTtmdW5jdGlvbiB5aChlLHQsbil7cmV0dXJuIG49PT12b2lkIDAmJihuPXt4OjAseTowfSkse3RvcDplLnRvcC10LmhlaWdodC1uLnkscmlnaHQ6ZS5yaWdodC10LndpZHRoK24ueCxib3R0b206ZS5ib3R0b20tdC5oZWlnaHQrbi55LGxlZnQ6ZS5sZWZ0LXQud2lkdGgtbi54fX1mdW5jdGlvbiB2aChlKXtyZXR1cm5bUHQsb24scm4sJHRdLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0+PTB9KX1mdW5jdGlvbiBZMihlKXt2YXIgdD1lLnN0YXRlLG49ZS5uYW1lLHI9dC5yZWN0cy5yZWZlcmVuY2Usbz10LnJlY3RzLnBvcHBlcixpPXQubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3cscz11cyh0LHtlbGVtZW50Q29udGV4dDoicmVmZXJlbmNlIn0pLGE9dXModCx7YWx0Qm91bmRhcnk6ITB9KSxsPXloKHMsciksdT15aChhLG8saSksYz12aChsKSxkPXZoKHUpO3QubW9kaWZpZXJzRGF0YVtuXT17cmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOmwscG9wcGVyRXNjYXBlT2Zmc2V0czp1LGlzUmVmZXJlbmNlSGlkZGVuOmMsaGFzUG9wcGVyRXNjYXBlZDpkfSx0LmF0dHJpYnV0ZXMucG9wcGVyPU9iamVjdC5hc3NpZ24oe30sdC5hdHRyaWJ1dGVzLnBvcHBlcix7ImRhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4iOmMsImRhdGEtcG9wcGVyLWVzY2FwZWQiOmR9KX1jb25zdCBHMj17bmFtZToiaGlkZSIsZW5hYmxlZDohMCxwaGFzZToibWFpbiIscmVxdWlyZXNJZkV4aXN0czpbInByZXZlbnRPdmVyZmxvdyJdLGZuOlkyfTtmdW5jdGlvbiBRMihlLHQsbil7dmFyIHI9QW4oZSksbz1bJHQsUHRdLmluZGV4T2Yocik+PTA/LTE6MSxpPXR5cGVvZiBuPT0iZnVuY3Rpb24iP24oT2JqZWN0LmFzc2lnbih7fSx0LHtwbGFjZW1lbnQ6ZX0pKTpuLHM9aVswXSxhPWlbMV07cmV0dXJuIHM9c3x8MCxhPShhfHwwKSpvLFskdCxvbl0uaW5kZXhPZihyKT49MD97eDphLHk6c306e3g6cyx5OmF9fWZ1bmN0aW9uIFgyKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1lLm5hbWUsbz1uLm9mZnNldCxpPW89PT12b2lkIDA/WzAsMF06byxzPXYwLnJlZHVjZShmdW5jdGlvbihjLGQpe3JldHVybiBjW2RdPVEyKGQsdC5yZWN0cyxpKSxjfSx7fSksYT1zW3QucGxhY2VtZW50XSxsPWEueCx1PWEueTt0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyE9bnVsbCYmKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLngrPWwsdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSs9dSksdC5tb2RpZmllcnNEYXRhW3JdPXN9Y29uc3QgcTI9e25hbWU6Im9mZnNldCIsZW5hYmxlZDohMCxwaGFzZToibWFpbiIscmVxdWlyZXM6WyJwb3BwZXJPZmZzZXRzIl0sZm46WDJ9O2Z1bmN0aW9uIFoyKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm5hbWU7dC5tb2RpZmllcnNEYXRhW25dPUUwKHtyZWZlcmVuY2U6dC5yZWN0cy5yZWZlcmVuY2UsZWxlbWVudDp0LnJlY3RzLnBvcHBlcixzdHJhdGVneToiYWJzb2x1dGUiLHBsYWNlbWVudDp0LnBsYWNlbWVudH0pfWNvbnN0IEoyPXtuYW1lOiJwb3BwZXJPZmZzZXRzIixlbmFibGVkOiEwLHBoYXNlOiJyZWFkIixmbjpaMixkYXRhOnt9fTtmdW5jdGlvbiBlUihlKXtyZXR1cm4gZT09PSJ4Ij8ieSI6IngifWZ1bmN0aW9uIHRSKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1lLm5hbWUsbz1uLm1haW5BeGlzLGk9bz09PXZvaWQgMD8hMDpvLHM9bi5hbHRBeGlzLGE9cz09PXZvaWQgMD8hMTpzLGw9bi5ib3VuZGFyeSx1PW4ucm9vdEJvdW5kYXJ5LGM9bi5hbHRCb3VuZGFyeSxkPW4ucGFkZGluZyxtPW4udGV0aGVyLHY9bT09PXZvaWQgMD8hMDptLHc9bi50ZXRoZXJPZmZzZXQsUz13PT09dm9pZCAwPzA6dyx4PXVzKHQse2JvdW5kYXJ5Omwscm9vdEJvdW5kYXJ5OnUscGFkZGluZzpkLGFsdEJvdW5kYXJ5OmN9KSxoPUFuKHQucGxhY2VtZW50KSxnPUhvKHQucGxhY2VtZW50KSxmPSFnLHk9bnAoaCksYj1lUih5KSxFPXQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFI9dC5yZWN0cy5yZWZlcmVuY2UsUD10LnJlY3RzLnBvcHBlcixJPXR5cGVvZiBTPT0iZnVuY3Rpb24iP1MoT2JqZWN0LmFzc2lnbih7fSx0LnJlY3RzLHtwbGFjZW1lbnQ6dC5wbGFjZW1lbnR9KSk6UyxwPXR5cGVvZiBJPT0ibnVtYmVyIj97bWFpbkF4aXM6SSxhbHRBeGlzOkl9Ok9iamVjdC5hc3NpZ24oe21haW5BeGlzOjAsYWx0QXhpczowfSxJKSwkPXQubW9kaWZpZXJzRGF0YS5vZmZzZXQ/dC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF06bnVsbCxMPXt4OjAseTowfTtpZihFKXtpZihpKXt2YXIgaixOPXk9PT0ieSI/UHQ6JHQsTz15PT09InkiP3JuOm9uLE09eT09PSJ5Ij8iaGVpZ2h0Ijoid2lkdGgiLF89RVt5XSxUPV8reFtOXSxBPV8teFtPXSxEPXY/LVBbTV0vMjowLEI9Zz09PUJvP1JbTV06UFtNXSxIPWc9PT1Cbz8tUFtNXTotUltNXSxWPXQuZWxlbWVudHMuYXJyb3csVT12JiZWP3RwKFYpOnt3aWR0aDowLGhlaWdodDowfSxYPXQubW9kaWZpZXJzRGF0YVsiYXJyb3cjcGVyc2lzdGVudCJdP3QubW9kaWZpZXJzRGF0YVsiYXJyb3cjcGVyc2lzdGVudCJdLnBhZGRpbmc6eDAoKSxXPVhbTl0sSj1YW09dLG9lPUFpKDAsUltNXSxVW01dKSxyZT1mP1JbTV0vMi1ELW9lLVctcC5tYWluQXhpczpCLW9lLVctcC5tYWluQXhpcyxRPWY/LVJbTV0vMitEK29lK0orcC5tYWluQXhpczpIK29lK0orcC5tYWluQXhpcyxlZT10LmVsZW1lbnRzLmFycm93JiZScyh0LmVsZW1lbnRzLmFycm93KSxZPWVlP3k9PT0ieSI/ZWUuY2xpZW50VG9wfHwwOmVlLmNsaWVudExlZnR8fDA6MCx1ZT0oaj0kPT1udWxsP3ZvaWQgMDokW3ldKSE9bnVsbD9qOjAsaWU9XytyZS11ZS1ZLGZlPV8rUS11ZSxaZT1BaSh2P0phKFQsaWUpOlQsXyx2P1dyKEEsZmUpOkEpO0VbeV09WmUsTFt5XT1aZS1ffWlmKGEpe3ZhciBWZSxPZT15PT09IngiP1B0OiR0LE5lPXk9PT0ieCI/cm46b24sV2U9RVtiXSxoZT1iPT09InkiPyJoZWlnaHQiOiJ3aWR0aCIsaHQ9V2UreFtPZV0scT1XZS14W05lXSxJZT1bUHQsJHRdLmluZGV4T2YoaCkhPT0tMSx4bj0oVmU9JD09bnVsbD92b2lkIDA6JFtiXSkhPW51bGw/VmU6MCxTdD1JZT9odDpXZS1SW2hlXS1QW2hlXS14bitwLmFsdEF4aXMseHQ9SWU/V2UrUltoZV0rUFtoZV0teG4tcC5hbHRBeGlzOnEsQ249diYmSWU/RTIoU3QsV2UseHQpOkFpKHY/U3Q6aHQsV2Usdj94dDpxKTtFW2JdPUNuLExbYl09Q24tV2V9dC5tb2RpZmllcnNEYXRhW3JdPUx9fWNvbnN0IG5SPXtuYW1lOiJwcmV2ZW50T3ZlcmZsb3ciLGVuYWJsZWQ6ITAscGhhc2U6Im1haW4iLGZuOnRSLHJlcXVpcmVzSWZFeGlzdHM6WyJvZmZzZXQiXX07ZnVuY3Rpb24gclIoZSl7cmV0dXJue3Njcm9sbExlZnQ6ZS5zY3JvbGxMZWZ0LHNjcm9sbFRvcDplLnNjcm9sbFRvcH19ZnVuY3Rpb24gb1IoZSl7cmV0dXJuIGU9PT1CdChlKXx8IWVuKGUpP3JwKGUpOnJSKGUpfWZ1bmN0aW9uIGlSKGUpe3ZhciB0PWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj1Xbyh0LndpZHRoKS9lLm9mZnNldFdpZHRofHwxLHI9V28odC5oZWlnaHQpL2Uub2Zmc2V0SGVpZ2h0fHwxO3JldHVybiBuIT09MXx8ciE9PTF9ZnVuY3Rpb24gc1IoZSx0LG4pe249PT12b2lkIDAmJihuPSExKTt2YXIgcj1lbih0KSxvPWVuKHQpJiZpUih0KSxpPVRyKHQpLHM9VW8oZSxvLG4pLGE9e3Njcm9sbExlZnQ6MCxzY3JvbGxUb3A6MH0sbD17eDowLHk6MH07cmV0dXJuKHJ8fCFyJiYhbikmJigoTG4odCkhPT0iYm9keSJ8fGlwKGkpKSYmKGE9b1IodCkpLGVuKHQpPyhsPVVvKHQsITApLGwueCs9dC5jbGllbnRMZWZ0LGwueSs9dC5jbGllbnRUb3ApOmkmJihsLng9b3AoaSkpKSx7eDpzLmxlZnQrYS5zY3JvbGxMZWZ0LWwueCx5OnMudG9wK2Euc2Nyb2xsVG9wLWwueSx3aWR0aDpzLndpZHRoLGhlaWdodDpzLmhlaWdodH19ZnVuY3Rpb24gYVIoZSl7dmFyIHQ9bmV3IE1hcCxuPW5ldyBTZXQscj1bXTtlLmZvckVhY2goZnVuY3Rpb24oaSl7dC5zZXQoaS5uYW1lLGkpfSk7ZnVuY3Rpb24gbyhpKXtuLmFkZChpLm5hbWUpO3ZhciBzPVtdLmNvbmNhdChpLnJlcXVpcmVzfHxbXSxpLnJlcXVpcmVzSWZFeGlzdHN8fFtdKTtzLmZvckVhY2goZnVuY3Rpb24oYSl7aWYoIW4uaGFzKGEpKXt2YXIgbD10LmdldChhKTtsJiZvKGwpfX0pLHIucHVzaChpKX1yZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGkpe24uaGFzKGkubmFtZSl8fG8oaSl9KSxyfWZ1bmN0aW9uIGxSKGUpe3ZhciB0PWFSKGUpO3JldHVybiB3Mi5yZWR1Y2UoZnVuY3Rpb24obixyKXtyZXR1cm4gbi5jb25jYXQodC5maWx0ZXIoZnVuY3Rpb24obyl7cmV0dXJuIG8ucGhhc2U9PT1yfSkpfSxbXSl9ZnVuY3Rpb24gdVIoZSl7dmFyIHQ7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR8fCh0PW5ldyBQcm9taXNlKGZ1bmN0aW9uKG4pe1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXt0PXZvaWQgMCxuKGUoKSl9KX0pKSx0fX1mdW5jdGlvbiBjUihlKXt2YXIgdD1lLnJlZHVjZShmdW5jdGlvbihuLHIpe3ZhciBvPW5bci5uYW1lXTtyZXR1cm4gbltyLm5hbWVdPW8/T2JqZWN0LmFzc2lnbih7fSxvLHIse29wdGlvbnM6T2JqZWN0LmFzc2lnbih7fSxvLm9wdGlvbnMsci5vcHRpb25zKSxkYXRhOk9iamVjdC5hc3NpZ24oe30sby5kYXRhLHIuZGF0YSl9KTpyLG59LHt9KTtyZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiB0W25dfSl9dmFyIHdoPXtwbGFjZW1lbnQ6ImJvdHRvbSIsbW9kaWZpZXJzOltdLHN0cmF0ZWd5OiJhYnNvbHV0ZSJ9O2Z1bmN0aW9uIFNoKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGgsdD1uZXcgQXJyYXkoZSksbj0wO248ZTtuKyspdFtuXT1hcmd1bWVudHNbbl07cmV0dXJuIXQuc29tZShmdW5jdGlvbihyKXtyZXR1cm4hKHImJnR5cGVvZiByLmdldEJvdW5kaW5nQ2xpZW50UmVjdD09ImZ1bmN0aW9uIil9KX1mdW5jdGlvbiBkUihlKXtlPT09dm9pZCAwJiYoZT17fSk7dmFyIHQ9ZSxuPXQuZGVmYXVsdE1vZGlmaWVycyxyPW49PT12b2lkIDA/W106bixvPXQuZGVmYXVsdE9wdGlvbnMsaT1vPT09dm9pZCAwP3doOm87cmV0dXJuIGZ1bmN0aW9uKGEsbCx1KXt1PT09dm9pZCAwJiYodT1pKTt2YXIgYz17cGxhY2VtZW50OiJib3R0b20iLG9yZGVyZWRNb2RpZmllcnM6W10sb3B0aW9uczpPYmplY3QuYXNzaWduKHt9LHdoLGkpLG1vZGlmaWVyc0RhdGE6e30sZWxlbWVudHM6e3JlZmVyZW5jZTphLHBvcHBlcjpsfSxhdHRyaWJ1dGVzOnt9LHN0eWxlczp7fX0sZD1bXSxtPSExLHY9e3N0YXRlOmMsc2V0T3B0aW9uczpmdW5jdGlvbihoKXt2YXIgZz10eXBlb2YgaD09ImZ1bmN0aW9uIj9oKGMub3B0aW9ucyk6aDtTKCksYy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe30saSxjLm9wdGlvbnMsZyksYy5zY3JvbGxQYXJlbnRzPXtyZWZlcmVuY2U6R3IoYSk/emkoYSk6YS5jb250ZXh0RWxlbWVudD96aShhLmNvbnRleHRFbGVtZW50KTpbXSxwb3BwZXI6emkobCl9O3ZhciBmPWxSKGNSKFtdLmNvbmNhdChyLGMub3B0aW9ucy5tb2RpZmllcnMpKSk7cmV0dXJuIGMub3JkZXJlZE1vZGlmaWVycz1mLmZpbHRlcihmdW5jdGlvbih5KXtyZXR1cm4geS5lbmFibGVkfSksdygpLHYudXBkYXRlKCl9LGZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7aWYoIW0pe3ZhciBoPWMuZWxlbWVudHMsZz1oLnJlZmVyZW5jZSxmPWgucG9wcGVyO2lmKFNoKGcsZikpe2MucmVjdHM9e3JlZmVyZW5jZTpzUihnLFJzKGYpLGMub3B0aW9ucy5zdHJhdGVneT09PSJmaXhlZCIpLHBvcHBlcjp0cChmKX0sYy5yZXNldD0hMSxjLnBsYWNlbWVudD1jLm9wdGlvbnMucGxhY2VtZW50LGMub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKHApe3JldHVybiBjLm1vZGlmaWVyc0RhdGFbcC5uYW1lXT1PYmplY3QuYXNzaWduKHt9LHAuZGF0YSl9KTtmb3IodmFyIHk9MDt5PGMub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7eSsrKXtpZihjLnJlc2V0PT09ITApe2MucmVzZXQ9ITEseT0tMTtjb250aW51ZX12YXIgYj1jLm9yZGVyZWRNb2RpZmllcnNbeV0sRT1iLmZuLFI9Yi5vcHRpb25zLFA9Uj09PXZvaWQgMD97fTpSLEk9Yi5uYW1lO3R5cGVvZiBFPT0iZnVuY3Rpb24iJiYoYz1FKHtzdGF0ZTpjLG9wdGlvbnM6UCxuYW1lOkksaW5zdGFuY2U6dn0pfHxjKX19fX0sdXBkYXRlOnVSKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHgpe3YuZm9yY2VVcGRhdGUoKSx4KGMpfSl9KSxkZXN0cm95OmZ1bmN0aW9uKCl7UygpLG09ITB9fTtpZighU2goYSxsKSlyZXR1cm4gdjt2LnNldE9wdGlvbnModSkudGhlbihmdW5jdGlvbih4KXshbSYmdS5vbkZpcnN0VXBkYXRlJiZ1Lm9uRmlyc3RVcGRhdGUoeCl9KTtmdW5jdGlvbiB3KCl7Yy5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oeCl7dmFyIGg9eC5uYW1lLGc9eC5vcHRpb25zLGY9Zz09PXZvaWQgMD97fTpnLHk9eC5lZmZlY3Q7aWYodHlwZW9mIHk9PSJmdW5jdGlvbiIpe3ZhciBiPXkoe3N0YXRlOmMsbmFtZTpoLGluc3RhbmNlOnYsb3B0aW9uczpmfSksRT1mdW5jdGlvbigpe307ZC5wdXNoKGJ8fEUpfX0pfWZ1bmN0aW9uIFMoKXtkLmZvckVhY2goZnVuY3Rpb24oeCl7cmV0dXJuIHgoKX0pLGQ9W119cmV0dXJuIHZ9fXZhciBmUj1bQTIsSjIsTjIsQzIscTIsSzIsblIsJDIsRzJdLHBSPWRSKHtkZWZhdWx0TW9kaWZpZXJzOmZSfSk7ZnVuY3Rpb24gbVIoZSl7cmV0dXJuIHR5cGVvZiBlPT0iZnVuY3Rpb24iP2UoKTplfWNvbnN0IFIwPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0e2NoaWxkcmVuOnIsY29udGFpbmVyOm8sZGlzYWJsZVBvcnRhbDppPSExfT10LFtzLGFdPUMudXNlU3RhdGUobnVsbCksbD1RZShDLmlzVmFsaWRFbGVtZW50KHIpP1FvKHIpOm51bGwsbik7aWYoWW4oKCk9PntpfHxhKG1SKG8pfHxkb2N1bWVudC5ib2R5KX0sW28saV0pLFluKCgpPT57aWYocyYmIWkpcmV0dXJuIGZjKG4scyksKCk9PntmYyhuLG51bGwpfX0sW24scyxpXSksaSl7aWYoQy5pc1ZhbGlkRWxlbWVudChyKSl7Y29uc3QgdT17cmVmOmx9O3JldHVybiBDLmNsb25lRWxlbWVudChyLHUpfXJldHVybiBrLmpzeChDLkZyYWdtZW50LHtjaGlsZHJlbjpyfSl9cmV0dXJuIGsuanN4KEMuRnJhZ21lbnQse2NoaWxkcmVuOnMmJllmLmNyZWF0ZVBvcnRhbChyLHMpfSl9KTtmdW5jdGlvbiBoUihlKXtyZXR1cm4gY2UoIk11aVBvcHBlciIsZSl9ZGUoIk11aVBvcHBlciIsWyJyb290Il0pO2Z1bmN0aW9uIGdSKGUsdCl7aWYodD09PSJsdHIiKXJldHVybiBlO3N3aXRjaChlKXtjYXNlImJvdHRvbS1lbmQiOnJldHVybiJib3R0b20tc3RhcnQiO2Nhc2UiYm90dG9tLXN0YXJ0IjpyZXR1cm4iYm90dG9tLWVuZCI7Y2FzZSJ0b3AtZW5kIjpyZXR1cm4idG9wLXN0YXJ0IjtjYXNlInRvcC1zdGFydCI6cmV0dXJuInRvcC1lbmQiO2RlZmF1bHQ6cmV0dXJuIGV9fWZ1bmN0aW9uIG1kKGUpe3JldHVybiB0eXBlb2YgZT09ImZ1bmN0aW9uIj9lKCk6ZX1mdW5jdGlvbiB5UihlKXtyZXR1cm4gZS5ub2RlVHlwZSE9PXZvaWQgMH1jb25zdCB2Uj1lPT57Y29uc3R7Y2xhc3Nlczp0fT1lO3JldHVybiBwZSh7cm9vdDpbInJvb3QiXX0saFIsdCl9LHdSPXt9LFNSPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0e2FuY2hvckVsOnIsY2hpbGRyZW46byxkaXJlY3Rpb246aSxkaXNhYmxlUG9ydGFsOnMsbW9kaWZpZXJzOmEsb3BlbjpsLHBsYWNlbWVudDp1LHBvcHBlck9wdGlvbnM6Yyxwb3BwZXJSZWY6ZCxzbG90UHJvcHM6bT17fSxzbG90czp2PXt9LFRyYW5zaXRpb25Qcm9wczp3LG93bmVyU3RhdGU6UywuLi54fT10LGg9Qy51c2VSZWYobnVsbCksZz1RZShoLG4pLGY9Qy51c2VSZWYobnVsbCkseT1RZShmLGQpLGI9Qy51c2VSZWYoeSk7WW4oKCk9PntiLmN1cnJlbnQ9eX0sW3ldKSxDLnVzZUltcGVyYXRpdmVIYW5kbGUoZCwoKT0+Zi5jdXJyZW50LFtdKTtjb25zdCBFPWdSKHUsaSksW1IsUF09Qy51c2VTdGF0ZShFKSxbSSxwXT1DLnVzZVN0YXRlKG1kKHIpKTtDLnVzZUVmZmVjdCgoKT0+e2YuY3VycmVudCYmZi5jdXJyZW50LmZvcmNlVXBkYXRlKCl9KSxDLnVzZUVmZmVjdCgoKT0+e3ImJnAobWQocikpfSxbcl0pLFluKCgpPT57aWYoIUl8fCFsKXJldHVybjtjb25zdCBPPVQ9PntQKFQucGxhY2VtZW50KX07bGV0IE09W3tuYW1lOiJwcmV2ZW50T3ZlcmZsb3ciLG9wdGlvbnM6e2FsdEJvdW5kYXJ5OnN9fSx7bmFtZToiZmxpcCIsb3B0aW9uczp7YWx0Qm91bmRhcnk6c319LHtuYW1lOiJvblVwZGF0ZSIsZW5hYmxlZDohMCxwaGFzZToiYWZ0ZXJXcml0ZSIsZm46KHtzdGF0ZTpUfSk9PntPKFQpfX1dO2EhPW51bGwmJihNPU0uY29uY2F0KGEpKSxjJiZjLm1vZGlmaWVycyE9bnVsbCYmKE09TS5jb25jYXQoYy5tb2RpZmllcnMpKTtjb25zdCBfPXBSKEksaC5jdXJyZW50LHtwbGFjZW1lbnQ6RSwuLi5jLG1vZGlmaWVyczpNfSk7cmV0dXJuIGIuY3VycmVudChfKSwoKT0+e18uZGVzdHJveSgpLGIuY3VycmVudChudWxsKX19LFtJLHMsYSxsLGMsRV0pO2NvbnN0ICQ9e3BsYWNlbWVudDpSfTt3IT09bnVsbCYmKCQuVHJhbnNpdGlvblByb3BzPXcpO2NvbnN0IEw9dlIodCksaj12LnJvb3Q/PyJkaXYiLE49cGMoe2VsZW1lbnRUeXBlOmosZXh0ZXJuYWxTbG90UHJvcHM6bS5yb290LGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6eCxhZGRpdGlvbmFsUHJvcHM6e3JvbGU6InRvb2x0aXAiLHJlZjpnfSxvd25lclN0YXRlOnQsY2xhc3NOYW1lOkwucm9vdH0pO3JldHVybiBrLmpzeChqLHsuLi5OLGNoaWxkcmVuOnR5cGVvZiBvPT0iZnVuY3Rpb24iP28oJCk6b30pfSkseFI9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3R7YW5jaG9yRWw6cixjaGlsZHJlbjpvLGNvbnRhaW5lcjppLGRpcmVjdGlvbjpzPSJsdHIiLGRpc2FibGVQb3J0YWw6YT0hMSxrZWVwTW91bnRlZDpsPSExLG1vZGlmaWVyczp1LG9wZW46YyxwbGFjZW1lbnQ6ZD0iYm90dG9tIixwb3BwZXJPcHRpb25zOm09d1IscG9wcGVyUmVmOnYsc3R5bGU6dyx0cmFuc2l0aW9uOlM9ITEsc2xvdFByb3BzOng9e30sc2xvdHM6aD17fSwuLi5nfT10LFtmLHldPUMudXNlU3RhdGUoITApLGI9KCk9Pnt5KCExKX0sRT0oKT0+e3koITApfTtpZighbCYmIWMmJighU3x8ZikpcmV0dXJuIG51bGw7bGV0IFI7aWYoaSlSPWk7ZWxzZSBpZihyKXtjb25zdCBwPW1kKHIpO1I9cCYmeVIocCk/RHQocCkuYm9keTpEdChudWxsKS5ib2R5fWNvbnN0IFA9IWMmJmwmJighU3x8Zik/Im5vbmUiOnZvaWQgMCxJPVM/e2luOmMsb25FbnRlcjpiLG9uRXhpdGVkOkV9OnZvaWQgMDtyZXR1cm4gay5qc3goUjAse2Rpc2FibGVQb3J0YWw6YSxjb250YWluZXI6UixjaGlsZHJlbjprLmpzeChTUix7YW5jaG9yRWw6cixkaXJlY3Rpb246cyxkaXNhYmxlUG9ydGFsOmEsbW9kaWZpZXJzOnUscmVmOm4sb3BlbjpTPyFmOmMscGxhY2VtZW50OmQscG9wcGVyT3B0aW9uczptLHBvcHBlclJlZjp2LHNsb3RQcm9wczp4LHNsb3RzOmgsLi4uZyxzdHlsZTp7cG9zaXRpb246ImZpeGVkIix0b3A6MCxsZWZ0OjAsZGlzcGxheTpQLC4uLnd9LFRyYW5zaXRpb25Qcm9wczpJLGNoaWxkcmVuOm99KX0pfSksQ1I9Ryh4Uix7bmFtZToiTXVpUG9wcGVyIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+dC5yb290fSkoe30pLFQwPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9cWQoKSxvPW1lKHtwcm9wczp0LG5hbWU6Ik11aVBvcHBlciJ9KSx7YW5jaG9yRWw6aSxjb21wb25lbnQ6cyxjb21wb25lbnRzOmEsY29tcG9uZW50c1Byb3BzOmwsY29udGFpbmVyOnUsZGlzYWJsZVBvcnRhbDpjLGtlZXBNb3VudGVkOmQsbW9kaWZpZXJzOm0sb3Blbjp2LHBsYWNlbWVudDp3LHBvcHBlck9wdGlvbnM6Uyxwb3BwZXJSZWY6eCx0cmFuc2l0aW9uOmgsc2xvdHM6ZyxzbG90UHJvcHM6ZiwuLi55fT1vLGI9KGc9PW51bGw/dm9pZCAwOmcucm9vdCk/PyhhPT1udWxsP3ZvaWQgMDphLlJvb3QpLEU9e2FuY2hvckVsOmksY29udGFpbmVyOnUsZGlzYWJsZVBvcnRhbDpjLGtlZXBNb3VudGVkOmQsbW9kaWZpZXJzOm0sb3Blbjp2LHBsYWNlbWVudDp3LHBvcHBlck9wdGlvbnM6Uyxwb3BwZXJSZWY6eCx0cmFuc2l0aW9uOmgsLi4ueX07cmV0dXJuIGsuanN4KENSLHthczpzLGRpcmVjdGlvbjpyPyJydGwiOiJsdHIiLHNsb3RzOntyb290OmJ9LHNsb3RQcm9wczpmPz9sLC4uLkUscmVmOm59KX0pO2Z1bmN0aW9uIHFzKGUpe3JldHVybiBwYXJzZUludChlLDEwKXx8MH1jb25zdCBiUj17c2hhZG93Ont2aXNpYmlsaXR5OiJoaWRkZW4iLHBvc2l0aW9uOiJhYnNvbHV0ZSIsb3ZlcmZsb3c6ImhpZGRlbiIsaGVpZ2h0OjAsdG9wOjAsbGVmdDowLHRyYW5zZm9ybToidHJhbnNsYXRlWigwKSJ9fTtmdW5jdGlvbiBrUihlKXtyZXR1cm4gZT09bnVsbHx8T2JqZWN0LmtleXMoZSkubGVuZ3RoPT09MHx8ZS5vdXRlckhlaWdodFN0eWxlPT09MCYmIWUub3ZlcmZsb3dpbmd9Y29uc3QgRVI9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3R7b25DaGFuZ2U6cixtYXhSb3dzOm8sbWluUm93czppPTEsc3R5bGU6cyx2YWx1ZTphLC4uLmx9PXQse2N1cnJlbnQ6dX09Qy51c2VSZWYoYSE9bnVsbCksYz1DLnVzZVJlZihudWxsKSxkPVFlKG4sYyksbT1DLnVzZVJlZihudWxsKSx2PUMudXNlUmVmKG51bGwpLHc9Qy51c2VDYWxsYmFjaygoKT0+e2NvbnN0IGg9Yy5jdXJyZW50LGY9R24oaCkuZ2V0Q29tcHV0ZWRTdHlsZShoKTtpZihmLndpZHRoPT09IjBweCIpcmV0dXJue291dGVySGVpZ2h0U3R5bGU6MCxvdmVyZmxvd2luZzohMX07Y29uc3QgeT12LmN1cnJlbnQ7eS5zdHlsZS53aWR0aD1mLndpZHRoLHkudmFsdWU9aC52YWx1ZXx8dC5wbGFjZWhvbGRlcnx8IngiLHkudmFsdWUuc2xpY2UoLTEpPT09YApgJiYoeS52YWx1ZSs9IiAiKTtjb25zdCBiPWYuYm94U2l6aW5nLEU9cXMoZi5wYWRkaW5nQm90dG9tKStxcyhmLnBhZGRpbmdUb3ApLFI9cXMoZi5ib3JkZXJCb3R0b21XaWR0aCkrcXMoZi5ib3JkZXJUb3BXaWR0aCksUD15LnNjcm9sbEhlaWdodDt5LnZhbHVlPSJ4Ijtjb25zdCBJPXkuc2Nyb2xsSGVpZ2h0O2xldCBwPVA7aSYmKHA9TWF0aC5tYXgoTnVtYmVyKGkpKkkscCkpLG8mJihwPU1hdGgubWluKE51bWJlcihvKSpJLHApKSxwPU1hdGgubWF4KHAsSSk7Y29uc3QgJD1wKyhiPT09ImJvcmRlci1ib3giP0UrUjowKSxMPU1hdGguYWJzKHAtUCk8PTE7cmV0dXJue291dGVySGVpZ2h0U3R5bGU6JCxvdmVyZmxvd2luZzpMfX0sW28saSx0LnBsYWNlaG9sZGVyXSksUz1DLnVzZUNhbGxiYWNrKCgpPT57Y29uc3QgaD13KCk7aWYoa1IoaCkpcmV0dXJuO2NvbnN0IGc9aC5vdXRlckhlaWdodFN0eWxlLGY9Yy5jdXJyZW50O20uY3VycmVudCE9PWcmJihtLmN1cnJlbnQ9ZyxmLnN0eWxlLmhlaWdodD1gJHtnfXB4YCksZi5zdHlsZS5vdmVyZmxvdz1oLm92ZXJmbG93aW5nPyJoaWRkZW4iOiIifSxbd10pO1luKCgpPT57Y29uc3QgaD0oKT0+e1MoKX07bGV0IGc7Y29uc3QgZj1YZyhoKSx5PWMuY3VycmVudCxiPUduKHkpO2IuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixmKTtsZXQgRTtyZXR1cm4gdHlwZW9mIFJlc2l6ZU9ic2VydmVyPCJ1IiYmKEU9bmV3IFJlc2l6ZU9ic2VydmVyKGgpLEUub2JzZXJ2ZSh5KSksKCk9PntmLmNsZWFyKCksY2FuY2VsQW5pbWF0aW9uRnJhbWUoZyksYi5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLGYpLEUmJkUuZGlzY29ubmVjdCgpfX0sW3csU10pLFluKCgpPT57UygpfSk7Y29uc3QgeD1oPT57dXx8UygpLHImJnIoaCl9O3JldHVybiBrLmpzeHMoQy5GcmFnbWVudCx7Y2hpbGRyZW46W2suanN4KCJ0ZXh0YXJlYSIse3ZhbHVlOmEsb25DaGFuZ2U6eCxyZWY6ZCxyb3dzOmksc3R5bGU6cywuLi5sfSksay5qc3goInRleHRhcmVhIix7ImFyaWEtaGlkZGVuIjohMCxjbGFzc05hbWU6dC5jbGFzc05hbWUscmVhZE9ubHk6ITAscmVmOnYsdGFiSW5kZXg6LTEsc3R5bGU6ey4uLmJSLnNoYWRvdywuLi5zLHBhZGRpbmdUb3A6MCxwYWRkaW5nQm90dG9tOjB9fSldfSl9KTtmdW5jdGlvbiBoZChlKXtyZXR1cm4gdHlwZW9mIGU9PSJzdHJpbmcifWZ1bmN0aW9uIFpvKHtwcm9wczplLHN0YXRlczp0LG11aUZvcm1Db250cm9sOm59KXtyZXR1cm4gdC5yZWR1Y2UoKHIsbyk9PihyW29dPWVbb10sbiYmdHlwZW9mIGVbb10+InUiJiYocltvXT1uW29dKSxyKSx7fSl9Y29uc3Qgc3A9Qy5jcmVhdGVDb250ZXh0KHZvaWQgMCk7ZnVuY3Rpb24gSm8oKXtyZXR1cm4gQy51c2VDb250ZXh0KHNwKX1mdW5jdGlvbiB4aChlKXtyZXR1cm4gZSE9bnVsbCYmIShBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD09PTApfWZ1bmN0aW9uIGVsKGUsdD0hMSl7cmV0dXJuIGUmJih4aChlLnZhbHVlKSYmZS52YWx1ZSE9PSIifHx0JiZ4aChlLmRlZmF1bHRWYWx1ZSkmJmUuZGVmYXVsdFZhbHVlIT09IiIpfWZ1bmN0aW9uIFJSKGUpe3JldHVybiBlLnN0YXJ0QWRvcm5tZW50fWZ1bmN0aW9uIFRSKGUpe3JldHVybiBjZSgiTXVpSW5wdXRCYXNlIixlKX1jb25zdCBWbz1kZSgiTXVpSW5wdXRCYXNlIixbInJvb3QiLCJmb3JtQ29udHJvbCIsImZvY3VzZWQiLCJkaXNhYmxlZCIsImFkb3JuZWRTdGFydCIsImFkb3JuZWRFbmQiLCJlcnJvciIsInNpemVTbWFsbCIsIm11bHRpbGluZSIsImNvbG9yU2Vjb25kYXJ5IiwiZnVsbFdpZHRoIiwiaGlkZGVuTGFiZWwiLCJyZWFkT25seSIsImlucHV0IiwiaW5wdXRTaXplU21hbGwiLCJpbnB1dE11bHRpbGluZSIsImlucHV0VHlwZVNlYXJjaCIsImlucHV0QWRvcm5lZFN0YXJ0IiwiaW5wdXRBZG9ybmVkRW5kIiwiaW5wdXRIaWRkZW5MYWJlbCJdKTt2YXIgQ2g7Y29uc3QgbHU9KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3Qucm9vdCxuLmZvcm1Db250cm9sJiZ0LmZvcm1Db250cm9sLG4uc3RhcnRBZG9ybm1lbnQmJnQuYWRvcm5lZFN0YXJ0LG4uZW5kQWRvcm5tZW50JiZ0LmFkb3JuZWRFbmQsbi5lcnJvciYmdC5lcnJvcixuLnNpemU9PT0ic21hbGwiJiZ0LnNpemVTbWFsbCxuLm11bHRpbGluZSYmdC5tdWx0aWxpbmUsbi5jb2xvciYmdFtgY29sb3Ike25lKG4uY29sb3IpfWBdLG4uZnVsbFdpZHRoJiZ0LmZ1bGxXaWR0aCxuLmhpZGRlbkxhYmVsJiZ0LmhpZGRlbkxhYmVsXX0sdXU9KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3QuaW5wdXQsbi5zaXplPT09InNtYWxsIiYmdC5pbnB1dFNpemVTbWFsbCxuLm11bHRpbGluZSYmdC5pbnB1dE11bHRpbGluZSxuLnR5cGU9PT0ic2VhcmNoIiYmdC5pbnB1dFR5cGVTZWFyY2gsbi5zdGFydEFkb3JubWVudCYmdC5pbnB1dEFkb3JuZWRTdGFydCxuLmVuZEFkb3JubWVudCYmdC5pbnB1dEFkb3JuZWRFbmQsbi5oaWRkZW5MYWJlbCYmdC5pbnB1dEhpZGRlbkxhYmVsXX0sUFI9ZT0+e2NvbnN0e2NsYXNzZXM6dCxjb2xvcjpuLGRpc2FibGVkOnIsZXJyb3I6byxlbmRBZG9ybm1lbnQ6aSxmb2N1c2VkOnMsZm9ybUNvbnRyb2w6YSxmdWxsV2lkdGg6bCxoaWRkZW5MYWJlbDp1LG11bHRpbGluZTpjLHJlYWRPbmx5OmQsc2l6ZTptLHN0YXJ0QWRvcm5tZW50OnYsdHlwZTp3fT1lLFM9e3Jvb3Q6WyJyb290IixgY29sb3Ike25lKG4pfWAsciYmImRpc2FibGVkIixvJiYiZXJyb3IiLGwmJiJmdWxsV2lkdGgiLHMmJiJmb2N1c2VkIixhJiYiZm9ybUNvbnRyb2wiLG0mJm0hPT0ibWVkaXVtIiYmYHNpemUke25lKG0pfWAsYyYmIm11bHRpbGluZSIsdiYmImFkb3JuZWRTdGFydCIsaSYmImFkb3JuZWRFbmQiLHUmJiJoaWRkZW5MYWJlbCIsZCYmInJlYWRPbmx5Il0saW5wdXQ6WyJpbnB1dCIsciYmImRpc2FibGVkIix3PT09InNlYXJjaCImJiJpbnB1dFR5cGVTZWFyY2giLGMmJiJpbnB1dE11bHRpbGluZSIsbT09PSJzbWFsbCImJiJpbnB1dFNpemVTbWFsbCIsdSYmImlucHV0SGlkZGVuTGFiZWwiLHYmJiJpbnB1dEFkb3JuZWRTdGFydCIsaSYmImlucHV0QWRvcm5lZEVuZCIsZCYmInJlYWRPbmx5Il19O3JldHVybiBwZShTLFRSLHQpfSxjdT1HKCJkaXYiLHtuYW1lOiJNdWlJbnB1dEJhc2UiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOmx1fSkoeWUoKHt0aGVtZTplfSk9Pih7Li4uZS50eXBvZ3JhcGh5LmJvZHkxLGNvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUudGV4dC5wcmltYXJ5LGxpbmVIZWlnaHQ6IjEuNDM3NWVtIixib3hTaXppbmc6ImJvcmRlci1ib3giLHBvc2l0aW9uOiJyZWxhdGl2ZSIsY3Vyc29yOiJ0ZXh0IixkaXNwbGF5OiJpbmxpbmUtZmxleCIsYWxpZ25JdGVtczoiY2VudGVyIixbYCYuJHtWby5kaXNhYmxlZH1gXTp7Y29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LmRpc2FibGVkLGN1cnNvcjoiZGVmYXVsdCJ9LHZhcmlhbnRzOlt7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5tdWx0aWxpbmUsc3R5bGU6e3BhZGRpbmc6IjRweCAwIDVweCJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOnQsc2l6ZTpufSk9PnQubXVsdGlsaW5lJiZuPT09InNtYWxsIixzdHlsZTp7cGFkZGluZ1RvcDoxfX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuZnVsbFdpZHRoLHN0eWxlOnt3aWR0aDoiMTAwJSJ9fV19KSkpLGR1PUcoImlucHV0Iix7bmFtZToiTXVpSW5wdXRCYXNlIixzbG90OiJJbnB1dCIsb3ZlcnJpZGVzUmVzb2x2ZXI6dXV9KSh5ZSgoe3RoZW1lOmV9KT0+e2NvbnN0IHQ9ZS5wYWxldHRlLm1vZGU9PT0ibGlnaHQiLG49e2NvbG9yOiJjdXJyZW50Q29sb3IiLC4uLmUudmFycz97b3BhY2l0eTplLnZhcnMub3BhY2l0eS5pbnB1dFBsYWNlaG9sZGVyfTp7b3BhY2l0eTp0Py40MjouNX0sdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIse2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcn0pfSxyPXtvcGFjaXR5OiIwICFpbXBvcnRhbnQifSxvPWUudmFycz97b3BhY2l0eTplLnZhcnMub3BhY2l0eS5pbnB1dFBsYWNlaG9sZGVyfTp7b3BhY2l0eTp0Py40MjouNX07cmV0dXJue2ZvbnQ6ImluaGVyaXQiLGxldHRlclNwYWNpbmc6ImluaGVyaXQiLGNvbG9yOiJjdXJyZW50Q29sb3IiLHBhZGRpbmc6IjRweCAwIDVweCIsYm9yZGVyOjAsYm94U2l6aW5nOiJjb250ZW50LWJveCIsYmFja2dyb3VuZDoibm9uZSIsaGVpZ2h0OiIxLjQzNzVlbSIsbWFyZ2luOjAsV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6InRyYW5zcGFyZW50IixkaXNwbGF5OiJibG9jayIsbWluV2lkdGg6MCx3aWR0aDoiMTAwJSIsIiY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIiOm4sIiY6Oi1tb3otcGxhY2Vob2xkZXIiOm4sIiY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciI6biwiJjpmb2N1cyI6e291dGxpbmU6MH0sIiY6aW52YWxpZCI6e2JveFNoYWRvdzoibm9uZSJ9LCImOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIjp7V2Via2l0QXBwZWFyYW5jZToibm9uZSJ9LFtgbGFiZWxbZGF0YS1zaHJpbms9ZmFsc2VdICsgLiR7Vm8uZm9ybUNvbnRyb2x9ICZgXTp7IiY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIiOnIsIiY6Oi1tb3otcGxhY2Vob2xkZXIiOnIsIiY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciI6ciwiJjpmb2N1czo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciI6bywiJjpmb2N1czo6LW1vei1wbGFjZWhvbGRlciI6bywiJjpmb2N1czo6LW1zLWlucHV0LXBsYWNlaG9sZGVyIjpvfSxbYCYuJHtWby5kaXNhYmxlZH1gXTp7b3BhY2l0eToxLFdlYmtpdFRleHRGaWxsQ29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LmRpc2FibGVkfSx2YXJpYW50czpbe3Byb3BzOih7b3duZXJTdGF0ZTppfSk9PiFpLmRpc2FibGVJbmplY3RpbmdHbG9iYWxTdHlsZXMsc3R5bGU6e2FuaW1hdGlvbk5hbWU6Im11aS1hdXRvLWZpbGwtY2FuY2VsIixhbmltYXRpb25EdXJhdGlvbjoiMTBtcyIsIiY6LXdlYmtpdC1hdXRvZmlsbCI6e2FuaW1hdGlvbkR1cmF0aW9uOiI1MDAwcyIsYW5pbWF0aW9uTmFtZToibXVpLWF1dG8tZmlsbCJ9fX0se3Byb3BzOntzaXplOiJzbWFsbCJ9LHN0eWxlOntwYWRkaW5nVG9wOjF9fSx7cHJvcHM6KHtvd25lclN0YXRlOml9KT0+aS5tdWx0aWxpbmUsc3R5bGU6e2hlaWdodDoiYXV0byIscmVzaXplOiJub25lIixwYWRkaW5nOjAscGFkZGluZ1RvcDowfX0se3Byb3BzOnt0eXBlOiJzZWFyY2gifSxzdHlsZTp7TW96QXBwZWFyYW5jZToidGV4dGZpZWxkIn19XX19KSksYmg9WkMoeyJAa2V5ZnJhbWVzIG11aS1hdXRvLWZpbGwiOntmcm9tOntkaXNwbGF5OiJibG9jayJ9fSwiQGtleWZyYW1lcyBtdWktYXV0by1maWxsLWNhbmNlbCI6e2Zyb206e2Rpc3BsYXk6ImJsb2NrIn19fSksYXA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlJbnB1dEJhc2UifSkseyJhcmlhLWRlc2NyaWJlZGJ5IjpvLGF1dG9Db21wbGV0ZTppLGF1dG9Gb2N1czpzLGNsYXNzTmFtZTphLGNvbG9yOmwsY29tcG9uZW50czp1PXt9LGNvbXBvbmVudHNQcm9wczpjPXt9LGRlZmF1bHRWYWx1ZTpkLGRpc2FibGVkOm0sZGlzYWJsZUluamVjdGluZ0dsb2JhbFN0eWxlczp2LGVuZEFkb3JubWVudDp3LGVycm9yOlMsZnVsbFdpZHRoOng9ITEsaWQ6aCxpbnB1dENvbXBvbmVudDpnPSJpbnB1dCIsaW5wdXRQcm9wczpmPXt9LGlucHV0UmVmOnksbWFyZ2luOmIsbWF4Um93czpFLG1pblJvd3M6UixtdWx0aWxpbmU6UD0hMSxuYW1lOkksb25CbHVyOnAsb25DaGFuZ2U6JCxvbkNsaWNrOkwsb25Gb2N1czpqLG9uS2V5RG93bjpOLG9uS2V5VXA6TyxwbGFjZWhvbGRlcjpNLHJlYWRPbmx5Ol8scmVuZGVyU3VmZml4OlQscm93czpBLHNpemU6RCxzbG90UHJvcHM6Qj17fSxzbG90czpIPXt9LHN0YXJ0QWRvcm5tZW50OlYsdHlwZTpVPSJ0ZXh0Iix2YWx1ZTpYLC4uLld9PXIsSj1mLnZhbHVlIT1udWxsP2YudmFsdWU6WCx7Y3VycmVudDpvZX09Qy51c2VSZWYoSiE9bnVsbCkscmU9Qy51c2VSZWYoKSxRPUMudXNlQ2FsbGJhY2sobGU9Pnt9LFtdKSxlZT1RZShyZSx5LGYucmVmLFEpLFtZLHVlXT1DLnVzZVN0YXRlKCExKSxpZT1KbygpLGZlPVpvKHtwcm9wczpyLG11aUZvcm1Db250cm9sOmllLHN0YXRlczpbImNvbG9yIiwiZGlzYWJsZWQiLCJlcnJvciIsImhpZGRlbkxhYmVsIiwic2l6ZSIsInJlcXVpcmVkIiwiZmlsbGVkIl19KTtmZS5mb2N1c2VkPWllP2llLmZvY3VzZWQ6WSxDLnVzZUVmZmVjdCgoKT0+eyFpZSYmbSYmWSYmKHVlKCExKSxwJiZwKCkpfSxbaWUsbSxZLHBdKTtjb25zdCBaZT1pZSYmaWUub25GaWxsZWQsVmU9aWUmJmllLm9uRW1wdHksT2U9Qy51c2VDYWxsYmFjayhsZT0+e2VsKGxlKT9aZSYmWmUoKTpWZSYmVmUoKX0sW1plLFZlXSk7WW4oKCk9PntvZSYmT2Uoe3ZhbHVlOkp9KX0sW0osT2Usb2VdKTtjb25zdCBOZT1sZT0+e2omJmoobGUpLGYub25Gb2N1cyYmZi5vbkZvY3VzKGxlKSxpZSYmaWUub25Gb2N1cz9pZS5vbkZvY3VzKGxlKTp1ZSghMCl9LFdlPWxlPT57cCYmcChsZSksZi5vbkJsdXImJmYub25CbHVyKGxlKSxpZSYmaWUub25CbHVyP2llLm9uQmx1cihsZSk6dWUoITEpfSxoZT0obGUsLi4udW4pPT57aWYoIW9lKXtjb25zdCBQcj1sZS50YXJnZXR8fHJlLmN1cnJlbnQ7aWYoUHI9PW51bGwpdGhyb3cgbmV3IEVycm9yKFZuKDEpKTtPZSh7dmFsdWU6UHIudmFsdWV9KX1mLm9uQ2hhbmdlJiZmLm9uQ2hhbmdlKGxlLC4uLnVuKSwkJiYkKGxlLC4uLnVuKX07Qy51c2VFZmZlY3QoKCk9PntPZShyZS5jdXJyZW50KX0sW10pO2NvbnN0IGh0PWxlPT57cmUuY3VycmVudCYmbGUuY3VycmVudFRhcmdldD09PWxlLnRhcmdldCYmcmUuY3VycmVudC5mb2N1cygpLEwmJkwobGUpfTtsZXQgcT1nLEllPWY7UCYmcT09PSJpbnB1dCImJihBP0llPXt0eXBlOnZvaWQgMCxtaW5Sb3dzOkEsbWF4Um93czpBLC4uLkllfTpJZT17dHlwZTp2b2lkIDAsbWF4Um93czpFLG1pblJvd3M6UiwuLi5JZX0scT1FUik7Y29uc3QgeG49bGU9PntPZShsZS5hbmltYXRpb25OYW1lPT09Im11aS1hdXRvLWZpbGwtY2FuY2VsIj9yZS5jdXJyZW50Ont2YWx1ZToieCJ9KX07Qy51c2VFZmZlY3QoKCk9PntpZSYmaWUuc2V0QWRvcm5lZFN0YXJ0KCEhVil9LFtpZSxWXSk7Y29uc3QgU3Q9ey4uLnIsY29sb3I6ZmUuY29sb3J8fCJwcmltYXJ5IixkaXNhYmxlZDpmZS5kaXNhYmxlZCxlbmRBZG9ybm1lbnQ6dyxlcnJvcjpmZS5lcnJvcixmb2N1c2VkOmZlLmZvY3VzZWQsZm9ybUNvbnRyb2w6aWUsZnVsbFdpZHRoOngsaGlkZGVuTGFiZWw6ZmUuaGlkZGVuTGFiZWwsbXVsdGlsaW5lOlAsc2l6ZTpmZS5zaXplLHN0YXJ0QWRvcm5tZW50OlYsdHlwZTpVfSx4dD1QUihTdCksQ249SC5yb290fHx1LlJvb3R8fGN1LEN0PUIucm9vdHx8Yy5yb290fHx7fSxibj1ILmlucHV0fHx1LklucHV0fHxkdTtyZXR1cm4gSWU9ey4uLkllLC4uLkIuaW5wdXQ/P2MuaW5wdXR9LGsuanN4cyhDLkZyYWdtZW50LHtjaGlsZHJlbjpbIXYmJnR5cGVvZiBiaD09ImZ1bmN0aW9uIiYmKENofHwoQ2g9ay5qc3goYmgse30pKSksay5qc3hzKENuLHsuLi5DdCxyZWY6bixvbkNsaWNrOmh0LC4uLlcsLi4uIWhkKENuKSYme293bmVyU3RhdGU6ey4uLlN0LC4uLkN0Lm93bmVyU3RhdGV9fSxjbGFzc05hbWU6dGUoeHQucm9vdCxDdC5jbGFzc05hbWUsYSxfJiYiTXVpSW5wdXRCYXNlLXJlYWRPbmx5IiksY2hpbGRyZW46W1Ysay5qc3goc3AuUHJvdmlkZXIse3ZhbHVlOm51bGwsY2hpbGRyZW46ay5qc3goYm4seyJhcmlhLWludmFsaWQiOmZlLmVycm9yLCJhcmlhLWRlc2NyaWJlZGJ5IjpvLGF1dG9Db21wbGV0ZTppLGF1dG9Gb2N1czpzLGRlZmF1bHRWYWx1ZTpkLGRpc2FibGVkOmZlLmRpc2FibGVkLGlkOmgsb25BbmltYXRpb25TdGFydDp4bixuYW1lOkkscGxhY2Vob2xkZXI6TSxyZWFkT25seTpfLHJlcXVpcmVkOmZlLnJlcXVpcmVkLHJvd3M6QSx2YWx1ZTpKLG9uS2V5RG93bjpOLG9uS2V5VXA6Tyx0eXBlOlUsLi4uSWUsLi4uIWhkKGJuKSYme2FzOnEsb3duZXJTdGF0ZTp7Li4uU3QsLi4uSWUub3duZXJTdGF0ZX19LHJlZjplZSxjbGFzc05hbWU6dGUoeHQuaW5wdXQsSWUuY2xhc3NOYW1lLF8mJiJNdWlJbnB1dEJhc2UtcmVhZE9ubHkiKSxvbkJsdXI6V2Usb25DaGFuZ2U6aGUsb25Gb2N1czpOZX0pfSksdyxUP1Qoey4uLmZlLHN0YXJ0QWRvcm5tZW50OlZ9KTpudWxsXX0pXX0pfSk7ZnVuY3Rpb24gJFIoZSl7cmV0dXJuIGNlKCJNdWlJbnB1dCIsZSl9Y29uc3QgcGk9ey4uLlZvLC4uLmRlKCJNdWlJbnB1dCIsWyJyb290IiwidW5kZXJsaW5lIiwiaW5wdXQiXSl9O2Z1bmN0aW9uIE9SKGUpe3JldHVybiBjZSgiTXVpT3V0bGluZWRJbnB1dCIsZSl9Y29uc3QgUm49ey4uLlZvLC4uLmRlKCJNdWlPdXRsaW5lZElucHV0IixbInJvb3QiLCJub3RjaGVkT3V0bGluZSIsImlucHV0Il0pfTtmdW5jdGlvbiBNUihlKXtyZXR1cm4gY2UoIk11aUZpbGxlZElucHV0IixlKX1jb25zdCAkcj17Li4uVm8sLi4uZGUoIk11aUZpbGxlZElucHV0IixbInJvb3QiLCJ1bmRlcmxpbmUiLCJpbnB1dCIsImFkb3JuZWRTdGFydCIsImFkb3JuZWRFbmQiLCJzaXplU21hbGwiLCJtdWx0aWxpbmUiLCJoaWRkZW5MYWJlbCJdKX0sX1I9VnQoay5qc3goInBhdGgiLHtkOiJNNyAxMGw1IDUgNS01eiJ9KSwiQXJyb3dEcm9wRG93biIpLE5SPXtlbnRlcmluZzp7b3BhY2l0eToxfSxlbnRlcmVkOntvcGFjaXR5OjF9fSxJUj1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPVNzKCksbz17ZW50ZXI6ci50cmFuc2l0aW9ucy5kdXJhdGlvbi5lbnRlcmluZ1NjcmVlbixleGl0OnIudHJhbnNpdGlvbnMuZHVyYXRpb24ubGVhdmluZ1NjcmVlbn0se2FkZEVuZExpc3RlbmVyOmksYXBwZWFyOnM9ITAsY2hpbGRyZW46YSxlYXNpbmc6bCxpbjp1LG9uRW50ZXI6YyxvbkVudGVyZWQ6ZCxvbkVudGVyaW5nOm0sb25FeGl0OnYsb25FeGl0ZWQ6dyxvbkV4aXRpbmc6UyxzdHlsZTp4LHRpbWVvdXQ6aD1vLFRyYW5zaXRpb25Db21wb25lbnQ6Zz1sbiwuLi5mfT10LHk9Qy51c2VSZWYobnVsbCksYj1RZSh5LFFvKGEpLG4pLEU9Tj0+Tz0+e2lmKE4pe2NvbnN0IE09eS5jdXJyZW50O089PT12b2lkIDA/TihNKTpOKE0sTyl9fSxSPUUobSksUD1FKChOLE8pPT57ZDAoTik7Y29uc3QgTT1Gbyh7c3R5bGU6eCx0aW1lb3V0OmgsZWFzaW5nOmx9LHttb2RlOiJlbnRlciJ9KTtOLnN0eWxlLndlYmtpdFRyYW5zaXRpb249ci50cmFuc2l0aW9ucy5jcmVhdGUoIm9wYWNpdHkiLE0pLE4uc3R5bGUudHJhbnNpdGlvbj1yLnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIsTSksYyYmYyhOLE8pfSksST1FKGQpLHA9RShTKSwkPUUoTj0+e2NvbnN0IE89Rm8oe3N0eWxlOngsdGltZW91dDpoLGVhc2luZzpsfSx7bW9kZToiZXhpdCJ9KTtOLnN0eWxlLndlYmtpdFRyYW5zaXRpb249ci50cmFuc2l0aW9ucy5jcmVhdGUoIm9wYWNpdHkiLE8pLE4uc3R5bGUudHJhbnNpdGlvbj1yLnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIsTyksdiYmdihOKX0pLEw9RSh3KSxqPU49PntpJiZpKHkuY3VycmVudCxOKX07cmV0dXJuIGsuanN4KGcse2FwcGVhcjpzLGluOnUsbm9kZVJlZjp5LG9uRW50ZXI6UCxvbkVudGVyZWQ6SSxvbkVudGVyaW5nOlIsb25FeGl0OiQsb25FeGl0ZWQ6TCxvbkV4aXRpbmc6cCxhZGRFbmRMaXN0ZW5lcjpqLHRpbWVvdXQ6aCwuLi5mLGNoaWxkcmVuOihOLE8pPT5DLmNsb25lRWxlbWVudChhLHtzdHlsZTp7b3BhY2l0eTowLHZpc2liaWxpdHk6Tj09PSJleGl0ZWQiJiYhdT8iaGlkZGVuIjp2b2lkIDAsLi4uTlJbTl0sLi4ueCwuLi5hLnByb3BzLnN0eWxlfSxyZWY6YiwuLi5PfSl9KX0pO2Z1bmN0aW9uIEFSKGUpe3JldHVybiBjZSgiTXVpQmFja2Ryb3AiLGUpfWRlKCJNdWlCYWNrZHJvcCIsWyJyb290IiwiaW52aXNpYmxlIl0pO2NvbnN0IHpSPWU9Pntjb25zdHtvd25lclN0YXRlOnQsLi4ubn09ZTtyZXR1cm4gbn0sTFI9ZT0+e2NvbnN0e2NsYXNzZXM6dCxpbnZpc2libGU6bn09ZTtyZXR1cm4gcGUoe3Jvb3Q6WyJyb290IixuJiYiaW52aXNpYmxlIl19LEFSLHQpfSxqUj1HKCJkaXYiLHtuYW1lOiJNdWlCYWNrZHJvcCIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3Qucm9vdCxuLmludmlzaWJsZSYmdC5pbnZpc2libGVdfX0pKHtwb3NpdGlvbjoiZml4ZWQiLGRpc3BsYXk6ImZsZXgiLGFsaWduSXRlbXM6ImNlbnRlciIsanVzdGlmeUNvbnRlbnQ6ImNlbnRlciIscmlnaHQ6MCxib3R0b206MCx0b3A6MCxsZWZ0OjAsYmFja2dyb3VuZENvbG9yOiJyZ2JhKDAsIDAsIDAsIDAuNSkiLFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiJ0cmFuc3BhcmVudCIsdmFyaWFudHM6W3twcm9wczp7aW52aXNpYmxlOiEwfSxzdHlsZTp7YmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fV19KSxEUj1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aUJhY2tkcm9wIn0pLHtjaGlsZHJlbjpvLGNsYXNzTmFtZTppLGNvbXBvbmVudDpzPSJkaXYiLGludmlzaWJsZTphPSExLG9wZW46bCxjb21wb25lbnRzOnU9e30sY29tcG9uZW50c1Byb3BzOmM9e30sc2xvdFByb3BzOmQ9e30sc2xvdHM6bT17fSxUcmFuc2l0aW9uQ29tcG9uZW50OnYsdHJhbnNpdGlvbkR1cmF0aW9uOncsLi4uU309cix4PXsuLi5yLGNvbXBvbmVudDpzLGludmlzaWJsZTphfSxoPUxSKHgpLGc9e3RyYW5zaXRpb246dixyb290OnUuUm9vdCwuLi5tfSxmPXsuLi5jLC4uLmR9LHk9e3Nsb3RzOmcsc2xvdFByb3BzOmZ9LFtiLEVdPU50KCJyb290Iix7ZWxlbWVudFR5cGU6alIsZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczp5LGNsYXNzTmFtZTp0ZShoLnJvb3QsaSksb3duZXJTdGF0ZTp4fSksW1IsUF09TnQoInRyYW5zaXRpb24iLHtlbGVtZW50VHlwZTpJUixleHRlcm5hbEZvcndhcmRlZFByb3BzOnksb3duZXJTdGF0ZTp4fSksST16UihQKTtyZXR1cm4gay5qc3goUix7aW46bCx0aW1lb3V0OncsLi4uUywuLi5JLGNoaWxkcmVuOmsuanN4KGIseyJhcmlhLWhpZGRlbiI6ITAsLi4uRSxjbGFzc2VzOmgscmVmOm4sY2hpbGRyZW46b30pfSl9KTtmdW5jdGlvbiBGUihlKXtyZXR1cm4gY2UoIk11aUJ1dHRvbiIsZSl9Y29uc3Qgc289ZGUoIk11aUJ1dHRvbiIsWyJyb290IiwidGV4dCIsInRleHRJbmhlcml0IiwidGV4dFByaW1hcnkiLCJ0ZXh0U2Vjb25kYXJ5IiwidGV4dFN1Y2Nlc3MiLCJ0ZXh0RXJyb3IiLCJ0ZXh0SW5mbyIsInRleHRXYXJuaW5nIiwib3V0bGluZWQiLCJvdXRsaW5lZEluaGVyaXQiLCJvdXRsaW5lZFByaW1hcnkiLCJvdXRsaW5lZFNlY29uZGFyeSIsIm91dGxpbmVkU3VjY2VzcyIsIm91dGxpbmVkRXJyb3IiLCJvdXRsaW5lZEluZm8iLCJvdXRsaW5lZFdhcm5pbmciLCJjb250YWluZWQiLCJjb250YWluZWRJbmhlcml0IiwiY29udGFpbmVkUHJpbWFyeSIsImNvbnRhaW5lZFNlY29uZGFyeSIsImNvbnRhaW5lZFN1Y2Nlc3MiLCJjb250YWluZWRFcnJvciIsImNvbnRhaW5lZEluZm8iLCJjb250YWluZWRXYXJuaW5nIiwiZGlzYWJsZUVsZXZhdGlvbiIsImZvY3VzVmlzaWJsZSIsImRpc2FibGVkIiwiY29sb3JJbmhlcml0IiwiY29sb3JQcmltYXJ5IiwiY29sb3JTZWNvbmRhcnkiLCJjb2xvclN1Y2Nlc3MiLCJjb2xvckVycm9yIiwiY29sb3JJbmZvIiwiY29sb3JXYXJuaW5nIiwidGV4dFNpemVTbWFsbCIsInRleHRTaXplTWVkaXVtIiwidGV4dFNpemVMYXJnZSIsIm91dGxpbmVkU2l6ZVNtYWxsIiwib3V0bGluZWRTaXplTWVkaXVtIiwib3V0bGluZWRTaXplTGFyZ2UiLCJjb250YWluZWRTaXplU21hbGwiLCJjb250YWluZWRTaXplTWVkaXVtIiwiY29udGFpbmVkU2l6ZUxhcmdlIiwic2l6ZU1lZGl1bSIsInNpemVTbWFsbCIsInNpemVMYXJnZSIsImZ1bGxXaWR0aCIsInN0YXJ0SWNvbiIsImVuZEljb24iLCJpY29uIiwiaWNvblNpemVTbWFsbCIsImljb25TaXplTWVkaXVtIiwiaWNvblNpemVMYXJnZSJdKSxCUj1DLmNyZWF0ZUNvbnRleHQoe30pLFdSPUMuY3JlYXRlQ29udGV4dCh2b2lkIDApLFVSPWU9Pntjb25zdHtjb2xvcjp0LGRpc2FibGVFbGV2YXRpb246bixmdWxsV2lkdGg6cixzaXplOm8sdmFyaWFudDppLGNsYXNzZXM6c309ZSxhPXtyb290Olsicm9vdCIsaSxgJHtpfSR7bmUodCl9YCxgc2l6ZSR7bmUobyl9YCxgJHtpfVNpemUke25lKG8pfWAsYGNvbG9yJHtuZSh0KX1gLG4mJiJkaXNhYmxlRWxldmF0aW9uIixyJiYiZnVsbFdpZHRoIl0sbGFiZWw6WyJsYWJlbCJdLHN0YXJ0SWNvbjpbImljb24iLCJzdGFydEljb24iLGBpY29uU2l6ZSR7bmUobyl9YF0sZW5kSWNvbjpbImljb24iLCJlbmRJY29uIixgaWNvblNpemUke25lKG8pfWBdfSxsPXBlKGEsRlIscyk7cmV0dXJuey4uLnMsLi4ubH19LFAwPVt7cHJvcHM6e3NpemU6InNtYWxsIn0sc3R5bGU6eyImID4gKjpudGgtb2YtdHlwZSgxKSI6e2ZvbnRTaXplOjE4fX19LHtwcm9wczp7c2l6ZToibWVkaXVtIn0sc3R5bGU6eyImID4gKjpudGgtb2YtdHlwZSgxKSI6e2ZvbnRTaXplOjIwfX19LHtwcm9wczp7c2l6ZToibGFyZ2UifSxzdHlsZTp7IiYgPiAqOm50aC1vZi10eXBlKDEpIjp7Zm9udFNpemU6MjJ9fX1dLEhSPUcocWYse3Nob3VsZEZvcndhcmRQcm9wOmU9PlNuKGUpfHxlPT09ImNsYXNzZXMiLG5hbWU6Ik11aUJ1dHRvbiIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3Qucm9vdCx0W24udmFyaWFudF0sdFtgJHtuLnZhcmlhbnR9JHtuZShuLmNvbG9yKX1gXSx0W2BzaXplJHtuZShuLnNpemUpfWBdLHRbYCR7bi52YXJpYW50fVNpemUke25lKG4uc2l6ZSl9YF0sbi5jb2xvcj09PSJpbmhlcml0IiYmdC5jb2xvckluaGVyaXQsbi5kaXNhYmxlRWxldmF0aW9uJiZ0LmRpc2FibGVFbGV2YXRpb24sbi5mdWxsV2lkdGgmJnQuZnVsbFdpZHRoXX19KSh5ZSgoe3RoZW1lOmV9KT0+e2NvbnN0IHQ9ZS5wYWxldHRlLm1vZGU9PT0ibGlnaHQiP2UucGFsZXR0ZS5ncmV5WzMwMF06ZS5wYWxldHRlLmdyZXlbODAwXSxuPWUucGFsZXR0ZS5tb2RlPT09ImxpZ2h0Ij9lLnBhbGV0dGUuZ3JleS5BMTAwOmUucGFsZXR0ZS5ncmV5WzcwMF07cmV0dXJuey4uLmUudHlwb2dyYXBoeS5idXR0b24sbWluV2lkdGg6NjQscGFkZGluZzoiNnB4IDE2cHgiLGJvcmRlcjowLGJvcmRlclJhZGl1czooZS52YXJzfHxlKS5zaGFwZS5ib3JkZXJSYWRpdXMsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZShbImJhY2tncm91bmQtY29sb3IiLCJib3gtc2hhZG93IiwiYm9yZGVyLWNvbG9yIiwiY29sb3IiXSx7ZHVyYXRpb246ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydH0pLCImOmhvdmVyIjp7dGV4dERlY29yYXRpb246Im5vbmUifSxbYCYuJHtzby5kaXNhYmxlZH1gXTp7Y29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWR9LHZhcmlhbnRzOlt7cHJvcHM6e3ZhcmlhbnQ6ImNvbnRhaW5lZCJ9LHN0eWxlOntjb2xvcjoidmFyKC0tdmFyaWFudC1jb250YWluZWRDb2xvcikiLGJhY2tncm91bmRDb2xvcjoidmFyKC0tdmFyaWFudC1jb250YWluZWRCZykiLGJveFNoYWRvdzooZS52YXJzfHxlKS5zaGFkb3dzWzJdLCImOmhvdmVyIjp7Ym94U2hhZG93OihlLnZhcnN8fGUpLnNoYWRvd3NbNF0sIkBtZWRpYSAoaG92ZXI6IG5vbmUpIjp7Ym94U2hhZG93OihlLnZhcnN8fGUpLnNoYWRvd3NbMl19fSwiJjphY3RpdmUiOntib3hTaGFkb3c6KGUudmFyc3x8ZSkuc2hhZG93c1s4XX0sW2AmLiR7c28uZm9jdXNWaXNpYmxlfWBdOntib3hTaGFkb3c6KGUudmFyc3x8ZSkuc2hhZG93c1s2XX0sW2AmLiR7c28uZGlzYWJsZWR9YF06e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkLGJveFNoYWRvdzooZS52YXJzfHxlKS5zaGFkb3dzWzBdLGJhY2tncm91bmRDb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZEJhY2tncm91bmR9fX0se3Byb3BzOnt2YXJpYW50OiJvdXRsaW5lZCJ9LHN0eWxlOntwYWRkaW5nOiI1cHggMTVweCIsYm9yZGVyOiIxcHggc29saWQgY3VycmVudENvbG9yIixib3JkZXJDb2xvcjoidmFyKC0tdmFyaWFudC1vdXRsaW5lZEJvcmRlciwgY3VycmVudENvbG9yKSIsYmFja2dyb3VuZENvbG9yOiJ2YXIoLS12YXJpYW50LW91dGxpbmVkQmcpIixjb2xvcjoidmFyKC0tdmFyaWFudC1vdXRsaW5lZENvbG9yKSIsW2AmLiR7c28uZGlzYWJsZWR9YF06e2JvcmRlcjpgMXB4IHNvbGlkICR7KGUudmFyc3x8ZSkucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRCYWNrZ3JvdW5kfWB9fX0se3Byb3BzOnt2YXJpYW50OiJ0ZXh0In0sc3R5bGU6e3BhZGRpbmc6IjZweCA4cHgiLGNvbG9yOiJ2YXIoLS12YXJpYW50LXRleHRDb2xvcikiLGJhY2tncm91bmRDb2xvcjoidmFyKC0tdmFyaWFudC10ZXh0QmcpIn19LC4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKGJyKCkpLm1hcCgoW3JdKT0+KHtwcm9wczp7Y29sb3I6cn0sc3R5bGU6eyItLXZhcmlhbnQtdGV4dENvbG9yIjooZS52YXJzfHxlKS5wYWxldHRlW3JdLm1haW4sIi0tdmFyaWFudC1vdXRsaW5lZENvbG9yIjooZS52YXJzfHxlKS5wYWxldHRlW3JdLm1haW4sIi0tdmFyaWFudC1vdXRsaW5lZEJvcmRlciI6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGVbcl0ubWFpbkNoYW5uZWx9IC8gMC41KWA6ZnQoZS5wYWxldHRlW3JdLm1haW4sLjUpLCItLXZhcmlhbnQtY29udGFpbmVkQ29sb3IiOihlLnZhcnN8fGUpLnBhbGV0dGVbcl0uY29udHJhc3RUZXh0LCItLXZhcmlhbnQtY29udGFpbmVkQmciOihlLnZhcnN8fGUpLnBhbGV0dGVbcl0ubWFpbiwiQG1lZGlhIChob3ZlcjogaG92ZXIpIjp7IiY6aG92ZXIiOnsiLS12YXJpYW50LWNvbnRhaW5lZEJnIjooZS52YXJzfHxlKS5wYWxldHRlW3JdLmRhcmssIi0tdmFyaWFudC10ZXh0QmciOmUudmFycz9gcmdiYSgke2UudmFycy5wYWxldHRlW3JdLm1haW5DaGFubmVsfSAvICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pYDpmdChlLnBhbGV0dGVbcl0ubWFpbixlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksIi0tdmFyaWFudC1vdXRsaW5lZEJvcmRlciI6KGUudmFyc3x8ZSkucGFsZXR0ZVtyXS5tYWluLCItLXZhcmlhbnQtb3V0bGluZWRCZyI6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGVbcl0ubWFpbkNoYW5uZWx9IC8gJHtlLnZhcnMucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5fSlgOmZ0KGUucGFsZXR0ZVtyXS5tYWluLGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KX19fX0pKSx7cHJvcHM6e2NvbG9yOiJpbmhlcml0In0sc3R5bGU6e2NvbG9yOiJpbmhlcml0Iixib3JkZXJDb2xvcjoiY3VycmVudENvbG9yIiwiLS12YXJpYW50LWNvbnRhaW5lZEJnIjplLnZhcnM/ZS52YXJzLnBhbGV0dGUuQnV0dG9uLmluaGVyaXRDb250YWluZWRCZzp0LCJAbWVkaWEgKGhvdmVyOiBob3ZlcikiOnsiJjpob3ZlciI6eyItLXZhcmlhbnQtY29udGFpbmVkQmciOmUudmFycz9lLnZhcnMucGFsZXR0ZS5CdXR0b24uaW5oZXJpdENvbnRhaW5lZEhvdmVyQmc6biwiLS12YXJpYW50LXRleHRCZyI6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGUudGV4dC5wcmltYXJ5Q2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHl9KWA6ZnQoZS5wYWxldHRlLnRleHQucHJpbWFyeSxlLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksIi0tdmFyaWFudC1vdXRsaW5lZEJnIjplLnZhcnM/YHJnYmEoJHtlLnZhcnMucGFsZXR0ZS50ZXh0LnByaW1hcnlDaGFubmVsfSAvICR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eX0pYDpmdChlLnBhbGV0dGUudGV4dC5wcmltYXJ5LGUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KX19fX0se3Byb3BzOntzaXplOiJzbWFsbCIsdmFyaWFudDoidGV4dCJ9LHN0eWxlOntwYWRkaW5nOiI0cHggNXB4Iixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxMyl9fSx7cHJvcHM6e3NpemU6ImxhcmdlIix2YXJpYW50OiJ0ZXh0In0sc3R5bGU6e3BhZGRpbmc6IjhweCAxMXB4Iixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxNSl9fSx7cHJvcHM6e3NpemU6InNtYWxsIix2YXJpYW50OiJvdXRsaW5lZCJ9LHN0eWxlOntwYWRkaW5nOiIzcHggOXB4Iixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxMyl9fSx7cHJvcHM6e3NpemU6ImxhcmdlIix2YXJpYW50OiJvdXRsaW5lZCJ9LHN0eWxlOntwYWRkaW5nOiI3cHggMjFweCIsZm9udFNpemU6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTUpfX0se3Byb3BzOntzaXplOiJzbWFsbCIsdmFyaWFudDoiY29udGFpbmVkIn0sc3R5bGU6e3BhZGRpbmc6IjRweCAxMHB4Iixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxMyl9fSx7cHJvcHM6e3NpemU6ImxhcmdlIix2YXJpYW50OiJjb250YWluZWQifSxzdHlsZTp7cGFkZGluZzoiOHB4IDIycHgiLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDE1KX19LHtwcm9wczp7ZGlzYWJsZUVsZXZhdGlvbjohMH0sc3R5bGU6e2JveFNoYWRvdzoibm9uZSIsIiY6aG92ZXIiOntib3hTaGFkb3c6Im5vbmUifSxbYCYuJHtzby5mb2N1c1Zpc2libGV9YF06e2JveFNoYWRvdzoibm9uZSJ9LCImOmFjdGl2ZSI6e2JveFNoYWRvdzoibm9uZSJ9LFtgJi4ke3NvLmRpc2FibGVkfWBdOntib3hTaGFkb3c6Im5vbmUifX19LHtwcm9wczp7ZnVsbFdpZHRoOiEwfSxzdHlsZTp7d2lkdGg6IjEwMCUifX1dfX0pKSxWUj1HKCJzcGFuIix7bmFtZToiTXVpQnV0dG9uIixzbG90OiJTdGFydEljb24iLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt0LnN0YXJ0SWNvbix0W2BpY29uU2l6ZSR7bmUobi5zaXplKX1gXV19fSkoe2Rpc3BsYXk6ImluaGVyaXQiLG1hcmdpblJpZ2h0OjgsbWFyZ2luTGVmdDotNCx2YXJpYW50czpbe3Byb3BzOntzaXplOiJzbWFsbCJ9LHN0eWxlOnttYXJnaW5MZWZ0Oi0yfX0sLi4uUDBdfSksS1I9Rygic3BhbiIse25hbWU6Ik11aUJ1dHRvbiIsc2xvdDoiRW5kSWNvbiIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3QuZW5kSWNvbix0W2BpY29uU2l6ZSR7bmUobi5zaXplKX1gXV19fSkoe2Rpc3BsYXk6ImluaGVyaXQiLG1hcmdpblJpZ2h0Oi00LG1hcmdpbkxlZnQ6OCx2YXJpYW50czpbe3Byb3BzOntzaXplOiJzbWFsbCJ9LHN0eWxlOnttYXJnaW5SaWdodDotMn19LC4uLlAwXX0pLHp0PUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9Qy51c2VDb250ZXh0KEJSKSxvPUMudXNlQ29udGV4dChXUiksaT1iYShyLHQpLHM9bWUoe3Byb3BzOmksbmFtZToiTXVpQnV0dG9uIn0pLHtjaGlsZHJlbjphLGNvbG9yOmw9InByaW1hcnkiLGNvbXBvbmVudDp1PSJidXR0b24iLGNsYXNzTmFtZTpjLGRpc2FibGVkOmQ9ITEsZGlzYWJsZUVsZXZhdGlvbjptPSExLGRpc2FibGVGb2N1c1JpcHBsZTp2PSExLGVuZEljb246dyxmb2N1c1Zpc2libGVDbGFzc05hbWU6UyxmdWxsV2lkdGg6eD0hMSxzaXplOmg9Im1lZGl1bSIsc3RhcnRJY29uOmcsdHlwZTpmLHZhcmlhbnQ6eT0idGV4dCIsLi4uYn09cyxFPXsuLi5zLGNvbG9yOmwsY29tcG9uZW50OnUsZGlzYWJsZWQ6ZCxkaXNhYmxlRWxldmF0aW9uOm0sZGlzYWJsZUZvY3VzUmlwcGxlOnYsZnVsbFdpZHRoOngsc2l6ZTpoLHR5cGU6Zix2YXJpYW50Onl9LFI9VVIoRSksUD1nJiZrLmpzeChWUix7Y2xhc3NOYW1lOlIuc3RhcnRJY29uLG93bmVyU3RhdGU6RSxjaGlsZHJlbjpnfSksST13JiZrLmpzeChLUix7Y2xhc3NOYW1lOlIuZW5kSWNvbixvd25lclN0YXRlOkUsY2hpbGRyZW46d30pLHA9b3x8IiI7cmV0dXJuIGsuanN4cyhIUix7b3duZXJTdGF0ZTpFLGNsYXNzTmFtZTp0ZShyLmNsYXNzTmFtZSxSLnJvb3QsYyxwKSxjb21wb25lbnQ6dSxkaXNhYmxlZDpkLGZvY3VzUmlwcGxlOiF2LGZvY3VzVmlzaWJsZUNsYXNzTmFtZTp0ZShSLmZvY3VzVmlzaWJsZSxTKSxyZWY6bix0eXBlOmYsLi4uYixjbGFzc2VzOlIsY2hpbGRyZW46W1AsYSxJXX0pfSk7ZnVuY3Rpb24gWVIoZSl7Y29uc3QgdD1EdChlKTtyZXR1cm4gdC5ib2R5PT09ZT9HbihlKS5pbm5lcldpZHRoPnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoOmUuc2Nyb2xsSGVpZ2h0PmUuY2xpZW50SGVpZ2h0fWZ1bmN0aW9uIExpKGUsdCl7dD9lLnNldEF0dHJpYnV0ZSgiYXJpYS1oaWRkZW4iLCJ0cnVlIik6ZS5yZW1vdmVBdHRyaWJ1dGUoImFyaWEtaGlkZGVuIil9ZnVuY3Rpb24ga2goZSl7cmV0dXJuIHBhcnNlSW50KEduKGUpLmdldENvbXB1dGVkU3R5bGUoZSkucGFkZGluZ1JpZ2h0LDEwKXx8MH1mdW5jdGlvbiBHUihlKXtjb25zdCBuPVsiVEVNUExBVEUiLCJTQ1JJUFQiLCJTVFlMRSIsIkxJTksiLCJNQVAiLCJNRVRBIiwiTk9TQ1JJUFQiLCJQSUNUVVJFIiwiQ09MIiwiQ09MR1JPVVAiLCJQQVJBTSIsIlNMT1QiLCJTT1VSQ0UiLCJUUkFDSyJdLmluY2x1ZGVzKGUudGFnTmFtZSkscj1lLnRhZ05hbWU9PT0iSU5QVVQiJiZlLmdldEF0dHJpYnV0ZSgidHlwZSIpPT09ImhpZGRlbiI7cmV0dXJuIG58fHJ9ZnVuY3Rpb24gRWgoZSx0LG4scixvKXtjb25zdCBpPVt0LG4sLi4ucl07W10uZm9yRWFjaC5jYWxsKGUuY2hpbGRyZW4scz0+e2NvbnN0IGE9IWkuaW5jbHVkZXMocyksbD0hR1Iocyk7YSYmbCYmTGkocyxvKX0pfWZ1bmN0aW9uIHF1KGUsdCl7bGV0IG49LTE7cmV0dXJuIGUuc29tZSgocixvKT0+dChyKT8obj1vLCEwKTohMSksbn1mdW5jdGlvbiBRUihlLHQpe2NvbnN0IG49W10scj1lLmNvbnRhaW5lcjtpZighdC5kaXNhYmxlU2Nyb2xsTG9jayl7aWYoWVIocikpe2NvbnN0IHM9WmcoR24ocikpO24ucHVzaCh7dmFsdWU6ci5zdHlsZS5wYWRkaW5nUmlnaHQscHJvcGVydHk6InBhZGRpbmctcmlnaHQiLGVsOnJ9KSxyLnN0eWxlLnBhZGRpbmdSaWdodD1gJHtraChyKStzfXB4YDtjb25zdCBhPUR0KHIpLnF1ZXJ5U2VsZWN0b3JBbGwoIi5tdWktZml4ZWQiKTtbXS5mb3JFYWNoLmNhbGwoYSxsPT57bi5wdXNoKHt2YWx1ZTpsLnN0eWxlLnBhZGRpbmdSaWdodCxwcm9wZXJ0eToicGFkZGluZy1yaWdodCIsZWw6bH0pLGwuc3R5bGUucGFkZGluZ1JpZ2h0PWAke2toKGwpK3N9cHhgfSl9bGV0IGk7aWYoci5wYXJlbnROb2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClpPUR0KHIpLmJvZHk7ZWxzZXtjb25zdCBzPXIucGFyZW50RWxlbWVudCxhPUduKHIpO2k9KHM9PW51bGw/dm9pZCAwOnMubm9kZU5hbWUpPT09IkhUTUwiJiZhLmdldENvbXB1dGVkU3R5bGUocykub3ZlcmZsb3dZPT09InNjcm9sbCI/czpyfW4ucHVzaCh7dmFsdWU6aS5zdHlsZS5vdmVyZmxvdyxwcm9wZXJ0eToib3ZlcmZsb3ciLGVsOml9LHt2YWx1ZTppLnN0eWxlLm92ZXJmbG93WCxwcm9wZXJ0eToib3ZlcmZsb3cteCIsZWw6aX0se3ZhbHVlOmkuc3R5bGUub3ZlcmZsb3dZLHByb3BlcnR5OiJvdmVyZmxvdy15IixlbDppfSksaS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIn1yZXR1cm4oKT0+e24uZm9yRWFjaCgoe3ZhbHVlOmksZWw6cyxwcm9wZXJ0eTphfSk9PntpP3Muc3R5bGUuc2V0UHJvcGVydHkoYSxpKTpzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGEpfSl9fWZ1bmN0aW9uIFhSKGUpe2NvbnN0IHQ9W107cmV0dXJuW10uZm9yRWFjaC5jYWxsKGUuY2hpbGRyZW4sbj0+e24uZ2V0QXR0cmlidXRlKCJhcmlhLWhpZGRlbiIpPT09InRydWUiJiZ0LnB1c2gobil9KSx0fWNsYXNzIHFSe2NvbnN0cnVjdG9yKCl7dGhpcy5tb2RhbHM9W10sdGhpcy5jb250YWluZXJzPVtdfWFkZCh0LG4pe2xldCByPXRoaXMubW9kYWxzLmluZGV4T2YodCk7aWYociE9PS0xKXJldHVybiByO3I9dGhpcy5tb2RhbHMubGVuZ3RoLHRoaXMubW9kYWxzLnB1c2godCksdC5tb2RhbFJlZiYmTGkodC5tb2RhbFJlZiwhMSk7Y29uc3Qgbz1YUihuKTtFaChuLHQubW91bnQsdC5tb2RhbFJlZixvLCEwKTtjb25zdCBpPXF1KHRoaXMuY29udGFpbmVycyxzPT5zLmNvbnRhaW5lcj09PW4pO3JldHVybiBpIT09LTE/KHRoaXMuY29udGFpbmVyc1tpXS5tb2RhbHMucHVzaCh0KSxyKToodGhpcy5jb250YWluZXJzLnB1c2goe21vZGFsczpbdF0sY29udGFpbmVyOm4scmVzdG9yZTpudWxsLGhpZGRlblNpYmxpbmdzOm99KSxyKX1tb3VudCh0LG4pe2NvbnN0IHI9cXUodGhpcy5jb250YWluZXJzLGk9PmkubW9kYWxzLmluY2x1ZGVzKHQpKSxvPXRoaXMuY29udGFpbmVyc1tyXTtvLnJlc3RvcmV8fChvLnJlc3RvcmU9UVIobyxuKSl9cmVtb3ZlKHQsbj0hMCl7Y29uc3Qgcj10aGlzLm1vZGFscy5pbmRleE9mKHQpO2lmKHI9PT0tMSlyZXR1cm4gcjtjb25zdCBvPXF1KHRoaXMuY29udGFpbmVycyxzPT5zLm1vZGFscy5pbmNsdWRlcyh0KSksaT10aGlzLmNvbnRhaW5lcnNbb107aWYoaS5tb2RhbHMuc3BsaWNlKGkubW9kYWxzLmluZGV4T2YodCksMSksdGhpcy5tb2RhbHMuc3BsaWNlKHIsMSksaS5tb2RhbHMubGVuZ3RoPT09MClpLnJlc3RvcmUmJmkucmVzdG9yZSgpLHQubW9kYWxSZWYmJkxpKHQubW9kYWxSZWYsbiksRWgoaS5jb250YWluZXIsdC5tb3VudCx0Lm1vZGFsUmVmLGkuaGlkZGVuU2libGluZ3MsITEpLHRoaXMuY29udGFpbmVycy5zcGxpY2UobywxKTtlbHNle2NvbnN0IHM9aS5tb2RhbHNbaS5tb2RhbHMubGVuZ3RoLTFdO3MubW9kYWxSZWYmJkxpKHMubW9kYWxSZWYsITEpfXJldHVybiByfWlzVG9wTW9kYWwodCl7cmV0dXJuIHRoaXMubW9kYWxzLmxlbmd0aD4wJiZ0aGlzLm1vZGFsc1t0aGlzLm1vZGFscy5sZW5ndGgtMV09PT10fX1jb25zdCBaUj1bImlucHV0Iiwic2VsZWN0IiwidGV4dGFyZWEiLCJhW2hyZWZdIiwiYnV0dG9uIiwiW3RhYmluZGV4XSIsImF1ZGlvW2NvbnRyb2xzXSIsInZpZGVvW2NvbnRyb2xzXSIsJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSJmYWxzZSJdKSddLmpvaW4oIiwiKTtmdW5jdGlvbiBKUihlKXtjb25zdCB0PXBhcnNlSW50KGUuZ2V0QXR0cmlidXRlKCJ0YWJpbmRleCIpfHwiIiwxMCk7cmV0dXJuIE51bWJlci5pc05hTih0KT9lLmNvbnRlbnRFZGl0YWJsZT09PSJ0cnVlInx8KGUubm9kZU5hbWU9PT0iQVVESU8ifHxlLm5vZGVOYW1lPT09IlZJREVPInx8ZS5ub2RlTmFtZT09PSJERVRBSUxTIikmJmUuZ2V0QXR0cmlidXRlKCJ0YWJpbmRleCIpPT09bnVsbD8wOmUudGFiSW5kZXg6dH1mdW5jdGlvbiBlVChlKXtpZihlLnRhZ05hbWUhPT0iSU5QVVQifHxlLnR5cGUhPT0icmFkaW8ifHwhZS5uYW1lKXJldHVybiExO2NvbnN0IHQ9cj0+ZS5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGlucHV0W3R5cGU9InJhZGlvIl0ke3J9YCk7bGV0IG49dChgW25hbWU9IiR7ZS5uYW1lfSJdOmNoZWNrZWRgKTtyZXR1cm4gbnx8KG49dChgW25hbWU9IiR7ZS5uYW1lfSJdYCkpLG4hPT1lfWZ1bmN0aW9uIHRUKGUpe3JldHVybiEoZS5kaXNhYmxlZHx8ZS50YWdOYW1lPT09IklOUFVUIiYmZS50eXBlPT09ImhpZGRlbiJ8fGVUKGUpKX1mdW5jdGlvbiBuVChlKXtjb25zdCB0PVtdLG49W107cmV0dXJuIEFycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKFpSKSkuZm9yRWFjaCgocixvKT0+e2NvbnN0IGk9SlIocik7aT09PS0xfHwhdFQocil8fChpPT09MD90LnB1c2gocik6bi5wdXNoKHtkb2N1bWVudE9yZGVyOm8sdGFiSW5kZXg6aSxub2RlOnJ9KSl9KSxuLnNvcnQoKHIsbyk9PnIudGFiSW5kZXg9PT1vLnRhYkluZGV4P3IuZG9jdW1lbnRPcmRlci1vLmRvY3VtZW50T3JkZXI6ci50YWJJbmRleC1vLnRhYkluZGV4KS5tYXAocj0+ci5ub2RlKS5jb25jYXQodCl9ZnVuY3Rpb24gclQoKXtyZXR1cm4hMH1mdW5jdGlvbiBvVChlKXtjb25zdHtjaGlsZHJlbjp0LGRpc2FibGVBdXRvRm9jdXM6bj0hMSxkaXNhYmxlRW5mb3JjZUZvY3VzOnI9ITEsZGlzYWJsZVJlc3RvcmVGb2N1czpvPSExLGdldFRhYmJhYmxlOmk9blQsaXNFbmFibGVkOnM9clQsb3BlbjphfT1lLGw9Qy51c2VSZWYoITEpLHU9Qy51c2VSZWYobnVsbCksYz1DLnVzZVJlZihudWxsKSxkPUMudXNlUmVmKG51bGwpLG09Qy51c2VSZWYobnVsbCksdj1DLnVzZVJlZighMSksdz1DLnVzZVJlZihudWxsKSxTPVFlKFFvKHQpLHcpLHg9Qy51c2VSZWYobnVsbCk7Qy51c2VFZmZlY3QoKCk9PnshYXx8IXcuY3VycmVudHx8KHYuY3VycmVudD0hbil9LFtuLGFdKSxDLnVzZUVmZmVjdCgoKT0+e2lmKCFhfHwhdy5jdXJyZW50KXJldHVybjtjb25zdCBmPUR0KHcuY3VycmVudCk7cmV0dXJuIHcuY3VycmVudC5jb250YWlucyhmLmFjdGl2ZUVsZW1lbnQpfHwody5jdXJyZW50Lmhhc0F0dHJpYnV0ZSgidGFiSW5kZXgiKXx8dy5jdXJyZW50LnNldEF0dHJpYnV0ZSgidGFiSW5kZXgiLCItMSIpLHYuY3VycmVudCYmdy5jdXJyZW50LmZvY3VzKCkpLCgpPT57b3x8KGQuY3VycmVudCYmZC5jdXJyZW50LmZvY3VzJiYobC5jdXJyZW50PSEwLGQuY3VycmVudC5mb2N1cygpKSxkLmN1cnJlbnQ9bnVsbCl9fSxbYV0pLEMudXNlRWZmZWN0KCgpPT57aWYoIWF8fCF3LmN1cnJlbnQpcmV0dXJuO2NvbnN0IGY9RHQody5jdXJyZW50KSx5PVI9Pnt4LmN1cnJlbnQ9UiwhKHJ8fCFzKCl8fFIua2V5IT09IlRhYiIpJiZmLmFjdGl2ZUVsZW1lbnQ9PT13LmN1cnJlbnQmJlIuc2hpZnRLZXkmJihsLmN1cnJlbnQ9ITAsYy5jdXJyZW50JiZjLmN1cnJlbnQuZm9jdXMoKSl9LGI9KCk9Pnt2YXIgSSxwO2NvbnN0IFI9dy5jdXJyZW50O2lmKFI9PT1udWxsKXJldHVybjtpZighZi5oYXNGb2N1cygpfHwhcygpfHxsLmN1cnJlbnQpe2wuY3VycmVudD0hMTtyZXR1cm59aWYoUi5jb250YWlucyhmLmFjdGl2ZUVsZW1lbnQpfHxyJiZmLmFjdGl2ZUVsZW1lbnQhPT11LmN1cnJlbnQmJmYuYWN0aXZlRWxlbWVudCE9PWMuY3VycmVudClyZXR1cm47aWYoZi5hY3RpdmVFbGVtZW50IT09bS5jdXJyZW50KW0uY3VycmVudD1udWxsO2Vsc2UgaWYobS5jdXJyZW50IT09bnVsbClyZXR1cm47aWYoIXYuY3VycmVudClyZXR1cm47bGV0IFA9W107aWYoKGYuYWN0aXZlRWxlbWVudD09PXUuY3VycmVudHx8Zi5hY3RpdmVFbGVtZW50PT09Yy5jdXJyZW50KSYmKFA9aSh3LmN1cnJlbnQpKSxQLmxlbmd0aD4wKXtjb25zdCAkPSEhKChJPXguY3VycmVudCkhPW51bGwmJkkuc2hpZnRLZXkmJigocD14LmN1cnJlbnQpPT1udWxsP3ZvaWQgMDpwLmtleSk9PT0iVGFiIiksTD1QWzBdLGo9UFtQLmxlbmd0aC0xXTt0eXBlb2YgTCE9InN0cmluZyImJnR5cGVvZiBqIT0ic3RyaW5nIiYmKCQ/ai5mb2N1cygpOkwuZm9jdXMoKSl9ZWxzZSBSLmZvY3VzKCl9O2YuYWRkRXZlbnRMaXN0ZW5lcigiZm9jdXNpbiIsYiksZi5hZGRFdmVudExpc3RlbmVyKCJrZXlkb3duIix5LCEwKTtjb25zdCBFPXNldEludGVydmFsKCgpPT57Zi5hY3RpdmVFbGVtZW50JiZmLmFjdGl2ZUVsZW1lbnQudGFnTmFtZT09PSJCT0RZIiYmYigpfSw1MCk7cmV0dXJuKCk9PntjbGVhckludGVydmFsKEUpLGYucmVtb3ZlRXZlbnRMaXN0ZW5lcigiZm9jdXNpbiIsYiksZi5yZW1vdmVFdmVudExpc3RlbmVyKCJrZXlkb3duIix5LCEwKX19LFtuLHIsbyxzLGEsaV0pO2NvbnN0IGg9Zj0+e2QuY3VycmVudD09PW51bGwmJihkLmN1cnJlbnQ9Zi5yZWxhdGVkVGFyZ2V0KSx2LmN1cnJlbnQ9ITAsbS5jdXJyZW50PWYudGFyZ2V0O2NvbnN0IHk9dC5wcm9wcy5vbkZvY3VzO3kmJnkoZil9LGc9Zj0+e2QuY3VycmVudD09PW51bGwmJihkLmN1cnJlbnQ9Zi5yZWxhdGVkVGFyZ2V0KSx2LmN1cnJlbnQ9ITB9O3JldHVybiBrLmpzeHMoQy5GcmFnbWVudCx7Y2hpbGRyZW46W2suanN4KCJkaXYiLHt0YWJJbmRleDphPzA6LTEsb25Gb2N1czpnLHJlZjp1LCJkYXRhLXRlc3RpZCI6InNlbnRpbmVsU3RhcnQifSksQy5jbG9uZUVsZW1lbnQodCx7cmVmOlMsb25Gb2N1czpofSksay5qc3goImRpdiIse3RhYkluZGV4OmE/MDotMSxvbkZvY3VzOmcscmVmOmMsImRhdGEtdGVzdGlkIjoic2VudGluZWxFbmQifSldfSl9ZnVuY3Rpb24gaVQoZSl7cmV0dXJuIHR5cGVvZiBlPT0iZnVuY3Rpb24iP2UoKTplfWZ1bmN0aW9uIHNUKGUpe3JldHVybiBlP2UucHJvcHMuaGFzT3duUHJvcGVydHkoImluIik6ITF9Y29uc3QgWnM9bmV3IHFSO2Z1bmN0aW9uIGFUKGUpe2NvbnN0e2NvbnRhaW5lcjp0LGRpc2FibGVFc2NhcGVLZXlEb3duOm49ITEsZGlzYWJsZVNjcm9sbExvY2s6cj0hMSxjbG9zZUFmdGVyVHJhbnNpdGlvbjpvPSExLG9uVHJhbnNpdGlvbkVudGVyOmksb25UcmFuc2l0aW9uRXhpdGVkOnMsY2hpbGRyZW46YSxvbkNsb3NlOmwsb3Blbjp1LHJvb3RSZWY6Y309ZSxkPUMudXNlUmVmKHt9KSxtPUMudXNlUmVmKG51bGwpLHY9Qy51c2VSZWYobnVsbCksdz1RZSh2LGMpLFtTLHhdPUMudXNlU3RhdGUoIXUpLGg9c1QoYSk7bGV0IGc9ITA7KGVbImFyaWEtaGlkZGVuIl09PT0iZmFsc2UifHxlWyJhcmlhLWhpZGRlbiJdPT09ITEpJiYoZz0hMSk7Y29uc3QgZj0oKT0+RHQobS5jdXJyZW50KSx5PSgpPT4oZC5jdXJyZW50Lm1vZGFsUmVmPXYuY3VycmVudCxkLmN1cnJlbnQubW91bnQ9bS5jdXJyZW50LGQuY3VycmVudCksYj0oKT0+e1pzLm1vdW50KHkoKSx7ZGlzYWJsZVNjcm9sbExvY2s6cn0pLHYuY3VycmVudCYmKHYuY3VycmVudC5zY3JvbGxUb3A9MCl9LEU9dXIoKCk9Pntjb25zdCBPPWlUKHQpfHxmKCkuYm9keTtacy5hZGQoeSgpLE8pLHYuY3VycmVudCYmYigpfSksUj0oKT0+WnMuaXNUb3BNb2RhbCh5KCkpLFA9dXIoTz0+e20uY3VycmVudD1PLE8mJih1JiZSKCk/YigpOnYuY3VycmVudCYmTGkodi5jdXJyZW50LGcpKX0pLEk9Qy51c2VDYWxsYmFjaygoKT0+e1pzLnJlbW92ZSh5KCksZyl9LFtnXSk7Qy51c2VFZmZlY3QoKCk9PigpPT57SSgpfSxbSV0pLEMudXNlRWZmZWN0KCgpPT57dT9FKCk6KCFofHwhbykmJkkoKX0sW3UsSSxoLG8sRV0pO2NvbnN0IHA9Tz0+TT0+e3ZhciBfOyhfPU8ub25LZXlEb3duKT09bnVsbHx8Xy5jYWxsKE8sTSksIShNLmtleSE9PSJFc2NhcGUifHxNLndoaWNoPT09MjI5fHwhUigpKSYmKG58fChNLnN0b3BQcm9wYWdhdGlvbigpLGwmJmwoTSwiZXNjYXBlS2V5RG93biIpKSl9LCQ9Tz0+TT0+e3ZhciBfOyhfPU8ub25DbGljayk9PW51bGx8fF8uY2FsbChPLE0pLE0udGFyZ2V0PT09TS5jdXJyZW50VGFyZ2V0JiZsJiZsKE0sImJhY2tkcm9wQ2xpY2siKX07cmV0dXJue2dldFJvb3RQcm9wczooTz17fSk9Pntjb25zdCBNPUpnKGUpO2RlbGV0ZSBNLm9uVHJhbnNpdGlvbkVudGVyLGRlbGV0ZSBNLm9uVHJhbnNpdGlvbkV4aXRlZDtjb25zdCBfPXsuLi5NLC4uLk99O3JldHVybntyb2xlOiJwcmVzZW50YXRpb24iLC4uLl8sb25LZXlEb3duOnAoXykscmVmOnd9fSxnZXRCYWNrZHJvcFByb3BzOihPPXt9KT0+e2NvbnN0IE09TztyZXR1cm57ImFyaWEtaGlkZGVuIjohMCwuLi5NLG9uQ2xpY2s6JChNKSxvcGVuOnV9fSxnZXRUcmFuc2l0aW9uUHJvcHM6KCk9Pntjb25zdCBPPSgpPT57eCghMSksaSYmaSgpfSxNPSgpPT57eCghMCkscyYmcygpLG8mJkkoKX07cmV0dXJue29uRW50ZXI6VnAoTyxhPT1udWxsP3ZvaWQgMDphLnByb3BzLm9uRW50ZXIpLG9uRXhpdGVkOlZwKE0sYT09bnVsbD92b2lkIDA6YS5wcm9wcy5vbkV4aXRlZCl9fSxyb290UmVmOncscG9ydGFsUmVmOlAsaXNUb3BNb2RhbDpSLGV4aXRlZDpTLGhhc1RyYW5zaXRpb246aH19ZnVuY3Rpb24gbFQoZSl7cmV0dXJuIGNlKCJNdWlNb2RhbCIsZSl9ZGUoIk11aU1vZGFsIixbInJvb3QiLCJoaWRkZW4iLCJiYWNrZHJvcCJdKTtjb25zdCB1VD1lPT57Y29uc3R7b3Blbjp0LGV4aXRlZDpuLGNsYXNzZXM6cn09ZTtyZXR1cm4gcGUoe3Jvb3Q6WyJyb290IiwhdCYmbiYmImhpZGRlbiJdLGJhY2tkcm9wOlsiYmFja2Ryb3AiXX0sbFQscil9LGNUPUcoImRpdiIse25hbWU6Ik11aU1vZGFsIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5yb290LCFuLm9wZW4mJm4uZXhpdGVkJiZ0LmhpZGRlbl19fSkoeWUoKHt0aGVtZTplfSk9Pih7cG9zaXRpb246ImZpeGVkIix6SW5kZXg6KGUudmFyc3x8ZSkuekluZGV4Lm1vZGFsLHJpZ2h0OjAsYm90dG9tOjAsdG9wOjAsbGVmdDowLHZhcmlhbnRzOlt7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+IXQub3BlbiYmdC5leGl0ZWQsc3R5bGU6e3Zpc2liaWxpdHk6ImhpZGRlbiJ9fV19KSkpLGRUPUcoRFIse25hbWU6Ik11aU1vZGFsIixzbG90OiJCYWNrZHJvcCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQuYmFja2Ryb3B9KSh7ekluZGV4Oi0xfSksZlQ9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7bmFtZToiTXVpTW9kYWwiLHByb3BzOnR9KSx7QmFja2Ryb3BDb21wb25lbnQ6bz1kVCxCYWNrZHJvcFByb3BzOmksY2xhc3NlczpzLGNsYXNzTmFtZTphLGNsb3NlQWZ0ZXJUcmFuc2l0aW9uOmw9ITEsY2hpbGRyZW46dSxjb250YWluZXI6Yyxjb21wb25lbnQ6ZCxjb21wb25lbnRzOm09e30sY29tcG9uZW50c1Byb3BzOnY9e30sZGlzYWJsZUF1dG9Gb2N1czp3PSExLGRpc2FibGVFbmZvcmNlRm9jdXM6Uz0hMSxkaXNhYmxlRXNjYXBlS2V5RG93bjp4PSExLGRpc2FibGVQb3J0YWw6aD0hMSxkaXNhYmxlUmVzdG9yZUZvY3VzOmc9ITEsZGlzYWJsZVNjcm9sbExvY2s6Zj0hMSxoaWRlQmFja2Ryb3A6eT0hMSxrZWVwTW91bnRlZDpiPSExLG9uQmFja2Ryb3BDbGljazpFLG9uQ2xvc2U6UixvblRyYW5zaXRpb25FbnRlcjpQLG9uVHJhbnNpdGlvbkV4aXRlZDpJLG9wZW46cCxzbG90UHJvcHM6JD17fSxzbG90czpMPXt9LHRoZW1lOmosLi4uTn09cixPPXsuLi5yLGNsb3NlQWZ0ZXJUcmFuc2l0aW9uOmwsZGlzYWJsZUF1dG9Gb2N1czp3LGRpc2FibGVFbmZvcmNlRm9jdXM6UyxkaXNhYmxlRXNjYXBlS2V5RG93bjp4LGRpc2FibGVQb3J0YWw6aCxkaXNhYmxlUmVzdG9yZUZvY3VzOmcsZGlzYWJsZVNjcm9sbExvY2s6ZixoaWRlQmFja2Ryb3A6eSxrZWVwTW91bnRlZDpifSx7Z2V0Um9vdFByb3BzOk0sZ2V0QmFja2Ryb3BQcm9wczpfLGdldFRyYW5zaXRpb25Qcm9wczpULHBvcnRhbFJlZjpBLGlzVG9wTW9kYWw6RCxleGl0ZWQ6QixoYXNUcmFuc2l0aW9uOkh9PWFUKHsuLi5PLHJvb3RSZWY6bn0pLFY9ey4uLk8sZXhpdGVkOkJ9LFU9dVQoViksWD17fTtpZih1LnByb3BzLnRhYkluZGV4PT09dm9pZCAwJiYoWC50YWJJbmRleD0iLTEiKSxIKXtjb25zdHtvbkVudGVyOlksb25FeGl0ZWQ6dWV9PVQoKTtYLm9uRW50ZXI9WSxYLm9uRXhpdGVkPXVlfWNvbnN0IFc9ey4uLk4sc2xvdHM6e3Jvb3Q6bS5Sb290LGJhY2tkcm9wOm0uQmFja2Ryb3AsLi4uTH0sc2xvdFByb3BzOnsuLi52LC4uLiR9fSxbSixvZV09TnQoInJvb3QiLHtlbGVtZW50VHlwZTpjVCxleHRlcm5hbEZvcndhcmRlZFByb3BzOlcsZ2V0U2xvdFByb3BzOk0sYWRkaXRpb25hbFByb3BzOntyZWY6bixhczpkfSxvd25lclN0YXRlOlYsY2xhc3NOYW1lOnRlKGEsVT09bnVsbD92b2lkIDA6VS5yb290LCFWLm9wZW4mJlYuZXhpdGVkJiYoVT09bnVsbD92b2lkIDA6VS5oaWRkZW4pKX0pLFtyZSxRXT1OdCgiYmFja2Ryb3AiLHtlbGVtZW50VHlwZTpvLGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6VyxhZGRpdGlvbmFsUHJvcHM6aSxnZXRTbG90UHJvcHM6WT0+Xyh7Li4uWSxvbkNsaWNrOnVlPT57RSYmRSh1ZSksWSE9bnVsbCYmWS5vbkNsaWNrJiZZLm9uQ2xpY2sodWUpfX0pLGNsYXNzTmFtZTp0ZShpPT1udWxsP3ZvaWQgMDppLmNsYXNzTmFtZSxVPT1udWxsP3ZvaWQgMDpVLmJhY2tkcm9wKSxvd25lclN0YXRlOlZ9KSxlZT1RZShpPT1udWxsP3ZvaWQgMDppLnJlZixRLnJlZik7cmV0dXJuIWImJiFwJiYoIUh8fEIpP251bGw6ay5qc3goUjAse3JlZjpBLGNvbnRhaW5lcjpjLGRpc2FibGVQb3J0YWw6aCxjaGlsZHJlbjprLmpzeHMoSix7Li4ub2UsY2hpbGRyZW46WyF5JiZvP2suanN4KHJlLHsuLi5RLHJlZjplZX0pOm51bGwsay5qc3gob1Qse2Rpc2FibGVFbmZvcmNlRm9jdXM6UyxkaXNhYmxlQXV0b0ZvY3VzOncsZGlzYWJsZVJlc3RvcmVGb2N1czpnLGlzRW5hYmxlZDpELG9wZW46cCxjaGlsZHJlbjpDLmNsb25lRWxlbWVudCh1LFgpfSldfSl9KX0pLHBUPWU9Pntjb25zdHtjbGFzc2VzOnQsZGlzYWJsZVVuZGVybGluZTpuLHN0YXJ0QWRvcm5tZW50OnIsZW5kQWRvcm5tZW50Om8sc2l6ZTppLGhpZGRlbkxhYmVsOnMsbXVsdGlsaW5lOmF9PWUsbD17cm9vdDpbInJvb3QiLCFuJiYidW5kZXJsaW5lIixyJiYiYWRvcm5lZFN0YXJ0IixvJiYiYWRvcm5lZEVuZCIsaT09PSJzbWFsbCImJmBzaXplJHtuZShpKX1gLHMmJiJoaWRkZW5MYWJlbCIsYSYmIm11bHRpbGluZSJdLGlucHV0OlsiaW5wdXQiXX0sdT1wZShsLE1SLHQpO3JldHVybnsuLi50LC4uLnV9fSxtVD1HKGN1LHtzaG91bGRGb3J3YXJkUHJvcDplPT5TbihlKXx8ZT09PSJjbGFzc2VzIixuYW1lOiJNdWlGaWxsZWRJbnB1dCIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuWy4uLmx1KGUsdCksIW4uZGlzYWJsZVVuZGVybGluZSYmdC51bmRlcmxpbmVdfX0pKHllKCh7dGhlbWU6ZX0pPT57Y29uc3QgdD1lLnBhbGV0dGUubW9kZT09PSJsaWdodCIsbj10PyJyZ2JhKDAsIDAsIDAsIDAuNDIpIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpIixyPXQ/InJnYmEoMCwgMCwgMCwgMC4wNikiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDkpIixvPXQ/InJnYmEoMCwgMCwgMCwgMC4wOSkiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTMpIixpPXQ/InJnYmEoMCwgMCwgMCwgMC4xMikiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpIjtyZXR1cm57cG9zaXRpb246InJlbGF0aXZlIixiYWNrZ3JvdW5kQ29sb3I6ZS52YXJzP2UudmFycy5wYWxldHRlLkZpbGxlZElucHV0LmJnOnIsYm9yZGVyVG9wTGVmdFJhZGl1czooZS52YXJzfHxlKS5zaGFwZS5ib3JkZXJSYWRpdXMsYm9yZGVyVG9wUmlnaHRSYWRpdXM6KGUudmFyc3x8ZSkuc2hhcGUuYm9yZGVyUmFkaXVzLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoImJhY2tncm91bmQtY29sb3IiLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsZWFzaW5nOmUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXR9KSwiJjpob3ZlciI6e2JhY2tncm91bmRDb2xvcjplLnZhcnM/ZS52YXJzLnBhbGV0dGUuRmlsbGVkSW5wdXQuaG92ZXJCZzpvLCJAbWVkaWEgKGhvdmVyOiBub25lKSI6e2JhY2tncm91bmRDb2xvcjplLnZhcnM/ZS52YXJzLnBhbGV0dGUuRmlsbGVkSW5wdXQuYmc6cn19LFtgJi4keyRyLmZvY3VzZWR9YF06e2JhY2tncm91bmRDb2xvcjplLnZhcnM/ZS52YXJzLnBhbGV0dGUuRmlsbGVkSW5wdXQuYmc6cn0sW2AmLiR7JHIuZGlzYWJsZWR9YF06e2JhY2tncm91bmRDb2xvcjplLnZhcnM/ZS52YXJzLnBhbGV0dGUuRmlsbGVkSW5wdXQuZGlzYWJsZWRCZzppfSx2YXJpYW50czpbe3Byb3BzOih7b3duZXJTdGF0ZTpzfSk9PiFzLmRpc2FibGVVbmRlcmxpbmUsc3R5bGU6eyImOjphZnRlciI6e2xlZnQ6MCxib3R0b206MCxjb250ZW50OiciIicscG9zaXRpb246ImFic29sdXRlIixyaWdodDowLHRyYW5zZm9ybToic2NhbGVYKDApIix0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKCJ0cmFuc2Zvcm0iLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsZWFzaW5nOmUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXR9KSxwb2ludGVyRXZlbnRzOiJub25lIn0sW2AmLiR7JHIuZm9jdXNlZH06YWZ0ZXJgXTp7dHJhbnNmb3JtOiJzY2FsZVgoMSkgdHJhbnNsYXRlWCgwKSJ9LFtgJi4keyRyLmVycm9yfWBdOnsiJjo6YmVmb3JlLCAmOjphZnRlciI6e2JvcmRlckJvdHRvbUNvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuZXJyb3IubWFpbn19LCImOjpiZWZvcmUiOntib3JkZXJCb3R0b206YDFweCBzb2xpZCAke2UudmFycz9gcmdiYSgke2UudmFycy5wYWxldHRlLmNvbW1vbi5vbkJhY2tncm91bmRDaGFubmVsfSAvICR7ZS52YXJzLm9wYWNpdHkuaW5wdXRVbmRlcmxpbmV9KWA6bn1gLGxlZnQ6MCxib3R0b206MCxjb250ZW50OiciXFwwMGEwIicscG9zaXRpb246ImFic29sdXRlIixyaWdodDowLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoImJvcmRlci1ib3R0b20tY29sb3IiLHtkdXJhdGlvbjplLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJ9KSxwb2ludGVyRXZlbnRzOiJub25lIn0sW2AmOmhvdmVyOm5vdCguJHskci5kaXNhYmxlZH0sIC4keyRyLmVycm9yfSk6YmVmb3JlYF06e2JvcmRlckJvdHRvbTpgMXB4IHNvbGlkICR7KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LnByaW1hcnl9YH0sW2AmLiR7JHIuZGlzYWJsZWR9OmJlZm9yZWBdOntib3JkZXJCb3R0b21TdHlsZToiZG90dGVkIn19fSwuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihicigpKS5tYXAoKFtzXSk9Pnt2YXIgYTtyZXR1cm57cHJvcHM6e2Rpc2FibGVVbmRlcmxpbmU6ITEsY29sb3I6c30sc3R5bGU6eyImOjphZnRlciI6e2JvcmRlckJvdHRvbTpgMnB4IHNvbGlkICR7KGE9KGUudmFyc3x8ZSkucGFsZXR0ZVtzXSk9PW51bGw/dm9pZCAwOmEubWFpbn1gfX19fSkse3Byb3BzOih7b3duZXJTdGF0ZTpzfSk9PnMuc3RhcnRBZG9ybm1lbnQsc3R5bGU6e3BhZGRpbmdMZWZ0OjEyfX0se3Byb3BzOih7b3duZXJTdGF0ZTpzfSk9PnMuZW5kQWRvcm5tZW50LHN0eWxlOntwYWRkaW5nUmlnaHQ6MTJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOnN9KT0+cy5tdWx0aWxpbmUsc3R5bGU6e3BhZGRpbmc6IjI1cHggMTJweCA4cHgifX0se3Byb3BzOih7b3duZXJTdGF0ZTpzLHNpemU6YX0pPT5zLm11bHRpbGluZSYmYT09PSJzbWFsbCIsc3R5bGU6e3BhZGRpbmdUb3A6MjEscGFkZGluZ0JvdHRvbTo0fX0se3Byb3BzOih7b3duZXJTdGF0ZTpzfSk9PnMubXVsdGlsaW5lJiZzLmhpZGRlbkxhYmVsLHN0eWxlOntwYWRkaW5nVG9wOjE2LHBhZGRpbmdCb3R0b206MTd9fSx7cHJvcHM6KHtvd25lclN0YXRlOnN9KT0+cy5tdWx0aWxpbmUmJnMuaGlkZGVuTGFiZWwmJnMuc2l6ZT09PSJzbWFsbCIsc3R5bGU6e3BhZGRpbmdUb3A6OCxwYWRkaW5nQm90dG9tOjl9fV19fSkpLGhUPUcoZHUse25hbWU6Ik11aUZpbGxlZElucHV0IixzbG90OiJJbnB1dCIsb3ZlcnJpZGVzUmVzb2x2ZXI6dXV9KSh5ZSgoe3RoZW1lOmV9KT0+KHtwYWRkaW5nVG9wOjI1LHBhZGRpbmdSaWdodDoxMixwYWRkaW5nQm90dG9tOjgscGFkZGluZ0xlZnQ6MTIsLi4uIWUudmFycyYmeyImOi13ZWJraXQtYXV0b2ZpbGwiOntXZWJraXRCb3hTaGFkb3c6ZS5wYWxldHRlLm1vZGU9PT0ibGlnaHQiP251bGw6IjAgMCAwIDEwMHB4ICMyNjY3OTggaW5zZXQiLFdlYmtpdFRleHRGaWxsQ29sb3I6ZS5wYWxldHRlLm1vZGU9PT0ibGlnaHQiP251bGw6IiNmZmYiLGNhcmV0Q29sb3I6ZS5wYWxldHRlLm1vZGU9PT0ibGlnaHQiP251bGw6IiNmZmYiLGJvcmRlclRvcExlZnRSYWRpdXM6ImluaGVyaXQiLGJvcmRlclRvcFJpZ2h0UmFkaXVzOiJpbmhlcml0In19LC4uLmUudmFycyYmeyImOi13ZWJraXQtYXV0b2ZpbGwiOntib3JkZXJUb3BMZWZ0UmFkaXVzOiJpbmhlcml0Iixib3JkZXJUb3BSaWdodFJhZGl1czoiaW5oZXJpdCJ9LFtlLmdldENvbG9yU2NoZW1lU2VsZWN0b3IoImRhcmsiKV06eyImOi13ZWJraXQtYXV0b2ZpbGwiOntXZWJraXRCb3hTaGFkb3c6IjAgMCAwIDEwMHB4ICMyNjY3OTggaW5zZXQiLFdlYmtpdFRleHRGaWxsQ29sb3I6IiNmZmYiLGNhcmV0Q29sb3I6IiNmZmYifX19LHZhcmlhbnRzOlt7cHJvcHM6e3NpemU6InNtYWxsIn0sc3R5bGU6e3BhZGRpbmdUb3A6MjEscGFkZGluZ0JvdHRvbTo0fX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuaGlkZGVuTGFiZWwsc3R5bGU6e3BhZGRpbmdUb3A6MTYscGFkZGluZ0JvdHRvbToxN319LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT50LnN0YXJ0QWRvcm5tZW50LHN0eWxlOntwYWRkaW5nTGVmdDowfX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuZW5kQWRvcm5tZW50LHN0eWxlOntwYWRkaW5nUmlnaHQ6MH19LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT50LmhpZGRlbkxhYmVsJiZ0LnNpemU9PT0ic21hbGwiLHN0eWxlOntwYWRkaW5nVG9wOjgscGFkZGluZ0JvdHRvbTo5fX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQubXVsdGlsaW5lLHN0eWxlOntwYWRkaW5nVG9wOjAscGFkZGluZ0JvdHRvbTowLHBhZGRpbmdMZWZ0OjAscGFkZGluZ1JpZ2h0OjB9fV19KSkpLHRsPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpRmlsbGVkSW5wdXQifSkse2Rpc2FibGVVbmRlcmxpbmU6bz0hMSxjb21wb25lbnRzOmk9e30sY29tcG9uZW50c1Byb3BzOnMsZnVsbFdpZHRoOmE9ITEsaGlkZGVuTGFiZWw6bCxpbnB1dENvbXBvbmVudDp1PSJpbnB1dCIsbXVsdGlsaW5lOmM9ITEsc2xvdFByb3BzOmQsc2xvdHM6bT17fSx0eXBlOnY9InRleHQiLC4uLnd9PXIsUz17Li4ucixkaXNhYmxlVW5kZXJsaW5lOm8sZnVsbFdpZHRoOmEsaW5wdXRDb21wb25lbnQ6dSxtdWx0aWxpbmU6Yyx0eXBlOnZ9LHg9cFQociksaD17cm9vdDp7b3duZXJTdGF0ZTpTfSxpbnB1dDp7b3duZXJTdGF0ZTpTfX0sZz1kPz9zP3B0KGgsZD8/cyk6aCxmPW0ucm9vdD8/aS5Sb290Pz9tVCx5PW0uaW5wdXQ/P2kuSW5wdXQ/P2hUO3JldHVybiBrLmpzeChhcCx7c2xvdHM6e3Jvb3Q6ZixpbnB1dDp5fSxjb21wb25lbnRzUHJvcHM6ZyxmdWxsV2lkdGg6YSxpbnB1dENvbXBvbmVudDp1LG11bHRpbGluZTpjLHJlZjpuLHR5cGU6diwuLi53LGNsYXNzZXM6eH0pfSk7dGwmJih0bC5tdWlOYW1lPSJJbnB1dCIpO2Z1bmN0aW9uIGdUKGUpe3JldHVybiBjZSgiTXVpRm9ybUNvbnRyb2wiLGUpfWRlKCJNdWlGb3JtQ29udHJvbCIsWyJyb290IiwibWFyZ2luTm9uZSIsIm1hcmdpbk5vcm1hbCIsIm1hcmdpbkRlbnNlIiwiZnVsbFdpZHRoIiwiZGlzYWJsZWQiXSk7Y29uc3QgeVQ9ZT0+e2NvbnN0e2NsYXNzZXM6dCxtYXJnaW46bixmdWxsV2lkdGg6cn09ZSxvPXtyb290Olsicm9vdCIsbiE9PSJub25lIiYmYG1hcmdpbiR7bmUobil9YCxyJiYiZnVsbFdpZHRoIl19O3JldHVybiBwZShvLGdULHQpfSx2VD1HKCJkaXYiLHtuYW1lOiJNdWlGb3JtQ29udHJvbCIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KHtvd25lclN0YXRlOmV9LHQpPT4oey4uLnQucm9vdCwuLi50W2BtYXJnaW4ke25lKGUubWFyZ2luKX1gXSwuLi5lLmZ1bGxXaWR0aCYmdC5mdWxsV2lkdGh9KX0pKHtkaXNwbGF5OiJpbmxpbmUtZmxleCIsZmxleERpcmVjdGlvbjoiY29sdW1uIixwb3NpdGlvbjoicmVsYXRpdmUiLG1pbldpZHRoOjAscGFkZGluZzowLG1hcmdpbjowLGJvcmRlcjowLHZlcnRpY2FsQWxpZ246InRvcCIsdmFyaWFudHM6W3twcm9wczp7bWFyZ2luOiJub3JtYWwifSxzdHlsZTp7bWFyZ2luVG9wOjE2LG1hcmdpbkJvdHRvbTo4fX0se3Byb3BzOnttYXJnaW46ImRlbnNlIn0sc3R5bGU6e21hcmdpblRvcDo4LG1hcmdpbkJvdHRvbTo0fX0se3Byb3BzOntmdWxsV2lkdGg6ITB9LHN0eWxlOnt3aWR0aDoiMTAwJSJ9fV19KSx3VD1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aUZvcm1Db250cm9sIn0pLHtjaGlsZHJlbjpvLGNsYXNzTmFtZTppLGNvbG9yOnM9InByaW1hcnkiLGNvbXBvbmVudDphPSJkaXYiLGRpc2FibGVkOmw9ITEsZXJyb3I6dT0hMSxmb2N1c2VkOmMsZnVsbFdpZHRoOmQ9ITEsaGlkZGVuTGFiZWw6bT0hMSxtYXJnaW46dj0ibm9uZSIscmVxdWlyZWQ6dz0hMSxzaXplOlM9Im1lZGl1bSIsdmFyaWFudDp4PSJvdXRsaW5lZCIsLi4uaH09cixnPXsuLi5yLGNvbG9yOnMsY29tcG9uZW50OmEsZGlzYWJsZWQ6bCxlcnJvcjp1LGZ1bGxXaWR0aDpkLGhpZGRlbkxhYmVsOm0sbWFyZ2luOnYscmVxdWlyZWQ6dyxzaXplOlMsdmFyaWFudDp4fSxmPXlUKGcpLFt5LGJdPUMudXNlU3RhdGUoKCk9PntsZXQgaj0hMTtyZXR1cm4gbyYmQy5DaGlsZHJlbi5mb3JFYWNoKG8sTj0+e2lmKCFDdShOLFsiSW5wdXQiLCJTZWxlY3QiXSkpcmV0dXJuO2NvbnN0IE89Q3UoTixbIlNlbGVjdCJdKT9OLnByb3BzLmlucHV0Ok47TyYmUlIoTy5wcm9wcykmJihqPSEwKX0pLGp9KSxbRSxSXT1DLnVzZVN0YXRlKCgpPT57bGV0IGo9ITE7cmV0dXJuIG8mJkMuQ2hpbGRyZW4uZm9yRWFjaChvLE49PntDdShOLFsiSW5wdXQiLCJTZWxlY3QiXSkmJihlbChOLnByb3BzLCEwKXx8ZWwoTi5wcm9wcy5pbnB1dFByb3BzLCEwKSkmJihqPSEwKX0pLGp9KSxbUCxJXT1DLnVzZVN0YXRlKCExKTtsJiZQJiZJKCExKTtjb25zdCBwPWMhPT12b2lkIDAmJiFsP2M6UDtsZXQgJDtDLnVzZVJlZighMSk7Y29uc3QgTD1DLnVzZU1lbW8oKCk9Pih7YWRvcm5lZFN0YXJ0Onksc2V0QWRvcm5lZFN0YXJ0OmIsY29sb3I6cyxkaXNhYmxlZDpsLGVycm9yOnUsZmlsbGVkOkUsZm9jdXNlZDpwLGZ1bGxXaWR0aDpkLGhpZGRlbkxhYmVsOm0sc2l6ZTpTLG9uQmx1cjooKT0+e0koITEpfSxvbkVtcHR5OigpPT57UighMSl9LG9uRmlsbGVkOigpPT57UighMCl9LG9uRm9jdXM6KCk9PntJKCEwKX0scmVnaXN0ZXJFZmZlY3Q6JCxyZXF1aXJlZDp3LHZhcmlhbnQ6eH0pLFt5LHMsbCx1LEUscCxkLG0sJCx3LFMseF0pO3JldHVybiBrLmpzeChzcC5Qcm92aWRlcix7dmFsdWU6TCxjaGlsZHJlbjprLmpzeCh2VCx7YXM6YSxvd25lclN0YXRlOmcsY2xhc3NOYW1lOnRlKGYucm9vdCxpKSxyZWY6biwuLi5oLGNoaWxkcmVuOm99KX0pfSk7ZnVuY3Rpb24gU1QoZSl7cmV0dXJuIGNlKCJNdWlGb3JtSGVscGVyVGV4dCIsZSl9Y29uc3QgUmg9ZGUoIk11aUZvcm1IZWxwZXJUZXh0IixbInJvb3QiLCJlcnJvciIsImRpc2FibGVkIiwic2l6ZVNtYWxsIiwic2l6ZU1lZGl1bSIsImNvbnRhaW5lZCIsImZvY3VzZWQiLCJmaWxsZWQiLCJyZXF1aXJlZCJdKTt2YXIgVGg7Y29uc3QgeFQ9ZT0+e2NvbnN0e2NsYXNzZXM6dCxjb250YWluZWQ6bixzaXplOnIsZGlzYWJsZWQ6byxlcnJvcjppLGZpbGxlZDpzLGZvY3VzZWQ6YSxyZXF1aXJlZDpsfT1lLHU9e3Jvb3Q6WyJyb290IixvJiYiZGlzYWJsZWQiLGkmJiJlcnJvciIsciYmYHNpemUke25lKHIpfWAsbiYmImNvbnRhaW5lZCIsYSYmImZvY3VzZWQiLHMmJiJmaWxsZWQiLGwmJiJyZXF1aXJlZCJdfTtyZXR1cm4gcGUodSxTVCx0KX0sQ1Q9RygicCIse25hbWU6Ik11aUZvcm1IZWxwZXJUZXh0IixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5yb290LG4uc2l6ZSYmdFtgc2l6ZSR7bmUobi5zaXplKX1gXSxuLmNvbnRhaW5lZCYmdC5jb250YWluZWQsbi5maWxsZWQmJnQuZmlsbGVkXX19KSh5ZSgoe3RoZW1lOmV9KT0+KHtjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5LC4uLmUudHlwb2dyYXBoeS5jYXB0aW9uLHRleHRBbGlnbjoibGVmdCIsbWFyZ2luVG9wOjMsbWFyZ2luUmlnaHQ6MCxtYXJnaW5Cb3R0b206MCxtYXJnaW5MZWZ0OjAsW2AmLiR7UmguZGlzYWJsZWR9YF06e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUudGV4dC5kaXNhYmxlZH0sW2AmLiR7UmguZXJyb3J9YF06e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuZXJyb3IubWFpbn0sdmFyaWFudHM6W3twcm9wczp7c2l6ZToic21hbGwifSxzdHlsZTp7bWFyZ2luVG9wOjR9fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5jb250YWluZWQsc3R5bGU6e21hcmdpbkxlZnQ6MTQsbWFyZ2luUmlnaHQ6MTR9fV19KSkpLGJUPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpRm9ybUhlbHBlclRleHQifSkse2NoaWxkcmVuOm8sY2xhc3NOYW1lOmksY29tcG9uZW50OnM9InAiLGRpc2FibGVkOmEsZXJyb3I6bCxmaWxsZWQ6dSxmb2N1c2VkOmMsbWFyZ2luOmQscmVxdWlyZWQ6bSx2YXJpYW50OnYsLi4ud309cixTPUpvKCkseD1abyh7cHJvcHM6cixtdWlGb3JtQ29udHJvbDpTLHN0YXRlczpbInZhcmlhbnQiLCJzaXplIiwiZGlzYWJsZWQiLCJlcnJvciIsImZpbGxlZCIsImZvY3VzZWQiLCJyZXF1aXJlZCJdfSksaD17Li4ucixjb21wb25lbnQ6cyxjb250YWluZWQ6eC52YXJpYW50PT09ImZpbGxlZCJ8fHgudmFyaWFudD09PSJvdXRsaW5lZCIsdmFyaWFudDp4LnZhcmlhbnQsc2l6ZTp4LnNpemUsZGlzYWJsZWQ6eC5kaXNhYmxlZCxlcnJvcjp4LmVycm9yLGZpbGxlZDp4LmZpbGxlZCxmb2N1c2VkOnguZm9jdXNlZCxyZXF1aXJlZDp4LnJlcXVpcmVkfTtkZWxldGUgaC5vd25lclN0YXRlO2NvbnN0IGc9eFQoaCk7cmV0dXJuIGsuanN4KENULHthczpzLGNsYXNzTmFtZTp0ZShnLnJvb3QsaSkscmVmOm4sLi4udyxvd25lclN0YXRlOmgsY2hpbGRyZW46bz09PSIgIj9UaHx8KFRoPWsuanN4KCJzcGFuIix7Y2xhc3NOYW1lOiJub3RyYW5zbGF0ZSIsY2hpbGRyZW46IuKAiyJ9KSk6b30pfSk7ZnVuY3Rpb24ga1QoZSl7cmV0dXJuIGNlKCJNdWlGb3JtTGFiZWwiLGUpfWNvbnN0IGppPWRlKCJNdWlGb3JtTGFiZWwiLFsicm9vdCIsImNvbG9yU2Vjb25kYXJ5IiwiZm9jdXNlZCIsImRpc2FibGVkIiwiZXJyb3IiLCJmaWxsZWQiLCJyZXF1aXJlZCIsImFzdGVyaXNrIl0pLEVUPWU9Pntjb25zdHtjbGFzc2VzOnQsY29sb3I6bixmb2N1c2VkOnIsZGlzYWJsZWQ6byxlcnJvcjppLGZpbGxlZDpzLHJlcXVpcmVkOmF9PWUsbD17cm9vdDpbInJvb3QiLGBjb2xvciR7bmUobil9YCxvJiYiZGlzYWJsZWQiLGkmJiJlcnJvciIscyYmImZpbGxlZCIsciYmImZvY3VzZWQiLGEmJiJyZXF1aXJlZCJdLGFzdGVyaXNrOlsiYXN0ZXJpc2siLGkmJiJlcnJvciJdfTtyZXR1cm4gcGUobCxrVCx0KX0sUlQ9RygibGFiZWwiLHtuYW1lOiJNdWlGb3JtTGFiZWwiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOih7b3duZXJTdGF0ZTplfSx0KT0+KHsuLi50LnJvb3QsLi4uZS5jb2xvcj09PSJzZWNvbmRhcnkiJiZ0LmNvbG9yU2Vjb25kYXJ5LC4uLmUuZmlsbGVkJiZ0LmZpbGxlZH0pfSkoeWUoKHt0aGVtZTplfSk9Pih7Y29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSwuLi5lLnR5cG9ncmFwaHkuYm9keTEsbGluZUhlaWdodDoiMS40Mzc1ZW0iLHBhZGRpbmc6MCxwb3NpdGlvbjoicmVsYXRpdmUiLHZhcmlhbnRzOlsuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihicigpKS5tYXAoKFt0XSk9Pih7cHJvcHM6e2NvbG9yOnR9LHN0eWxlOntbYCYuJHtqaS5mb2N1c2VkfWBdOntjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlW3RdLm1haW59fX0pKSx7cHJvcHM6e30sc3R5bGU6e1tgJi4ke2ppLmRpc2FibGVkfWBdOntjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLnRleHQuZGlzYWJsZWR9LFtgJi4ke2ppLmVycm9yfWBdOntjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmVycm9yLm1haW59fX1dfSkpKSxUVD1HKCJzcGFuIix7bmFtZToiTXVpRm9ybUxhYmVsIixzbG90OiJBc3RlcmlzayIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQuYXN0ZXJpc2t9KSh5ZSgoe3RoZW1lOmV9KT0+KHtbYCYuJHtqaS5lcnJvcn1gXTp7Y29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5lcnJvci5tYWlufX0pKSksUFQ9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlGb3JtTGFiZWwifSkse2NoaWxkcmVuOm8sY2xhc3NOYW1lOmksY29sb3I6cyxjb21wb25lbnQ6YT0ibGFiZWwiLGRpc2FibGVkOmwsZXJyb3I6dSxmaWxsZWQ6Yyxmb2N1c2VkOmQscmVxdWlyZWQ6bSwuLi52fT1yLHc9Sm8oKSxTPVpvKHtwcm9wczpyLG11aUZvcm1Db250cm9sOncsc3RhdGVzOlsiY29sb3IiLCJyZXF1aXJlZCIsImZvY3VzZWQiLCJkaXNhYmxlZCIsImVycm9yIiwiZmlsbGVkIl19KSx4PXsuLi5yLGNvbG9yOlMuY29sb3J8fCJwcmltYXJ5Iixjb21wb25lbnQ6YSxkaXNhYmxlZDpTLmRpc2FibGVkLGVycm9yOlMuZXJyb3IsZmlsbGVkOlMuZmlsbGVkLGZvY3VzZWQ6Uy5mb2N1c2VkLHJlcXVpcmVkOlMucmVxdWlyZWR9LGg9RVQoeCk7cmV0dXJuIGsuanN4cyhSVCx7YXM6YSxvd25lclN0YXRlOngsY2xhc3NOYW1lOnRlKGgucm9vdCxpKSxyZWY6biwuLi52LGNoaWxkcmVuOltvLFMucmVxdWlyZWQmJmsuanN4cyhUVCx7b3duZXJTdGF0ZTp4LCJhcmlhLWhpZGRlbiI6ITAsY2xhc3NOYW1lOmguYXN0ZXJpc2ssY2hpbGRyZW46WyLigIkiLCIqIl19KV19KX0pO2Z1bmN0aW9uIGdkKGUpe3JldHVybmBzY2FsZSgke2V9LCAke2UqKjJ9KWB9Y29uc3QgJFQ9e2VudGVyaW5nOntvcGFjaXR5OjEsdHJhbnNmb3JtOmdkKDEpfSxlbnRlcmVkOntvcGFjaXR5OjEsdHJhbnNmb3JtOiJub25lIn19LFp1PXR5cGVvZiBuYXZpZ2F0b3I8InUiJiYvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSooc2FmYXJpfG1vYmlsZSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvKG9zIHx2ZXJzaW9uXC8pMTUoLnxfKTQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLGNzPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0e2FkZEVuZExpc3RlbmVyOnIsYXBwZWFyOm89ITAsY2hpbGRyZW46aSxlYXNpbmc6cyxpbjphLG9uRW50ZXI6bCxvbkVudGVyZWQ6dSxvbkVudGVyaW5nOmMsb25FeGl0OmQsb25FeGl0ZWQ6bSxvbkV4aXRpbmc6dixzdHlsZTp3LHRpbWVvdXQ6Uz0iYXV0byIsVHJhbnNpdGlvbkNvbXBvbmVudDp4PWxuLC4uLmh9PXQsZz1BcigpLGY9Qy51c2VSZWYoKSx5PVNzKCksYj1DLnVzZVJlZihudWxsKSxFPVFlKGIsUW8oaSksbiksUj1PPT5NPT57aWYoTyl7Y29uc3QgXz1iLmN1cnJlbnQ7TT09PXZvaWQgMD9PKF8pOk8oXyxNKX19LFA9UihjKSxJPVIoKE8sTSk9PntkMChPKTtjb25zdHtkdXJhdGlvbjpfLGRlbGF5OlQsZWFzaW5nOkF9PUZvKHtzdHlsZTp3LHRpbWVvdXQ6UyxlYXNpbmc6c30se21vZGU6ImVudGVyIn0pO2xldCBEO1M9PT0iYXV0byI/KEQ9eS50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24oTy5jbGllbnRIZWlnaHQpLGYuY3VycmVudD1EKTpEPV8sTy5zdHlsZS50cmFuc2l0aW9uPVt5LnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIse2R1cmF0aW9uOkQsZGVsYXk6VH0pLHkudHJhbnNpdGlvbnMuY3JlYXRlKCJ0cmFuc2Zvcm0iLHtkdXJhdGlvbjpadT9EOkQqLjY2NixkZWxheTpULGVhc2luZzpBfSldLmpvaW4oIiwiKSxsJiZsKE8sTSl9KSxwPVIodSksJD1SKHYpLEw9UihPPT57Y29uc3R7ZHVyYXRpb246TSxkZWxheTpfLGVhc2luZzpUfT1Gbyh7c3R5bGU6dyx0aW1lb3V0OlMsZWFzaW5nOnN9LHttb2RlOiJleGl0In0pO2xldCBBO1M9PT0iYXV0byI/KEE9eS50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24oTy5jbGllbnRIZWlnaHQpLGYuY3VycmVudD1BKTpBPU0sTy5zdHlsZS50cmFuc2l0aW9uPVt5LnRyYW5zaXRpb25zLmNyZWF0ZSgib3BhY2l0eSIse2R1cmF0aW9uOkEsZGVsYXk6X30pLHkudHJhbnNpdGlvbnMuY3JlYXRlKCJ0cmFuc2Zvcm0iLHtkdXJhdGlvbjpadT9BOkEqLjY2NixkZWxheTpadT9fOl98fEEqLjMzMyxlYXNpbmc6VH0pXS5qb2luKCIsIiksTy5zdHlsZS5vcGFjaXR5PTAsTy5zdHlsZS50cmFuc2Zvcm09Z2QoLjc1KSxkJiZkKE8pfSksaj1SKG0pLE49Tz0+e1M9PT0iYXV0byImJmcuc3RhcnQoZi5jdXJyZW50fHwwLE8pLHImJnIoYi5jdXJyZW50LE8pfTtyZXR1cm4gay5qc3goeCx7YXBwZWFyOm8saW46YSxub2RlUmVmOmIsb25FbnRlcjpJLG9uRW50ZXJlZDpwLG9uRW50ZXJpbmc6UCxvbkV4aXQ6TCxvbkV4aXRlZDpqLG9uRXhpdGluZzokLGFkZEVuZExpc3RlbmVyOk4sdGltZW91dDpTPT09ImF1dG8iP251bGw6UywuLi5oLGNoaWxkcmVuOihPLE0pPT5DLmNsb25lRWxlbWVudChpLHtzdHlsZTp7b3BhY2l0eTowLHRyYW5zZm9ybTpnZCguNzUpLHZpc2liaWxpdHk6Tz09PSJleGl0ZWQiJiYhYT8iaGlkZGVuIjp2b2lkIDAsLi4uJFRbT10sLi4udywuLi5pLnByb3BzLnN0eWxlfSxyZWY6RSwuLi5NfSl9KX0pO2NzJiYoY3MubXVpU3VwcG9ydEF1dG89ITApO2NvbnN0IE9UPWU9Pntjb25zdHtjbGFzc2VzOnQsZGlzYWJsZVVuZGVybGluZTpufT1lLG89cGUoe3Jvb3Q6WyJyb290IiwhbiYmInVuZGVybGluZSJdLGlucHV0OlsiaW5wdXQiXX0sJFIsdCk7cmV0dXJuey4uLnQsLi4ub319LE1UPUcoY3Use3Nob3VsZEZvcndhcmRQcm9wOmU9PlNuKGUpfHxlPT09ImNsYXNzZXMiLG5hbWU6Ik11aUlucHV0IixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bLi4ubHUoZSx0KSwhbi5kaXNhYmxlVW5kZXJsaW5lJiZ0LnVuZGVybGluZV19fSkoeWUoKHt0aGVtZTplfSk9PntsZXQgbj1lLnBhbGV0dGUubW9kZT09PSJsaWdodCI/InJnYmEoMCwgMCwgMCwgMC40MikiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNykiO3JldHVybiBlLnZhcnMmJihuPWByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuY29tbW9uLm9uQmFja2dyb3VuZENoYW5uZWx9IC8gJHtlLnZhcnMub3BhY2l0eS5pbnB1dFVuZGVybGluZX0pYCkse3Bvc2l0aW9uOiJyZWxhdGl2ZSIsdmFyaWFudHM6W3twcm9wczooe293bmVyU3RhdGU6cn0pPT5yLmZvcm1Db250cm9sLHN0eWxlOnsibGFiZWwgKyAmIjp7bWFyZ2luVG9wOjE2fX19LHtwcm9wczooe293bmVyU3RhdGU6cn0pPT4hci5kaXNhYmxlVW5kZXJsaW5lLHN0eWxlOnsiJjo6YWZ0ZXIiOntsZWZ0OjAsYm90dG9tOjAsY29udGVudDonIiInLHBvc2l0aW9uOiJhYnNvbHV0ZSIscmlnaHQ6MCx0cmFuc2Zvcm06InNjYWxlWCgwKSIsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgidHJhbnNmb3JtIix7ZHVyYXRpb246ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLGVhc2luZzplLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0fSkscG9pbnRlckV2ZW50czoibm9uZSJ9LFtgJi4ke3BpLmZvY3VzZWR9OmFmdGVyYF06e3RyYW5zZm9ybToic2NhbGVYKDEpIHRyYW5zbGF0ZVgoMCkifSxbYCYuJHtwaS5lcnJvcn1gXTp7IiY6OmJlZm9yZSwgJjo6YWZ0ZXIiOntib3JkZXJCb3R0b21Db2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmVycm9yLm1haW59fSwiJjo6YmVmb3JlIjp7Ym9yZGVyQm90dG9tOmAxcHggc29saWQgJHtufWAsbGVmdDowLGJvdHRvbTowLGNvbnRlbnQ6JyJcXDAwYTAiJyxwb3NpdGlvbjoiYWJzb2x1dGUiLHJpZ2h0OjAsdHJhbnNpdGlvbjplLnRyYW5zaXRpb25zLmNyZWF0ZSgiYm9yZGVyLWJvdHRvbS1jb2xvciIse2R1cmF0aW9uOmUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcn0pLHBvaW50ZXJFdmVudHM6Im5vbmUifSxbYCY6aG92ZXI6bm90KC4ke3BpLmRpc2FibGVkfSwgLiR7cGkuZXJyb3J9KTpiZWZvcmVgXTp7Ym9yZGVyQm90dG9tOmAycHggc29saWQgJHsoZS52YXJzfHxlKS5wYWxldHRlLnRleHQucHJpbWFyeX1gLCJAbWVkaWEgKGhvdmVyOiBub25lKSI6e2JvcmRlckJvdHRvbTpgMXB4IHNvbGlkICR7bn1gfX0sW2AmLiR7cGkuZGlzYWJsZWR9OmJlZm9yZWBdOntib3JkZXJCb3R0b21TdHlsZToiZG90dGVkIn19fSwuLi5PYmplY3QuZW50cmllcyhlLnBhbGV0dGUpLmZpbHRlcihicigpKS5tYXAoKFtyXSk9Pih7cHJvcHM6e2NvbG9yOnIsZGlzYWJsZVVuZGVybGluZTohMX0sc3R5bGU6eyImOjphZnRlciI6e2JvcmRlckJvdHRvbTpgMnB4IHNvbGlkICR7KGUudmFyc3x8ZSkucGFsZXR0ZVtyXS5tYWlufWB9fX0pKV19fSkpLF9UPUcoZHUse25hbWU6Ik11aUlucHV0IixzbG90OiJJbnB1dCIsb3ZlcnJpZGVzUmVzb2x2ZXI6dXV9KSh7fSksbmw9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlJbnB1dCJ9KSx7ZGlzYWJsZVVuZGVybGluZTpvPSExLGNvbXBvbmVudHM6aT17fSxjb21wb25lbnRzUHJvcHM6cyxmdWxsV2lkdGg6YT0hMSxpbnB1dENvbXBvbmVudDpsPSJpbnB1dCIsbXVsdGlsaW5lOnU9ITEsc2xvdFByb3BzOmMsc2xvdHM6ZD17fSx0eXBlOm09InRleHQiLC4uLnZ9PXIsdz1PVChyKSx4PXtyb290Ontvd25lclN0YXRlOntkaXNhYmxlVW5kZXJsaW5lOm99fX0saD1jPz9zP3B0KGM/P3MseCk6eCxnPWQucm9vdD8/aS5Sb290Pz9NVCxmPWQuaW5wdXQ/P2kuSW5wdXQ/P19UO3JldHVybiBrLmpzeChhcCx7c2xvdHM6e3Jvb3Q6ZyxpbnB1dDpmfSxzbG90UHJvcHM6aCxmdWxsV2lkdGg6YSxpbnB1dENvbXBvbmVudDpsLG11bHRpbGluZTp1LHJlZjpuLHR5cGU6bSwuLi52LGNsYXNzZXM6d30pfSk7bmwmJihubC5tdWlOYW1lPSJJbnB1dCIpO2Z1bmN0aW9uIE5UKGUpe3JldHVybiBjZSgiTXVpSW5wdXRMYWJlbCIsZSl9ZGUoIk11aUlucHV0TGFiZWwiLFsicm9vdCIsImZvY3VzZWQiLCJkaXNhYmxlZCIsImVycm9yIiwicmVxdWlyZWQiLCJhc3RlcmlzayIsImZvcm1Db250cm9sIiwic2l6ZVNtYWxsIiwic2hyaW5rIiwiYW5pbWF0ZWQiLCJzdGFuZGFyZCIsImZpbGxlZCIsIm91dGxpbmVkIl0pO2NvbnN0IElUPWU9Pntjb25zdHtjbGFzc2VzOnQsZm9ybUNvbnRyb2w6bixzaXplOnIsc2hyaW5rOm8sZGlzYWJsZUFuaW1hdGlvbjppLHZhcmlhbnQ6cyxyZXF1aXJlZDphfT1lLGw9e3Jvb3Q6WyJyb290IixuJiYiZm9ybUNvbnRyb2wiLCFpJiYiYW5pbWF0ZWQiLG8mJiJzaHJpbmsiLHImJnIhPT0ibm9ybWFsIiYmYHNpemUke25lKHIpfWAsc10sYXN0ZXJpc2s6W2EmJiJhc3RlcmlzayJdfSx1PXBlKGwsTlQsdCk7cmV0dXJuey4uLnQsLi4udX19LEFUPUcoUFQse3Nob3VsZEZvcndhcmRQcm9wOmU9PlNuKGUpfHxlPT09ImNsYXNzZXMiLG5hbWU6Ik11aUlucHV0TGFiZWwiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt7W2AmIC4ke2ppLmFzdGVyaXNrfWBdOnQuYXN0ZXJpc2t9LHQucm9vdCxuLmZvcm1Db250cm9sJiZ0LmZvcm1Db250cm9sLG4uc2l6ZT09PSJzbWFsbCImJnQuc2l6ZVNtYWxsLG4uc2hyaW5rJiZ0LnNocmluaywhbi5kaXNhYmxlQW5pbWF0aW9uJiZ0LmFuaW1hdGVkLG4uZm9jdXNlZCYmdC5mb2N1c2VkLHRbbi52YXJpYW50XV19fSkoeWUoKHt0aGVtZTplfSk9Pih7ZGlzcGxheToiYmxvY2siLHRyYW5zZm9ybU9yaWdpbjoidG9wIGxlZnQiLHdoaXRlU3BhY2U6Im5vd3JhcCIsb3ZlcmZsb3c6ImhpZGRlbiIsdGV4dE92ZXJmbG93OiJlbGxpcHNpcyIsbWF4V2lkdGg6IjEwMCUiLHZhcmlhbnRzOlt7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5mb3JtQ29udHJvbCxzdHlsZTp7cG9zaXRpb246ImFic29sdXRlIixsZWZ0OjAsdG9wOjAsdHJhbnNmb3JtOiJ0cmFuc2xhdGUoMCwgMjBweCkgc2NhbGUoMSkifX0se3Byb3BzOntzaXplOiJzbWFsbCJ9LHN0eWxlOnt0cmFuc2Zvcm06InRyYW5zbGF0ZSgwLCAxN3B4KSBzY2FsZSgxKSJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5zaHJpbmssc3R5bGU6e3RyYW5zZm9ybToidHJhbnNsYXRlKDAsIC0xLjVweCkgc2NhbGUoMC43NSkiLHRyYW5zZm9ybU9yaWdpbjoidG9wIGxlZnQiLG1heFdpZHRoOiIxMzMlIn19LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT4hdC5kaXNhYmxlQW5pbWF0aW9uLHN0eWxlOnt0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKFsiY29sb3IiLCJ0cmFuc2Zvcm0iLCJtYXgtd2lkdGgiXSx7ZHVyYXRpb246ZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLGVhc2luZzplLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0fSl9fSx7cHJvcHM6e3ZhcmlhbnQ6ImZpbGxlZCJ9LHN0eWxlOnt6SW5kZXg6MSxwb2ludGVyRXZlbnRzOiJub25lIix0cmFuc2Zvcm06InRyYW5zbGF0ZSgxMnB4LCAxNnB4KSBzY2FsZSgxKSIsbWF4V2lkdGg6ImNhbGMoMTAwJSAtIDI0cHgpIn19LHtwcm9wczp7dmFyaWFudDoiZmlsbGVkIixzaXplOiJzbWFsbCJ9LHN0eWxlOnt0cmFuc2Zvcm06InRyYW5zbGF0ZSgxMnB4LCAxM3B4KSBzY2FsZSgxKSJ9fSx7cHJvcHM6KHt2YXJpYW50OnQsb3duZXJTdGF0ZTpufSk9PnQ9PT0iZmlsbGVkIiYmbi5zaHJpbmssc3R5bGU6e3VzZXJTZWxlY3Q6Im5vbmUiLHBvaW50ZXJFdmVudHM6ImF1dG8iLHRyYW5zZm9ybToidHJhbnNsYXRlKDEycHgsIDdweCkgc2NhbGUoMC43NSkiLG1heFdpZHRoOiJjYWxjKDEzMyUgLSAyNHB4KSJ9fSx7cHJvcHM6KHt2YXJpYW50OnQsb3duZXJTdGF0ZTpuLHNpemU6cn0pPT50PT09ImZpbGxlZCImJm4uc2hyaW5rJiZyPT09InNtYWxsIixzdHlsZTp7dHJhbnNmb3JtOiJ0cmFuc2xhdGUoMTJweCwgNHB4KSBzY2FsZSgwLjc1KSJ9fSx7cHJvcHM6e3ZhcmlhbnQ6Im91dGxpbmVkIn0sc3R5bGU6e3pJbmRleDoxLHBvaW50ZXJFdmVudHM6Im5vbmUiLHRyYW5zZm9ybToidHJhbnNsYXRlKDE0cHgsIDE2cHgpIHNjYWxlKDEpIixtYXhXaWR0aDoiY2FsYygxMDAlIC0gMjRweCkifX0se3Byb3BzOnt2YXJpYW50OiJvdXRsaW5lZCIsc2l6ZToic21hbGwifSxzdHlsZTp7dHJhbnNmb3JtOiJ0cmFuc2xhdGUoMTRweCwgOXB4KSBzY2FsZSgxKSJ9fSx7cHJvcHM6KHt2YXJpYW50OnQsb3duZXJTdGF0ZTpufSk9PnQ9PT0ib3V0bGluZWQiJiZuLnNocmluayxzdHlsZTp7dXNlclNlbGVjdDoibm9uZSIscG9pbnRlckV2ZW50czoiYXV0byIsbWF4V2lkdGg6ImNhbGMoMTMzJSAtIDMycHgpIix0cmFuc2Zvcm06InRyYW5zbGF0ZSgxNHB4LCAtOXB4KSBzY2FsZSgwLjc1KSJ9fV19KSkpLHpUPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe25hbWU6Ik11aUlucHV0TGFiZWwiLHByb3BzOnR9KSx7ZGlzYWJsZUFuaW1hdGlvbjpvPSExLG1hcmdpbjppLHNocmluazpzLHZhcmlhbnQ6YSxjbGFzc05hbWU6bCwuLi51fT1yLGM9Sm8oKTtsZXQgZD1zO3R5cGVvZiBkPiJ1IiYmYyYmKGQ9Yy5maWxsZWR8fGMuZm9jdXNlZHx8Yy5hZG9ybmVkU3RhcnQpO2NvbnN0IG09Wm8oe3Byb3BzOnIsbXVpRm9ybUNvbnRyb2w6YyxzdGF0ZXM6WyJzaXplIiwidmFyaWFudCIsInJlcXVpcmVkIiwiZm9jdXNlZCJdfSksdj17Li4ucixkaXNhYmxlQW5pbWF0aW9uOm8sZm9ybUNvbnRyb2w6YyxzaHJpbms6ZCxzaXplOm0uc2l6ZSx2YXJpYW50Om0udmFyaWFudCxyZXF1aXJlZDptLnJlcXVpcmVkLGZvY3VzZWQ6bS5mb2N1c2VkfSx3PUlUKHYpO3JldHVybiBrLmpzeChBVCx7ImRhdGEtc2hyaW5rIjpkLHJlZjpuLGNsYXNzTmFtZTp0ZSh3LnJvb3QsbCksLi4udSxvd25lclN0YXRlOnYsY2xhc3Nlczp3fSl9KSxMVD1DLmNyZWF0ZUNvbnRleHQoe30pO2Z1bmN0aW9uIGpUKGUpe3JldHVybiBjZSgiTXVpTGlzdCIsZSl9ZGUoIk11aUxpc3QiLFsicm9vdCIsInBhZGRpbmciLCJkZW5zZSIsInN1YmhlYWRlciJdKTtjb25zdCBEVD1lPT57Y29uc3R7Y2xhc3Nlczp0LGRpc2FibGVQYWRkaW5nOm4sZGVuc2U6cixzdWJoZWFkZXI6b309ZTtyZXR1cm4gcGUoe3Jvb3Q6WyJyb290IiwhbiYmInBhZGRpbmciLHImJiJkZW5zZSIsbyYmInN1YmhlYWRlciJdfSxqVCx0KX0sRlQ9RygidWwiLHtuYW1lOiJNdWlMaXN0IixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5yb290LCFuLmRpc2FibGVQYWRkaW5nJiZ0LnBhZGRpbmcsbi5kZW5zZSYmdC5kZW5zZSxuLnN1YmhlYWRlciYmdC5zdWJoZWFkZXJdfX0pKHtsaXN0U3R5bGU6Im5vbmUiLG1hcmdpbjowLHBhZGRpbmc6MCxwb3NpdGlvbjoicmVsYXRpdmUiLHZhcmlhbnRzOlt7cHJvcHM6KHtvd25lclN0YXRlOmV9KT0+IWUuZGlzYWJsZVBhZGRpbmcsc3R5bGU6e3BhZGRpbmdUb3A6OCxwYWRkaW5nQm90dG9tOjh9fSx7cHJvcHM6KHtvd25lclN0YXRlOmV9KT0+ZS5zdWJoZWFkZXIsc3R5bGU6e3BhZGRpbmdUb3A6MH19XX0pLEJUPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpTGlzdCJ9KSx7Y2hpbGRyZW46byxjbGFzc05hbWU6aSxjb21wb25lbnQ6cz0idWwiLGRlbnNlOmE9ITEsZGlzYWJsZVBhZGRpbmc6bD0hMSxzdWJoZWFkZXI6dSwuLi5jfT1yLGQ9Qy51c2VNZW1vKCgpPT4oe2RlbnNlOmF9KSxbYV0pLG09ey4uLnIsY29tcG9uZW50OnMsZGVuc2U6YSxkaXNhYmxlUGFkZGluZzpsfSx2PURUKG0pO3JldHVybiBrLmpzeChMVC5Qcm92aWRlcix7dmFsdWU6ZCxjaGlsZHJlbjprLmpzeHMoRlQse2FzOnMsY2xhc3NOYW1lOnRlKHYucm9vdCxpKSxyZWY6bixvd25lclN0YXRlOm0sLi4uYyxjaGlsZHJlbjpbdSxvXX0pfSl9KTtmdW5jdGlvbiBKdShlLHQsbil7cmV0dXJuIGU9PT10P2UuZmlyc3RDaGlsZDp0JiZ0Lm5leHRFbGVtZW50U2libGluZz90Lm5leHRFbGVtZW50U2libGluZzpuP251bGw6ZS5maXJzdENoaWxkfWZ1bmN0aW9uIFBoKGUsdCxuKXtyZXR1cm4gZT09PXQ/bj9lLmZpcnN0Q2hpbGQ6ZS5sYXN0Q2hpbGQ6dCYmdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nP3QucHJldmlvdXNFbGVtZW50U2libGluZzpuP251bGw6ZS5sYXN0Q2hpbGR9ZnVuY3Rpb24gJDAoZSx0KXtpZih0PT09dm9pZCAwKXJldHVybiEwO2xldCBuPWUuaW5uZXJUZXh0O3JldHVybiBuPT09dm9pZCAwJiYobj1lLnRleHRDb250ZW50KSxuPW4udHJpbSgpLnRvTG93ZXJDYXNlKCksbi5sZW5ndGg9PT0wPyExOnQucmVwZWF0aW5nP25bMF09PT10LmtleXNbMF06bi5zdGFydHNXaXRoKHQua2V5cy5qb2luKCIiKSl9ZnVuY3Rpb24gbWkoZSx0LG4scixvLGkpe2xldCBzPSExLGE9byhlLHQsdD9uOiExKTtmb3IoO2E7KXtpZihhPT09ZS5maXJzdENoaWxkKXtpZihzKXJldHVybiExO3M9ITB9Y29uc3QgbD1yPyExOmEuZGlzYWJsZWR8fGEuZ2V0QXR0cmlidXRlKCJhcmlhLWRpc2FibGVkIik9PT0idHJ1ZSI7aWYoIWEuaGFzQXR0cmlidXRlKCJ0YWJpbmRleCIpfHwhJDAoYSxpKXx8bClhPW8oZSxhLG4pO2Vsc2UgcmV0dXJuIGEuZm9jdXMoKSwhMH1yZXR1cm4hMX1jb25zdCBXVD1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdHthY3Rpb25zOnIsYXV0b0ZvY3VzOm89ITEsYXV0b0ZvY3VzSXRlbTppPSExLGNoaWxkcmVuOnMsY2xhc3NOYW1lOmEsZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZTpsPSExLGRpc2FibGVMaXN0V3JhcDp1PSExLG9uS2V5RG93bjpjLHZhcmlhbnQ6ZD0ic2VsZWN0ZWRNZW51IiwuLi5tfT10LHY9Qy51c2VSZWYobnVsbCksdz1DLnVzZVJlZih7a2V5czpbXSxyZXBlYXRpbmc6ITAscHJldmlvdXNLZXlNYXRjaGVkOiEwLGxhc3RUaW1lOm51bGx9KTtZbigoKT0+e28mJnYuY3VycmVudC5mb2N1cygpfSxbb10pLEMudXNlSW1wZXJhdGl2ZUhhbmRsZShyLCgpPT4oe2FkanVzdFN0eWxlRm9yU2Nyb2xsYmFyOihmLHtkaXJlY3Rpb246eX0pPT57Y29uc3QgYj0hdi5jdXJyZW50LnN0eWxlLndpZHRoO2lmKGYuY2xpZW50SGVpZ2h0PHYuY3VycmVudC5jbGllbnRIZWlnaHQmJmIpe2NvbnN0IEU9YCR7WmcoR24oZikpfXB4YDt2LmN1cnJlbnQuc3R5bGVbeT09PSJydGwiPyJwYWRkaW5nTGVmdCI6InBhZGRpbmdSaWdodCJdPUUsdi5jdXJyZW50LnN0eWxlLndpZHRoPWBjYWxjKDEwMCUgKyAke0V9KWB9cmV0dXJuIHYuY3VycmVudH19KSxbXSk7Y29uc3QgUz1mPT57Y29uc3QgeT12LmN1cnJlbnQsYj1mLmtleTtpZihmLmN0cmxLZXl8fGYubWV0YUtleXx8Zi5hbHRLZXkpe2MmJmMoZik7cmV0dXJufWNvbnN0IFI9RHQoeSkuYWN0aXZlRWxlbWVudDtpZihiPT09IkFycm93RG93biIpZi5wcmV2ZW50RGVmYXVsdCgpLG1pKHksUix1LGwsSnUpO2Vsc2UgaWYoYj09PSJBcnJvd1VwIilmLnByZXZlbnREZWZhdWx0KCksbWkoeSxSLHUsbCxQaCk7ZWxzZSBpZihiPT09IkhvbWUiKWYucHJldmVudERlZmF1bHQoKSxtaSh5LG51bGwsdSxsLEp1KTtlbHNlIGlmKGI9PT0iRW5kIilmLnByZXZlbnREZWZhdWx0KCksbWkoeSxudWxsLHUsbCxQaCk7ZWxzZSBpZihiLmxlbmd0aD09PTEpe2NvbnN0IFA9dy5jdXJyZW50LEk9Yi50b0xvd2VyQ2FzZSgpLHA9cGVyZm9ybWFuY2Uubm93KCk7UC5rZXlzLmxlbmd0aD4wJiYocC1QLmxhc3RUaW1lPjUwMD8oUC5rZXlzPVtdLFAucmVwZWF0aW5nPSEwLFAucHJldmlvdXNLZXlNYXRjaGVkPSEwKTpQLnJlcGVhdGluZyYmSSE9PVAua2V5c1swXSYmKFAucmVwZWF0aW5nPSExKSksUC5sYXN0VGltZT1wLFAua2V5cy5wdXNoKEkpO2NvbnN0ICQ9UiYmIVAucmVwZWF0aW5nJiYkMChSLFApO1AucHJldmlvdXNLZXlNYXRjaGVkJiYoJHx8bWkoeSxSLCExLGwsSnUsUCkpP2YucHJldmVudERlZmF1bHQoKTpQLnByZXZpb3VzS2V5TWF0Y2hlZD0hMX1jJiZjKGYpfSx4PVFlKHYsbik7bGV0IGg9LTE7Qy5DaGlsZHJlbi5mb3JFYWNoKHMsKGYseSk9PntpZighQy5pc1ZhbGlkRWxlbWVudChmKSl7aD09PXkmJihoKz0xLGg+PXMubGVuZ3RoJiYoaD0tMSkpO3JldHVybn1mLnByb3BzLmRpc2FibGVkfHwoZD09PSJzZWxlY3RlZE1lbnUiJiZmLnByb3BzLnNlbGVjdGVkfHxoPT09LTEpJiYoaD15KSxoPT09eSYmKGYucHJvcHMuZGlzYWJsZWR8fGYucHJvcHMubXVpU2tpcExpc3RIaWdobGlnaHR8fGYudHlwZS5tdWlTa2lwTGlzdEhpZ2hsaWdodCkmJihoKz0xLGg+PXMubGVuZ3RoJiYoaD0tMSkpfSk7Y29uc3QgZz1DLkNoaWxkcmVuLm1hcChzLChmLHkpPT57aWYoeT09PWgpe2NvbnN0IGI9e307cmV0dXJuIGkmJihiLmF1dG9Gb2N1cz0hMCksZi5wcm9wcy50YWJJbmRleD09PXZvaWQgMCYmZD09PSJzZWxlY3RlZE1lbnUiJiYoYi50YWJJbmRleD0wKSxDLmNsb25lRWxlbWVudChmLGIpfXJldHVybiBmfSk7cmV0dXJuIGsuanN4KEJULHtyb2xlOiJtZW51IixyZWY6eCxjbGFzc05hbWU6YSxvbktleURvd246Uyx0YWJJbmRleDpvPzA6LTEsLi4ubSxjaGlsZHJlbjpnfSl9KTtmdW5jdGlvbiBVVChlKXtyZXR1cm4gY2UoIk11aVBvcG92ZXIiLGUpfWRlKCJNdWlQb3BvdmVyIixbInJvb3QiLCJwYXBlciJdKTtmdW5jdGlvbiAkaChlLHQpe2xldCBuPTA7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj9uPXQ6dD09PSJjZW50ZXIiP249ZS5oZWlnaHQvMjp0PT09ImJvdHRvbSImJihuPWUuaGVpZ2h0KSxufWZ1bmN0aW9uIE9oKGUsdCl7bGV0IG49MDtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP249dDp0PT09ImNlbnRlciI/bj1lLndpZHRoLzI6dD09PSJyaWdodCImJihuPWUud2lkdGgpLG59ZnVuY3Rpb24gTWgoZSl7cmV0dXJuW2UuaG9yaXpvbnRhbCxlLnZlcnRpY2FsXS5tYXAodD0+dHlwZW9mIHQ9PSJudW1iZXIiP2Ake3R9cHhgOnQpLmpvaW4oIiAiKX1mdW5jdGlvbiBlYyhlKXtyZXR1cm4gdHlwZW9mIGU9PSJmdW5jdGlvbiI/ZSgpOmV9Y29uc3QgSFQ9ZT0+e2NvbnN0e2NsYXNzZXM6dH09ZTtyZXR1cm4gcGUoe3Jvb3Q6WyJyb290Il0scGFwZXI6WyJwYXBlciJdfSxVVCx0KX0sVlQ9RyhmVCx7bmFtZToiTXVpUG9wb3ZlciIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucm9vdH0pKHt9KSxPMD1HKFhmLHtuYW1lOiJNdWlQb3BvdmVyIixzbG90OiJQYXBlciIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucGFwZXJ9KSh7cG9zaXRpb246ImFic29sdXRlIixvdmVyZmxvd1k6ImF1dG8iLG92ZXJmbG93WDoiaGlkZGVuIixtaW5XaWR0aDoxNixtaW5IZWlnaHQ6MTYsbWF4V2lkdGg6ImNhbGMoMTAwJSAtIDMycHgpIixtYXhIZWlnaHQ6ImNhbGMoMTAwJSAtIDMycHgpIixvdXRsaW5lOjB9KSxLVD1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aVBvcG92ZXIifSkse2FjdGlvbjpvLGFuY2hvckVsOmksYW5jaG9yT3JpZ2luOnM9e3ZlcnRpY2FsOiJ0b3AiLGhvcml6b250YWw6ImxlZnQifSxhbmNob3JQb3NpdGlvbjphLGFuY2hvclJlZmVyZW5jZTpsPSJhbmNob3JFbCIsY2hpbGRyZW46dSxjbGFzc05hbWU6Yyxjb250YWluZXI6ZCxlbGV2YXRpb246bT04LG1hcmdpblRocmVzaG9sZDp2PTE2LG9wZW46dyxQYXBlclByb3BzOlM9e30sc2xvdHM6eD17fSxzbG90UHJvcHM6aD17fSx0cmFuc2Zvcm1PcmlnaW46Zz17dmVydGljYWw6InRvcCIsaG9yaXpvbnRhbDoibGVmdCJ9LFRyYW5zaXRpb25Db21wb25lbnQ6Zj1jcyx0cmFuc2l0aW9uRHVyYXRpb246eT0iYXV0byIsVHJhbnNpdGlvblByb3BzOntvbkVudGVyaW5nOmIsLi4uRX09e30sZGlzYWJsZVNjcm9sbExvY2s6Uj0hMSwuLi5QfT1yLEk9KGg9PW51bGw/dm9pZCAwOmgucGFwZXIpPz9TLHA9Qy51c2VSZWYoKSwkPXsuLi5yLGFuY2hvck9yaWdpbjpzLGFuY2hvclJlZmVyZW5jZTpsLGVsZXZhdGlvbjptLG1hcmdpblRocmVzaG9sZDp2LGV4dGVybmFsUGFwZXJTbG90UHJvcHM6SSx0cmFuc2Zvcm1PcmlnaW46ZyxUcmFuc2l0aW9uQ29tcG9uZW50OmYsdHJhbnNpdGlvbkR1cmF0aW9uOnksVHJhbnNpdGlvblByb3BzOkV9LEw9SFQoJCksaj1DLnVzZUNhbGxiYWNrKCgpPT57aWYobD09PSJhbmNob3JQb3NpdGlvbiIpcmV0dXJuIGE7Y29uc3QgUT1lYyhpKSxZPShRJiZRLm5vZGVUeXBlPT09MT9ROkR0KHAuY3VycmVudCkuYm9keSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3RvcDpZLnRvcCskaChZLHMudmVydGljYWwpLGxlZnQ6WS5sZWZ0K09oKFkscy5ob3Jpem9udGFsKX19LFtpLHMuaG9yaXpvbnRhbCxzLnZlcnRpY2FsLGEsbF0pLE49Qy51c2VDYWxsYmFjayhRPT4oe3ZlcnRpY2FsOiRoKFEsZy52ZXJ0aWNhbCksaG9yaXpvbnRhbDpPaChRLGcuaG9yaXpvbnRhbCl9KSxbZy5ob3Jpem9udGFsLGcudmVydGljYWxdKSxPPUMudXNlQ2FsbGJhY2soUT0+e2NvbnN0IGVlPXt3aWR0aDpRLm9mZnNldFdpZHRoLGhlaWdodDpRLm9mZnNldEhlaWdodH0sWT1OKGVlKTtpZihsPT09Im5vbmUiKXJldHVybnt0b3A6bnVsbCxsZWZ0Om51bGwsdHJhbnNmb3JtT3JpZ2luOk1oKFkpfTtjb25zdCB1ZT1qKCk7bGV0IGllPXVlLnRvcC1ZLnZlcnRpY2FsLGZlPXVlLmxlZnQtWS5ob3Jpem9udGFsO2NvbnN0IFplPWllK2VlLmhlaWdodCxWZT1mZStlZS53aWR0aCxPZT1HbihlYyhpKSksTmU9T2UuaW5uZXJIZWlnaHQtdixXZT1PZS5pbm5lcldpZHRoLXY7aWYodiE9PW51bGwmJmllPHYpe2NvbnN0IGhlPWllLXY7aWUtPWhlLFkudmVydGljYWwrPWhlfWVsc2UgaWYodiE9PW51bGwmJlplPk5lKXtjb25zdCBoZT1aZS1OZTtpZS09aGUsWS52ZXJ0aWNhbCs9aGV9aWYodiE9PW51bGwmJmZlPHYpe2NvbnN0IGhlPWZlLXY7ZmUtPWhlLFkuaG9yaXpvbnRhbCs9aGV9ZWxzZSBpZihWZT5XZSl7Y29uc3QgaGU9VmUtV2U7ZmUtPWhlLFkuaG9yaXpvbnRhbCs9aGV9cmV0dXJue3RvcDpgJHtNYXRoLnJvdW5kKGllKX1weGAsbGVmdDpgJHtNYXRoLnJvdW5kKGZlKX1weGAsdHJhbnNmb3JtT3JpZ2luOk1oKFkpfX0sW2ksbCxqLE4sdl0pLFtNLF9dPUMudXNlU3RhdGUodyksVD1DLnVzZUNhbGxiYWNrKCgpPT57Y29uc3QgUT1wLmN1cnJlbnQ7aWYoIVEpcmV0dXJuO2NvbnN0IGVlPU8oUSk7ZWUudG9wIT09bnVsbCYmUS5zdHlsZS5zZXRQcm9wZXJ0eSgidG9wIixlZS50b3ApLGVlLmxlZnQhPT1udWxsJiYoUS5zdHlsZS5sZWZ0PWVlLmxlZnQpLFEuc3R5bGUudHJhbnNmb3JtT3JpZ2luPWVlLnRyYW5zZm9ybU9yaWdpbixfKCEwKX0sW09dKTtDLnVzZUVmZmVjdCgoKT0+KFImJndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJzY3JvbGwiLFQpLCgpPT53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigic2Nyb2xsIixUKSksW2ksUixUXSk7Y29uc3QgQT0oUSxlZSk9PntiJiZiKFEsZWUpLFQoKX0sRD0oKT0+e18oITEpfTtDLnVzZUVmZmVjdCgoKT0+e3cmJlQoKX0pLEMudXNlSW1wZXJhdGl2ZUhhbmRsZShvLCgpPT53P3t1cGRhdGVQb3NpdGlvbjooKT0+e1QoKX19Om51bGwsW3csVF0pLEMudXNlRWZmZWN0KCgpPT57aWYoIXcpcmV0dXJuO2NvbnN0IFE9WGcoKCk9PntUKCl9KSxlZT1HbihpKTtyZXR1cm4gZWUuYWRkRXZlbnRMaXN0ZW5lcigicmVzaXplIixRKSwoKT0+e1EuY2xlYXIoKSxlZS5yZW1vdmVFdmVudExpc3RlbmVyKCJyZXNpemUiLFEpfX0sW2ksdyxUXSk7bGV0IEI9eTt5PT09ImF1dG8iJiYhZi5tdWlTdXBwb3J0QXV0byYmKEI9dm9pZCAwKTtjb25zdCBIPWR8fChpP0R0KGVjKGkpKS5ib2R5OnZvaWQgMCksVj17c2xvdHM6eCxzbG90UHJvcHM6ey4uLmgscGFwZXI6SX19LFtVLFhdPU50KCJwYXBlciIse2VsZW1lbnRUeXBlOk8wLGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6VixhZGRpdGlvbmFsUHJvcHM6e2VsZXZhdGlvbjptLGNsYXNzTmFtZTp0ZShMLnBhcGVyLEk9PW51bGw/dm9pZCAwOkkuY2xhc3NOYW1lKSxzdHlsZTpNP0kuc3R5bGU6ey4uLkkuc3R5bGUsb3BhY2l0eTowfX0sb3duZXJTdGF0ZTokfSksW1cse3Nsb3RQcm9wczpKLC4uLm9lfV09TnQoInJvb3QiLHtlbGVtZW50VHlwZTpWVCxleHRlcm5hbEZvcndhcmRlZFByb3BzOlYsYWRkaXRpb25hbFByb3BzOntzbG90UHJvcHM6e2JhY2tkcm9wOntpbnZpc2libGU6ITB9fSxjb250YWluZXI6SCxvcGVuOnd9LG93bmVyU3RhdGU6JCxjbGFzc05hbWU6dGUoTC5yb290LGMpfSkscmU9UWUocCxYLnJlZik7cmV0dXJuIGsuanN4KFcsey4uLm9lLC4uLiFoZChXKSYme3Nsb3RQcm9wczpKLGRpc2FibGVTY3JvbGxMb2NrOlJ9LC4uLlAscmVmOm4sY2hpbGRyZW46ay5qc3goZix7YXBwZWFyOiEwLGluOncsb25FbnRlcmluZzpBLG9uRXhpdGVkOkQsdGltZW91dDpCLC4uLkUsY2hpbGRyZW46ay5qc3goVSx7Li4uWCxyZWY6cmUsY2hpbGRyZW46dX0pfSl9KX0pO2Z1bmN0aW9uIFlUKGUpe3JldHVybiBjZSgiTXVpTWVudSIsZSl9ZGUoIk11aU1lbnUiLFsicm9vdCIsInBhcGVyIiwibGlzdCJdKTtjb25zdCBHVD17dmVydGljYWw6InRvcCIsaG9yaXpvbnRhbDoicmlnaHQifSxRVD17dmVydGljYWw6InRvcCIsaG9yaXpvbnRhbDoibGVmdCJ9LFhUPWU9Pntjb25zdHtjbGFzc2VzOnR9PWU7cmV0dXJuIHBlKHtyb290Olsicm9vdCJdLHBhcGVyOlsicGFwZXIiXSxsaXN0OlsibGlzdCJdfSxZVCx0KX0scVQ9RyhLVCx7c2hvdWxkRm9yd2FyZFByb3A6ZT0+U24oZSl8fGU9PT0iY2xhc3NlcyIsbmFtZToiTXVpTWVudSIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucm9vdH0pKHt9KSxaVD1HKE8wLHtuYW1lOiJNdWlNZW51IixzbG90OiJQYXBlciIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucGFwZXJ9KSh7bWF4SGVpZ2h0OiJjYWxjKDEwMCUgLSA5NnB4KSIsV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6InRvdWNoIn0pLEpUPUcoV1Qse25hbWU6Ik11aU1lbnUiLHNsb3Q6Ikxpc3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT50Lmxpc3R9KSh7b3V0bGluZTowfSksZVA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlNZW51In0pLHthdXRvRm9jdXM6bz0hMCxjaGlsZHJlbjppLGNsYXNzTmFtZTpzLGRpc2FibGVBdXRvRm9jdXNJdGVtOmE9ITEsTWVudUxpc3RQcm9wczpsPXt9LG9uQ2xvc2U6dSxvcGVuOmMsUGFwZXJQcm9wczpkPXt9LFBvcG92ZXJDbGFzc2VzOm0sdHJhbnNpdGlvbkR1cmF0aW9uOnY9ImF1dG8iLFRyYW5zaXRpb25Qcm9wczp7b25FbnRlcmluZzp3LC4uLlN9PXt9LHZhcmlhbnQ6eD0ic2VsZWN0ZWRNZW51IixzbG90czpoPXt9LHNsb3RQcm9wczpnPXt9LC4uLmZ9PXIseT1xZCgpLGI9ey4uLnIsYXV0b0ZvY3VzOm8sZGlzYWJsZUF1dG9Gb2N1c0l0ZW06YSxNZW51TGlzdFByb3BzOmwsb25FbnRlcmluZzp3LFBhcGVyUHJvcHM6ZCx0cmFuc2l0aW9uRHVyYXRpb246dixUcmFuc2l0aW9uUHJvcHM6Uyx2YXJpYW50Onh9LEU9WFQoYiksUj1vJiYhYSYmYyxQPUMudXNlUmVmKG51bGwpLEk9KE0sXyk9PntQLmN1cnJlbnQmJlAuY3VycmVudC5hZGp1c3RTdHlsZUZvclNjcm9sbGJhcihNLHtkaXJlY3Rpb246eT8icnRsIjoibHRyIn0pLHcmJncoTSxfKX0scD1NPT57TS5rZXk9PT0iVGFiIiYmKE0ucHJldmVudERlZmF1bHQoKSx1JiZ1KE0sInRhYktleURvd24iKSl9O2xldCAkPS0xO0MuQ2hpbGRyZW4ubWFwKGksKE0sXyk9PntDLmlzVmFsaWRFbGVtZW50KE0pJiYoTS5wcm9wcy5kaXNhYmxlZHx8KHg9PT0ic2VsZWN0ZWRNZW51IiYmTS5wcm9wcy5zZWxlY3RlZHx8JD09PS0xKSYmKCQ9XykpfSk7Y29uc3QgTD1oLnBhcGVyPz9aVCxqPWcucGFwZXI/P2QsTj1wYyh7ZWxlbWVudFR5cGU6aC5yb290LGV4dGVybmFsU2xvdFByb3BzOmcucm9vdCxvd25lclN0YXRlOmIsY2xhc3NOYW1lOltFLnJvb3Qsc119KSxPPXBjKHtlbGVtZW50VHlwZTpMLGV4dGVybmFsU2xvdFByb3BzOmosb3duZXJTdGF0ZTpiLGNsYXNzTmFtZTpFLnBhcGVyfSk7cmV0dXJuIGsuanN4KHFULHtvbkNsb3NlOnUsYW5jaG9yT3JpZ2luOnt2ZXJ0aWNhbDoiYm90dG9tIixob3Jpem9udGFsOnk/InJpZ2h0IjoibGVmdCJ9LHRyYW5zZm9ybU9yaWdpbjp5P0dUOlFULHNsb3RzOntwYXBlcjpMLHJvb3Q6aC5yb290fSxzbG90UHJvcHM6e3Jvb3Q6TixwYXBlcjpPfSxvcGVuOmMscmVmOm4sdHJhbnNpdGlvbkR1cmF0aW9uOnYsVHJhbnNpdGlvblByb3BzOntvbkVudGVyaW5nOkksLi4uU30sb3duZXJTdGF0ZTpiLC4uLmYsY2xhc3NlczptLGNoaWxkcmVuOmsuanN4KEpULHtvbktleURvd246cCxhY3Rpb25zOlAsYXV0b0ZvY3VzOm8mJigkPT09LTF8fGEpLGF1dG9Gb2N1c0l0ZW06Uix2YXJpYW50OngsLi4ubCxjbGFzc05hbWU6dGUoRS5saXN0LGwuY2xhc3NOYW1lKSxjaGlsZHJlbjppfSl9KX0pO2Z1bmN0aW9uIHRQKGUpe3JldHVybiBjZSgiTXVpTmF0aXZlU2VsZWN0IixlKX1jb25zdCBscD1kZSgiTXVpTmF0aXZlU2VsZWN0IixbInJvb3QiLCJzZWxlY3QiLCJtdWx0aXBsZSIsImZpbGxlZCIsIm91dGxpbmVkIiwic3RhbmRhcmQiLCJkaXNhYmxlZCIsImljb24iLCJpY29uT3BlbiIsImljb25GaWxsZWQiLCJpY29uT3V0bGluZWQiLCJpY29uU3RhbmRhcmQiLCJuYXRpdmVJbnB1dCIsImVycm9yIl0pLG5QPWU9Pntjb25zdHtjbGFzc2VzOnQsdmFyaWFudDpuLGRpc2FibGVkOnIsbXVsdGlwbGU6byxvcGVuOmksZXJyb3I6c309ZSxhPXtzZWxlY3Q6WyJzZWxlY3QiLG4sciYmImRpc2FibGVkIixvJiYibXVsdGlwbGUiLHMmJiJlcnJvciJdLGljb246WyJpY29uIixgaWNvbiR7bmUobil9YCxpJiYiaWNvbk9wZW4iLHImJiJkaXNhYmxlZCJdfTtyZXR1cm4gcGUoYSx0UCx0KX0sTTA9Rygic2VsZWN0IikoKHt0aGVtZTplfSk9Pih7TW96QXBwZWFyYW5jZToibm9uZSIsV2Via2l0QXBwZWFyYW5jZToibm9uZSIsdXNlclNlbGVjdDoibm9uZSIsYm9yZGVyUmFkaXVzOjAsY3Vyc29yOiJwb2ludGVyIiwiJjpmb2N1cyI6e2JvcmRlclJhZGl1czowfSxbYCYuJHtscC5kaXNhYmxlZH1gXTp7Y3Vyc29yOiJkZWZhdWx0In0sIiZbbXVsdGlwbGVdIjp7aGVpZ2h0OiJhdXRvIn0sIiY6bm90KFttdWx0aXBsZV0pIG9wdGlvbiwgJjpub3QoW211bHRpcGxlXSkgb3B0Z3JvdXAiOntiYWNrZ3JvdW5kQ29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5iYWNrZ3JvdW5kLnBhcGVyfSx2YXJpYW50czpbe3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQudmFyaWFudCE9PSJmaWxsZWQiJiZ0LnZhcmlhbnQhPT0ib3V0bGluZWQiLHN0eWxlOnsiJiYmIjp7cGFkZGluZ1JpZ2h0OjI0LG1pbldpZHRoOjE2fX19LHtwcm9wczp7dmFyaWFudDoiZmlsbGVkIn0sc3R5bGU6eyImJiYiOntwYWRkaW5nUmlnaHQ6MzJ9fX0se3Byb3BzOnt2YXJpYW50OiJvdXRsaW5lZCJ9LHN0eWxlOntib3JkZXJSYWRpdXM6KGUudmFyc3x8ZSkuc2hhcGUuYm9yZGVyUmFkaXVzLCImOmZvY3VzIjp7Ym9yZGVyUmFkaXVzOihlLnZhcnN8fGUpLnNoYXBlLmJvcmRlclJhZGl1c30sIiYmJiI6e3BhZGRpbmdSaWdodDozMn19fV19KSksclA9RyhNMCx7bmFtZToiTXVpTmF0aXZlU2VsZWN0IixzbG90OiJTZWxlY3QiLHNob3VsZEZvcndhcmRQcm9wOlNuLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt0LnNlbGVjdCx0W24udmFyaWFudF0sbi5lcnJvciYmdC5lcnJvcix7W2AmLiR7bHAubXVsdGlwbGV9YF06dC5tdWx0aXBsZX1dfX0pKHt9KSxfMD1HKCJzdmciKSgoe3RoZW1lOmV9KT0+KHtwb3NpdGlvbjoiYWJzb2x1dGUiLHJpZ2h0OjAsdG9wOiJjYWxjKDUwJSAtIC41ZW0pIixwb2ludGVyRXZlbnRzOiJub25lIixjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsW2AmLiR7bHAuZGlzYWJsZWR9YF06e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkfSx2YXJpYW50czpbe3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQub3BlbixzdHlsZTp7dHJhbnNmb3JtOiJyb3RhdGUoMTgwZGVnKSJ9fSx7cHJvcHM6e3ZhcmlhbnQ6ImZpbGxlZCJ9LHN0eWxlOntyaWdodDo3fX0se3Byb3BzOnt2YXJpYW50OiJvdXRsaW5lZCJ9LHN0eWxlOntyaWdodDo3fX1dfSkpLG9QPUcoXzAse25hbWU6Ik11aU5hdGl2ZVNlbGVjdCIsc2xvdDoiSWNvbiIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3QuaWNvbixuLnZhcmlhbnQmJnRbYGljb24ke25lKG4udmFyaWFudCl9YF0sbi5vcGVuJiZ0Lmljb25PcGVuXX19KSh7fSksaVA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3R7Y2xhc3NOYW1lOnIsZGlzYWJsZWQ6byxlcnJvcjppLEljb25Db21wb25lbnQ6cyxpbnB1dFJlZjphLHZhcmlhbnQ6bD0ic3RhbmRhcmQiLC4uLnV9PXQsYz17Li4udCxkaXNhYmxlZDpvLHZhcmlhbnQ6bCxlcnJvcjppfSxkPW5QKGMpO3JldHVybiBrLmpzeHMoQy5GcmFnbWVudCx7Y2hpbGRyZW46W2suanN4KHJQLHtvd25lclN0YXRlOmMsY2xhc3NOYW1lOnRlKGQuc2VsZWN0LHIpLGRpc2FibGVkOm8scmVmOmF8fG4sLi4udX0pLHQubXVsdGlwbGU/bnVsbDprLmpzeChvUCx7YXM6cyxvd25lclN0YXRlOmMsY2xhc3NOYW1lOmQuaWNvbn0pXX0pfSk7dmFyIF9oO2NvbnN0IHNQPUcoImZpZWxkc2V0Iix7c2hvdWxkRm9yd2FyZFByb3A6U259KSh7dGV4dEFsaWduOiJsZWZ0Iixwb3NpdGlvbjoiYWJzb2x1dGUiLGJvdHRvbTowLHJpZ2h0OjAsdG9wOi01LGxlZnQ6MCxtYXJnaW46MCxwYWRkaW5nOiIwIDhweCIscG9pbnRlckV2ZW50czoibm9uZSIsYm9yZGVyUmFkaXVzOiJpbmhlcml0Iixib3JkZXJTdHlsZToic29saWQiLGJvcmRlcldpZHRoOjEsb3ZlcmZsb3c6ImhpZGRlbiIsbWluV2lkdGg6IjAlIn0pLGFQPUcoImxlZ2VuZCIse3Nob3VsZEZvcndhcmRQcm9wOlNufSkoeWUoKHt0aGVtZTplfSk9Pih7ZmxvYXQ6InVuc2V0Iix3aWR0aDoiYXV0byIsb3ZlcmZsb3c6ImhpZGRlbiIsdmFyaWFudHM6W3twcm9wczooe293bmVyU3RhdGU6dH0pPT4hdC53aXRoTGFiZWwsc3R5bGU6e3BhZGRpbmc6MCxsaW5lSGVpZ2h0OiIxMXB4Iix0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKCJ3aWR0aCIse2R1cmF0aW9uOjE1MCxlYXNpbmc6ZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dH0pfX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQud2l0aExhYmVsLHN0eWxlOntkaXNwbGF5OiJibG9jayIscGFkZGluZzowLGhlaWdodDoxMSxmb250U2l6ZToiMC43NWVtIix2aXNpYmlsaXR5OiJoaWRkZW4iLG1heFdpZHRoOi4wMSx0cmFuc2l0aW9uOmUudHJhbnNpdGlvbnMuY3JlYXRlKCJtYXgtd2lkdGgiLHtkdXJhdGlvbjo1MCxlYXNpbmc6ZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dH0pLHdoaXRlU3BhY2U6Im5vd3JhcCIsIiYgPiBzcGFuIjp7cGFkZGluZ0xlZnQ6NSxwYWRkaW5nUmlnaHQ6NSxkaXNwbGF5OiJpbmxpbmUtYmxvY2siLG9wYWNpdHk6MCx2aXNpYmlsaXR5OiJ2aXNpYmxlIn19fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC53aXRoTGFiZWwmJnQubm90Y2hlZCxzdHlsZTp7bWF4V2lkdGg6IjEwMCUiLHRyYW5zaXRpb246ZS50cmFuc2l0aW9ucy5jcmVhdGUoIm1heC13aWR0aCIse2R1cmF0aW9uOjEwMCxlYXNpbmc6ZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dCxkZWxheTo1MH0pfX1dfSkpKTtmdW5jdGlvbiBsUChlKXtjb25zdHtjaGlsZHJlbjp0LGNsYXNzZXM6bixjbGFzc05hbWU6cixsYWJlbDpvLG5vdGNoZWQ6aSwuLi5zfT1lLGE9byE9bnVsbCYmbyE9PSIiLGw9ey4uLmUsbm90Y2hlZDppLHdpdGhMYWJlbDphfTtyZXR1cm4gay5qc3goc1AseyJhcmlhLWhpZGRlbiI6ITAsY2xhc3NOYW1lOnIsb3duZXJTdGF0ZTpsLC4uLnMsY2hpbGRyZW46ay5qc3goYVAse293bmVyU3RhdGU6bCxjaGlsZHJlbjphP2suanN4KCJzcGFuIix7Y2hpbGRyZW46b30pOl9ofHwoX2g9ay5qc3goInNwYW4iLHtjbGFzc05hbWU6Im5vdHJhbnNsYXRlIixjaGlsZHJlbjoi4oCLIn0pKX0pfSl9Y29uc3QgdVA9ZT0+e2NvbnN0e2NsYXNzZXM6dH09ZSxyPXBlKHtyb290Olsicm9vdCJdLG5vdGNoZWRPdXRsaW5lOlsibm90Y2hlZE91dGxpbmUiXSxpbnB1dDpbImlucHV0Il19LE9SLHQpO3JldHVybnsuLi50LC4uLnJ9fSxjUD1HKGN1LHtzaG91bGRGb3J3YXJkUHJvcDplPT5TbihlKXx8ZT09PSJjbGFzc2VzIixuYW1lOiJNdWlPdXRsaW5lZElucHV0IixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjpsdX0pKHllKCh7dGhlbWU6ZX0pPT57Y29uc3QgdD1lLnBhbGV0dGUubW9kZT09PSJsaWdodCI/InJnYmEoMCwgMCwgMCwgMC4yMykiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjMpIjtyZXR1cm57cG9zaXRpb246InJlbGF0aXZlIixib3JkZXJSYWRpdXM6KGUudmFyc3x8ZSkuc2hhcGUuYm9yZGVyUmFkaXVzLFtgJjpob3ZlciAuJHtSbi5ub3RjaGVkT3V0bGluZX1gXTp7Ym9yZGVyQ29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LnByaW1hcnl9LCJAbWVkaWEgKGhvdmVyOiBub25lKSI6e1tgJjpob3ZlciAuJHtSbi5ub3RjaGVkT3V0bGluZX1gXTp7Ym9yZGVyQ29sb3I6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuY29tbW9uLm9uQmFja2dyb3VuZENoYW5uZWx9IC8gMC4yMylgOnR9fSxbYCYuJHtSbi5mb2N1c2VkfSAuJHtSbi5ub3RjaGVkT3V0bGluZX1gXTp7Ym9yZGVyV2lkdGg6Mn0sdmFyaWFudHM6Wy4uLk9iamVjdC5lbnRyaWVzKGUucGFsZXR0ZSkuZmlsdGVyKGJyKCkpLm1hcCgoW25dKT0+KHtwcm9wczp7Y29sb3I6bn0sc3R5bGU6e1tgJi4ke1JuLmZvY3VzZWR9IC4ke1JuLm5vdGNoZWRPdXRsaW5lfWBdOntib3JkZXJDb2xvcjooZS52YXJzfHxlKS5wYWxldHRlW25dLm1haW59fX0pKSx7cHJvcHM6e30sc3R5bGU6e1tgJi4ke1JuLmVycm9yfSAuJHtSbi5ub3RjaGVkT3V0bGluZX1gXTp7Ym9yZGVyQ29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5lcnJvci5tYWlufSxbYCYuJHtSbi5kaXNhYmxlZH0gLiR7Um4ubm90Y2hlZE91dGxpbmV9YF06e2JvcmRlckNvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkfX19LHtwcm9wczooe293bmVyU3RhdGU6bn0pPT5uLnN0YXJ0QWRvcm5tZW50LHN0eWxlOntwYWRkaW5nTGVmdDoxNH19LHtwcm9wczooe293bmVyU3RhdGU6bn0pPT5uLmVuZEFkb3JubWVudCxzdHlsZTp7cGFkZGluZ1JpZ2h0OjE0fX0se3Byb3BzOih7b3duZXJTdGF0ZTpufSk9Pm4ubXVsdGlsaW5lLHN0eWxlOntwYWRkaW5nOiIxNi41cHggMTRweCJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOm4sc2l6ZTpyfSk9Pm4ubXVsdGlsaW5lJiZyPT09InNtYWxsIixzdHlsZTp7cGFkZGluZzoiOC41cHggMTRweCJ9fV19fSkpLGRQPUcobFAse25hbWU6Ik11aU91dGxpbmVkSW5wdXQiLHNsb3Q6Ik5vdGNoZWRPdXRsaW5lIixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+dC5ub3RjaGVkT3V0bGluZX0pKHllKCh7dGhlbWU6ZX0pPT57Y29uc3QgdD1lLnBhbGV0dGUubW9kZT09PSJsaWdodCI/InJnYmEoMCwgMCwgMCwgMC4yMykiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjMpIjtyZXR1cm57Ym9yZGVyQ29sb3I6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGUuY29tbW9uLm9uQmFja2dyb3VuZENoYW5uZWx9IC8gMC4yMylgOnR9fSkpLGZQPUcoZHUse25hbWU6Ik11aU91dGxpbmVkSW5wdXQiLHNsb3Q6IklucHV0IixvdmVycmlkZXNSZXNvbHZlcjp1dX0pKHllKCh7dGhlbWU6ZX0pPT4oe3BhZGRpbmc6IjE2LjVweCAxNHB4IiwuLi4hZS52YXJzJiZ7IiY6LXdlYmtpdC1hdXRvZmlsbCI6e1dlYmtpdEJveFNoYWRvdzplLnBhbGV0dGUubW9kZT09PSJsaWdodCI/bnVsbDoiMCAwIDAgMTAwcHggIzI2Njc5OCBpbnNldCIsV2Via2l0VGV4dEZpbGxDb2xvcjplLnBhbGV0dGUubW9kZT09PSJsaWdodCI/bnVsbDoiI2ZmZiIsY2FyZXRDb2xvcjplLnBhbGV0dGUubW9kZT09PSJsaWdodCI/bnVsbDoiI2ZmZiIsYm9yZGVyUmFkaXVzOiJpbmhlcml0In19LC4uLmUudmFycyYmeyImOi13ZWJraXQtYXV0b2ZpbGwiOntib3JkZXJSYWRpdXM6ImluaGVyaXQifSxbZS5nZXRDb2xvclNjaGVtZVNlbGVjdG9yKCJkYXJrIildOnsiJjotd2Via2l0LWF1dG9maWxsIjp7V2Via2l0Qm94U2hhZG93OiIwIDAgMCAxMDBweCAjMjY2Nzk4IGluc2V0IixXZWJraXRUZXh0RmlsbENvbG9yOiIjZmZmIixjYXJldENvbG9yOiIjZmZmIn19fSx2YXJpYW50czpbe3Byb3BzOntzaXplOiJzbWFsbCJ9LHN0eWxlOntwYWRkaW5nOiI4LjVweCAxNHB4In19LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT50Lm11bHRpbGluZSxzdHlsZTp7cGFkZGluZzowfX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuc3RhcnRBZG9ybm1lbnQsc3R5bGU6e3BhZGRpbmdMZWZ0OjB9fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5lbmRBZG9ybm1lbnQsc3R5bGU6e3BhZGRpbmdSaWdodDowfX1dfSkpKSxybD1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXt2YXIgcjtjb25zdCBvPW1lKHtwcm9wczp0LG5hbWU6Ik11aU91dGxpbmVkSW5wdXQifSkse2NvbXBvbmVudHM6aT17fSxmdWxsV2lkdGg6cz0hMSxpbnB1dENvbXBvbmVudDphPSJpbnB1dCIsbGFiZWw6bCxtdWx0aWxpbmU6dT0hMSxub3RjaGVkOmMsc2xvdHM6ZD17fSx0eXBlOm09InRleHQiLC4uLnZ9PW8sdz11UChvKSxTPUpvKCkseD1abyh7cHJvcHM6byxtdWlGb3JtQ29udHJvbDpTLHN0YXRlczpbImNvbG9yIiwiZGlzYWJsZWQiLCJlcnJvciIsImZvY3VzZWQiLCJoaWRkZW5MYWJlbCIsInNpemUiLCJyZXF1aXJlZCJdfSksaD17Li4ubyxjb2xvcjp4LmNvbG9yfHwicHJpbWFyeSIsZGlzYWJsZWQ6eC5kaXNhYmxlZCxlcnJvcjp4LmVycm9yLGZvY3VzZWQ6eC5mb2N1c2VkLGZvcm1Db250cm9sOlMsZnVsbFdpZHRoOnMsaGlkZGVuTGFiZWw6eC5oaWRkZW5MYWJlbCxtdWx0aWxpbmU6dSxzaXplOnguc2l6ZSx0eXBlOm19LGc9ZC5yb290Pz9pLlJvb3Q/P2NQLGY9ZC5pbnB1dD8/aS5JbnB1dD8/ZlA7cmV0dXJuIGsuanN4KGFwLHtzbG90czp7cm9vdDpnLGlucHV0OmZ9LHJlbmRlclN1ZmZpeDp5PT5rLmpzeChkUCx7b3duZXJTdGF0ZTpoLGNsYXNzTmFtZTp3Lm5vdGNoZWRPdXRsaW5lLGxhYmVsOmwhPW51bGwmJmwhPT0iIiYmeC5yZXF1aXJlZD9yfHwocj1rLmpzeHMoQy5GcmFnbWVudCx7Y2hpbGRyZW46W2wsIuKAiSIsIioiXX0pKTpsLG5vdGNoZWQ6dHlwZW9mIGM8InUiP2M6ISEoeS5zdGFydEFkb3JubWVudHx8eS5maWxsZWR8fHkuZm9jdXNlZCl9KSxmdWxsV2lkdGg6cyxpbnB1dENvbXBvbmVudDphLG11bHRpbGluZTp1LHJlZjpuLHR5cGU6bSwuLi52LGNsYXNzZXM6ey4uLncsbm90Y2hlZE91dGxpbmU6bnVsbH19KX0pO3JsJiYocmwubXVpTmFtZT0iSW5wdXQiKTtmdW5jdGlvbiBwUChlKXtyZXR1cm4gY2UoIk11aVNlbGVjdCIsZSl9Y29uc3QgaGk9ZGUoIk11aVNlbGVjdCIsWyJyb290Iiwic2VsZWN0IiwibXVsdGlwbGUiLCJmaWxsZWQiLCJvdXRsaW5lZCIsInN0YW5kYXJkIiwiZGlzYWJsZWQiLCJmb2N1c2VkIiwiaWNvbiIsImljb25PcGVuIiwiaWNvbkZpbGxlZCIsImljb25PdXRsaW5lZCIsImljb25TdGFuZGFyZCIsIm5hdGl2ZUlucHV0IiwiZXJyb3IiXSk7dmFyIE5oO2NvbnN0IG1QPUcoTTAse25hbWU6Ik11aVNlbGVjdCIsc2xvdDoiU2VsZWN0IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5be1tgJi4ke2hpLnNlbGVjdH1gXTp0LnNlbGVjdH0se1tgJi4ke2hpLnNlbGVjdH1gXTp0W24udmFyaWFudF19LHtbYCYuJHtoaS5lcnJvcn1gXTp0LmVycm9yfSx7W2AmLiR7aGkubXVsdGlwbGV9YF06dC5tdWx0aXBsZX1dfX0pKHtbYCYuJHtoaS5zZWxlY3R9YF06e2hlaWdodDoiYXV0byIsbWluSGVpZ2h0OiIxLjQzNzVlbSIsdGV4dE92ZXJmbG93OiJlbGxpcHNpcyIsd2hpdGVTcGFjZToibm93cmFwIixvdmVyZmxvdzoiaGlkZGVuIn19KSxoUD1HKF8wLHtuYW1lOiJNdWlTZWxlY3QiLHNsb3Q6Ikljb24iLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt0Lmljb24sbi52YXJpYW50JiZ0W2BpY29uJHtuZShuLnZhcmlhbnQpfWBdLG4ub3BlbiYmdC5pY29uT3Blbl19fSkoe30pLGdQPUcoImlucHV0Iix7c2hvdWxkRm9yd2FyZFByb3A6ZT0+bHkoZSkmJmUhPT0iY2xhc3NlcyIsbmFtZToiTXVpU2VsZWN0IixzbG90OiJOYXRpdmVJbnB1dCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQubmF0aXZlSW5wdXR9KSh7Ym90dG9tOjAsbGVmdDowLHBvc2l0aW9uOiJhYnNvbHV0ZSIsb3BhY2l0eTowLHBvaW50ZXJFdmVudHM6Im5vbmUiLHdpZHRoOiIxMDAlIixib3hTaXppbmc6ImJvcmRlci1ib3gifSk7ZnVuY3Rpb24gSWgoZSx0KXtyZXR1cm4gdHlwZW9mIHQ9PSJvYmplY3QiJiZ0IT09bnVsbD9lPT09dDpTdHJpbmcoZSk9PT1TdHJpbmcodCl9ZnVuY3Rpb24geVAoZSl7cmV0dXJuIGU9PW51bGx8fHR5cGVvZiBlPT0ic3RyaW5nIiYmIWUudHJpbSgpfWNvbnN0IHZQPWU9Pntjb25zdHtjbGFzc2VzOnQsdmFyaWFudDpuLGRpc2FibGVkOnIsbXVsdGlwbGU6byxvcGVuOmksZXJyb3I6c309ZSxhPXtzZWxlY3Q6WyJzZWxlY3QiLG4sciYmImRpc2FibGVkIixvJiYibXVsdGlwbGUiLHMmJiJlcnJvciJdLGljb246WyJpY29uIixgaWNvbiR7bmUobil9YCxpJiYiaWNvbk9wZW4iLHImJiJkaXNhYmxlZCJdLG5hdGl2ZUlucHV0OlsibmF0aXZlSW5wdXQiXX07cmV0dXJuIHBlKGEscFAsdCl9LHdQPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe3ZhciBQcjtjb25zdHsiYXJpYS1kZXNjcmliZWRieSI6ciwiYXJpYS1sYWJlbCI6byxhdXRvRm9jdXM6aSxhdXRvV2lkdGg6cyxjaGlsZHJlbjphLGNsYXNzTmFtZTpsLGRlZmF1bHRPcGVuOnUsZGVmYXVsdFZhbHVlOmMsZGlzYWJsZWQ6ZCxkaXNwbGF5RW1wdHk6bSxlcnJvcjp2PSExLEljb25Db21wb25lbnQ6dyxpbnB1dFJlZjpTLGxhYmVsSWQ6eCxNZW51UHJvcHM6aD17fSxtdWx0aXBsZTpnLG5hbWU6ZixvbkJsdXI6eSxvbkNoYW5nZTpiLG9uQ2xvc2U6RSxvbkZvY3VzOlIsb25PcGVuOlAsb3BlbjpJLHJlYWRPbmx5OnAscmVuZGVyVmFsdWU6JCxTZWxlY3REaXNwbGF5UHJvcHM6TD17fSx0YWJJbmRleDpqLHR5cGU6Tix2YWx1ZTpPLHZhcmlhbnQ6TT0ic3RhbmRhcmQiLC4uLl99PXQsW1QsQV09a2Eoe2NvbnRyb2xsZWQ6TyxkZWZhdWx0OmMsbmFtZToiU2VsZWN0In0pLFtELEJdPWthKHtjb250cm9sbGVkOkksZGVmYXVsdDp1LG5hbWU6IlNlbGVjdCJ9KSxIPUMudXNlUmVmKG51bGwpLFY9Qy51c2VSZWYobnVsbCksW1UsWF09Qy51c2VTdGF0ZShudWxsKSx7Y3VycmVudDpXfT1DLnVzZVJlZihJIT1udWxsKSxbSixvZV09Qy51c2VTdGF0ZSgpLHJlPVFlKG4sUyksUT1DLnVzZUNhbGxiYWNrKFo9PntWLmN1cnJlbnQ9WixaJiZYKFopfSxbXSksZWU9VT09bnVsbD92b2lkIDA6VS5wYXJlbnROb2RlO0MudXNlSW1wZXJhdGl2ZUhhbmRsZShyZSwoKT0+KHtmb2N1czooKT0+e1YuY3VycmVudC5mb2N1cygpfSxub2RlOkguY3VycmVudCx2YWx1ZTpUfSksW1RdKSxDLnVzZUVmZmVjdCgoKT0+e3UmJkQmJlUmJiFXJiYob2Uocz9udWxsOmVlLmNsaWVudFdpZHRoKSxWLmN1cnJlbnQuZm9jdXMoKSl9LFtVLHNdKSxDLnVzZUVmZmVjdCgoKT0+e2kmJlYuY3VycmVudC5mb2N1cygpfSxbaV0pLEMudXNlRWZmZWN0KCgpPT57aWYoIXgpcmV0dXJuO2NvbnN0IFo9RHQoVi5jdXJyZW50KS5nZXRFbGVtZW50QnlJZCh4KTtpZihaKXtjb25zdCB4ZT0oKT0+e2dldFNlbGVjdGlvbigpLmlzQ29sbGFwc2VkJiZWLmN1cnJlbnQuZm9jdXMoKX07cmV0dXJuIFouYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLHhlKSwoKT0+e1oucmVtb3ZlRXZlbnRMaXN0ZW5lcigiY2xpY2siLHhlKX19fSxbeF0pO2NvbnN0IFk9KFoseGUpPT57Wj9QJiZQKHhlKTpFJiZFKHhlKSxXfHwob2Uocz9udWxsOmVlLmNsaWVudFdpZHRoKSxCKFopKX0sdWU9Wj0+e1ouYnV0dG9uPT09MCYmKFoucHJldmVudERlZmF1bHQoKSxWLmN1cnJlbnQuZm9jdXMoKSxZKCEwLFopKX0saWU9Wj0+e1koITEsWil9LGZlPUMuQ2hpbGRyZW4udG9BcnJheShhKSxaZT1aPT57Y29uc3QgeGU9ZmUuZmluZChLZT0+S2UucHJvcHMudmFsdWU9PT1aLnRhcmdldC52YWx1ZSk7eGUhPT12b2lkIDAmJihBKHhlLnByb3BzLnZhbHVlKSxiJiZiKFoseGUpKX0sVmU9Wj0+eGU9PntsZXQgS2U7aWYoeGUuY3VycmVudFRhcmdldC5oYXNBdHRyaWJ1dGUoInRhYmluZGV4Iikpe2lmKGcpe0tlPUFycmF5LmlzQXJyYXkoVCk/VC5zbGljZSgpOltdO2NvbnN0IGpuPVQuaW5kZXhPZihaLnByb3BzLnZhbHVlKTtqbj09PS0xP0tlLnB1c2goWi5wcm9wcy52YWx1ZSk6S2Uuc3BsaWNlKGpuLDEpfWVsc2UgS2U9Wi5wcm9wcy52YWx1ZTtpZihaLnByb3BzLm9uQ2xpY2smJloucHJvcHMub25DbGljayh4ZSksVCE9PUtlJiYoQShLZSksYikpe2NvbnN0IGpuPXhlLm5hdGl2ZUV2ZW50fHx4ZSxlaT1uZXcgam4uY29uc3RydWN0b3Ioam4udHlwZSxqbik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGVpLCJ0YXJnZXQiLHt3cml0YWJsZTohMCx2YWx1ZTp7dmFsdWU6S2UsbmFtZTpmfX0pLGIoZWksWil9Z3x8WSghMSx4ZSl9fSxPZT1aPT57cHx8WyIgIiwiQXJyb3dVcCIsIkFycm93RG93biIsIkVudGVyIl0uaW5jbHVkZXMoWi5rZXkpJiYoWi5wcmV2ZW50RGVmYXVsdCgpLFkoITAsWikpfSxOZT1VIT09bnVsbCYmRCxXZT1aPT57IU5lJiZ5JiYoT2JqZWN0LmRlZmluZVByb3BlcnR5KFosInRhcmdldCIse3dyaXRhYmxlOiEwLHZhbHVlOnt2YWx1ZTpULG5hbWU6Zn19KSx5KFopKX07ZGVsZXRlIF9bImFyaWEtaW52YWxpZCJdO2xldCBoZSxodDtjb25zdCBxPVtdO2xldCBJZT0hMTsoZWwoe3ZhbHVlOlR9KXx8bSkmJigkP2hlPSQoVCk6SWU9ITApO2NvbnN0IHhuPWZlLm1hcChaPT57aWYoIUMuaXNWYWxpZEVsZW1lbnQoWikpcmV0dXJuIG51bGw7bGV0IHhlO2lmKGcpe2lmKCFBcnJheS5pc0FycmF5KFQpKXRocm93IG5ldyBFcnJvcihWbigyKSk7eGU9VC5zb21lKEtlPT5JaChLZSxaLnByb3BzLnZhbHVlKSkseGUmJkllJiZxLnB1c2goWi5wcm9wcy5jaGlsZHJlbil9ZWxzZSB4ZT1JaChULFoucHJvcHMudmFsdWUpLHhlJiZJZSYmKGh0PVoucHJvcHMuY2hpbGRyZW4pO3JldHVybiBDLmNsb25lRWxlbWVudChaLHsiYXJpYS1zZWxlY3RlZCI6eGU/InRydWUiOiJmYWxzZSIsb25DbGljazpWZShaKSxvbktleVVwOktlPT57S2Uua2V5PT09IiAiJiZLZS5wcmV2ZW50RGVmYXVsdCgpLFoucHJvcHMub25LZXlVcCYmWi5wcm9wcy5vbktleVVwKEtlKX0scm9sZToib3B0aW9uIixzZWxlY3RlZDp4ZSx2YWx1ZTp2b2lkIDAsImRhdGEtdmFsdWUiOloucHJvcHMudmFsdWV9KX0pO0llJiYoZz9xLmxlbmd0aD09PTA/aGU9bnVsbDpoZT1xLnJlZHVjZSgoWix4ZSxLZSk9PihaLnB1c2goeGUpLEtlPHEubGVuZ3RoLTEmJloucHVzaCgiLCAiKSxaKSxbXSk6aGU9aHQpO2xldCBTdD1KOyFzJiZXJiZVJiYoU3Q9ZWUuY2xpZW50V2lkdGgpO2xldCB4dDt0eXBlb2YgajwidSI/eHQ9ajp4dD1kP251bGw6MDtjb25zdCBDbj1MLmlkfHwoZj9gbXVpLWNvbXBvbmVudC1zZWxlY3QtJHtmfWA6dm9pZCAwKSxDdD17Li4udCx2YXJpYW50Ok0sdmFsdWU6VCxvcGVuOk5lLGVycm9yOnZ9LGJuPXZQKEN0KSxsZT17Li4uaC5QYXBlclByb3BzLC4uLihQcj1oLnNsb3RQcm9wcyk9PW51bGw/dm9pZCAwOlByLnBhcGVyfSx1bj1YZCgpO3JldHVybiBrLmpzeHMoQy5GcmFnbWVudCx7Y2hpbGRyZW46W2suanN4KG1QLHthczoiZGl2IixyZWY6USx0YWJJbmRleDp4dCxyb2xlOiJjb21ib2JveCIsImFyaWEtY29udHJvbHMiOnVuLCJhcmlhLWRpc2FibGVkIjpkPyJ0cnVlIjp2b2lkIDAsImFyaWEtZXhwYW5kZWQiOk5lPyJ0cnVlIjoiZmFsc2UiLCJhcmlhLWhhc3BvcHVwIjoibGlzdGJveCIsImFyaWEtbGFiZWwiOm8sImFyaWEtbGFiZWxsZWRieSI6W3gsQ25dLmZpbHRlcihCb29sZWFuKS5qb2luKCIgIil8fHZvaWQgMCwiYXJpYS1kZXNjcmliZWRieSI6cixvbktleURvd246T2Usb25Nb3VzZURvd246ZHx8cD9udWxsOnVlLG9uQmx1cjpXZSxvbkZvY3VzOlIsLi4uTCxvd25lclN0YXRlOkN0LGNsYXNzTmFtZTp0ZShMLmNsYXNzTmFtZSxibi5zZWxlY3QsbCksaWQ6Q24sY2hpbGRyZW46eVAoaGUpP05ofHwoTmg9ay5qc3goInNwYW4iLHtjbGFzc05hbWU6Im5vdHJhbnNsYXRlIixjaGlsZHJlbjoi4oCLIn0pKTpoZX0pLGsuanN4KGdQLHsiYXJpYS1pbnZhbGlkIjp2LHZhbHVlOkFycmF5LmlzQXJyYXkoVCk/VC5qb2luKCIsIik6VCxuYW1lOmYscmVmOkgsImFyaWEtaGlkZGVuIjohMCxvbkNoYW5nZTpaZSx0YWJJbmRleDotMSxkaXNhYmxlZDpkLGNsYXNzTmFtZTpibi5uYXRpdmVJbnB1dCxhdXRvRm9jdXM6aSwuLi5fLG93bmVyU3RhdGU6Q3R9KSxrLmpzeChoUCx7YXM6dyxjbGFzc05hbWU6Ym4uaWNvbixvd25lclN0YXRlOkN0fSksay5qc3goZVAse2lkOmBtZW51LSR7Znx8IiJ9YCxhbmNob3JFbDplZSxvcGVuOk5lLG9uQ2xvc2U6aWUsYW5jaG9yT3JpZ2luOnt2ZXJ0aWNhbDoiYm90dG9tIixob3Jpem9udGFsOiJjZW50ZXIifSx0cmFuc2Zvcm1PcmlnaW46e3ZlcnRpY2FsOiJ0b3AiLGhvcml6b250YWw6ImNlbnRlciJ9LC4uLmgsTWVudUxpc3RQcm9wczp7ImFyaWEtbGFiZWxsZWRieSI6eCxyb2xlOiJsaXN0Ym94IiwiYXJpYS1tdWx0aXNlbGVjdGFibGUiOmc/InRydWUiOnZvaWQgMCxkaXNhYmxlTGlzdFdyYXA6ITAsaWQ6dW4sLi4uaC5NZW51TGlzdFByb3BzfSxzbG90UHJvcHM6ey4uLmguc2xvdFByb3BzLHBhcGVyOnsuLi5sZSxzdHlsZTp7bWluV2lkdGg6U3QsLi4ubGUhPW51bGw/bGUuc3R5bGU6bnVsbH19fSxjaGlsZHJlbjp4bn0pXX0pfSksU1A9ZT0+e2NvbnN0e2NsYXNzZXM6dH09ZTtyZXR1cm4gdH0sdXA9e25hbWU6Ik11aVNlbGVjdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucm9vdCxzaG91bGRGb3J3YXJkUHJvcDplPT5TbihlKSYmZSE9PSJ2YXJpYW50IixzbG90OiJSb290In0seFA9RyhubCx1cCkoIiIpLENQPUcocmwsdXApKCIiKSxiUD1HKHRsLHVwKSgiIiksTjA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7bmFtZToiTXVpU2VsZWN0Iixwcm9wczp0fSkse2F1dG9XaWR0aDpvPSExLGNoaWxkcmVuOmksY2xhc3NlczpzPXt9LGNsYXNzTmFtZTphLGRlZmF1bHRPcGVuOmw9ITEsZGlzcGxheUVtcHR5OnU9ITEsSWNvbkNvbXBvbmVudDpjPV9SLGlkOmQsaW5wdXQ6bSxpbnB1dFByb3BzOnYsbGFiZWw6dyxsYWJlbElkOlMsTWVudVByb3BzOngsbXVsdGlwbGU6aD0hMSxuYXRpdmU6Zz0hMSxvbkNsb3NlOmYsb25PcGVuOnksb3BlbjpiLHJlbmRlclZhbHVlOkUsU2VsZWN0RGlzcGxheVByb3BzOlIsdmFyaWFudDpQPSJvdXRsaW5lZCIsLi4uSX09cixwPWc/aVA6d1AsJD1KbygpLEw9Wm8oe3Byb3BzOnIsbXVpRm9ybUNvbnRyb2w6JCxzdGF0ZXM6WyJ2YXJpYW50IiwiZXJyb3IiXX0pLGo9TC52YXJpYW50fHxQLE49ey4uLnIsdmFyaWFudDpqLGNsYXNzZXM6c30sTz1TUChOKSx7cm9vdDpNLC4uLl99PU8sVD1tfHx7c3RhbmRhcmQ6ay5qc3goeFAse293bmVyU3RhdGU6Tn0pLG91dGxpbmVkOmsuanN4KENQLHtsYWJlbDp3LG93bmVyU3RhdGU6Tn0pLGZpbGxlZDprLmpzeChiUCx7b3duZXJTdGF0ZTpOfSl9W2pdLEE9UWUobixRbyhUKSk7cmV0dXJuIGsuanN4KEMuRnJhZ21lbnQse2NoaWxkcmVuOkMuY2xvbmVFbGVtZW50KFQse2lucHV0Q29tcG9uZW50OnAsaW5wdXRQcm9wczp7Y2hpbGRyZW46aSxlcnJvcjpMLmVycm9yLEljb25Db21wb25lbnQ6Yyx2YXJpYW50OmosdHlwZTp2b2lkIDAsbXVsdGlwbGU6aCwuLi5nP3tpZDpkfTp7YXV0b1dpZHRoOm8sZGVmYXVsdE9wZW46bCxkaXNwbGF5RW1wdHk6dSxsYWJlbElkOlMsTWVudVByb3BzOngsb25DbG9zZTpmLG9uT3Blbjp5LG9wZW46YixyZW5kZXJWYWx1ZTpFLFNlbGVjdERpc3BsYXlQcm9wczp7aWQ6ZCwuLi5SfX0sLi4udixjbGFzc2VzOnY/cHQoXyx2LmNsYXNzZXMpOl8sLi4ubT9tLnByb3BzLmlucHV0UHJvcHM6e319LC4uLihoJiZnfHx1KSYmaj09PSJvdXRsaW5lZCI/e25vdGNoZWQ6ITB9Ont9LHJlZjpBLGNsYXNzTmFtZTp0ZShULnByb3BzLmNsYXNzTmFtZSxhLE8ucm9vdCksLi4uIW0mJnt2YXJpYW50Omp9LC4uLkl9KX0pfSk7TjAubXVpTmFtZT0iU2VsZWN0IjtmdW5jdGlvbiBrUChlKXtyZXR1cm4gY2UoIk11aVRvb2x0aXAiLGUpfWNvbnN0IEZlPWRlKCJNdWlUb29sdGlwIixbInBvcHBlciIsInBvcHBlckludGVyYWN0aXZlIiwicG9wcGVyQXJyb3ciLCJwb3BwZXJDbG9zZSIsInRvb2x0aXAiLCJ0b29sdGlwQXJyb3ciLCJ0b3VjaCIsInRvb2x0aXBQbGFjZW1lbnRMZWZ0IiwidG9vbHRpcFBsYWNlbWVudFJpZ2h0IiwidG9vbHRpcFBsYWNlbWVudFRvcCIsInRvb2x0aXBQbGFjZW1lbnRCb3R0b20iLCJhcnJvdyJdKTtmdW5jdGlvbiBFUChlKXtyZXR1cm4gTWF0aC5yb3VuZChlKjFlNSkvMWU1fWNvbnN0IFJQPWU9Pntjb25zdHtjbGFzc2VzOnQsZGlzYWJsZUludGVyYWN0aXZlOm4sYXJyb3c6cix0b3VjaDpvLHBsYWNlbWVudDppfT1lLHM9e3BvcHBlcjpbInBvcHBlciIsIW4mJiJwb3BwZXJJbnRlcmFjdGl2ZSIsciYmInBvcHBlckFycm93Il0sdG9vbHRpcDpbInRvb2x0aXAiLHImJiJ0b29sdGlwQXJyb3ciLG8mJiJ0b3VjaCIsYHRvb2x0aXBQbGFjZW1lbnQke25lKGkuc3BsaXQoIi0iKVswXSl9YF0sYXJyb3c6WyJhcnJvdyJdfTtyZXR1cm4gcGUocyxrUCx0KX0sVFA9RyhUMCx7bmFtZToiTXVpVG9vbHRpcCIsc2xvdDoiUG9wcGVyIixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+e2NvbnN0e293bmVyU3RhdGU6bn09ZTtyZXR1cm5bdC5wb3BwZXIsIW4uZGlzYWJsZUludGVyYWN0aXZlJiZ0LnBvcHBlckludGVyYWN0aXZlLG4uYXJyb3cmJnQucG9wcGVyQXJyb3csIW4ub3BlbiYmdC5wb3BwZXJDbG9zZV19fSkoeWUoKHt0aGVtZTplfSk9Pih7ekluZGV4OihlLnZhcnN8fGUpLnpJbmRleC50b29sdGlwLHBvaW50ZXJFdmVudHM6Im5vbmUiLHZhcmlhbnRzOlt7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+IXQuZGlzYWJsZUludGVyYWN0aXZlLHN0eWxlOntwb2ludGVyRXZlbnRzOiJhdXRvIn19LHtwcm9wczooe29wZW46dH0pPT4hdCxzdHlsZTp7cG9pbnRlckV2ZW50czoibm9uZSJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5hcnJvdyxzdHlsZTp7W2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9ImJvdHRvbSJdIC4ke0ZlLmFycm93fWBdOnt0b3A6MCxtYXJnaW5Ub3A6Ii0wLjcxZW0iLCImOjpiZWZvcmUiOnt0cmFuc2Zvcm1PcmlnaW46IjAgMTAwJSJ9fSxbYCZbZGF0YS1wb3BwZXItcGxhY2VtZW50Kj0idG9wIl0gLiR7RmUuYXJyb3d9YF06e2JvdHRvbTowLG1hcmdpbkJvdHRvbToiLTAuNzFlbSIsIiY6OmJlZm9yZSI6e3RyYW5zZm9ybU9yaWdpbjoiMTAwJSAwIn19LFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJyaWdodCJdIC4ke0ZlLmFycm93fWBdOntoZWlnaHQ6IjFlbSIsd2lkdGg6IjAuNzFlbSIsIiY6OmJlZm9yZSI6e3RyYW5zZm9ybU9yaWdpbjoiMTAwJSAxMDAlIn19LFtgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJsZWZ0Il0gLiR7RmUuYXJyb3d9YF06e2hlaWdodDoiMWVtIix3aWR0aDoiMC43MWVtIiwiJjo6YmVmb3JlIjp7dHJhbnNmb3JtT3JpZ2luOiIwIDAifX19fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC5hcnJvdyYmIXQuaXNSdGwsc3R5bGU6e1tgJltkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJyaWdodCJdIC4ke0ZlLmFycm93fWBdOntsZWZ0OjAsbWFyZ2luTGVmdDoiLTAuNzFlbSJ9fX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuYXJyb3cmJiEhdC5pc1J0bCxzdHlsZTp7W2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9InJpZ2h0Il0gLiR7RmUuYXJyb3d9YF06e3JpZ2h0OjAsbWFyZ2luUmlnaHQ6Ii0wLjcxZW0ifX19LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT50LmFycm93JiYhdC5pc1J0bCxzdHlsZTp7W2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9ImxlZnQiXSAuJHtGZS5hcnJvd31gXTp7cmlnaHQ6MCxtYXJnaW5SaWdodDoiLTAuNzFlbSJ9fX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuYXJyb3cmJiEhdC5pc1J0bCxzdHlsZTp7W2AmW2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9ImxlZnQiXSAuJHtGZS5hcnJvd31gXTp7bGVmdDowLG1hcmdpbkxlZnQ6Ii0wLjcxZW0ifX19XX0pKSksUFA9RygiZGl2Iix7bmFtZToiTXVpVG9vbHRpcCIsc2xvdDoiVG9vbHRpcCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3QudG9vbHRpcCxuLnRvdWNoJiZ0LnRvdWNoLG4uYXJyb3cmJnQudG9vbHRpcEFycm93LHRbYHRvb2x0aXBQbGFjZW1lbnQke25lKG4ucGxhY2VtZW50LnNwbGl0KCItIilbMF0pfWBdXX19KSh5ZSgoe3RoZW1lOmV9KT0+KHtiYWNrZ3JvdW5kQ29sb3I6ZS52YXJzP2UudmFycy5wYWxldHRlLlRvb2x0aXAuYmc6ZnQoZS5wYWxldHRlLmdyZXlbNzAwXSwuOTIpLGJvcmRlclJhZGl1czooZS52YXJzfHxlKS5zaGFwZS5ib3JkZXJSYWRpdXMsY29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5jb21tb24ud2hpdGUsZm9udEZhbWlseTplLnR5cG9ncmFwaHkuZm9udEZhbWlseSxwYWRkaW5nOiI0cHggOHB4Iixmb250U2l6ZTplLnR5cG9ncmFwaHkucHhUb1JlbSgxMSksbWF4V2lkdGg6MzAwLG1hcmdpbjoyLHdvcmRXcmFwOiJicmVhay13b3JkIixmb250V2VpZ2h0OmUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFtgLiR7RmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJsZWZ0Il0gJmBdOnt0cmFuc2Zvcm1PcmlnaW46InJpZ2h0IGNlbnRlciJ9LFtgLiR7RmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJyaWdodCJdICZgXTp7dHJhbnNmb3JtT3JpZ2luOiJsZWZ0IGNlbnRlciJ9LFtgLiR7RmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJ0b3AiXSAmYF06e3RyYW5zZm9ybU9yaWdpbjoiY2VudGVyIGJvdHRvbSIsbWFyZ2luQm90dG9tOiIxNHB4In0sW2AuJHtGZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9ImJvdHRvbSJdICZgXTp7dHJhbnNmb3JtT3JpZ2luOiJjZW50ZXIgdG9wIixtYXJnaW5Ub3A6IjE0cHgifSx2YXJpYW50czpbe3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuYXJyb3csc3R5bGU6e3Bvc2l0aW9uOiJyZWxhdGl2ZSIsbWFyZ2luOjB9fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC50b3VjaCxzdHlsZTp7cGFkZGluZzoiOHB4IDE2cHgiLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDE0KSxsaW5lSGVpZ2h0OmAke0VQKDE2LzE0KX1lbWAsZm9udFdlaWdodDplLnR5cG9ncmFwaHkuZm9udFdlaWdodFJlZ3VsYXJ9fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+IXQuaXNSdGwsc3R5bGU6e1tgLiR7RmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJsZWZ0Il0gJmBdOnttYXJnaW5SaWdodDoiMTRweCJ9LFtgLiR7RmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJyaWdodCJdICZgXTp7bWFyZ2luTGVmdDoiMTRweCJ9fX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PiF0LmlzUnRsJiZ0LnRvdWNoLHN0eWxlOntbYC4ke0ZlLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj0ibGVmdCJdICZgXTp7bWFyZ2luUmlnaHQ6IjI0cHgifSxbYC4ke0ZlLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj0icmlnaHQiXSAmYF06e21hcmdpbkxlZnQ6IjI0cHgifX19LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT4hIXQuaXNSdGwsc3R5bGU6e1tgLiR7RmUucG9wcGVyfVtkYXRhLXBvcHBlci1wbGFjZW1lbnQqPSJsZWZ0Il0gJmBdOnttYXJnaW5MZWZ0OiIxNHB4In0sW2AuJHtGZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9InJpZ2h0Il0gJmBdOnttYXJnaW5SaWdodDoiMTRweCJ9fX0se3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PiEhdC5pc1J0bCYmdC50b3VjaCxzdHlsZTp7W2AuJHtGZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9ImxlZnQiXSAmYF06e21hcmdpbkxlZnQ6IjI0cHgifSxbYC4ke0ZlLnBvcHBlcn1bZGF0YS1wb3BwZXItcGxhY2VtZW50Kj0icmlnaHQiXSAmYF06e21hcmdpblJpZ2h0OiIyNHB4In19fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC50b3VjaCxzdHlsZTp7W2AuJHtGZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9InRvcCJdICZgXTp7bWFyZ2luQm90dG9tOiIyNHB4In19fSx7cHJvcHM6KHtvd25lclN0YXRlOnR9KT0+dC50b3VjaCxzdHlsZTp7W2AuJHtGZS5wb3BwZXJ9W2RhdGEtcG9wcGVyLXBsYWNlbWVudCo9ImJvdHRvbSJdICZgXTp7bWFyZ2luVG9wOiIyNHB4In19fV19KSkpLCRQPUcoInNwYW4iLHtuYW1lOiJNdWlUb29sdGlwIixzbG90OiJBcnJvdyIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQuYXJyb3d9KSh5ZSgoe3RoZW1lOmV9KT0+KHtvdmVyZmxvdzoiaGlkZGVuIixwb3NpdGlvbjoiYWJzb2x1dGUiLHdpZHRoOiIxZW0iLGhlaWdodDoiMC43MWVtIixib3hTaXppbmc6ImJvcmRlci1ib3giLGNvbG9yOmUudmFycz9lLnZhcnMucGFsZXR0ZS5Ub29sdGlwLmJnOmZ0KGUucGFsZXR0ZS5ncmV5WzcwMF0sLjkpLCImOjpiZWZvcmUiOntjb250ZW50OiciIicsbWFyZ2luOiJhdXRvIixkaXNwbGF5OiJibG9jayIsd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSIsYmFja2dyb3VuZENvbG9yOiJjdXJyZW50Q29sb3IiLHRyYW5zZm9ybToicm90YXRlKDQ1ZGVnKSJ9fSkpKTtsZXQgSnM9ITE7Y29uc3QgQWg9bmV3IEhsO2xldCBnaT17eDowLHk6MH07ZnVuY3Rpb24gZWEoZSx0KXtyZXR1cm4obiwuLi5yKT0+e3QmJnQobiwuLi5yKSxlKG4sLi4ucil9fWNvbnN0IHpoPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe3ZhciB5cCx2cCx3cDtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aVRvb2x0aXAifSkse2Fycm93Om89ITEsY2hpbGRyZW46aSxjbGFzc2VzOnMsY29tcG9uZW50czphPXt9LGNvbXBvbmVudHNQcm9wczpsPXt9LGRlc2NyaWJlQ2hpbGQ6dT0hMSxkaXNhYmxlRm9jdXNMaXN0ZW5lcjpjPSExLGRpc2FibGVIb3Zlckxpc3RlbmVyOmQ9ITEsZGlzYWJsZUludGVyYWN0aXZlOm09ITEsZGlzYWJsZVRvdWNoTGlzdGVuZXI6dj0hMSxlbnRlckRlbGF5Onc9MTAwLGVudGVyTmV4dERlbGF5OlM9MCxlbnRlclRvdWNoRGVsYXk6eD03MDAsZm9sbG93Q3Vyc29yOmg9ITEsaWQ6ZyxsZWF2ZURlbGF5OmY9MCxsZWF2ZVRvdWNoRGVsYXk6eT0xNTAwLG9uQ2xvc2U6Yixvbk9wZW46RSxvcGVuOlIscGxhY2VtZW50OlA9ImJvdHRvbSIsUG9wcGVyQ29tcG9uZW50OkksUG9wcGVyUHJvcHM6cD17fSxzbG90UHJvcHM6JD17fSxzbG90czpMPXt9LHRpdGxlOmosVHJhbnNpdGlvbkNvbXBvbmVudDpOPWNzLFRyYW5zaXRpb25Qcm9wczpPLC4uLk19PXIsXz1DLmlzVmFsaWRFbGVtZW50KGkpP2k6ay5qc3goInNwYW4iLHtjaGlsZHJlbjppfSksVD1TcygpLEE9cWQoKSxbRCxCXT1DLnVzZVN0YXRlKCksW0gsVl09Qy51c2VTdGF0ZShudWxsKSxVPUMudXNlUmVmKCExKSxYPW18fGgsVz1BcigpLEo9QXIoKSxvZT1BcigpLHJlPUFyKCksW1EsZWVdPWthKHtjb250cm9sbGVkOlIsZGVmYXVsdDohMSxuYW1lOiJUb29sdGlwIixzdGF0ZToib3BlbiJ9KTtsZXQgWT1RO2NvbnN0IHVlPVhkKGcpLGllPUMudXNlUmVmKCksZmU9dXIoKCk9PntpZS5jdXJyZW50IT09dm9pZCAwJiYoZG9jdW1lbnQuYm9keS5zdHlsZS5XZWJraXRVc2VyU2VsZWN0PWllLmN1cnJlbnQsaWUuY3VycmVudD12b2lkIDApLHJlLmNsZWFyKCl9KTtDLnVzZUVmZmVjdCgoKT0+ZmUsW2ZlXSk7Y29uc3QgWmU9c2U9PntBaC5jbGVhcigpLEpzPSEwLGVlKCEwKSxFJiYhWSYmRShzZSl9LFZlPXVyKHNlPT57QWguc3RhcnQoODAwK2YsKCk9PntKcz0hMX0pLGVlKCExKSxiJiZZJiZiKHNlKSxXLnN0YXJ0KFQudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3QsKCk9PntVLmN1cnJlbnQ9ITF9KX0pLE9lPXNlPT57VS5jdXJyZW50JiZzZS50eXBlIT09InRvdWNoc3RhcnQifHwoRCYmRC5yZW1vdmVBdHRyaWJ1dGUoInRpdGxlIiksSi5jbGVhcigpLG9lLmNsZWFyKCksd3x8SnMmJlM/Si5zdGFydChKcz9TOncsKCk9PntaZShzZSl9KTpaZShzZSkpfSxOZT1zZT0+e0ouY2xlYXIoKSxvZS5zdGFydChmLCgpPT57VmUoc2UpfSl9LFssV2VdPUMudXNlU3RhdGUoITEpLGhlPXNlPT57RWEoc2UudGFyZ2V0KXx8KFdlKCExKSxOZShzZSkpfSxodD1zZT0+e0R8fEIoc2UuY3VycmVudFRhcmdldCksRWEoc2UudGFyZ2V0KSYmKFdlKCEwKSxPZShzZSkpfSxxPXNlPT57VS5jdXJyZW50PSEwO2NvbnN0IGNuPV8ucHJvcHM7Y24ub25Ub3VjaFN0YXJ0JiZjbi5vblRvdWNoU3RhcnQoc2UpfSxJZT1zZT0+e3Eoc2UpLG9lLmNsZWFyKCksVy5jbGVhcigpLGZlKCksaWUuY3VycmVudD1kb2N1bWVudC5ib2R5LnN0eWxlLldlYmtpdFVzZXJTZWxlY3QsZG9jdW1lbnQuYm9keS5zdHlsZS5XZWJraXRVc2VyU2VsZWN0PSJub25lIixyZS5zdGFydCh4LCgpPT57ZG9jdW1lbnQuYm9keS5zdHlsZS5XZWJraXRVc2VyU2VsZWN0PWllLmN1cnJlbnQsT2Uoc2UpfSl9LHhuPXNlPT57Xy5wcm9wcy5vblRvdWNoRW5kJiZfLnByb3BzLm9uVG91Y2hFbmQoc2UpLGZlKCksb2Uuc3RhcnQoeSwoKT0+e1ZlKHNlKX0pfTtDLnVzZUVmZmVjdCgoKT0+e2lmKCFZKXJldHVybjtmdW5jdGlvbiBzZShjbil7Y24ua2V5PT09IkVzY2FwZSImJlZlKGNuKX1yZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigia2V5ZG93biIsc2UpLCgpPT57ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigia2V5ZG93biIsc2UpfX0sW1ZlLFldKTtjb25zdCBTdD1RZShRbyhfKSxCLG4pOyFqJiZqIT09MCYmKFk9ITEpO2NvbnN0IHh0PUMudXNlUmVmKCksQ249c2U9Pntjb25zdCBjbj1fLnByb3BzO2NuLm9uTW91c2VNb3ZlJiZjbi5vbk1vdXNlTW92ZShzZSksZ2k9e3g6c2UuY2xpZW50WCx5OnNlLmNsaWVudFl9LHh0LmN1cnJlbnQmJnh0LmN1cnJlbnQudXBkYXRlKCl9LEN0PXt9LGJuPXR5cGVvZiBqPT0ic3RyaW5nIjt1PyhDdC50aXRsZT0hWSYmYm4mJiFkP2o6bnVsbCxDdFsiYXJpYS1kZXNjcmliZWRieSJdPVk/dWU6bnVsbCk6KEN0WyJhcmlhLWxhYmVsIl09Ym4/ajpudWxsLEN0WyJhcmlhLWxhYmVsbGVkYnkiXT1ZJiYhYm4/dWU6bnVsbCk7Y29uc3QgbGU9ey4uLkN0LC4uLk0sLi4uXy5wcm9wcyxjbGFzc05hbWU6dGUoTS5jbGFzc05hbWUsXy5wcm9wcy5jbGFzc05hbWUpLG9uVG91Y2hTdGFydDpxLHJlZjpTdCwuLi5oP3tvbk1vdXNlTW92ZTpDbn06e319LHVuPXt9O3Z8fChsZS5vblRvdWNoU3RhcnQ9SWUsbGUub25Ub3VjaEVuZD14biksZHx8KGxlLm9uTW91c2VPdmVyPWVhKE9lLGxlLm9uTW91c2VPdmVyKSxsZS5vbk1vdXNlTGVhdmU9ZWEoTmUsbGUub25Nb3VzZUxlYXZlKSxYfHwodW4ub25Nb3VzZU92ZXI9T2UsdW4ub25Nb3VzZUxlYXZlPU5lKSksY3x8KGxlLm9uRm9jdXM9ZWEoaHQsbGUub25Gb2N1cyksbGUub25CbHVyPWVhKGhlLGxlLm9uQmx1ciksWHx8KHVuLm9uRm9jdXM9aHQsdW4ub25CbHVyPWhlKSk7Y29uc3QgUHI9Qy51c2VNZW1vKCgpPT57dmFyIGNuO2xldCBzZT1be25hbWU6ImFycm93IixlbmFibGVkOiEhSCxvcHRpb25zOntlbGVtZW50OkgscGFkZGluZzo0fX1dO3JldHVybihjbj1wLnBvcHBlck9wdGlvbnMpIT1udWxsJiZjbi5tb2RpZmllcnMmJihzZT1zZS5jb25jYXQocC5wb3BwZXJPcHRpb25zLm1vZGlmaWVycykpLHsuLi5wLnBvcHBlck9wdGlvbnMsbW9kaWZpZXJzOnNlfX0sW0gscF0pLFo9ey4uLnIsaXNSdGw6QSxhcnJvdzpvLGRpc2FibGVJbnRlcmFjdGl2ZTpYLHBsYWNlbWVudDpQLFBvcHBlckNvbXBvbmVudFByb3A6SSx0b3VjaDpVLmN1cnJlbnR9LHhlPVJQKFopLEtlPUwucG9wcGVyPz9hLlBvcHBlcj8/VFAsam49TC50cmFuc2l0aW9uPz9hLlRyYW5zaXRpb24/P04/P2NzLGVpPUwudG9vbHRpcD8/YS5Ub29sdGlwPz9QUCxncD1MLmFycm93Pz9hLkFycm93Pz8kUCxuMT1sbyhLZSx7Li4ucCwuLi4kLnBvcHBlcj8/bC5wb3BwZXIsY2xhc3NOYW1lOnRlKHhlLnBvcHBlcixwPT1udWxsP3ZvaWQgMDpwLmNsYXNzTmFtZSwoeXA9JC5wb3BwZXI/P2wucG9wcGVyKT09bnVsbD92b2lkIDA6eXAuY2xhc3NOYW1lKX0sWikscjE9bG8oam4sey4uLk8sLi4uJC50cmFuc2l0aW9uPz9sLnRyYW5zaXRpb259LFopLG8xPWxvKGVpLHsuLi4kLnRvb2x0aXA/P2wudG9vbHRpcCxjbGFzc05hbWU6dGUoeGUudG9vbHRpcCwodnA9JC50b29sdGlwPz9sLnRvb2x0aXApPT1udWxsP3ZvaWQgMDp2cC5jbGFzc05hbWUpfSxaKSxpMT1sbyhncCx7Li4uJC5hcnJvdz8/bC5hcnJvdyxjbGFzc05hbWU6dGUoeGUuYXJyb3csKHdwPSQuYXJyb3c/P2wuYXJyb3cpPT1udWxsP3ZvaWQgMDp3cC5jbGFzc05hbWUpfSxaKTtyZXR1cm4gay5qc3hzKEMuRnJhZ21lbnQse2NoaWxkcmVuOltDLmNsb25lRWxlbWVudChfLGxlKSxrLmpzeChLZSx7YXM6ST8/VDAscGxhY2VtZW50OlAsYW5jaG9yRWw6aD97Z2V0Qm91bmRpbmdDbGllbnRSZWN0OigpPT4oe3RvcDpnaS55LGxlZnQ6Z2kueCxyaWdodDpnaS54LGJvdHRvbTpnaS55LHdpZHRoOjAsaGVpZ2h0OjB9KX06RCxwb3BwZXJSZWY6eHQsb3BlbjpEP1k6ITEsaWQ6dWUsdHJhbnNpdGlvbjohMCwuLi51biwuLi5uMSxwb3BwZXJPcHRpb25zOlByLGNoaWxkcmVuOih7VHJhbnNpdGlvblByb3BzOnNlfSk9PmsuanN4KGpuLHt0aW1lb3V0OlQudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlciwuLi5zZSwuLi5yMSxjaGlsZHJlbjprLmpzeHMoZWksey4uLm8xLGNoaWxkcmVuOltqLG8/ay5qc3goZ3Asey4uLmkxLHJlZjpWfSk6bnVsbF19KX0pfSldfSl9KSxJMD1DLmNyZWF0ZUNvbnRleHQoKTtmdW5jdGlvbiBPUChlKXtyZXR1cm4gY2UoIk11aVRhYmxlIixlKX1kZSgiTXVpVGFibGUiLFsicm9vdCIsInN0aWNreUhlYWRlciJdKTtjb25zdCBNUD1lPT57Y29uc3R7Y2xhc3Nlczp0LHN0aWNreUhlYWRlcjpufT1lO3JldHVybiBwZSh7cm9vdDpbInJvb3QiLG4mJiJzdGlja3lIZWFkZXIiXX0sT1AsdCl9LF9QPUcoInRhYmxlIix7bmFtZToiTXVpVGFibGUiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT57Y29uc3R7b3duZXJTdGF0ZTpufT1lO3JldHVyblt0LnJvb3Qsbi5zdGlja3lIZWFkZXImJnQuc3RpY2t5SGVhZGVyXX19KSh5ZSgoe3RoZW1lOmV9KT0+KHtkaXNwbGF5OiJ0YWJsZSIsd2lkdGg6IjEwMCUiLGJvcmRlckNvbGxhcHNlOiJjb2xsYXBzZSIsYm9yZGVyU3BhY2luZzowLCImIGNhcHRpb24iOnsuLi5lLnR5cG9ncmFwaHkuYm9keTIscGFkZGluZzplLnNwYWNpbmcoMiksY29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSx0ZXh0QWxpZ246ImxlZnQiLGNhcHRpb25TaWRlOiJib3R0b20ifSx2YXJpYW50czpbe3Byb3BzOih7b3duZXJTdGF0ZTp0fSk9PnQuc3RpY2t5SGVhZGVyLHN0eWxlOntib3JkZXJDb2xsYXBzZToic2VwYXJhdGUifX1dfSkpKSxMaD0idGFibGUiLE5QPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpVGFibGUifSkse2NsYXNzTmFtZTpvLGNvbXBvbmVudDppPUxoLHBhZGRpbmc6cz0ibm9ybWFsIixzaXplOmE9Im1lZGl1bSIsc3RpY2t5SGVhZGVyOmw9ITEsLi4udX09cixjPXsuLi5yLGNvbXBvbmVudDppLHBhZGRpbmc6cyxzaXplOmEsc3RpY2t5SGVhZGVyOmx9LGQ9TVAoYyksbT1DLnVzZU1lbW8oKCk9Pih7cGFkZGluZzpzLHNpemU6YSxzdGlja3lIZWFkZXI6bH0pLFtzLGEsbF0pO3JldHVybiBrLmpzeChJMC5Qcm92aWRlcix7dmFsdWU6bSxjaGlsZHJlbjprLmpzeChfUCx7YXM6aSxyb2xlOmk9PT1MaD9udWxsOiJ0YWJsZSIscmVmOm4sY2xhc3NOYW1lOnRlKGQucm9vdCxvKSxvd25lclN0YXRlOmMsLi4udX0pfSl9KSxmdT1DLmNyZWF0ZUNvbnRleHQoKTtmdW5jdGlvbiBJUChlKXtyZXR1cm4gY2UoIk11aVRhYmxlQm9keSIsZSl9ZGUoIk11aVRhYmxlQm9keSIsWyJyb290Il0pO2NvbnN0IEFQPWU9Pntjb25zdHtjbGFzc2VzOnR9PWU7cmV0dXJuIHBlKHtyb290Olsicm9vdCJdfSxJUCx0KX0selA9RygidGJvZHkiLHtuYW1lOiJNdWlUYWJsZUJvZHkiLHNsb3Q6IlJvb3QiLG92ZXJyaWRlc1Jlc29sdmVyOihlLHQpPT50LnJvb3R9KSh7ZGlzcGxheToidGFibGUtcm93LWdyb3VwIn0pLExQPXt2YXJpYW50OiJib2R5In0samg9InRib2R5IixqUD1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aVRhYmxlQm9keSJ9KSx7Y2xhc3NOYW1lOm8sY29tcG9uZW50Omk9amgsLi4uc309cixhPXsuLi5yLGNvbXBvbmVudDppfSxsPUFQKGEpO3JldHVybiBrLmpzeChmdS5Qcm92aWRlcix7dmFsdWU6TFAsY2hpbGRyZW46ay5qc3goelAse2NsYXNzTmFtZTp0ZShsLnJvb3QsbyksYXM6aSxyZWY6bixyb2xlOmk9PT1qaD9udWxsOiJyb3dncm91cCIsb3duZXJTdGF0ZTphLC4uLnN9KX0pfSk7ZnVuY3Rpb24gRFAoZSl7cmV0dXJuIGNlKCJNdWlUYWJsZUNlbGwiLGUpfWNvbnN0IEZQPWRlKCJNdWlUYWJsZUNlbGwiLFsicm9vdCIsImhlYWQiLCJib2R5IiwiZm9vdGVyIiwic2l6ZVNtYWxsIiwic2l6ZU1lZGl1bSIsInBhZGRpbmdDaGVja2JveCIsInBhZGRpbmdOb25lIiwiYWxpZ25MZWZ0IiwiYWxpZ25DZW50ZXIiLCJhbGlnblJpZ2h0IiwiYWxpZ25KdXN0aWZ5Iiwic3RpY2t5SGVhZGVyIl0pLEJQPWU9Pntjb25zdHtjbGFzc2VzOnQsdmFyaWFudDpuLGFsaWduOnIscGFkZGluZzpvLHNpemU6aSxzdGlja3lIZWFkZXI6c309ZSxhPXtyb290Olsicm9vdCIsbixzJiYic3RpY2t5SGVhZGVyIixyIT09ImluaGVyaXQiJiZgYWxpZ24ke25lKHIpfWAsbyE9PSJub3JtYWwiJiZgcGFkZGluZyR7bmUobyl9YCxgc2l6ZSR7bmUoaSl9YF19O3JldHVybiBwZShhLERQLHQpfSxXUD1HKCJ0ZCIse25hbWU6Ik11aVRhYmxlQ2VsbCIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3Qucm9vdCx0W24udmFyaWFudF0sdFtgc2l6ZSR7bmUobi5zaXplKX1gXSxuLnBhZGRpbmchPT0ibm9ybWFsIiYmdFtgcGFkZGluZyR7bmUobi5wYWRkaW5nKX1gXSxuLmFsaWduIT09ImluaGVyaXQiJiZ0W2BhbGlnbiR7bmUobi5hbGlnbil9YF0sbi5zdGlja3lIZWFkZXImJnQuc3RpY2t5SGVhZGVyXX19KSh5ZSgoe3RoZW1lOmV9KT0+KHsuLi5lLnR5cG9ncmFwaHkuYm9keTIsZGlzcGxheToidGFibGUtY2VsbCIsdmVydGljYWxBbGlnbjoiaW5oZXJpdCIsYm9yZGVyQm90dG9tOmUudmFycz9gMXB4IHNvbGlkICR7ZS52YXJzLnBhbGV0dGUuVGFibGVDZWxsLmJvcmRlcn1gOmAxcHggc29saWQKICAgICR7ZS5wYWxldHRlLm1vZGU9PT0ibGlnaHQiP1VsKGZ0KGUucGFsZXR0ZS5kaXZpZGVyLDEpLC44OCk6V2woZnQoZS5wYWxldHRlLmRpdmlkZXIsMSksLjY4KX1gLHRleHRBbGlnbjoibGVmdCIscGFkZGluZzoxNix2YXJpYW50czpbe3Byb3BzOnt2YXJpYW50OiJoZWFkIn0sc3R5bGU6e2NvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUudGV4dC5wcmltYXJ5LGxpbmVIZWlnaHQ6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjQpLGZvbnRXZWlnaHQ6ZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW19fSx7cHJvcHM6e3ZhcmlhbnQ6ImJvZHkifSxzdHlsZTp7Y29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS50ZXh0LnByaW1hcnl9fSx7cHJvcHM6e3ZhcmlhbnQ6ImZvb3RlciJ9LHN0eWxlOntjb2xvcjooZS52YXJzfHxlKS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5LGxpbmVIZWlnaHQ6ZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjEpLGZvbnRTaXplOmUudHlwb2dyYXBoeS5weFRvUmVtKDEyKX19LHtwcm9wczp7c2l6ZToic21hbGwifSxzdHlsZTp7cGFkZGluZzoiNnB4IDE2cHgiLFtgJi4ke0ZQLnBhZGRpbmdDaGVja2JveH1gXTp7d2lkdGg6MjQscGFkZGluZzoiMCAxMnB4IDAgMTZweCIsIiYgPiAqIjp7cGFkZGluZzowfX19fSx7cHJvcHM6e3BhZGRpbmc6ImNoZWNrYm94In0sc3R5bGU6e3dpZHRoOjQ4LHBhZGRpbmc6IjAgMCAwIDRweCJ9fSx7cHJvcHM6e3BhZGRpbmc6Im5vbmUifSxzdHlsZTp7cGFkZGluZzowfX0se3Byb3BzOnthbGlnbjoibGVmdCJ9LHN0eWxlOnt0ZXh0QWxpZ246ImxlZnQifX0se3Byb3BzOnthbGlnbjoiY2VudGVyIn0sc3R5bGU6e3RleHRBbGlnbjoiY2VudGVyIn19LHtwcm9wczp7YWxpZ246InJpZ2h0In0sc3R5bGU6e3RleHRBbGlnbjoicmlnaHQiLGZsZXhEaXJlY3Rpb246InJvdy1yZXZlcnNlIn19LHtwcm9wczp7YWxpZ246Imp1c3RpZnkifSxzdHlsZTp7dGV4dEFsaWduOiJqdXN0aWZ5In19LHtwcm9wczooe293bmVyU3RhdGU6dH0pPT50LnN0aWNreUhlYWRlcixzdHlsZTp7cG9zaXRpb246InN0aWNreSIsdG9wOjAsekluZGV4OjIsYmFja2dyb3VuZENvbG9yOihlLnZhcnN8fGUpLnBhbGV0dGUuYmFja2dyb3VuZC5kZWZhdWx0fX1dfSkpKSxlcj1DLmZvcndhcmRSZWYoZnVuY3Rpb24odCxuKXtjb25zdCByPW1lKHtwcm9wczp0LG5hbWU6Ik11aVRhYmxlQ2VsbCJ9KSx7YWxpZ246bz0iaW5oZXJpdCIsY2xhc3NOYW1lOmksY29tcG9uZW50OnMscGFkZGluZzphLHNjb3BlOmwsc2l6ZTp1LHNvcnREaXJlY3Rpb246Yyx2YXJpYW50OmQsLi4ubX09cix2PUMudXNlQ29udGV4dChJMCksdz1DLnVzZUNvbnRleHQoZnUpLFM9dyYmdy52YXJpYW50PT09ImhlYWQiO2xldCB4O3M/eD1zOng9Uz8idGgiOiJ0ZCI7bGV0IGg9bDt4PT09InRkIj9oPXZvaWQgMDohaCYmUyYmKGg9ImNvbCIpO2NvbnN0IGc9ZHx8dyYmdy52YXJpYW50LGY9ey4uLnIsYWxpZ246byxjb21wb25lbnQ6eCxwYWRkaW5nOmF8fCh2JiZ2LnBhZGRpbmc/di5wYWRkaW5nOiJub3JtYWwiKSxzaXplOnV8fCh2JiZ2LnNpemU/di5zaXplOiJtZWRpdW0iKSxzb3J0RGlyZWN0aW9uOmMsc3RpY2t5SGVhZGVyOmc9PT0iaGVhZCImJnYmJnYuc3RpY2t5SGVhZGVyLHZhcmlhbnQ6Z30seT1CUChmKTtsZXQgYj1udWxsO3JldHVybiBjJiYoYj1jPT09ImFzYyI/ImFzY2VuZGluZyI6ImRlc2NlbmRpbmciKSxrLmpzeChXUCx7YXM6eCxyZWY6bixjbGFzc05hbWU6dGUoeS5yb290LGkpLCJhcmlhLXNvcnQiOmIsc2NvcGU6aCxvd25lclN0YXRlOmYsLi4ubX0pfSk7ZnVuY3Rpb24gVVAoZSl7cmV0dXJuIGNlKCJNdWlUYWJsZUNvbnRhaW5lciIsZSl9ZGUoIk11aVRhYmxlQ29udGFpbmVyIixbInJvb3QiXSk7Y29uc3QgSFA9ZT0+e2NvbnN0e2NsYXNzZXM6dH09ZTtyZXR1cm4gcGUoe3Jvb3Q6WyJyb290Il19LFVQLHQpfSxWUD1HKCJkaXYiLHtuYW1lOiJNdWlUYWJsZUNvbnRhaW5lciIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9PnQucm9vdH0pKHt3aWR0aDoiMTAwJSIsb3ZlcmZsb3dYOiJhdXRvIn0pLEtQPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpVGFibGVDb250YWluZXIifSkse2NsYXNzTmFtZTpvLGNvbXBvbmVudDppPSJkaXYiLC4uLnN9PXIsYT17Li4ucixjb21wb25lbnQ6aX0sbD1IUChhKTtyZXR1cm4gay5qc3goVlAse3JlZjpuLGFzOmksY2xhc3NOYW1lOnRlKGwucm9vdCxvKSxvd25lclN0YXRlOmEsLi4uc30pfSk7ZnVuY3Rpb24gWVAoZSl7cmV0dXJuIGNlKCJNdWlUYWJsZUhlYWQiLGUpfWRlKCJNdWlUYWJsZUhlYWQiLFsicm9vdCJdKTtjb25zdCBHUD1lPT57Y29uc3R7Y2xhc3Nlczp0fT1lO3JldHVybiBwZSh7cm9vdDpbInJvb3QiXX0sWVAsdCl9LFFQPUcoInRoZWFkIix7bmFtZToiTXVpVGFibGVIZWFkIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+dC5yb290fSkoe2Rpc3BsYXk6InRhYmxlLWhlYWRlci1ncm91cCJ9KSxYUD17dmFyaWFudDoiaGVhZCJ9LERoPSJ0aGVhZCIscVA9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlUYWJsZUhlYWQifSkse2NsYXNzTmFtZTpvLGNvbXBvbmVudDppPURoLC4uLnN9PXIsYT17Li4ucixjb21wb25lbnQ6aX0sbD1HUChhKTtyZXR1cm4gay5qc3goZnUuUHJvdmlkZXIse3ZhbHVlOlhQLGNoaWxkcmVuOmsuanN4KFFQLHthczppLGNsYXNzTmFtZTp0ZShsLnJvb3QsbykscmVmOm4scm9sZTppPT09RGg/bnVsbDoicm93Z3JvdXAiLG93bmVyU3RhdGU6YSwuLi5zfSl9KX0pO2Z1bmN0aW9uIFpQKGUpe3JldHVybiBjZSgiTXVpVGFibGVSb3ciLGUpfWNvbnN0IEZoPWRlKCJNdWlUYWJsZVJvdyIsWyJyb290Iiwic2VsZWN0ZWQiLCJob3ZlciIsImhlYWQiLCJmb290ZXIiXSksSlA9ZT0+e2NvbnN0e2NsYXNzZXM6dCxzZWxlY3RlZDpuLGhvdmVyOnIsaGVhZDpvLGZvb3RlcjppfT1lO3JldHVybiBwZSh7cm9vdDpbInJvb3QiLG4mJiJzZWxlY3RlZCIsciYmImhvdmVyIixvJiYiaGVhZCIsaSYmImZvb3RlciJdfSxaUCx0KX0sZSQ9RygidHIiLHtuYW1lOiJNdWlUYWJsZVJvdyIsc2xvdDoiUm9vdCIsb3ZlcnJpZGVzUmVzb2x2ZXI6KGUsdCk9Pntjb25zdHtvd25lclN0YXRlOm59PWU7cmV0dXJuW3Qucm9vdCxuLmhlYWQmJnQuaGVhZCxuLmZvb3RlciYmdC5mb290ZXJdfX0pKHllKCh7dGhlbWU6ZX0pPT4oe2NvbG9yOiJpbmhlcml0IixkaXNwbGF5OiJ0YWJsZS1yb3ciLHZlcnRpY2FsQWxpZ246Im1pZGRsZSIsb3V0bGluZTowLFtgJi4ke0ZoLmhvdmVyfTpob3ZlcmBdOntiYWNrZ3JvdW5kQ29sb3I6KGUudmFyc3x8ZSkucGFsZXR0ZS5hY3Rpb24uaG92ZXJ9LFtgJi4ke0ZoLnNlbGVjdGVkfWBdOntiYWNrZ3JvdW5kQ29sb3I6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGUucHJpbWFyeS5tYWluQ2hhbm5lbH0gLyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHl9KWA6ZnQoZS5wYWxldHRlLnByaW1hcnkubWFpbixlLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eSksIiY6aG92ZXIiOntiYWNrZ3JvdW5kQ29sb3I6ZS52YXJzP2ByZ2JhKCR7ZS52YXJzLnBhbGV0dGUucHJpbWFyeS5tYWluQ2hhbm5lbH0gLyBjYWxjKCR7ZS52YXJzLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkT3BhY2l0eX0gKyAke2UudmFycy5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHl9KSlgOmZ0KGUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZE9wYWNpdHkrZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpfX19KSkpLEJoPSJ0ciIsY3A9Qy5mb3J3YXJkUmVmKGZ1bmN0aW9uKHQsbil7Y29uc3Qgcj1tZSh7cHJvcHM6dCxuYW1lOiJNdWlUYWJsZVJvdyJ9KSx7Y2xhc3NOYW1lOm8sY29tcG9uZW50Omk9QmgsaG92ZXI6cz0hMSxzZWxlY3RlZDphPSExLC4uLmx9PXIsdT1DLnVzZUNvbnRleHQoZnUpLGM9ey4uLnIsY29tcG9uZW50OmksaG92ZXI6cyxzZWxlY3RlZDphLGhlYWQ6dSYmdS52YXJpYW50PT09ImhlYWQiLGZvb3Rlcjp1JiZ1LnZhcmlhbnQ9PT0iZm9vdGVyIn0sZD1KUChjKTtyZXR1cm4gay5qc3goZSQse2FzOmkscmVmOm4sY2xhc3NOYW1lOnRlKGQucm9vdCxvKSxyb2xlOmk9PT1CaD9udWxsOiJyb3ciLG93bmVyU3RhdGU6YywuLi5sfSl9KTtmdW5jdGlvbiB0JChlKXtyZXR1cm4gY2UoIk11aVRleHRGaWVsZCIsZSl9ZGUoIk11aVRleHRGaWVsZCIsWyJyb290Il0pO2NvbnN0IG4kPXtzdGFuZGFyZDpubCxmaWxsZWQ6dGwsb3V0bGluZWQ6cmx9LHIkPWU9Pntjb25zdHtjbGFzc2VzOnR9PWU7cmV0dXJuIHBlKHtyb290Olsicm9vdCJdfSx0JCx0KX0sbyQ9Ryh3VCx7bmFtZToiTXVpVGV4dEZpZWxkIixzbG90OiJSb290IixvdmVycmlkZXNSZXNvbHZlcjooZSx0KT0+dC5yb290fSkoe30pLG1uPUMuZm9yd2FyZFJlZihmdW5jdGlvbih0LG4pe2NvbnN0IHI9bWUoe3Byb3BzOnQsbmFtZToiTXVpVGV4dEZpZWxkIn0pLHthdXRvQ29tcGxldGU6byxhdXRvRm9jdXM6aT0hMSxjaGlsZHJlbjpzLGNsYXNzTmFtZTphLGNvbG9yOmw9InByaW1hcnkiLGRlZmF1bHRWYWx1ZTp1LGRpc2FibGVkOmM9ITEsZXJyb3I6ZD0hMSxGb3JtSGVscGVyVGV4dFByb3BzOm0sZnVsbFdpZHRoOnY9ITEsaGVscGVyVGV4dDp3LGlkOlMsSW5wdXRMYWJlbFByb3BzOngsaW5wdXRQcm9wczpoLElucHV0UHJvcHM6ZyxpbnB1dFJlZjpmLGxhYmVsOnksbWF4Um93czpiLG1pblJvd3M6RSxtdWx0aWxpbmU6Uj0hMSxuYW1lOlAsb25CbHVyOkksb25DaGFuZ2U6cCxvbkZvY3VzOiQscGxhY2Vob2xkZXI6TCxyZXF1aXJlZDpqPSExLHJvd3M6TixzZWxlY3Q6Tz0hMSxTZWxlY3RQcm9wczpNLHNsb3RzOl89e30sc2xvdFByb3BzOlQ9e30sdHlwZTpBLHZhbHVlOkQsdmFyaWFudDpCPSJvdXRsaW5lZCIsLi4uSH09cixWPXsuLi5yLGF1dG9Gb2N1czppLGNvbG9yOmwsZGlzYWJsZWQ6YyxlcnJvcjpkLGZ1bGxXaWR0aDp2LG11bHRpbGluZTpSLHJlcXVpcmVkOmosc2VsZWN0Ok8sdmFyaWFudDpCfSxVPXIkKFYpLFg9WGQoUyksVz13JiZYP2Ake1h9LWhlbHBlci10ZXh0YDp2b2lkIDAsSj15JiZYP2Ake1h9LWxhYmVsYDp2b2lkIDAsb2U9biRbQl0scmU9e3Nsb3RzOl8sc2xvdFByb3BzOntpbnB1dDpnLGlucHV0TGFiZWw6eCxodG1sSW5wdXQ6aCxmb3JtSGVscGVyVGV4dDptLHNlbGVjdDpNLC4uLlR9fSxRPXt9LGVlPXJlLnNsb3RQcm9wcy5pbnB1dExhYmVsO0I9PT0ib3V0bGluZWQiJiYoZWUmJnR5cGVvZiBlZS5zaHJpbms8InUiJiYoUS5ub3RjaGVkPWVlLnNocmluayksUS5sYWJlbD15KSxPJiYoKCFNfHwhTS5uYXRpdmUpJiYoUS5pZD12b2lkIDApLFFbImFyaWEtZGVzY3JpYmVkYnkiXT12b2lkIDApO2NvbnN0W1ksdWVdPU50KCJpbnB1dCIse2VsZW1lbnRUeXBlOm9lLGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6cmUsYWRkaXRpb25hbFByb3BzOlEsb3duZXJTdGF0ZTpWfSksW2llLGZlXT1OdCgiaW5wdXRMYWJlbCIse2VsZW1lbnRUeXBlOnpULGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6cmUsb3duZXJTdGF0ZTpWfSksW1plLFZlXT1OdCgiaHRtbElucHV0Iix7ZWxlbWVudFR5cGU6ImlucHV0IixleHRlcm5hbEZvcndhcmRlZFByb3BzOnJlLG93bmVyU3RhdGU6Vn0pLFtPZSxOZV09TnQoImZvcm1IZWxwZXJUZXh0Iix7ZWxlbWVudFR5cGU6YlQsZXh0ZXJuYWxGb3J3YXJkZWRQcm9wczpyZSxvd25lclN0YXRlOlZ9KSxbV2UsaGVdPU50KCJzZWxlY3QiLHtlbGVtZW50VHlwZTpOMCxleHRlcm5hbEZvcndhcmRlZFByb3BzOnJlLG93bmVyU3RhdGU6Vn0pLGh0PWsuanN4KFkseyJhcmlhLWRlc2NyaWJlZGJ5IjpXLGF1dG9Db21wbGV0ZTpvLGF1dG9Gb2N1czppLGRlZmF1bHRWYWx1ZTp1LGZ1bGxXaWR0aDp2LG11bHRpbGluZTpSLG5hbWU6UCxyb3dzOk4sbWF4Um93czpiLG1pblJvd3M6RSx0eXBlOkEsdmFsdWU6RCxpZDpYLGlucHV0UmVmOmYsb25CbHVyOkksb25DaGFuZ2U6cCxvbkZvY3VzOiQscGxhY2Vob2xkZXI6TCxpbnB1dFByb3BzOlZlLHNsb3RzOntpbnB1dDpfLmh0bWxJbnB1dD9aZTp2b2lkIDB9LC4uLnVlfSk7cmV0dXJuIGsuanN4cyhvJCx7Y2xhc3NOYW1lOnRlKFUucm9vdCxhKSxkaXNhYmxlZDpjLGVycm9yOmQsZnVsbFdpZHRoOnYscmVmOm4scmVxdWlyZWQ6aixjb2xvcjpsLHZhcmlhbnQ6Qixvd25lclN0YXRlOlYsLi4uSCxjaGlsZHJlbjpbeSE9bnVsbCYmeSE9PSIiJiZrLmpzeChpZSx7aHRtbEZvcjpYLGlkOkosLi4uZmUsY2hpbGRyZW46eX0pLE8/ay5qc3goV2UseyJhcmlhLWRlc2NyaWJlZGJ5IjpXLGlkOlgsbGFiZWxJZDpKLHZhbHVlOkQsaW5wdXQ6aHQsLi4uaGUsY2hpbGRyZW46c30pOmh0LHcmJmsuanN4KE9lLHtpZDpXLC4uLk5lLGNoaWxkcmVuOnd9KV19KX0pLHB1PVZ0KGsuanN4KCJwYXRoIix7ZDoiTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ6In0pLCJBZGQiKSxpJD1WdChrLmpzeCgicGF0aCIse2Q6Ik0xNi41OSA3LjU4IDEwIDE0LjE3bC0zLjU5LTMuNThMNSAxMmw1IDUgOC04ek0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAybTAgMThjLTQuNDIgMC04LTMuNTgtOC04czMuNTgtOCA4LTggOCAzLjU4IDggOC0zLjU4IDgtOCA4In0pLCJDaGVja0NpcmNsZU91dGxpbmUiKSxzJD1WdChrLmpzeCgicGF0aCIse2Q6Ik0xOSA2LjQxIDE3LjU5IDUgMTIgMTAuNTkgNi40MSA1IDUgNi40MSAxMC41OSAxMiA1IDE3LjU5IDYuNDEgMTkgMTIgMTMuNDEgMTcuNTkgMTkgMTkgMTcuNTkgMTMuNDEgMTJ6In0pLCJDbGVhciIpLGRwPVZ0KGsuanN4KCJwYXRoIix7ZDoiTTYgMTljMCAxLjEuOSAyIDIgMmg4YzEuMSAwIDItLjkgMi0yVjdINnpNMTkgNGgtMy41bC0xLTFoLTVsLTEgMUg1djJoMTR6In0pLCJEZWxldGUiKSxhJD1WdChrLmpzeCgicGF0aCIse2Q6Ik0xMSAxNWgydjJoLTJ6bTAtOGgydjZoLTJ6bS45OS01QzYuNDcgMiAyIDYuNDggMiAxMnM0LjQ3IDEwIDkuOTkgMTBDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJTMTcuNTIgMiAxMS45OSAyTTEyIDIwYy00LjQyIDAtOC0zLjU4LTgtOHMzLjU4LTggOC04IDggMy41OCA4IDgtMy41OCA4LTggOCJ9KSwiRXJyb3JPdXRsaW5lIiksQTA9VnQoay5qc3goInBhdGgiLHtkOiJNMTYuNTkgOC41OSAxMiAxMy4xNyA3LjQxIDguNTkgNiAxMGw2IDYgNi02eiJ9KSwiRXhwYW5kTW9yZSIpLGwkPVZ0KGsuanN4KCJwYXRoIix7ZDoiTTE5IDloLTRWM0g5djZINWw3IDd6TTUgMTh2MmgxNHYtMnoifSksIkdldEFwcCIpLHUkPVZ0KGsuanN4KCJwYXRoIix7ZDoiTTMuOSAxMmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMWg0VjdIN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNWg0di0xLjlIN2MtMS43MSAwLTMuMS0xLjM5LTMuMS0zLjFNOCAxM2g4di0ySDh6bTktNmgtNHYxLjloNGMxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXMtMS4zOSAzLjEtMy4xIDMuMWgtNFYxN2g0YzIuNzYgMCA1LTIuMjQgNS01cy0yLjI0LTUtNS01In0pLCJMaW5rIiksYyQ9VnQoay5qc3goInBhdGgiLHtkOiJNMTcuNjUgNi4zNUMxNi4yIDQuOSAxNC4yMSA0IDEyIDRjLTQuNDIgMC03Ljk5IDMuNTgtNy45OSA4czMuNTcgOCA3Ljk5IDhjMy43MyAwIDYuODQtMi41NSA3LjczLTZoLTIuMDhjLS44MiAyLjMzLTMuMDQgNC01LjY1IDQtMy4zMSAwLTYtMi42OS02LTZzMi42OS02IDYtNmMxLjY2IDAgMy4xNC42OSA0LjIyIDEuNzhMMTMgMTFoN1Y0eiJ9KSwiUmVmcmVzaCIpLGQkPVZ0KGsuanN4KCJwYXRoIix7ZDoiTTE5IDEzSDV2LTJoMTR6In0pLCJSZW1vdmUiKSxmJD1WdChrLmpzeCgicGF0aCIse2Q6Ik0yLjAxIDIxIDIzIDEyIDIuMDEgMyAyIDEwbDE1IDItMTUgMnoifSksIlNlbmQiKSxwJD1WdChrLmpzeCgicGF0aCIse2Q6Ik02IDZoMTJ2MTJINnoifSksIlN0b3AiKTthc3luYyBmdW5jdGlvbiB5ZChlKXtyZXR1cm4gYXdhaXQgZmV0Y2goIi9hcGkvbXlMYXN0SXNzdWVzIix7bWV0aG9kOiJQT1NUIixib2R5OkpTT04uc3RyaW5naWZ5KGUpfSkudGhlbihhc3luYyB0PT4oYXdhaXQgdC5qc29uKCkpLmlzc3Vlc3x8W10pLmNhdGNoKCgpPT5bXSl9ZnVuY3Rpb24gejAoZSx0KXtjb25zdCBuPXt9O3JldHVybiBlLmZsYXRNYXAocj0+e3ZhciBvLGk7cmV0dXJuKChpPShvPXIuZmllbGRzKT09bnVsbD92b2lkIDA6by53b3JrbG9nKT09bnVsbD92b2lkIDA6aS53b3JrbG9ncyl8fFtdfSkuZmlsdGVyKHI9PnIuYXV0aG9yLmtleT09PXQpLm1hcCgoe3N0YXJ0ZWQ6cix0aW1lU3BlbnRTZWNvbmRzOm99KT0+KHtkYXRlOnIuc3Vic3RyKDAsMTApLHRpbWVTcGVudFNlY29uZHM6b30pKS5mb3JFYWNoKCh7ZGF0ZTpyLHRpbWVTcGVudFNlY29uZHM6b30pPT5uW3JdPW8rKG5bcl18fDApKSxufWNvbnN0IG0kPSh7ZGF0YTplLGNvbmZpZzp0LGlzc3VlQ2xpY2tlZDpuLHNldFdvcmtzTG9nZ2VkOnJ9KT0+e2NvbnN0W28saV09Qy51c2VTdGF0ZShbXSk7Qy51c2VFZmZlY3QoKCk9Pntjb25zdCB1PXNldFRpbWVvdXQoKCk9PnlkKHQpLnRoZW4oYz0+aShjKSksMWUzKTtyZXR1cm4oKT0+Y2xlYXJUaW1lb3V0KHUpfSxbdF0pLEMudXNlRWZmZWN0KCgpPT57cih7d29ya3NMb2dnZWQ6ejAobyx0LnVzZXJuYW1lKX0pfSxbdCxyLG9dKTtjb25zdFtzLGFdPUMudXNlU3RhdGUoInBhbmVsMSIpLGw9dT0+KGMsZCk9PmEoZD91OiExKTtyZXR1cm4gay5qc3hzKHAwLHtleHBhbmRlZDpzPT09InBhbmVsMSIsZWxldmF0aW9uOjMsb25DaGFuZ2U6bCgicGFuZWwxIiksY2hpbGRyZW46W2suanN4KGgwLHsiYXJpYS1jb250cm9scyI6InBhbmVsMWQtY29udGVudCIsaWQ6InBhbmVsMWQtaGVhZGVyIixleHBhbmRJY29uOmsuanN4KEEwLHt9KSxjaGlsZHJlbjprLmpzeChnMCx7dmFyaWFudDoiaDUiLGd1dHRlckJvdHRvbTohMCxjaGlsZHJlbjoiQWRkIGlzc3VlcyJ9KX0pLGsuanN4cyhtMCx7Y2hpbGRyZW46W2suanN4KCJkaXYiLHtzdHlsZTp7ZGlzcGxheToiZmxleCIsZmxleERpcmVjdGlvbjoicm93LXJldmVyc2UifSxjaGlsZHJlbjprLmpzeCh6dCx7dmFyaWFudDoiY29udGFpbmVkIixvbkNsaWNrOmFzeW5jKCk9PmkoYXdhaXQgeWQodCkpLGNoaWxkcmVuOmsuanN4KGMkLHt9KX0pfSksay5qc3goImRpdiIse2NsYXNzTmFtZToibGFzdC1pc3N1ZXMiLGNoaWxkcmVuOm8uZmlsdGVyKHU9PiFlLmlzc3Vlcy5tYXAoYz0+Yy5rZXkpLmluY2x1ZGVzKHUua2V5KSkubWFwKHU9Pnt2YXIgYztyZXR1cm4gay5qc3goImRpdiIse2NoaWxkcmVuOmsuanN4cyh6dCx7dmFyaWFudDoiY29udGFpbmVkIixjb2xvcjoicHJpbWFyeSIsY2xhc3NOYW1lOiJpc3N1ZS1idG4iLG9uQ2xpY2s6KCk9Pm4oe2lzc3VlOnV9KSxjaGlsZHJlbjpbdS5rZXksIiAtICIsKGM9dS5maWVsZHMpPT1udWxsP3ZvaWQgMDpjLnN1bW1hcnldfSl9LHUua2V5KX0pfSldfSldfSl9O2Z1bmN0aW9uIG50KGUpe3JldHVybmBNaW5pZmllZCBSZWR1eCBlcnJvciAjJHtlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgfXZhciBoJD10eXBlb2YgU3ltYm9sPT0iZnVuY3Rpb24iJiZTeW1ib2wub2JzZXJ2YWJsZXx8IkBAb2JzZXJ2YWJsZSIsV2g9aCQsdGM9KCk9Pk1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgiIikuam9pbigiLiIpLGckPXtJTklUOmBAQHJlZHV4L0lOSVQke3RjKCl9YCxSRVBMQUNFOmBAQHJlZHV4L1JFUExBQ0Uke3RjKCl9YCxQUk9CRV9VTktOT1dOX0FDVElPTjooKT0+YEBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT04ke3RjKCl9YH0sb2w9ZyQ7ZnVuY3Rpb24gZnAoZSl7aWYodHlwZW9mIGUhPSJvYmplY3QifHxlPT09bnVsbClyZXR1cm4hMTtsZXQgdD1lO2Zvcig7T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpIT09bnVsbDspdD1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7cmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlKT09PXR8fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKT09PW51bGx9ZnVuY3Rpb24gTDAoZSx0LG4pe2lmKHR5cGVvZiBlIT0iZnVuY3Rpb24iKXRocm93IG5ldyBFcnJvcihudCgyKSk7aWYodHlwZW9mIHQ9PSJmdW5jdGlvbiImJnR5cGVvZiBuPT0iZnVuY3Rpb24ifHx0eXBlb2Ygbj09ImZ1bmN0aW9uIiYmdHlwZW9mIGFyZ3VtZW50c1szXT09ImZ1bmN0aW9uIil0aHJvdyBuZXcgRXJyb3IobnQoMCkpO2lmKHR5cGVvZiB0PT0iZnVuY3Rpb24iJiZ0eXBlb2Ygbj4idSImJihuPXQsdD12b2lkIDApLHR5cGVvZiBuPCJ1Iil7aWYodHlwZW9mIG4hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IEVycm9yKG50KDEpKTtyZXR1cm4gbihMMCkoZSx0KX1sZXQgcj1lLG89dCxpPW5ldyBNYXAscz1pLGE9MCxsPSExO2Z1bmN0aW9uIHUoKXtzPT09aSYmKHM9bmV3IE1hcCxpLmZvckVhY2goKHgsaCk9PntzLnNldChoLHgpfSkpfWZ1bmN0aW9uIGMoKXtpZihsKXRocm93IG5ldyBFcnJvcihudCgzKSk7cmV0dXJuIG99ZnVuY3Rpb24gZCh4KXtpZih0eXBlb2YgeCE9ImZ1bmN0aW9uIil0aHJvdyBuZXcgRXJyb3IobnQoNCkpO2lmKGwpdGhyb3cgbmV3IEVycm9yKG50KDUpKTtsZXQgaD0hMDt1KCk7Y29uc3QgZz1hKys7cmV0dXJuIHMuc2V0KGcseCksZnVuY3Rpb24oKXtpZihoKXtpZihsKXRocm93IG5ldyBFcnJvcihudCg2KSk7aD0hMSx1KCkscy5kZWxldGUoZyksaT1udWxsfX19ZnVuY3Rpb24gbSh4KXtpZighZnAoeCkpdGhyb3cgbmV3IEVycm9yKG50KDcpKTtpZih0eXBlb2YgeC50eXBlPiJ1Iil0aHJvdyBuZXcgRXJyb3IobnQoOCkpO2lmKHR5cGVvZiB4LnR5cGUhPSJzdHJpbmciKXRocm93IG5ldyBFcnJvcihudCgxNykpO2lmKGwpdGhyb3cgbmV3IEVycm9yKG50KDkpKTt0cnl7bD0hMCxvPXIobyx4KX1maW5hbGx5e2w9ITF9cmV0dXJuKGk9cykuZm9yRWFjaChnPT57ZygpfSkseH1mdW5jdGlvbiB2KHgpe2lmKHR5cGVvZiB4IT0iZnVuY3Rpb24iKXRocm93IG5ldyBFcnJvcihudCgxMCkpO3I9eCxtKHt0eXBlOm9sLlJFUExBQ0V9KX1mdW5jdGlvbiB3KCl7Y29uc3QgeD1kO3JldHVybntzdWJzY3JpYmUoaCl7aWYodHlwZW9mIGghPSJvYmplY3QifHxoPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IobnQoMTEpKTtmdW5jdGlvbiBnKCl7Y29uc3QgeT1oO3kubmV4dCYmeS5uZXh0KGMoKSl9cmV0dXJuIGcoKSx7dW5zdWJzY3JpYmU6eChnKX19LFtXaF0oKXtyZXR1cm4gdGhpc319fXJldHVybiBtKHt0eXBlOm9sLklOSVR9KSx7ZGlzcGF0Y2g6bSxzdWJzY3JpYmU6ZCxnZXRTdGF0ZTpjLHJlcGxhY2VSZWR1Y2VyOnYsW1doXTp3fX1mdW5jdGlvbiB5JChlKXtPYmplY3Qua2V5cyhlKS5mb3JFYWNoKHQ9Pntjb25zdCBuPWVbdF07aWYodHlwZW9mIG4odm9pZCAwLHt0eXBlOm9sLklOSVR9KT4idSIpdGhyb3cgbmV3IEVycm9yKG50KDEyKSk7aWYodHlwZW9mIG4odm9pZCAwLHt0eXBlOm9sLlBST0JFX1VOS05PV05fQUNUSU9OKCl9KT4idSIpdGhyb3cgbmV3IEVycm9yKG50KDEzKSl9KX1mdW5jdGlvbiB2JChlKXtjb25zdCB0PU9iamVjdC5rZXlzKGUpLG49e307Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2NvbnN0IHM9dFtpXTt0eXBlb2YgZVtzXT09ImZ1bmN0aW9uIiYmKG5bc109ZVtzXSl9Y29uc3Qgcj1PYmplY3Qua2V5cyhuKTtsZXQgbzt0cnl7eSQobil9Y2F0Y2goaSl7bz1pfXJldHVybiBmdW5jdGlvbihzPXt9LGEpe2lmKG8pdGhyb3cgbztsZXQgbD0hMTtjb25zdCB1PXt9O2ZvcihsZXQgYz0wO2M8ci5sZW5ndGg7YysrKXtjb25zdCBkPXJbY10sbT1uW2RdLHY9c1tkXSx3PW0odixhKTtpZih0eXBlb2Ygdz4idSIpdGhyb3cgYSYmYS50eXBlLG5ldyBFcnJvcihudCgxNCkpO3VbZF09dyxsPWx8fHchPT12fXJldHVybiBsPWx8fHIubGVuZ3RoIT09T2JqZWN0LmtleXMocykubGVuZ3RoLGw/dTpzfX1mdW5jdGlvbiBpbCguLi5lKXtyZXR1cm4gZS5sZW5ndGg9PT0wP3Q9PnQ6ZS5sZW5ndGg9PT0xP2VbMF06ZS5yZWR1Y2UoKHQsbik9PiguLi5yKT0+dChuKC4uLnIpKSl9ZnVuY3Rpb24gdyQoLi4uZSl7cmV0dXJuIHQ9PihuLHIpPT57Y29uc3Qgbz10KG4scik7bGV0IGk9KCk9Pnt0aHJvdyBuZXcgRXJyb3IobnQoMTUpKX07Y29uc3Qgcz17Z2V0U3RhdGU6by5nZXRTdGF0ZSxkaXNwYXRjaDoobCwuLi51KT0+aShsLC4uLnUpfSxhPWUubWFwKGw9PmwocykpO3JldHVybiBpPWlsKC4uLmEpKG8uZGlzcGF0Y2gpLHsuLi5vLGRpc3BhdGNoOml9fX1mdW5jdGlvbiBTJChlKXtyZXR1cm4gZnAoZSkmJiJ0eXBlImluIGUmJnR5cGVvZiBlLnR5cGU9PSJzdHJpbmcifXZhciBqMD1TeW1ib2wuZm9yKCJpbW1lci1ub3RoaW5nIiksVWg9U3ltYm9sLmZvcigiaW1tZXItZHJhZnRhYmxlIiksV3Q9U3ltYm9sLmZvcigiaW1tZXItc3RhdGUiKTtmdW5jdGlvbiBnbihlLC4uLnQpe3Rocm93IG5ldyBFcnJvcihgW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogJHtlfS4gRnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmApfXZhciBLbz1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7ZnVuY3Rpb24gUXIoZSl7cmV0dXJuISFlJiYhIWVbV3RdfWZ1bmN0aW9uIHRyKGUpe3ZhciB0O3JldHVybiBlP0QwKGUpfHxBcnJheS5pc0FycmF5KGUpfHwhIWVbVWhdfHwhISgodD1lLmNvbnN0cnVjdG9yKSE9bnVsbCYmdFtVaF0pfHxodShlKXx8Z3UoZSk6ITF9dmFyIHgkPU9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtmdW5jdGlvbiBEMChlKXtpZighZXx8dHlwZW9mIGUhPSJvYmplY3QiKXJldHVybiExO2NvbnN0IHQ9S28oZSk7aWYodD09PW51bGwpcmV0dXJuITA7Y29uc3Qgbj1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LCJjb25zdHJ1Y3RvciIpJiZ0LmNvbnN0cnVjdG9yO3JldHVybiBuPT09T2JqZWN0PyEwOnR5cGVvZiBuPT0iZnVuY3Rpb24iJiZGdW5jdGlvbi50b1N0cmluZy5jYWxsKG4pPT09eCR9ZnVuY3Rpb24gc2woZSx0KXttdShlKT09PTA/UmVmbGVjdC5vd25LZXlzKGUpLmZvckVhY2gobj0+e3QobixlW25dLGUpfSk6ZS5mb3JFYWNoKChuLHIpPT50KHIsbixlKSl9ZnVuY3Rpb24gbXUoZSl7Y29uc3QgdD1lW1d0XTtyZXR1cm4gdD90LnR5cGVfOkFycmF5LmlzQXJyYXkoZSk/MTpodShlKT8yOmd1KGUpPzM6MH1mdW5jdGlvbiB2ZChlLHQpe3JldHVybiBtdShlKT09PTI/ZS5oYXModCk6T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9ZnVuY3Rpb24gRjAoZSx0LG4pe2NvbnN0IHI9bXUoZSk7cj09PTI/ZS5zZXQodCxuKTpyPT09Mz9lLmFkZChuKTplW3RdPW59ZnVuY3Rpb24gQyQoZSx0KXtyZXR1cm4gZT09PXQ/ZSE9PTB8fDEvZT09PTEvdDplIT09ZSYmdCE9PXR9ZnVuY3Rpb24gaHUoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBNYXB9ZnVuY3Rpb24gZ3UoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gSXIoZSl7cmV0dXJuIGUuY29weV98fGUuYmFzZV99ZnVuY3Rpb24gd2QoZSx0KXtpZihodShlKSlyZXR1cm4gbmV3IE1hcChlKTtpZihndShlKSlyZXR1cm4gbmV3IFNldChlKTtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKTtjb25zdCBuPUQwKGUpO2lmKHQ9PT0hMHx8dD09PSJjbGFzc19vbmx5IiYmIW4pe2NvbnN0IHI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoZSk7ZGVsZXRlIHJbV3RdO2xldCBvPVJlZmxlY3Qub3duS2V5cyhyKTtmb3IobGV0IGk9MDtpPG8ubGVuZ3RoO2krKyl7Y29uc3Qgcz1vW2ldLGE9cltzXTthLndyaXRhYmxlPT09ITEmJihhLndyaXRhYmxlPSEwLGEuY29uZmlndXJhYmxlPSEwKSwoYS5nZXR8fGEuc2V0KSYmKHJbc109e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOmEuZW51bWVyYWJsZSx2YWx1ZTplW3NdfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoS28oZSkscil9ZWxzZXtjb25zdCByPUtvKGUpO2lmKHIhPT1udWxsJiZuKXJldHVybnsuLi5lfTtjb25zdCBvPU9iamVjdC5jcmVhdGUocik7cmV0dXJuIE9iamVjdC5hc3NpZ24obyxlKX19ZnVuY3Rpb24gcHAoZSx0PSExKXtyZXR1cm4geXUoZSl8fFFyKGUpfHwhdHIoZSl8fChtdShlKT4xJiYoZS5zZXQ9ZS5hZGQ9ZS5jbGVhcj1lLmRlbGV0ZT1iJCksT2JqZWN0LmZyZWV6ZShlKSx0JiZPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbixyXSk9PnBwKHIsITApKSksZX1mdW5jdGlvbiBiJCgpe2duKDIpfWZ1bmN0aW9uIHl1KGUpe3JldHVybiBPYmplY3QuaXNGcm96ZW4oZSl9dmFyIGskPXt9O2Z1bmN0aW9uIFhyKGUpe2NvbnN0IHQ9ayRbZV07cmV0dXJuIHR8fGduKDAsZSksdH12YXIgZHM7ZnVuY3Rpb24gQjAoKXtyZXR1cm4gZHN9ZnVuY3Rpb24gRSQoZSx0KXtyZXR1cm57ZHJhZnRzXzpbXSxwYXJlbnRfOmUsaW1tZXJfOnQsY2FuQXV0b0ZyZWV6ZV86ITAsdW5maW5hbGl6ZWREcmFmdHNfOjB9fWZ1bmN0aW9uIEhoKGUsdCl7dCYmKFhyKCJQYXRjaGVzIiksZS5wYXRjaGVzXz1bXSxlLmludmVyc2VQYXRjaGVzXz1bXSxlLnBhdGNoTGlzdGVuZXJfPXQpfWZ1bmN0aW9uIFNkKGUpe3hkKGUpLGUuZHJhZnRzXy5mb3JFYWNoKFIkKSxlLmRyYWZ0c189bnVsbH1mdW5jdGlvbiB4ZChlKXtlPT09ZHMmJihkcz1lLnBhcmVudF8pfWZ1bmN0aW9uIFZoKGUpe3JldHVybiBkcz1FJChkcyxlKX1mdW5jdGlvbiBSJChlKXtjb25zdCB0PWVbV3RdO3QudHlwZV89PT0wfHx0LnR5cGVfPT09MT90LnJldm9rZV8oKTp0LnJldm9rZWRfPSEwfWZ1bmN0aW9uIEtoKGUsdCl7dC51bmZpbmFsaXplZERyYWZ0c189dC5kcmFmdHNfLmxlbmd0aDtjb25zdCBuPXQuZHJhZnRzX1swXTtyZXR1cm4gZSE9PXZvaWQgMCYmZSE9PW4/KG5bV3RdLm1vZGlmaWVkXyYmKFNkKHQpLGduKDQpKSx0cihlKSYmKGU9YWwodCxlKSx0LnBhcmVudF98fGxsKHQsZSkpLHQucGF0Y2hlc18mJlhyKCJQYXRjaGVzIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKG5bV3RdLmJhc2VfLGUsdC5wYXRjaGVzXyx0LmludmVyc2VQYXRjaGVzXykpOmU9YWwodCxuLFtdKSxTZCh0KSx0LnBhdGNoZXNfJiZ0LnBhdGNoTGlzdGVuZXJfKHQucGF0Y2hlc18sdC5pbnZlcnNlUGF0Y2hlc18pLGUhPT1qMD9lOnZvaWQgMH1mdW5jdGlvbiBhbChlLHQsbil7aWYoeXUodCkpcmV0dXJuIHQ7Y29uc3Qgcj10W1d0XTtpZighcilyZXR1cm4gc2wodCwobyxpKT0+WWgoZSxyLHQsbyxpLG4pKSx0O2lmKHIuc2NvcGVfIT09ZSlyZXR1cm4gdDtpZighci5tb2RpZmllZF8pcmV0dXJuIGxsKGUsci5iYXNlXywhMCksci5iYXNlXztpZighci5maW5hbGl6ZWRfKXtyLmZpbmFsaXplZF89ITAsci5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07Y29uc3Qgbz1yLmNvcHlfO2xldCBpPW8scz0hMTtyLnR5cGVfPT09MyYmKGk9bmV3IFNldChvKSxvLmNsZWFyKCkscz0hMCksc2woaSwoYSxsKT0+WWgoZSxyLG8sYSxsLG4scykpLGxsKGUsbywhMSksbiYmZS5wYXRjaGVzXyYmWHIoIlBhdGNoZXMiKS5nZW5lcmF0ZVBhdGNoZXNfKHIsbixlLnBhdGNoZXNfLGUuaW52ZXJzZVBhdGNoZXNfKX1yZXR1cm4gci5jb3B5X31mdW5jdGlvbiBZaChlLHQsbixyLG8saSxzKXtpZihRcihvKSl7Y29uc3QgYT1pJiZ0JiZ0LnR5cGVfIT09MyYmIXZkKHQuYXNzaWduZWRfLHIpP2kuY29uY2F0KHIpOnZvaWQgMCxsPWFsKGUsbyxhKTtpZihGMChuLHIsbCksUXIobCkpZS5jYW5BdXRvRnJlZXplXz0hMTtlbHNlIHJldHVybn1lbHNlIHMmJm4uYWRkKG8pO2lmKHRyKG8pJiYheXUobykpe2lmKCFlLmltbWVyXy5hdXRvRnJlZXplXyYmZS51bmZpbmFsaXplZERyYWZ0c188MSlyZXR1cm47YWwoZSxvKSwoIXR8fCF0LnNjb3BlXy5wYXJlbnRfKSYmdHlwZW9mIHIhPSJzeW1ib2wiJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobixyKSYmbGwoZSxvKX19ZnVuY3Rpb24gbGwoZSx0LG49ITEpeyFlLnBhcmVudF8mJmUuaW1tZXJfLmF1dG9GcmVlemVfJiZlLmNhbkF1dG9GcmVlemVfJiZwcCh0LG4pfWZ1bmN0aW9uIFQkKGUsdCl7Y29uc3Qgbj1BcnJheS5pc0FycmF5KGUpLHI9e3R5cGVfOm4/MTowLHNjb3BlXzp0P3Quc2NvcGVfOkIwKCksbW9kaWZpZWRfOiExLGZpbmFsaXplZF86ITEsYXNzaWduZWRfOnt9LHBhcmVudF86dCxiYXNlXzplLGRyYWZ0XzpudWxsLGNvcHlfOm51bGwscmV2b2tlXzpudWxsLGlzTWFudWFsXzohMX07bGV0IG89cixpPW1wO24mJihvPVtyXSxpPWZzKTtjb25zdHtyZXZva2U6cyxwcm94eTphfT1Qcm94eS5yZXZvY2FibGUobyxpKTtyZXR1cm4gci5kcmFmdF89YSxyLnJldm9rZV89cyxhfXZhciBtcD17Z2V0KGUsdCl7aWYodD09PVd0KXJldHVybiBlO2NvbnN0IG49SXIoZSk7aWYoIXZkKG4sdCkpcmV0dXJuIFAkKGUsbix0KTtjb25zdCByPW5bdF07cmV0dXJuIGUuZmluYWxpemVkX3x8IXRyKHIpP3I6cj09PW5jKGUuYmFzZV8sdCk/KHJjKGUpLGUuY29weV9bdF09YmQocixlKSk6cn0saGFzKGUsdCl7cmV0dXJuIHQgaW4gSXIoZSl9LG93bktleXMoZSl7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhJcihlKSl9LHNldChlLHQsbil7Y29uc3Qgcj1XMChJcihlKSx0KTtpZihyIT1udWxsJiZyLnNldClyZXR1cm4gci5zZXQuY2FsbChlLmRyYWZ0XyxuKSwhMDtpZighZS5tb2RpZmllZF8pe2NvbnN0IG89bmMoSXIoZSksdCksaT1vPT1udWxsP3ZvaWQgMDpvW1d0XTtpZihpJiZpLmJhc2VfPT09bilyZXR1cm4gZS5jb3B5X1t0XT1uLGUuYXNzaWduZWRfW3RdPSExLCEwO2lmKEMkKG4sbykmJihuIT09dm9pZCAwfHx2ZChlLmJhc2VfLHQpKSlyZXR1cm4hMDtyYyhlKSxDZChlKX1yZXR1cm4gZS5jb3B5X1t0XT09PW4mJihuIT09dm9pZCAwfHx0IGluIGUuY29weV8pfHxOdW1iZXIuaXNOYU4obikmJk51bWJlci5pc05hTihlLmNvcHlfW3RdKXx8KGUuY29weV9bdF09bixlLmFzc2lnbmVkX1t0XT0hMCksITB9LGRlbGV0ZVByb3BlcnR5KGUsdCl7cmV0dXJuIG5jKGUuYmFzZV8sdCkhPT12b2lkIDB8fHQgaW4gZS5iYXNlXz8oZS5hc3NpZ25lZF9bdF09ITEscmMoZSksQ2QoZSkpOmRlbGV0ZSBlLmFzc2lnbmVkX1t0XSxlLmNvcHlfJiZkZWxldGUgZS5jb3B5X1t0XSwhMH0sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCl7Y29uc3Qgbj1JcihlKSxyPVJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7cmV0dXJuIHImJnt3cml0YWJsZTohMCxjb25maWd1cmFibGU6ZS50eXBlXyE9PTF8fHQhPT0ibGVuZ3RoIixlbnVtZXJhYmxlOnIuZW51bWVyYWJsZSx2YWx1ZTpuW3RdfX0sZGVmaW5lUHJvcGVydHkoKXtnbigxMSl9LGdldFByb3RvdHlwZU9mKGUpe3JldHVybiBLbyhlLmJhc2VfKX0sc2V0UHJvdG90eXBlT2YoKXtnbigxMil9fSxmcz17fTtzbChtcCwoZSx0KT0+e2ZzW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c1swXT1hcmd1bWVudHNbMF1bMF0sdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSk7ZnMuZGVsZXRlUHJvcGVydHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnMuc2V0LmNhbGwodGhpcyxlLHQsdm9pZCAwKX07ZnMuc2V0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbXAuc2V0LmNhbGwodGhpcyxlWzBdLHQsbixlWzBdKX07ZnVuY3Rpb24gbmMoZSx0KXtjb25zdCBuPWVbV3RdO3JldHVybihuP0lyKG4pOmUpW3RdfWZ1bmN0aW9uIFAkKGUsdCxuKXt2YXIgbztjb25zdCByPVcwKHQsbik7cmV0dXJuIHI/InZhbHVlImluIHI/ci52YWx1ZToobz1yLmdldCk9PW51bGw/dm9pZCAwOm8uY2FsbChlLmRyYWZ0Xyk6dm9pZCAwfWZ1bmN0aW9uIFcwKGUsdCl7aWYoISh0IGluIGUpKXJldHVybjtsZXQgbj1LbyhlKTtmb3IoO247KXtjb25zdCByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZihyKXJldHVybiByO249S28obil9fWZ1bmN0aW9uIENkKGUpe2UubW9kaWZpZWRffHwoZS5tb2RpZmllZF89ITAsZS5wYXJlbnRfJiZDZChlLnBhcmVudF8pKX1mdW5jdGlvbiByYyhlKXtlLmNvcHlffHwoZS5jb3B5Xz13ZChlLmJhc2VfLGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV8pKX12YXIgJCQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5hdXRvRnJlZXplXz0hMCx0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5Xz0hMSx0aGlzLnByb2R1Y2U9KHQsbixyKT0+e2lmKHR5cGVvZiB0PT0iZnVuY3Rpb24iJiZ0eXBlb2YgbiE9ImZ1bmN0aW9uIil7Y29uc3QgaT1uO249dDtjb25zdCBzPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKGw9aSwuLi51KXtyZXR1cm4gcy5wcm9kdWNlKGwsYz0+bi5jYWxsKHRoaXMsYywuLi51KSl9fXR5cGVvZiBuIT0iZnVuY3Rpb24iJiZnbig2KSxyIT09dm9pZCAwJiZ0eXBlb2YgciE9ImZ1bmN0aW9uIiYmZ24oNyk7bGV0IG87aWYodHIodCkpe2NvbnN0IGk9VmgodGhpcykscz1iZCh0LHZvaWQgMCk7bGV0IGE9ITA7dHJ5e289bihzKSxhPSExfWZpbmFsbHl7YT9TZChpKTp4ZChpKX1yZXR1cm4gSGgoaSxyKSxLaChvLGkpfWVsc2UgaWYoIXR8fHR5cGVvZiB0IT0ib2JqZWN0Iil7aWYobz1uKHQpLG89PT12b2lkIDAmJihvPXQpLG89PT1qMCYmKG89dm9pZCAwKSx0aGlzLmF1dG9GcmVlemVfJiZwcChvLCEwKSxyKXtjb25zdCBpPVtdLHM9W107WHIoIlBhdGNoZXMiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18odCxvLGkscykscihpLHMpfXJldHVybiBvfWVsc2UgZ24oMSx0KX0sdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXM9KHQsbik9PntpZih0eXBlb2YgdD09ImZ1bmN0aW9uIilyZXR1cm4ocywuLi5hKT0+dGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMocyxsPT50KGwsLi4uYSkpO2xldCByLG87cmV0dXJuW3RoaXMucHJvZHVjZSh0LG4sKHMsYSk9PntyPXMsbz1hfSkscixvXX0sdHlwZW9mKGU9PW51bGw/dm9pZCAwOmUuYXV0b0ZyZWV6ZSk9PSJib29sZWFuIiYmdGhpcy5zZXRBdXRvRnJlZXplKGUuYXV0b0ZyZWV6ZSksdHlwZW9mKGU9PW51bGw/dm9pZCAwOmUudXNlU3RyaWN0U2hhbGxvd0NvcHkpPT0iYm9vbGVhbiImJnRoaXMuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkoZS51c2VTdHJpY3RTaGFsbG93Q29weSl9Y3JlYXRlRHJhZnQoZSl7dHIoZSl8fGduKDgpLFFyKGUpJiYoZT1PJChlKSk7Y29uc3QgdD1WaCh0aGlzKSxuPWJkKGUsdm9pZCAwKTtyZXR1cm4gbltXdF0uaXNNYW51YWxfPSEwLHhkKHQpLG59ZmluaXNoRHJhZnQoZSx0KXtjb25zdCBuPWUmJmVbV3RdOyghbnx8IW4uaXNNYW51YWxfKSYmZ24oOSk7Y29uc3R7c2NvcGVfOnJ9PW47cmV0dXJuIEhoKHIsdCksS2godm9pZCAwLHIpfXNldEF1dG9GcmVlemUoZSl7dGhpcy5hdXRvRnJlZXplXz1lfXNldFVzZVN0cmljdFNoYWxsb3dDb3B5KGUpe3RoaXMudXNlU3RyaWN0U2hhbGxvd0NvcHlfPWV9YXBwbHlQYXRjaGVzKGUsdCl7bGV0IG47Zm9yKG49dC5sZW5ndGgtMTtuPj0wO24tLSl7Y29uc3Qgbz10W25dO2lmKG8ucGF0aC5sZW5ndGg9PT0wJiZvLm9wPT09InJlcGxhY2UiKXtlPW8udmFsdWU7YnJlYWt9fW4+LTEmJih0PXQuc2xpY2UobisxKSk7Y29uc3Qgcj1YcigiUGF0Y2hlcyIpLmFwcGx5UGF0Y2hlc187cmV0dXJuIFFyKGUpP3IoZSx0KTp0aGlzLnByb2R1Y2UoZSxvPT5yKG8sdCkpfX07ZnVuY3Rpb24gYmQoZSx0KXtjb25zdCBuPWh1KGUpP1hyKCJNYXBTZXQiKS5wcm94eU1hcF8oZSx0KTpndShlKT9YcigiTWFwU2V0IikucHJveHlTZXRfKGUsdCk6VCQoZSx0KTtyZXR1cm4odD90LnNjb3BlXzpCMCgpKS5kcmFmdHNfLnB1c2gobiksbn1mdW5jdGlvbiBPJChlKXtyZXR1cm4gUXIoZSl8fGduKDEwLGUpLFUwKGUpfWZ1bmN0aW9uIFUwKGUpe2lmKCF0cihlKXx8eXUoZSkpcmV0dXJuIGU7Y29uc3QgdD1lW1d0XTtsZXQgbjtpZih0KXtpZighdC5tb2RpZmllZF8pcmV0dXJuIHQuYmFzZV87dC5maW5hbGl6ZWRfPSEwLG49d2QoZSx0LnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfKX1lbHNlIG49d2QoZSwhMCk7cmV0dXJuIHNsKG4sKHIsbyk9PntGMChuLHIsVTAobykpfSksdCYmKHQuZmluYWxpemVkXz0hMSksbn12YXIgVXQ9bmV3ICQkLFRzPVV0LnByb2R1Y2U7VXQucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoVXQpO1V0LnNldEF1dG9GcmVlemUuYmluZChVdCk7VXQuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkuYmluZChVdCk7VXQuYXBwbHlQYXRjaGVzLmJpbmQoVXQpO1V0LmNyZWF0ZURyYWZ0LmJpbmQoVXQpO1V0LmZpbmlzaERyYWZ0LmJpbmQoVXQpO2Z1bmN0aW9uIEgwKGUpe3JldHVybih7ZGlzcGF0Y2g6bixnZXRTdGF0ZTpyfSk9Pm89Pmk9PnR5cGVvZiBpPT0iZnVuY3Rpb24iP2kobixyLGUpOm8oaSl9dmFyIFYwPUgwKCksTSQ9SDAsXyQ9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18/d2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXzpmdW5jdGlvbigpe2lmKGFyZ3VtZW50cy5sZW5ndGghPT0wKXJldHVybiB0eXBlb2YgYXJndW1lbnRzWzBdPT0ib2JqZWN0Ij9pbDppbC5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIEdoKGUsdCl7ZnVuY3Rpb24gbiguLi5yKXtpZih0KXtsZXQgbz10KC4uLnIpO2lmKCFvKXRocm93IG5ldyBFcnJvcih6bigwKSk7cmV0dXJue3R5cGU6ZSxwYXlsb2FkOm8ucGF5bG9hZCwuLi4ibWV0YSJpbiBvJiZ7bWV0YTpvLm1ldGF9LC4uLiJlcnJvciJpbiBvJiZ7ZXJyb3I6by5lcnJvcn19fXJldHVybnt0eXBlOmUscGF5bG9hZDpyWzBdfX1yZXR1cm4gbi50b1N0cmluZz0oKT0+YCR7ZX1gLG4udHlwZT1lLG4ubWF0Y2g9cj0+UyQocikmJnIudHlwZT09PWUsbn12YXIgaHA9Y2xhc3Mga2kgZXh0ZW5kcyBBcnJheXtjb25zdHJ1Y3RvciguLi50KXtzdXBlciguLi50KSxPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxraS5wcm90b3R5cGUpfXN0YXRpYyBnZXRbU3ltYm9sLnNwZWNpZXNdKCl7cmV0dXJuIGtpfWNvbmNhdCguLi50KXtyZXR1cm4gc3VwZXIuY29uY2F0LmFwcGx5KHRoaXMsdCl9cHJlcGVuZCguLi50KXtyZXR1cm4gdC5sZW5ndGg9PT0xJiZBcnJheS5pc0FycmF5KHRbMF0pP25ldyBraSguLi50WzBdLmNvbmNhdCh0aGlzKSk6bmV3IGtpKC4uLnQuY29uY2F0KHRoaXMpKX19O2Z1bmN0aW9uIFFoKGUpe3JldHVybiB0cihlKT9UcyhlLCgpPT57fSk6ZX1mdW5jdGlvbiBYaChlLHQsbil7aWYoZS5oYXModCkpe2xldCBvPWUuZ2V0KHQpO3JldHVybiBuLnVwZGF0ZSYmKG89bi51cGRhdGUobyx0LGUpLGUuc2V0KHQsbykpLG99aWYoIW4uaW5zZXJ0KXRocm93IG5ldyBFcnJvcih6bigxMCkpO2NvbnN0IHI9bi5pbnNlcnQodCxlKTtyZXR1cm4gZS5zZXQodCxyKSxyfWZ1bmN0aW9uIE4kKGUpe3JldHVybiB0eXBlb2YgZT09ImJvb2xlYW4ifXZhciBJJD0oKT0+ZnVuY3Rpb24odCl7Y29uc3R7dGh1bms6bj0hMCxpbW11dGFibGVDaGVjazpyPSEwLHNlcmlhbGl6YWJsZUNoZWNrOm89ITAsYWN0aW9uQ3JlYXRvckNoZWNrOmk9ITB9PXQ/P3t9O2xldCBzPW5ldyBocDtyZXR1cm4gbiYmKE4kKG4pP3MucHVzaChWMCk6cy5wdXNoKE0kKG4uZXh0cmFBcmd1bWVudCkpKSxzfSxBJD0iUlRLX2F1dG9CYXRjaCIsSzA9ZT0+dD0+e3NldFRpbWVvdXQodCxlKX0seiQ9dHlwZW9mIHdpbmRvdzwidSImJndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTpLMCgxMCksTCQ9KGU9e3R5cGU6InJhZiJ9KT0+dD0+KC4uLm4pPT57Y29uc3Qgcj10KC4uLm4pO2xldCBvPSEwLGk9ITEscz0hMTtjb25zdCBhPW5ldyBTZXQsbD1lLnR5cGU9PT0idGljayI/cXVldWVNaWNyb3Rhc2s6ZS50eXBlPT09InJhZiI/eiQ6ZS50eXBlPT09ImNhbGxiYWNrIj9lLnF1ZXVlTm90aWZpY2F0aW9uOkswKGUudGltZW91dCksdT0oKT0+e3M9ITEsaSYmKGk9ITEsYS5mb3JFYWNoKGM9PmMoKSkpfTtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxyLHtzdWJzY3JpYmUoYyl7Y29uc3QgZD0oKT0+byYmYygpLG09ci5zdWJzY3JpYmUoZCk7cmV0dXJuIGEuYWRkKGMpLCgpPT57bSgpLGEuZGVsZXRlKGMpfX0sZGlzcGF0Y2goYyl7dmFyIGQ7dHJ5e3JldHVybiBvPSEoKGQ9Yz09bnVsbD92b2lkIDA6Yy5tZXRhKSE9bnVsbCYmZFtBJF0pLGk9IW8saSYmKHN8fChzPSEwLGwodSkpKSxyLmRpc3BhdGNoKGMpfWZpbmFsbHl7bz0hMH19fSl9LGokPWU9PmZ1bmN0aW9uKG4pe2NvbnN0e2F1dG9CYXRjaDpyPSEwfT1uPz97fTtsZXQgbz1uZXcgaHAoZSk7cmV0dXJuIHImJm8ucHVzaChMJCh0eXBlb2Ygcj09Im9iamVjdCI/cjp2b2lkIDApKSxvfTtmdW5jdGlvbiBEJChlKXtjb25zdCB0PUkkKCkse3JlZHVjZXI6bj12b2lkIDAsbWlkZGxld2FyZTpyLGRldlRvb2xzOm89ITAscHJlbG9hZGVkU3RhdGU6aT12b2lkIDAsZW5oYW5jZXJzOnM9dm9pZCAwfT1lfHx7fTtsZXQgYTtpZih0eXBlb2Ygbj09ImZ1bmN0aW9uIilhPW47ZWxzZSBpZihmcChuKSlhPXYkKG4pO2Vsc2UgdGhyb3cgbmV3IEVycm9yKHpuKDEpKTtsZXQgbDt0eXBlb2Ygcj09ImZ1bmN0aW9uIj9sPXIodCk6bD10KCk7bGV0IHU9aWw7byYmKHU9XyQoe3RyYWNlOiExLC4uLnR5cGVvZiBvPT0ib2JqZWN0IiYmb30pKTtjb25zdCBjPXckKC4uLmwpLGQ9aiQoYyk7bGV0IG09dHlwZW9mIHM9PSJmdW5jdGlvbiI/cyhkKTpkKCk7Y29uc3Qgdj11KC4uLm0pO3JldHVybiBMMChhLGksdil9ZnVuY3Rpb24gWTAoZSl7Y29uc3QgdD17fSxuPVtdO2xldCByO2NvbnN0IG89e2FkZENhc2UoaSxzKXtjb25zdCBhPXR5cGVvZiBpPT0ic3RyaW5nIj9pOmkudHlwZTtpZighYSl0aHJvdyBuZXcgRXJyb3Ioem4oMjgpKTtpZihhIGluIHQpdGhyb3cgbmV3IEVycm9yKHpuKDI5KSk7cmV0dXJuIHRbYV09cyxvfSxhZGRNYXRjaGVyKGkscyl7cmV0dXJuIG4ucHVzaCh7bWF0Y2hlcjppLHJlZHVjZXI6c30pLG99LGFkZERlZmF1bHRDYXNlKGkpe3JldHVybiByPWksb319O3JldHVybiBlKG8pLFt0LG4scl19ZnVuY3Rpb24gRiQoZSl7cmV0dXJuIHR5cGVvZiBlPT0iZnVuY3Rpb24ifWZ1bmN0aW9uIEIkKGUsdCl7bGV0W24scixvXT1ZMCh0KSxpO2lmKEYkKGUpKWk9KCk9PlFoKGUoKSk7ZWxzZXtjb25zdCBhPVFoKGUpO2k9KCk9PmF9ZnVuY3Rpb24gcyhhPWkoKSxsKXtsZXQgdT1bbltsLnR5cGVdLC4uLnIuZmlsdGVyKCh7bWF0Y2hlcjpjfSk9PmMobCkpLm1hcCgoe3JlZHVjZXI6Y30pPT5jKV07cmV0dXJuIHUuZmlsdGVyKGM9PiEhYykubGVuZ3RoPT09MCYmKHU9W29dKSx1LnJlZHVjZSgoYyxkKT0+e2lmKGQpaWYoUXIoYykpe2NvbnN0IHY9ZChjLGwpO3JldHVybiB2PT09dm9pZCAwP2M6dn1lbHNle2lmKHRyKGMpKXJldHVybiBUcyhjLG09PmQobSxsKSk7e2NvbnN0IG09ZChjLGwpO2lmKG09PT12b2lkIDApe2lmKGM9PT1udWxsKXJldHVybiBjO3Rocm93IEVycm9yKCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZCIpfXJldHVybiBtfX1yZXR1cm4gY30sYSl9cmV0dXJuIHMuZ2V0SW5pdGlhbFN0YXRlPWksc312YXIgVyQ9U3ltYm9sLmZvcigicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmsiKTtmdW5jdGlvbiBVJChlLHQpe3JldHVybmAke2V9LyR7dH1gfWZ1bmN0aW9uIEgkKHtjcmVhdG9yczplfT17fSl7dmFyIG47Y29uc3QgdD0obj1lPT1udWxsP3ZvaWQgMDplLmFzeW5jVGh1bmspPT1udWxsP3ZvaWQgMDpuW1ckXTtyZXR1cm4gZnVuY3Rpb24obyl7Y29uc3R7bmFtZTppLHJlZHVjZXJQYXRoOnM9aX09bztpZighaSl0aHJvdyBuZXcgRXJyb3Ioem4oMTEpKTt0eXBlb2YgcHJvY2VzczwidSI7Y29uc3QgYT0odHlwZW9mIG8ucmVkdWNlcnM9PSJmdW5jdGlvbiI/by5yZWR1Y2VycyhZJCgpKTpvLnJlZHVjZXJzKXx8e30sbD1PYmplY3Qua2V5cyhhKSx1PXtzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZTp7fSxzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZTp7fSxhY3Rpb25DcmVhdG9yczp7fSxzbGljZU1hdGNoZXJzOltdfSxjPXthZGRDYXNlKGYseSl7Y29uc3QgYj10eXBlb2YgZj09InN0cmluZyI/ZjpmLnR5cGU7aWYoIWIpdGhyb3cgbmV3IEVycm9yKHpuKDEyKSk7aWYoYiBpbiB1LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlKXRocm93IG5ldyBFcnJvcih6bigxMykpO3JldHVybiB1LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW2JdPXksY30sYWRkTWF0Y2hlcihmLHkpe3JldHVybiB1LnNsaWNlTWF0Y2hlcnMucHVzaCh7bWF0Y2hlcjpmLHJlZHVjZXI6eX0pLGN9LGV4cG9zZUFjdGlvbihmLHkpe3JldHVybiB1LmFjdGlvbkNyZWF0b3JzW2ZdPXksY30sZXhwb3NlQ2FzZVJlZHVjZXIoZix5KXtyZXR1cm4gdS5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtmXT15LGN9fTtsLmZvckVhY2goZj0+e2NvbnN0IHk9YVtmXSxiPXtyZWR1Y2VyTmFtZTpmLHR5cGU6VSQoaSxmKSxjcmVhdGVOb3RhdGlvbjp0eXBlb2Ygby5yZWR1Y2Vycz09ImZ1bmN0aW9uIn07USQoeSk/cSQoYix5LGMsdCk6RyQoYix5LGMpfSk7ZnVuY3Rpb24gZCgpe2NvbnN0W2Y9e30seT1bXSxiPXZvaWQgMF09dHlwZW9mIG8uZXh0cmFSZWR1Y2Vycz09ImZ1bmN0aW9uIj9ZMChvLmV4dHJhUmVkdWNlcnMpOltvLmV4dHJhUmVkdWNlcnNdLEU9ey4uLmYsLi4udS5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZX07cmV0dXJuIEIkKG8uaW5pdGlhbFN0YXRlLFI9Pntmb3IobGV0IFAgaW4gRSlSLmFkZENhc2UoUCxFW1BdKTtmb3IobGV0IFAgb2YgdS5zbGljZU1hdGNoZXJzKVIuYWRkTWF0Y2hlcihQLm1hdGNoZXIsUC5yZWR1Y2VyKTtmb3IobGV0IFAgb2YgeSlSLmFkZE1hdGNoZXIoUC5tYXRjaGVyLFAucmVkdWNlcik7YiYmUi5hZGREZWZhdWx0Q2FzZShiKX0pfWNvbnN0IG09Zj0+Zix2PW5ldyBNYXA7bGV0IHc7ZnVuY3Rpb24gUyhmLHkpe3JldHVybiB3fHwodz1kKCkpLHcoZix5KX1mdW5jdGlvbiB4KCl7cmV0dXJuIHd8fCh3PWQoKSksdy5nZXRJbml0aWFsU3RhdGUoKX1mdW5jdGlvbiBoKGYseT0hMSl7ZnVuY3Rpb24gYihSKXtsZXQgUD1SW2ZdO3JldHVybiB0eXBlb2YgUD4idSImJnkmJihQPXgoKSksUH1mdW5jdGlvbiBFKFI9bSl7Y29uc3QgUD1YaCh2LHkse2luc2VydDooKT0+bmV3IFdlYWtNYXB9KTtyZXR1cm4gWGgoUCxSLHtpbnNlcnQ6KCk9Pntjb25zdCBJPXt9O2Zvcihjb25zdFtwLCRdb2YgT2JqZWN0LmVudHJpZXMoby5zZWxlY3RvcnM/P3t9KSlJW3BdPVYkKCQsUix4LHkpO3JldHVybiBJfX0pfXJldHVybntyZWR1Y2VyUGF0aDpmLGdldFNlbGVjdG9yczpFLGdldCBzZWxlY3RvcnMoKXtyZXR1cm4gRShiKX0sc2VsZWN0U2xpY2U6Yn19Y29uc3QgZz17bmFtZTppLHJlZHVjZXI6UyxhY3Rpb25zOnUuYWN0aW9uQ3JlYXRvcnMsY2FzZVJlZHVjZXJzOnUuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsZ2V0SW5pdGlhbFN0YXRlOngsLi4uaChzKSxpbmplY3RJbnRvKGYse3JlZHVjZXJQYXRoOnksLi4uYn09e30pe2NvbnN0IEU9eT8/cztyZXR1cm4gZi5pbmplY3Qoe3JlZHVjZXJQYXRoOkUscmVkdWNlcjpTfSxiKSx7Li4uZywuLi5oKEUsITApfX19O3JldHVybiBnfX1mdW5jdGlvbiBWJChlLHQsbixyKXtmdW5jdGlvbiBvKGksLi4ucyl7bGV0IGE9dChpKTtyZXR1cm4gdHlwZW9mIGE+InUiJiZyJiYoYT1uKCkpLGUoYSwuLi5zKX1yZXR1cm4gby51bndyYXBwZWQ9ZSxvfXZhciBLJD1IJCgpO2Z1bmN0aW9uIFkkKCl7ZnVuY3Rpb24gZSh0LG4pe3JldHVybntfcmVkdWNlckRlZmluaXRpb25UeXBlOiJhc3luY1RodW5rIixwYXlsb2FkQ3JlYXRvcjp0LC4uLm59fXJldHVybiBlLndpdGhUeXBlcz0oKT0+ZSx7cmVkdWNlcih0KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7W3QubmFtZV0oLi4ubil7cmV0dXJuIHQoLi4ubil9fVt0Lm5hbWVdLHtfcmVkdWNlckRlZmluaXRpb25UeXBlOiJyZWR1Y2VyIn0pfSxwcmVwYXJlZFJlZHVjZXIodCxuKXtyZXR1cm57X3JlZHVjZXJEZWZpbml0aW9uVHlwZToicmVkdWNlcldpdGhQcmVwYXJlIixwcmVwYXJlOnQscmVkdWNlcjpufX0sYXN5bmNUaHVuazplfX1mdW5jdGlvbiBHJCh7dHlwZTplLHJlZHVjZXJOYW1lOnQsY3JlYXRlTm90YXRpb246bn0scixvKXtsZXQgaSxzO2lmKCJyZWR1Y2VyImluIHIpe2lmKG4mJiFYJChyKSl0aHJvdyBuZXcgRXJyb3Ioem4oMTcpKTtpPXIucmVkdWNlcixzPXIucHJlcGFyZX1lbHNlIGk9cjtvLmFkZENhc2UoZSxpKS5leHBvc2VDYXNlUmVkdWNlcih0LGkpLmV4cG9zZUFjdGlvbih0LHM/R2goZSxzKTpHaChlKSl9ZnVuY3Rpb24gUSQoZSl7cmV0dXJuIGUuX3JlZHVjZXJEZWZpbml0aW9uVHlwZT09PSJhc3luY1RodW5rIn1mdW5jdGlvbiBYJChlKXtyZXR1cm4gZS5fcmVkdWNlckRlZmluaXRpb25UeXBlPT09InJlZHVjZXJXaXRoUHJlcGFyZSJ9ZnVuY3Rpb24gcSQoe3R5cGU6ZSxyZWR1Y2VyTmFtZTp0fSxuLHIsbyl7aWYoIW8pdGhyb3cgbmV3IEVycm9yKHpuKDE4KSk7Y29uc3R7cGF5bG9hZENyZWF0b3I6aSxmdWxmaWxsZWQ6cyxwZW5kaW5nOmEscmVqZWN0ZWQ6bCxzZXR0bGVkOnUsb3B0aW9uczpjfT1uLGQ9byhlLGksYyk7ci5leHBvc2VBY3Rpb24odCxkKSxzJiZyLmFkZENhc2UoZC5mdWxmaWxsZWQscyksYSYmci5hZGRDYXNlKGQucGVuZGluZyxhKSxsJiZyLmFkZENhc2UoZC5yZWplY3RlZCxsKSx1JiZyLmFkZE1hdGNoZXIoZC5zZXR0bGVkLHUpLHIuZXhwb3NlQ2FzZVJlZHVjZXIodCx7ZnVsZmlsbGVkOnN8fHRhLHBlbmRpbmc6YXx8dGEscmVqZWN0ZWQ6bHx8dGEsc2V0dGxlZDp1fHx0YX0pfWZ1bmN0aW9uIHRhKCl7fWZ1bmN0aW9uIHpuKGUpe3JldHVybmBNaW5pZmllZCBSZWR1eCBUb29sa2l0IGVycm9yICMke2V9OyB2aXNpdCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL0Vycm9ycz9jb2RlPSR7ZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYH1jb25zdCBHMD0iamlyYS13b3JrLWxvZ2VyLWRhdGEtc3RhdGUiO2Z1bmN0aW9uIFokKGUpe2xvY2FsU3RvcmFnZS5zZXRJdGVtKEcwLEpTT04uc3RyaW5naWZ5KGUpKX1mdW5jdGlvbiBKJCgpe3JldHVybih7Z2V0U3RhdGU6ZX0pPT50PT5uPT57Y29uc3Qgcj10KG4pO3JldHVybiBaJChlKCkpLHJ9fWNvbnN0IGVPPUokKCk7ZnVuY3Rpb24gcnIoZSl7cmV0dXJuIE1hdGgucm91bmQoZSoxMDApLzEwMH1jb25zdCBvYz17fTthc3luYyBmdW5jdGlvbiBRMChlLHQsbixyKXt2YXIgcyxhO2NvbnN0IG89KChzPWUua2V5KT09bnVsbD92b2lkIDA6cy50cmltKCkpfHwiIixpPW9jW29dP29jW29dOmF3YWl0IGZldGNoKGAvYXBpL2lzc3VlLyR7b31gLHttZXRob2Q6IlBPU1QiLGJvZHk6SlNPTi5zdHJpbmdpZnkodCgpLmNvbmZpZyl9KS50aGVuKGFzeW5jIGw9PmF3YWl0IGwuanNvbigpfHx7a2V5OiIifSkuY2F0Y2goKCk9Pih7a2V5OiIifSkpO29jW29dPWksKGk9PW51bGw/dm9pZCAwOmkua2V5KT09PWUua2V5JiZuKGl0LnNldElzc3VlVmFsdWUoe3k6cixpc3N1ZTp7a2V5OmUua2V5fHwiIixmaWVsZHM6e3N1bW1hcnk6KGE9aT09bnVsbD92b2lkIDA6aS5maWVsZHMpPT1udWxsP3ZvaWQgMDphLnN1bW1hcnl9fX0pKX1jb25zdCB0Tz0oZSx0LG4scixvKT0+YXN5bmMoaSxzKT0+e3ZhciBhO2UmJmNsZWFyVGltZW91dChlKSxvLmtleSE9PXZvaWQgMCYmKChhPW8ua2V5KSE9bnVsbCYmYS50cmltKCkubWF0Y2goL1tBLVphLXowLTldKy1bMC05XSsvKT8oaShpdC5zZXRJc3N1ZVZhbHVlKHt5OnIsaXNzdWU6ey4uLm4sa2V5Om8ua2V5fHwiIixmaWVsZHM6e3N1bW1hcnk6IiJ9fX0pKSx0KHNldFRpbWVvdXQoKCk9PlEwKG8scyxpLHIpLDFlMykpKTppKGl0LnNldElzc3VlVmFsdWUoe3k6cixpc3N1ZTp7Li4ubixrZXk6by5rZXl8fCIiLGZpZWxkczp7c3VtbWFyeToiIn19fSkpKSxvLmNvbW1lbnQhPT12b2lkIDAmJmkoaXQuc2V0SXNzdWVWYWx1ZSh7eTpyLGlzc3VlOnsuLi5uLHdvcmtMb2dDb21tZW50Om8uY29tbWVudH19KSl9LG5PPSgpPT5hc3luYyhlLHQpPT57Y29uc3Qgcj1hd2FpdChhd2FpdCBmZXRjaChgL2FwaS9oYW1zdGVyRXhwb3J0P2hhbXN0ZXJEYXlzVG9JbXBvcnQ9JHt0KCkuY29uZmlnLmhhbXN0ZXJEYXlzVG9JbXBvcnR9Jmlnbm9yZT0ke3QoKS5jb25maWcuaGFtc3Rlcklnbm9yZUNvbW1lbnR9YCkpLmpzb24oKTthd2FpdCBlKGl0LmltcG9ydEhhbXN0ZXJSZXBvcnQoe2hhbXN0ZXJSZXBvcnQ6cn0pKSx0KCkuZGF0YS5pc3N1ZXMuZm9yRWFjaCgobyxpKT0+e28ua2V5JiZRMCh7a2V5Om8ua2V5fSx0LGUsaSl9KX07ZnVuY3Rpb24gck8oZSx0KXtjb25zdCBuPW5ldyBTZXQoZS5tYXAoaT0+aS5kYXRlKSkscj1uZXcgU2V0KGUubWFwKGk9PmkuY29tbWVudCkpLG89aT0+aS5tYXRjaCgvW0EtWjAtOV0rLVswLTldKy8pP2kucmVwbGFjZSgvXiguKj8pKFtBLVowLTldKy1bMC05XSspKC4qPykkL2csIiQyIik6IiI7dC5kYXRhPXtkYXRlczpBcnJheS5mcm9tKG4pLnNvcnQoKS5tYXAoaT0+bmV3IERhdGUoaSkpLGlzc3VlczpBcnJheS5mcm9tKHIpLm1hcChpPT4oe2tleTpvKGkpLHdvcmtMb2dDb21tZW50OmkscmVhY3RLZXk6TWF0aC5yYW5kb20oKX0pKSxob3VyczpbXX0sbi5mb3JFYWNoKCgpPT50LmRhdGEuaG91cnMucHVzaChuZXcgQXJyYXkodC5kYXRhLmlzc3Vlcy5sZW5ndGgpLmZpbGwoMCkpKSxlLmZvckVhY2goKHtjb21tZW50OmksaG91cnM6cyxkYXRlOmF9KT0+e2NvbnN0IGw9dC5kYXRhLmlzc3Vlcy5tYXAodT0+dS53b3JrTG9nQ29tbWVudCkuaW5kZXhPZihpKTtpZihsPj0wKXtjb25zdCB1PXQuZGF0YS5kYXRlcy5tYXAoYz0+Yy50b0lTT1N0cmluZygpLnN1YnN0cigwLDEwKSkuaW5kZXhPZihhKTt1Pj0wJiYodC5kYXRhLmhvdXJzW3VdW2xdPXJyKHQuZGF0YS5ob3Vyc1t1XVtsXStzKSl9fSl9ZnVuY3Rpb24ga2QoZSx0KXtyZXR1cm4gVHMoZSxuPT57Y29uc3Qgcj1lLmRhdGVzLmxlbmd0aD4wP2UuZGF0ZXNbZS5kYXRlcy5sZW5ndGgtMV06bnVsbDtuLmRhdGVzLnB1c2godHx8KHI/bmV3IERhdGUoci5nZXRUaW1lKCkrMjQqNjAqNjAqMWUzKTpuZXcgRGF0ZSkpLG4uaG91cnMucHVzaChuLmlzc3Vlcy5tYXAoKCk9PjApKX0pfWZ1bmN0aW9uIFgwKGUpe3JldHVybiBUcyhlLHQ9Pnt0PWtkKHQsbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCktNCoyNCo2MCo2MCoxZTMpKTtmb3IobGV0IG49MDtuPDQ7bisrKXQ9a2QodCk7cmV0dXJuIHR9KX1mdW5jdGlvbiBFZChlLHQ9e2tleToiIn0pe3JldHVybiBUcyhlLG49PntuLmlzc3Vlcy5wdXNoKHsuLi50LHJlYWN0S2V5OnQucmVhY3RLZXl8fE1hdGgucmFuZG9tKCl9KSxuLmhvdXJzLm1hcChyPT5yLnB1c2goMCkpfSl9Y29uc3QgcWg9KCk9PntsZXQgZTtjb25zdCB0PWxvY2FsU3RvcmFnZS5nZXRJdGVtKEcwKTtyZXR1cm4gdD8oZT1KU09OLnBhcnNlKHQpLGUuZGF0YS5kYXRlcz1lLmRhdGEuZGF0ZXMubWFwKG49Pm5ldyBEYXRlKG4pKSk6ZT17ZGF0YTpFZChYMCh7ZGF0ZXM6W10saG91cnM6W10saXNzdWVzOltdfSkpLGNvbmZpZzp7amlyYVVybDoiamlyYVVybCIsdXNlcm5hbWU6InVzZXJuYW1lIixwYXNzd29yZDoicGFzc3dvcmQiLHRva2VuOiJ0b2tlbiIsaGFtc3RlckRheXNUb0ltcG9ydDo1LGhhbXN0ZXJJZ25vcmVDb21tZW50OiIifSx3ZWJzb2NrZXRTdGF0ZToiVU5ERUZJTkVEIn0sZS5sb2dUaGlzV29ya0luUHJvZ3Jlc3M9ITEsZX0scTA9SyQoe25hbWU6InJvb3QiLGluaXRpYWxTdGF0ZTpxaCgpLHJlZHVjZXJzOntjbGVhckRhdGEoZSl7ZS5kYXRhPXtkYXRlczpbXSxpc3N1ZXM6W10saG91cnM6W119fSxhZGRMYXN0NURheXMoZSl7ZS5kYXRhPVgwKGUuZGF0YSl9LHNldENvbmZpZyhlLHtwYXlsb2FkOntjb25maWc6dH19KXtlLmNvbmZpZz10fSxpc3N1ZUNsaWNrZWQoZSx7cGF5bG9hZDp7aXNzdWU6dH19KXt2YXIgbjtlLmRhdGE9RWQoZS5kYXRhLHtrZXk6dC5rZXksZmllbGRzOntzdW1tYXJ5OihuPXQuZmllbGRzKT09bnVsbD92b2lkIDA6bi5zdW1tYXJ5fX0pfSxhZGRSb3coZSl7ZS5kYXRhPUVkKGUuZGF0YSl9LGFkZENvbHVtbihlKXtlLmRhdGE9a2QoZS5kYXRhKX0sc2V0RGF0YShlLHtwYXlsb2FkOntkYXRhOnR9fSl7ZS5kYXRhPXR9LHNldElzc3VlVmFsdWUoZSx7cGF5bG9hZDp7eTp0LGlzc3VlOm59fSl7ZS5kYXRhLmlzc3Vlc1t0XT17Li4ubix3b3JrTG9nQ29tbWVudDpuLndvcmtMb2dDb21tZW50IT09dm9pZCAwP24ud29ya0xvZ0NvbW1lbnQ6ZS5kYXRhLmlzc3Vlc1t0XS53b3JrTG9nQ29tbWVudCxyZWFjdEtleTplLmRhdGEuaXNzdWVzW3RdLnJlYWN0S2V5fHxNYXRoLnJhbmRvbSgpfX0scmVtb3ZlQ29sdW1uKGUse3BheWxvYWQ6e251bTp0fX0pe2UuZGF0YS5kYXRlcy5zcGxpY2UodCwxKSxlLmRhdGEuaG91cnMuc3BsaWNlKHQsMSl9LHJlbW92ZVJvdyhlLHtwYXlsb2FkOntudW06dH19KXtlLmRhdGEuaXNzdWVzLnNwbGljZSh0LDEpLGUuZGF0YS5ob3Vycy5tYXAobj0+bi5zcGxpY2UodCwxKSl9LHNldERhdGVWYWx1ZShlLHtwYXlsb2FkOntudW06dCxkYXRlOm59fSl7ZS5kYXRhLmRhdGVzW3RdPW59LHNldEhvdXJWYWx1ZShlLHtwYXlsb2FkOnt4OnQseTpuLGhvdXI6cn19KXtlLmRhdGEuaG91cnNbdF1bbl09cn0sc2V0V29ya3NMb2dnZWQoZSx7cGF5bG9hZDp7d29ya3NMb2dnZWQ6dH19KXtlLndvcmtzTG9nZ2VkPXR9LGltcG9ydEhhbXN0ZXJSZXBvcnQoZSx7cGF5bG9hZDp7aGFtc3RlclJlcG9ydDp0fX0pe3JPKHQsZSl9LHJlc2V0SG91cnMoZSl7ZS5kYXRhLmhvdXJzLmZvckVhY2goKHQsbik9PnQuZm9yRWFjaCgocixvKT0+dFtvXT0wKSl9LHJlc2V0Q29uZmlnKCl7cmV0dXJuIGxvY2FsU3RvcmFnZS5jbGVhcigpLHFoKCl9LHdlYnNvY2tldFN0YXR1c0NoYW5nZShlLHtwYXlsb2FkOnt3ZWJzb2NrZXRTdGF0ZTp0fX0peyh0PT09Ik9QRU4ifHxlLndlYnNvY2tldFN0YXRlIT09IkVSUk9SIikmJihlLndlYnNvY2tldFN0YXRlPXQpfSxzZXRMb2dUaGlzV29ya0luUHJvZ3Jlc3MoZSx7cGF5bG9hZDp7bmV3TG9nVGhpc1dvcmtJblByb2dyZXNzOnR9fSl7ZS5sb2dUaGlzV29ya0luUHJvZ3Jlc3M9dH19fSksaXQ9cTAuYWN0aW9ucyx3YT1EJCh7cmVkdWNlcjpxMC5yZWR1Y2VyLG1pZGRsZXdhcmU6KCk9Pm5ldyBocChWMCxlTyl9KSxvTz1ocyhlPT5lLGl0KShtJCk7ZnVuY3Rpb24gaU8oe2NvbmZpZzplLHNldENvbmZpZzp0LHJlc2V0Q29uZmlnOm59KXtyZXR1cm4gay5qc3hzKHAwLHtlbGV2YXRpb246MyxjaGlsZHJlbjpbay5qc3goaDAse2V4cGFuZEljb246ay5qc3goQTAse30pLGNoaWxkcmVuOmsuanN4KGcwLHt2YXJpYW50OiJoNSIsZ3V0dGVyQm90dG9tOiEwLGNoaWxkcmVuOiJDb25maWd1cmF0aW9uIn0pfSksay5qc3gobTAse2NoaWxkcmVuOmsuanN4cygiZm9ybSIse25vVmFsaWRhdGU6ITAsYXV0b0NvbXBsZXRlOiJvZmYiLGNoaWxkcmVuOltrLmpzeChtbix7bGFiZWw6IkppcmEgVXJsIixzdHlsZTp7bWluV2lkdGg6MzAwfSx2YWx1ZTplLmppcmFVcmwsb25DaGFuZ2U6cj0+dCh7Y29uZmlnOnsuLi5lLGppcmFVcmw6ci50YXJnZXQudmFsdWV9fSl9KSxrLmpzeChtbix7bGFiZWw6IlVzZXJuYW1lIix2YWx1ZTplLnVzZXJuYW1lLG9uQ2hhbmdlOnI9PnQoe2NvbmZpZzp7Li4uZSx1c2VybmFtZTpyLnRhcmdldC52YWx1ZX19KX0pLGsuanN4KG1uLHtsYWJlbDoicGFzc3dvcmQiLHR5cGU6InBhc3N3b3JkIix2YWx1ZTplLnBhc3N3b3JkLCJhcmlhLWF1dG9jb21wbGV0ZSI6Im5vbmUiLGF1dG9Db21wbGV0ZToib2ZmIixvbkNoYW5nZTpyPT50KHtjb25maWc6ey4uLmUscGFzc3dvcmQ6ci50YXJnZXQudmFsdWV9fSl9KSxrLmpzeChtbix7bGFiZWw6InRva2VuIix0eXBlOiJwYXNzd29yZCIsdmFsdWU6ZS50b2tlbiwiYXJpYS1hdXRvY29tcGxldGUiOiJub25lIixhdXRvQ29tcGxldGU6Im9mZiIsb25DaGFuZ2U6cj0+dCh7Y29uZmlnOnsuLi5lLHRva2VuOnIudGFyZ2V0LnZhbHVlfX0pfSksay5qc3gobW4se2xhYmVsOiJIYW1zdGVyIGNvbW1lbnRzIHRvIGlnbm9yZSAocmVnZXgpIixzdHlsZTp7bWluV2lkdGg6MzAwfSx2YWx1ZTplLmhhbXN0ZXJJZ25vcmVDb21tZW50LG9uQ2hhbmdlOnI9PnQoe2NvbmZpZzp7Li4uZSxoYW1zdGVySWdub3JlQ29tbWVudDpyLnRhcmdldC52YWx1ZX19KX0pLGsuanN4KG1uLHtsYWJlbDoiTmIgb2YgZGF5cyB0byBpbXBvcnQgZnJvbSBIYW1zdGVyIixzdHlsZTp7bWluV2lkdGg6MzAwfSx0eXBlOiJudW1iZXIiLHZhbHVlOmUuaGFtc3RlckRheXNUb0ltcG9ydCxvbkNoYW5nZTpyPT50KHtjb25maWc6ey4uLmUsaGFtc3RlckRheXNUb0ltcG9ydDpOdW1iZXIoci50YXJnZXQudmFsdWUpfX0pfSksay5qc3gobW4se2xhYmVsOiJOYiBvZiBob3VycyBieSBkYXkiLHN0eWxlOnttaW5XaWR0aDoyMDB9LHR5cGU6Im51bWJlciIsdmFsdWU6ZS5ob3Vyc0J5RGF5LG9uQ2hhbmdlOnI9PnQoe2NvbmZpZzp7Li4uZSxob3Vyc0J5RGF5Ok51bWJlcihyLnRhcmdldC52YWx1ZSl9fSl9KSxrLmpzeHMoenQse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsc2l6ZToic21hbGwiLG9uQ2xpY2s6bixjaGlsZHJlbjpbay5qc3gocyQse30pLCIgUmVzZXQgY29uZmlnIl19KV19KX0pXX0pfWNvbnN0IHNPPWhzKGU9PmUsaXQpKGlPKTtmdW5jdGlvbiBhTyhlLHQpe3JldHVybiBycihlLmhvdXJzW3RdLnJlZHVjZSgobixyKT0+bityLDApKX1mdW5jdGlvbiBaaChlLHQpe2NvbnN0IG49ZT9PYmplY3QuZW50cmllcyhlKS5maW5kKChbcixvXSk9PnI9PT10LnRvSVNPU3RyaW5nKCkuc3Vic3RyKDAsMTApKTowO3JldHVybiBuP3JyKG5bMV0vMzYwMCk6MH1mdW5jdGlvbiBsTyhlKXtyZXR1cm4gcnIoZS5ob3Vycy5tYXAodD0+dC5yZWR1Y2UoKG4scik9Pm4rciwwKSkucmVkdWNlKCh0LG4pPT50K24sMCkpfWZ1bmN0aW9uIHVPKHthZGRSb3c6ZSxkYXRhOnQsd29ya3NMb2dnZWQ6bn0pe3JldHVybiBrLmpzeHMoY3Ase2NsYXNzTmFtZToidG90YWwtcm93IixjaGlsZHJlbjpbay5qc3goZXIse2FsaWduOiJjZW50ZXIiLGNsYXNzTmFtZToiYWRkLWJ1dHRvbiIsY2hpbGRyZW46ay5qc3goenQse2NvbG9yOiJwcmltYXJ5IixvbkNsaWNrOmUsY2hpbGRyZW46ay5qc3gocHUse3N0eWxlOntmb250U2l6ZTo0MH19KX0pfSksdC5kYXRlcy5tYXAoKHIsbyk9PkMuY3JlYXRlRWxlbWVudChjTyx7eDpvLGRhdGU6cix3b3Jrc0xvZ2dlZDpuLGRhdGE6dCxrZXk6bytyLnRvSVNPU3RyaW5nKCl9KSksay5qc3goZXIse3N0eWxlOntmb250U2l6ZToyMCx0ZXh0QWxpZ246ImNlbnRlciIsbWluV2lkdGg6MTAwfSxjbGFzc05hbWU6InRvdGFsIixjaGlsZHJlbjpsTyh0KX0pXX0pfWZ1bmN0aW9uIGNPKHt4OmUsZGF0ZTp0LHdvcmtzTG9nZ2VkOm4sZGF0YTpyfSl7cmV0dXJuIGsuanN4cyhlcix7YWxpZ246ImNlbnRlciIsY2xhc3NOYW1lOiJ0b3RhbCIsY2hpbGRyZW46W2suanN4cygiZGl2Iix7c3R5bGU6e2NvbG9yOiIjYTkxYjFiIixmb250U2l6ZToxNn0sY2hpbGRyZW46WyJBbHJlYWR5IExvZ2dlZCAiLCI+IiwiPSAiLFpoKG4sdCldfSksay5qc3goImRpdiIse3N0eWxlOntkaXNwbGF5OiJmbGV4IixqdXN0aWZ5Q29udGVudDoiY2VudGVyIn0sY2hpbGRyZW46ay5qc3goZE8se3RvdGFsOnJyKGFPKHIsZSkrWmgobix0KSl9KX0pXX0pfWZ1bmN0aW9uIGRPKHt0b3RhbDplfSl7bGV0IHQ9IiI7c3dpdGNoKCEwKXtjYXNlIGU8MDpjYXNlIGU+Ny40OnQ9IiNmZjAwMDAiO2JyZWFrO2Nhc2UgZT09PTA6dD0iI2ZmYmViZSI7YnJlYWs7Y2FzZSBlPT09My43OnQ9IiM5NmJmZmYiO2JyZWFrO2Nhc2UgZT09PTcuNDp0PSIjODlmZjZmIjticmVhaztkZWZhdWx0OnQ9IiNmZmM1OTQiO2JyZWFrfXJldHVybiBrLmpzeCgiZGl2Iix7c3R5bGU6e2JhY2tncm91bmRDb2xvcjp0LGZvbnRTaXplOjIwLGJvcmRlclJhZGl1czoyMCx3aWR0aDoxMDB9LGNoaWxkcmVuOmV9KX1jb25zdCBmTz0oe2lzc3VlOmUsb25EZWxldGU6dCxvbktleUNoYW5nZTpuLG9uQ29tbWVudENoYW5nZTpyLGppcmFVcmw6b30pPT57dmFyIGkscztyZXR1cm4gay5qc3hzKCJkaXYiLHtjaGlsZHJlbjpbay5qc3hzKCJkaXYiLHtzdHlsZTp7ZGlzcGxheToiZmxleCJ9LGNoaWxkcmVuOltrLmpzeChaZix7Y29sb3I6InNlY29uZGFyeSIsb25DbGljazp0LGNoaWxkcmVuOmsuanN4KGRwLHtmb250U2l6ZToibGFyZ2UifSl9KSxrLmpzeChtbix7Y2xhc3NOYW1lOiJpc3N1ZSIsdmFsdWU6ZS5rZXksc3R5bGU6e21heFdpZHRoOjEwMCxiYWNrZ3JvdW5kQ29sb3I6ZS5rZXkubWF0Y2goL15bQS1aYS16MC05XSstWzAtOV0rJC8pPyIjZWRmNGZmIjoiI2ZmZGJkMCJ9LG9uQ2hhbmdlOmE9Pm4oYS50YXJnZXQudmFsdWUpfSksay5qc3gobW4se2NsYXNzTmFtZToiY29tbWVudCIsdmFsdWU6ZS53b3JrTG9nQ29tbWVudCxwbGFjZWhvbGRlcjoiV29yayBsb2cgY29tbWVudCIsc3R5bGU6e21pbldpZHRoOjE1MCxmbGV4OjF9LG9uQ2hhbmdlOmE9PnIoYS50YXJnZXQudmFsdWUpfSldfSksKGk9ZS5maWVsZHMpIT1udWxsJiZpLnN1bW1hcnk/ay5qc3goImRpdiIse2NsYXNzTmFtZToiaXNzdWUtc3VtbWFyeSIsY2hpbGRyZW46ay5qc3goImEiLHt0YXJnZXQ6Il9ibGFuayIscmVsOiJub29wZW5lciBub3JlZmVycmVyIixocmVmOmAke299L2Jyb3dzZS8ke2Uua2V5fWAsY2hpbGRyZW46KHM9ZS5maWVsZHMpPT1udWxsP3ZvaWQgMDpzLnN1bW1hcnl9KX0pOiIiXX0pfSxKaD0yNTAsZWc9NTA7ZnVuY3Rpb24gcE8oZSx0KXtzd2l0Y2goITApe2Nhc2UgZTw9MDpyZXR1cm4iI2ZmZiI7Y2FzZSBlPnQ6cmV0dXJuYGhzbCgke2VnfSwxMDAlLDc2JSlgO2RlZmF1bHQ6cmV0dXJuYGhzbCgke0poLWUvdCooSmgtZWcpfSwxMDAlLDc2JSlgfX1mdW5jdGlvbiB0ZyhlLHQpe3JldHVybiBycihlPWUtdCksZTwwPzA6ZX1mdW5jdGlvbiBuZyhlLHQpe3JldHVybiBycihlPWUrdC80KSxlPnQ/dDplfWNvbnN0IG1PPSh7aG91cjplLHNldEhvdXI6dCwuLi5ufSk9Pnt2YXIgaTtjb25zdCByPUMudXNlU3RhdGUoKSxvPSgoaT1yPT1udWxsP3ZvaWQgMDpyLmNvbmZpZyk9PW51bGw/dm9pZCAwOmkuaG91cnNCeURheSl8fDg7cmV0dXJuIGsuanN4cygiZGl2Iix7Y2xhc3NOYW1lOiJob3VyLWNlbGwiLGNoaWxkcmVuOltrLmpzeCh6dCx7c2l6ZToic21hbGwiLG9uQ2xpY2s6KCk9PnQodGcoZSxvLzQpKSxjaGlsZHJlbjprLmpzeChkJCx7fSl9KSxrLmpzeCgiZGl2Iix7Y2hpbGRyZW46ay5qc3gobW4se2NsYXNzTmFtZToiaG91ciIsdHlwZToibnVtYmVyIix2YWx1ZTpycihlKSxzdHlsZTp7YmFja2dyb3VuZENvbG9yOnBPKGUsbyksYm9yZGVyUmFkaXVzOjIwLHBhZGRpbmdMZWZ0OjEwfSxvbldoZWVsOnM9PntzLmRlbHRhWT4wP3QodGcoZSxvLzQpKTp0KG5nKGUsbykpLHMucHJldmVudERlZmF1bHQoKX0sdmFyaWFudDoic3RhbmRhcmQiLG9uQ2hhbmdlOnM9PnQoTnVtYmVyKHMudGFyZ2V0LnZhbHVlKSksSW5wdXRQcm9wczp7ZGlzYWJsZVVuZGVybGluZTohMCxpbnB1dFByb3BzOnttaW46MCxtYXg6byxzdGVwOm8vNH19LC4uLm59KX0pLGsuanN4KHp0LHtzaXplOiJzbWFsbCIsb25DbGljazooKT0+dChuZyhlLG8pKSxjaGlsZHJlbjprLmpzeChwdSx7fSl9KV19KX07ZnVuY3Rpb24gaE8oe2lzc3VlOmUscmVtb3ZlUm93OnQseTpuLG9uSXNzdWVLZXlVcGRhdGVkOnIsamlyYVVybDpvfSl7Y29uc3RbaSxzXT1DLnVzZVN0YXRlKCk7cmV0dXJuIGsuanN4KGVyLHtjb21wb25lbnQ6InRoIixhbGlnbjoiY2VudGVyIixjbGFzc05hbWU6InJvdy1oZWFkZXIiLGNoaWxkcmVuOmsuanN4KGZPLHtpc3N1ZTplLGppcmFVcmw6byxvbkRlbGV0ZTooKT0+dCh7bnVtOm59KSxvbktleUNoYW5nZTphPT5yKGkscyxlLG4se2tleTphfSksb25Db21tZW50Q2hhbmdlOmE9PnIoaSxzLGUsbix7Y29tbWVudDphfSl9KX0pfWZ1bmN0aW9uIGdPKGUsdCl7cmV0dXJuIHJyKGUuaG91cnMubWFwKG49Pm5bdF0pLnJlZHVjZSgobixyKT0+bityLDApKX1mdW5jdGlvbiB5Tyh7aXNzdWU6ZSx5OnQscmVtb3ZlUm93Om4sb25Jc3N1ZUtleVVwZGF0ZWQ6cixkYXRhOm8sc2V0SG91clZhbHVlOmksamlyYVVybDpzfSl7cmV0dXJuIGsuanN4cyhjcCx7Y2xhc3NOYW1lOnQlMj8ib2RkIjoiZXZlbiIsY2hpbGRyZW46W2suanN4KGhPLHtpc3N1ZTplLHJlbW92ZVJvdzpuLHk6dCxvbklzc3VlS2V5VXBkYXRlZDpyLGppcmFVcmw6c30pLG8uZGF0ZXMubWFwKChhLGwpPT5rLmpzeChlcix7YWxpZ246ImNlbnRlciIsc3R5bGU6e3Bvc2l0aW9uOiJyZWxhdGl2ZSJ9LGNoaWxkcmVuOmsuanN4KG1PLHtob3VyOm8uaG91cnNbbF1bdF0sc2V0SG91cjp1PT5pKHt4OmwseTp0LGhvdXI6dX0pfSl9LGwrYS50b0lTT1N0cmluZygpKSksay5qc3goZXIse3N0eWxlOntmb250U2l6ZToyMCx0ZXh0QWxpZ246ImNlbnRlciIsbWluV2lkdGg6MTAwfSxjbGFzc05hbWU6InRvdGFsIixjaGlsZHJlbjpnTyhvLHQpfSldfSl9ZnVuY3Rpb24gdk8oe2RhdGE6ZSxyZW1vdmVSb3c6dCxvbklzc3VlS2V5VXBkYXRlZDpuLHNldEhvdXJWYWx1ZTpyLGppcmFVcmw6b30pe3JldHVybiBrLmpzeChzdSx7Y29tcG9uZW50Om51bGwsY2hpbGRyZW46ZS5pc3N1ZXMubWFwKChpLHMpPT5rLmpzeChHZix7dGltZW91dDoxZTMsY2xhc3NOYW1lczoiaXNzdWUtZWwiLGNoaWxkcmVuOmsuanN4KHlPLHtpc3N1ZTppLHk6cyxyZW1vdmVSb3c6dCxvbklzc3VlS2V5VXBkYXRlZDpuLGRhdGE6ZSxzZXRIb3VyVmFsdWU6cixqaXJhVXJsOm99KX0saS5yZWFjdEtleSkpfSl9dmFyIGljPXtleHBvcnRzOnt9fSxyZztmdW5jdGlvbiBaMCgpe3JldHVybiByZ3x8KHJnPTEsZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obixyKXtlLmV4cG9ydHM9cigpfSkoaWcsZnVuY3Rpb24oKXt2YXIgbj0xZTMscj02ZTQsbz0zNmU1LGk9Im1pbGxpc2Vjb25kIixzPSJzZWNvbmQiLGE9Im1pbnV0ZSIsbD0iaG91ciIsdT0iZGF5IixjPSJ3ZWVrIixkPSJtb250aCIsbT0icXVhcnRlciIsdj0ieWVhciIsdz0iZGF0ZSIsUz0iSW52YWxpZCBEYXRlIix4PS9eKFxkezR9KVstL10/KFxkezEsMn0pP1stL10/KFxkezAsMn0pW1R0XHNdKihcZHsxLDJ9KT86PyhcZHsxLDJ9KT86PyhcZHsxLDJ9KT9bLjpdPyhcZCspPyQvLGg9L1xbKFteXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxnPXtuYW1lOiJlbiIsd2Vla2RheXM6IlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Ii5zcGxpdCgiXyIpLG1vbnRoczoiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlciIuc3BsaXQoIl8iKSxvcmRpbmFsOmZ1bmN0aW9uKE4pe3ZhciBPPVsidGgiLCJzdCIsIm5kIiwicmQiXSxNPU4lMTAwO3JldHVybiJbIitOKyhPWyhNLTIwKSUxMF18fE9bTV18fE9bMF0pKyJdIn19LGY9ZnVuY3Rpb24oTixPLE0pe3ZhciBfPVN0cmluZyhOKTtyZXR1cm4hX3x8Xy5sZW5ndGg+PU8/TjoiIitBcnJheShPKzEtXy5sZW5ndGgpLmpvaW4oTSkrTn0seT17czpmLHo6ZnVuY3Rpb24oTil7dmFyIE89LU4udXRjT2Zmc2V0KCksTT1NYXRoLmFicyhPKSxfPU1hdGguZmxvb3IoTS82MCksVD1NJTYwO3JldHVybihPPD0wPyIrIjoiLSIpK2YoXywyLCIwIikrIjoiK2YoVCwyLCIwIil9LG06ZnVuY3Rpb24gTihPLE0pe2lmKE8uZGF0ZSgpPE0uZGF0ZSgpKXJldHVybi1OKE0sTyk7dmFyIF89MTIqKE0ueWVhcigpLU8ueWVhcigpKSsoTS5tb250aCgpLU8ubW9udGgoKSksVD1PLmNsb25lKCkuYWRkKF8sZCksQT1NLVQ8MCxEPU8uY2xvbmUoKS5hZGQoXysoQT8tMToxKSxkKTtyZXR1cm4rKC0oXysoTS1UKS8oQT9ULUQ6RC1UKSl8fDApfSxhOmZ1bmN0aW9uKE4pe3JldHVybiBOPDA/TWF0aC5jZWlsKE4pfHwwOk1hdGguZmxvb3IoTil9LHA6ZnVuY3Rpb24oTil7cmV0dXJue006ZCx5OnYsdzpjLGQ6dSxEOncsaDpsLG06YSxzLG1zOmksUTptfVtOXXx8U3RyaW5nKE58fCIiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLywiIil9LHU6ZnVuY3Rpb24oTil7cmV0dXJuIE49PT12b2lkIDB9fSxiPSJlbiIsRT17fTtFW2JdPWc7dmFyIFI9IiRpc0RheWpzT2JqZWN0IixQPWZ1bmN0aW9uKE4pe3JldHVybiBOIGluc3RhbmNlb2YgTHx8ISghTnx8IU5bUl0pfSxJPWZ1bmN0aW9uIE4oTyxNLF8pe3ZhciBUO2lmKCFPKXJldHVybiBiO2lmKHR5cGVvZiBPPT0ic3RyaW5nIil7dmFyIEE9Ty50b0xvd2VyQ2FzZSgpO0VbQV0mJihUPUEpLE0mJihFW0FdPU0sVD1BKTt2YXIgRD1PLnNwbGl0KCItIik7aWYoIVQmJkQubGVuZ3RoPjEpcmV0dXJuIE4oRFswXSl9ZWxzZXt2YXIgQj1PLm5hbWU7RVtCXT1PLFQ9Qn1yZXR1cm4hXyYmVCYmKGI9VCksVHx8IV8mJmJ9LHA9ZnVuY3Rpb24oTixPKXtpZihQKE4pKXJldHVybiBOLmNsb25lKCk7dmFyIE09dHlwZW9mIE89PSJvYmplY3QiP086e307cmV0dXJuIE0uZGF0ZT1OLE0uYXJncz1hcmd1bWVudHMsbmV3IEwoTSl9LCQ9eTskLmw9SSwkLmk9UCwkLnc9ZnVuY3Rpb24oTixPKXtyZXR1cm4gcChOLHtsb2NhbGU6Ty4kTCx1dGM6Ty4kdSx4Ok8uJHgsJG9mZnNldDpPLiRvZmZzZXR9KX07dmFyIEw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBOKE0pe3RoaXMuJEw9SShNLmxvY2FsZSxudWxsLCEwKSx0aGlzLnBhcnNlKE0pLHRoaXMuJHg9dGhpcy4keHx8TS54fHx7fSx0aGlzW1JdPSEwfXZhciBPPU4ucHJvdG90eXBlO3JldHVybiBPLnBhcnNlPWZ1bmN0aW9uKE0pe3RoaXMuJGQ9ZnVuY3Rpb24oXyl7dmFyIFQ9Xy5kYXRlLEE9Xy51dGM7aWYoVD09PW51bGwpcmV0dXJuIG5ldyBEYXRlKE5hTik7aWYoJC51KFQpKXJldHVybiBuZXcgRGF0ZTtpZihUIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gbmV3IERhdGUoVCk7aWYodHlwZW9mIFQ9PSJzdHJpbmciJiYhL1okL2kudGVzdChUKSl7dmFyIEQ9VC5tYXRjaCh4KTtpZihEKXt2YXIgQj1EWzJdLTF8fDAsSD0oRFs3XXx8IjAiKS5zdWJzdHJpbmcoMCwzKTtyZXR1cm4gQT9uZXcgRGF0ZShEYXRlLlVUQyhEWzFdLEIsRFszXXx8MSxEWzRdfHwwLERbNV18fDAsRFs2XXx8MCxIKSk6bmV3IERhdGUoRFsxXSxCLERbM118fDEsRFs0XXx8MCxEWzVdfHwwLERbNl18fDAsSCl9fXJldHVybiBuZXcgRGF0ZShUKX0oTSksdGhpcy5pbml0KCl9LE8uaW5pdD1mdW5jdGlvbigpe3ZhciBNPXRoaXMuJGQ7dGhpcy4keT1NLmdldEZ1bGxZZWFyKCksdGhpcy4kTT1NLmdldE1vbnRoKCksdGhpcy4kRD1NLmdldERhdGUoKSx0aGlzLiRXPU0uZ2V0RGF5KCksdGhpcy4kSD1NLmdldEhvdXJzKCksdGhpcy4kbT1NLmdldE1pbnV0ZXMoKSx0aGlzLiRzPU0uZ2V0U2Vjb25kcygpLHRoaXMuJG1zPU0uZ2V0TWlsbGlzZWNvbmRzKCl9LE8uJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuICR9LE8uaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvU3RyaW5nKCkhPT1TfSxPLmlzU2FtZT1mdW5jdGlvbihNLF8pe3ZhciBUPXAoTSk7cmV0dXJuIHRoaXMuc3RhcnRPZihfKTw9VCYmVDw9dGhpcy5lbmRPZihfKX0sTy5pc0FmdGVyPWZ1bmN0aW9uKE0sXyl7cmV0dXJuIHAoTSk8dGhpcy5zdGFydE9mKF8pfSxPLmlzQmVmb3JlPWZ1bmN0aW9uKE0sXyl7cmV0dXJuIHRoaXMuZW5kT2YoXyk8cChNKX0sTy4kZz1mdW5jdGlvbihNLF8sVCl7cmV0dXJuICQudShNKT90aGlzW19dOnRoaXMuc2V0KFQsTSl9LE8udW5peD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpLzFlMyl9LE8udmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLmdldFRpbWUoKX0sTy5zdGFydE9mPWZ1bmN0aW9uKE0sXyl7dmFyIFQ9dGhpcyxBPSEhJC51KF8pfHxfLEQ9JC5wKE0pLEI9ZnVuY3Rpb24ocmUsUSl7dmFyIGVlPSQudyhULiR1P0RhdGUuVVRDKFQuJHksUSxyZSk6bmV3IERhdGUoVC4keSxRLHJlKSxUKTtyZXR1cm4gQT9lZTplZS5lbmRPZih1KX0sSD1mdW5jdGlvbihyZSxRKXtyZXR1cm4gJC53KFQudG9EYXRlKClbcmVdLmFwcGx5KFQudG9EYXRlKCJzIiksKEE/WzAsMCwwLDBdOlsyMyw1OSw1OSw5OTldKS5zbGljZShRKSksVCl9LFY9dGhpcy4kVyxVPXRoaXMuJE0sWD10aGlzLiRELFc9InNldCIrKHRoaXMuJHU/IlVUQyI6IiIpO3N3aXRjaChEKXtjYXNlIHY6cmV0dXJuIEE/QigxLDApOkIoMzEsMTEpO2Nhc2UgZDpyZXR1cm4gQT9CKDEsVSk6QigwLFUrMSk7Y2FzZSBjOnZhciBKPXRoaXMuJGxvY2FsZSgpLndlZWtTdGFydHx8MCxvZT0oVjxKP1YrNzpWKS1KO3JldHVybiBCKEE/WC1vZTpYKyg2LW9lKSxVKTtjYXNlIHU6Y2FzZSB3OnJldHVybiBIKFcrIkhvdXJzIiwwKTtjYXNlIGw6cmV0dXJuIEgoVysiTWludXRlcyIsMSk7Y2FzZSBhOnJldHVybiBIKFcrIlNlY29uZHMiLDIpO2Nhc2UgczpyZXR1cm4gSChXKyJNaWxsaXNlY29uZHMiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LE8uZW5kT2Y9ZnVuY3Rpb24oTSl7cmV0dXJuIHRoaXMuc3RhcnRPZihNLCExKX0sTy4kc2V0PWZ1bmN0aW9uKE0sXyl7dmFyIFQsQT0kLnAoTSksRD0ic2V0IisodGhpcy4kdT8iVVRDIjoiIiksQj0oVD17fSxUW3VdPUQrIkRhdGUiLFRbd109RCsiRGF0ZSIsVFtkXT1EKyJNb250aCIsVFt2XT1EKyJGdWxsWWVhciIsVFtsXT1EKyJIb3VycyIsVFthXT1EKyJNaW51dGVzIixUW3NdPUQrIlNlY29uZHMiLFRbaV09RCsiTWlsbGlzZWNvbmRzIixUKVtBXSxIPUE9PT11P3RoaXMuJEQrKF8tdGhpcy4kVyk6XztpZihBPT09ZHx8QT09PXYpe3ZhciBWPXRoaXMuY2xvbmUoKS5zZXQodywxKTtWLiRkW0JdKEgpLFYuaW5pdCgpLHRoaXMuJGQ9Vi5zZXQodyxNYXRoLm1pbih0aGlzLiRELFYuZGF5c0luTW9udGgoKSkpLiRkfWVsc2UgQiYmdGhpcy4kZFtCXShIKTtyZXR1cm4gdGhpcy5pbml0KCksdGhpc30sTy5zZXQ9ZnVuY3Rpb24oTSxfKXtyZXR1cm4gdGhpcy5jbG9uZSgpLiRzZXQoTSxfKX0sTy5nZXQ9ZnVuY3Rpb24oTSl7cmV0dXJuIHRoaXNbJC5wKE0pXSgpfSxPLmFkZD1mdW5jdGlvbihNLF8pe3ZhciBULEE9dGhpcztNPU51bWJlcihNKTt2YXIgRD0kLnAoXyksQj1mdW5jdGlvbihVKXt2YXIgWD1wKEEpO3JldHVybiAkLncoWC5kYXRlKFguZGF0ZSgpK01hdGgucm91bmQoVSpNKSksQSl9O2lmKEQ9PT1kKXJldHVybiB0aGlzLnNldChkLHRoaXMuJE0rTSk7aWYoRD09PXYpcmV0dXJuIHRoaXMuc2V0KHYsdGhpcy4keStNKTtpZihEPT09dSlyZXR1cm4gQigxKTtpZihEPT09YylyZXR1cm4gQig3KTt2YXIgSD0oVD17fSxUW2FdPXIsVFtsXT1vLFRbc109bixUKVtEXXx8MSxWPXRoaXMuJGQuZ2V0VGltZSgpK00qSDtyZXR1cm4gJC53KFYsdGhpcyl9LE8uc3VidHJhY3Q9ZnVuY3Rpb24oTSxfKXtyZXR1cm4gdGhpcy5hZGQoLTEqTSxfKX0sTy5mb3JtYXQ9ZnVuY3Rpb24oTSl7dmFyIF89dGhpcyxUPXRoaXMuJGxvY2FsZSgpO2lmKCF0aGlzLmlzVmFsaWQoKSlyZXR1cm4gVC5pbnZhbGlkRGF0ZXx8Uzt2YXIgQT1NfHwiWVlZWS1NTS1ERFRISDptbTpzc1oiLEQ9JC56KHRoaXMpLEI9dGhpcy4kSCxIPXRoaXMuJG0sVj10aGlzLiRNLFU9VC53ZWVrZGF5cyxYPVQubW9udGhzLFc9VC5tZXJpZGllbSxKPWZ1bmN0aW9uKFEsZWUsWSx1ZSl7cmV0dXJuIFEmJihRW2VlXXx8UShfLEEpKXx8WVtlZV0uc2xpY2UoMCx1ZSl9LG9lPWZ1bmN0aW9uKFEpe3JldHVybiAkLnMoQiUxMnx8MTIsUSwiMCIpfSxyZT1XfHxmdW5jdGlvbihRLGVlLFkpe3ZhciB1ZT1RPDEyPyJBTSI6IlBNIjtyZXR1cm4gWT91ZS50b0xvd2VyQ2FzZSgpOnVlfTtyZXR1cm4gQS5yZXBsYWNlKGgsZnVuY3Rpb24oUSxlZSl7cmV0dXJuIGVlfHxmdW5jdGlvbihZKXtzd2l0Y2goWSl7Y2FzZSJZWSI6cmV0dXJuIFN0cmluZyhfLiR5KS5zbGljZSgtMik7Y2FzZSJZWVlZIjpyZXR1cm4gJC5zKF8uJHksNCwiMCIpO2Nhc2UiTSI6cmV0dXJuIFYrMTtjYXNlIk1NIjpyZXR1cm4gJC5zKFYrMSwyLCIwIik7Y2FzZSJNTU0iOnJldHVybiBKKFQubW9udGhzU2hvcnQsVixYLDMpO2Nhc2UiTU1NTSI6cmV0dXJuIEooWCxWKTtjYXNlIkQiOnJldHVybiBfLiREO2Nhc2UiREQiOnJldHVybiAkLnMoXy4kRCwyLCIwIik7Y2FzZSJkIjpyZXR1cm4gU3RyaW5nKF8uJFcpO2Nhc2UiZGQiOnJldHVybiBKKFQud2Vla2RheXNNaW4sXy4kVyxVLDIpO2Nhc2UiZGRkIjpyZXR1cm4gSihULndlZWtkYXlzU2hvcnQsXy4kVyxVLDMpO2Nhc2UiZGRkZCI6cmV0dXJuIFVbXy4kV107Y2FzZSJIIjpyZXR1cm4gU3RyaW5nKEIpO2Nhc2UiSEgiOnJldHVybiAkLnMoQiwyLCIwIik7Y2FzZSJoIjpyZXR1cm4gb2UoMSk7Y2FzZSJoaCI6cmV0dXJuIG9lKDIpO2Nhc2UiYSI6cmV0dXJuIHJlKEIsSCwhMCk7Y2FzZSJBIjpyZXR1cm4gcmUoQixILCExKTtjYXNlIm0iOnJldHVybiBTdHJpbmcoSCk7Y2FzZSJtbSI6cmV0dXJuICQucyhILDIsIjAiKTtjYXNlInMiOnJldHVybiBTdHJpbmcoXy4kcyk7Y2FzZSJzcyI6cmV0dXJuICQucyhfLiRzLDIsIjAiKTtjYXNlIlNTUyI6cmV0dXJuICQucyhfLiRtcywzLCIwIik7Y2FzZSJaIjpyZXR1cm4gRH1yZXR1cm4gbnVsbH0oUSl8fEQucmVwbGFjZSgiOiIsIiIpfSl9LE8udXRjT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE1Ki1NYXRoLnJvdW5kKHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSl9LE8uZGlmZj1mdW5jdGlvbihNLF8sVCl7dmFyIEEsRD10aGlzLEI9JC5wKF8pLEg9cChNKSxWPShILnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKnIsVT10aGlzLUgsWD1mdW5jdGlvbigpe3JldHVybiAkLm0oRCxIKX07c3dpdGNoKEIpe2Nhc2UgdjpBPVgoKS8xMjticmVhaztjYXNlIGQ6QT1YKCk7YnJlYWs7Y2FzZSBtOkE9WCgpLzM7YnJlYWs7Y2FzZSBjOkE9KFUtVikvNjA0OGU1O2JyZWFrO2Nhc2UgdTpBPShVLVYpLzg2NGU1O2JyZWFrO2Nhc2UgbDpBPVUvbzticmVhaztjYXNlIGE6QT1VL3I7YnJlYWs7Y2FzZSBzOkE9VS9uO2JyZWFrO2RlZmF1bHQ6QT1VfXJldHVybiBUP0E6JC5hKEEpfSxPLmRheXNJbk1vbnRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kT2YoZCkuJER9LE8uJGxvY2FsZT1mdW5jdGlvbigpe3JldHVybiBFW3RoaXMuJExdfSxPLmxvY2FsZT1mdW5jdGlvbihNLF8pe2lmKCFNKXJldHVybiB0aGlzLiRMO3ZhciBUPXRoaXMuY2xvbmUoKSxBPUkoTSxfLCEwKTtyZXR1cm4gQSYmKFQuJEw9QSksVH0sTy5jbG9uZT1mdW5jdGlvbigpe3JldHVybiAkLncodGhpcy4kZCx0aGlzKX0sTy50b0RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpfSxPLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzVmFsaWQoKT90aGlzLnRvSVNPU3RyaW5nKCk6bnVsbH0sTy50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvSVNPU3RyaW5nKCl9LE8udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b1VUQ1N0cmluZygpfSxOfSgpLGo9TC5wcm90b3R5cGU7cmV0dXJuIHAucHJvdG90eXBlPWosW1siJG1zIixpXSxbIiRzIixzXSxbIiRtIixhXSxbIiRIIixsXSxbIiRXIix1XSxbIiRNIixkXSxbIiR5Iix2XSxbIiREIix3XV0uZm9yRWFjaChmdW5jdGlvbihOKXtqW05bMV1dPWZ1bmN0aW9uKE8pe3JldHVybiB0aGlzLiRnKE8sTlswXSxOWzFdKX19KSxwLmV4dGVuZD1mdW5jdGlvbihOLE8pe3JldHVybiBOLiRpfHwoTihPLEwscCksTi4kaT0hMCkscH0scC5sb2NhbGU9SSxwLmlzRGF5anM9UCxwLnVuaXg9ZnVuY3Rpb24oTil7cmV0dXJuIHAoMWUzKk4pfSxwLmVuPUVbYl0scC5Mcz1FLHAucD17fSxwfSl9KGljKSksaWMuZXhwb3J0c312YXIgd089WjAoKTtjb25zdCBKMD1SZCh3Tyk7dmFyIFNPPXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24obixyKXtlLmV4cG9ydHM9cihaMCgpKX0pKGlnLGZ1bmN0aW9uKG4pe2Z1bmN0aW9uIHIocyl7cmV0dXJuIHMmJnR5cGVvZiBzPT0ib2JqZWN0IiYmImRlZmF1bHQiaW4gcz9zOntkZWZhdWx0OnN9fXZhciBvPXIobiksaT17bmFtZToiZnIiLHdlZWtkYXlzOiJkaW1hbmNoZV9sdW5kaV9tYXJkaV9tZXJjcmVkaV9qZXVkaV92ZW5kcmVkaV9zYW1lZGkiLnNwbGl0KCJfIiksd2Vla2RheXNTaG9ydDoiZGltLl9sdW4uX21hci5fbWVyLl9qZXUuX3Zlbi5fc2FtLiIuc3BsaXQoIl8iKSx3ZWVrZGF5c01pbjoiZGlfbHVfbWFfbWVfamVfdmVfc2EiLnNwbGl0KCJfIiksbW9udGhzOiJqYW52aWVyX2bDqXZyaWVyX21hcnNfYXZyaWxfbWFpX2p1aW5fanVpbGxldF9hb8O7dF9zZXB0ZW1icmVfb2N0b2JyZV9ub3ZlbWJyZV9kw6ljZW1icmUiLnNwbGl0KCJfIiksbW9udGhzU2hvcnQ6ImphbnYuX2bDqXZyLl9tYXJzX2F2ci5fbWFpX2p1aW5fanVpbC5fYW/Du3Rfc2VwdC5fb2N0Ll9ub3YuX2TDqWMuIi5zcGxpdCgiXyIpLHdlZWtTdGFydDoxLHllYXJTdGFydDo0LGZvcm1hdHM6e0xUOiJISDptbSIsTFRTOiJISDptbTpzcyIsTDoiREQvTU0vWVlZWSIsTEw6IkQgTU1NTSBZWVlZIixMTEw6IkQgTU1NTSBZWVlZIEhIOm1tIixMTExMOiJkZGRkIEQgTU1NTSBZWVlZIEhIOm1tIn0scmVsYXRpdmVUaW1lOntmdXR1cmU6ImRhbnMgJXMiLHBhc3Q6ImlsIHkgYSAlcyIsczoicXVlbHF1ZXMgc2Vjb25kZXMiLG06InVuZSBtaW51dGUiLG1tOiIlZCBtaW51dGVzIixoOiJ1bmUgaGV1cmUiLGhoOiIlZCBoZXVyZXMiLGQ6InVuIGpvdXIiLGRkOiIlZCBqb3VycyIsTToidW4gbW9pcyIsTU06IiVkIG1vaXMiLHk6InVuIGFuIix5eToiJWQgYW5zIn0sb3JkaW5hbDpmdW5jdGlvbihzKXtyZXR1cm4iIitzKyhzPT09MT8iZXIiOiIiKX19O3JldHVybiBvLmRlZmF1bHQubG9jYWxlKGksbnVsbCwhMCksaX0pfSkoU08pO25hdmlnYXRvci5sYW5ndWFnZT09PSJmci1GUiImJkowLmxvY2FsZSgiZnIiKTtjb25zdCB4Tz0oe2RhdGU6ZSwuLi50fSk9PmsuanN4cyhrLkZyYWdtZW50LHtjaGlsZHJlbjpbay5qc3gobW4se2NsYXNzTmFtZToid29ya0xvZ0RhdGUiLHR5cGU6ImRhdGUiLHZhbHVlOmUudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwxMCksc3R5bGU6e21heFdpZHRoOjE0MH0sLi4udH0pLGsuanN4KCJkaXYiLHtzdHlsZTp7Zm9udFNpemU6MjAsbWFyZ2luVG9wOjR9LGNoaWxkcmVuOkowKGUpLmZvcm1hdCgiZGRkZCIpfSldfSk7ZnVuY3Rpb24gQ08oe3g6ZSxkYXRlOnQscmVtb3ZlQ29sdW1uOm4sc2V0RGF0ZVZhbHVlOnJ9KXtyZXR1cm4gay5qc3hzKGVyLHthbGlnbjoiY2VudGVyIixjaGlsZHJlbjpbay5qc3goWmYse2NvbG9yOiJzZWNvbmRhcnkiLG9uQ2xpY2s6KCk9Pm4oe251bTplfSksY2hpbGRyZW46ay5qc3goZHAse2ZvbnRTaXplOiJsYXJnZSJ9KX0pLGsuanN4KHhPLHtkYXRlOnQsb25DaGFuZ2U6bz0+cih7bnVtOmUsZGF0ZTpuZXcgRGF0ZShvLnRhcmdldC52YWx1ZSl9KX0pXX0pfWZ1bmN0aW9uIGJPKHtkYXRhOmUscmVtb3ZlQ29sdW1uOnQsc2V0RGF0ZVZhbHVlOm4sYWRkQ29sdW1uOnJ9KXtyZXR1cm4gay5qc3gocVAse2NoaWxkcmVuOmsuanN4cyhjcCx7Y2hpbGRyZW46W2suanN4KGVyLHtjaGlsZHJlbjprLmpzeCgiZGl2Iix7c3R5bGU6e21pbldpZHRoOjEwMCxtaW5IZWlnaHQ6NTB9LGNoaWxkcmVuOiLCoCJ9KX0pLGUuZGF0ZXMubWFwKChvLGkpPT5DLmNyZWF0ZUVsZW1lbnQoQ08se3g6aSxkYXRlOm8scmVtb3ZlQ29sdW1uOnQsc2V0RGF0ZVZhbHVlOm4sa2V5Omkrby50b0lTT1N0cmluZygpfSkpLGsuanN4KGVyLHtzdHlsZTp7Zm9udFNpemU6MjAsdGV4dEFsaWduOiJjZW50ZXIifSxjbGFzc05hbWU6ImFkZC1idXR0b24iLGNoaWxkcmVuOmsuanN4KHp0LHtjb2xvcjoicHJpbWFyeSIsb25DbGljazpyLGNoaWxkcmVuOmsuanN4KHB1LHtzdHlsZTp7Zm9udFNpemU6NDB9fSl9KX0pXX0pfSl9Y29uc3Qga089KHtkYXRhOmUsY29uZmlnOnQsd29ya3NMb2dnZWQ6bixhZGRSb3c6cixhZGRDb2x1bW46byxyZW1vdmVDb2x1bW46aSxyZW1vdmVSb3c6cyxzZXREYXRlVmFsdWU6YSxzZXRIb3VyVmFsdWU6bCxvbklzc3VlS2V5VXBkYXRlZDp1fSk9PmsuanN4KEtQLHtjb21wb25lbnQ6WGYsZWxldmF0aW9uOjMsY2hpbGRyZW46ay5qc3hzKE5QLHtzdGlja3lIZWFkZXI6ITAsc2l6ZToic21hbGwiLHN0eWxlOntvdmVyZmxvdzoiaGlkZGVuIn0sY2hpbGRyZW46W2suanN4KGJPLHtkYXRhOmUscmVtb3ZlQ29sdW1uOmksc2V0RGF0ZVZhbHVlOmEsYWRkQ29sdW1uOm99KSxrLmpzeHMoalAse2NoaWxkcmVuOltrLmpzeCh2Tyx7ZGF0YTplLHJlbW92ZVJvdzpzLG9uSXNzdWVLZXlVcGRhdGVkOnUsc2V0SG91clZhbHVlOmwsamlyYVVybDp0LmppcmFVcmx9KSxrLmpzeCh1Tyx7YWRkUm93OnIsZGF0YTplLHdvcmtzTG9nZ2VkOm59KV19KV19KX0pLEVPPWhzKGU9PmUsey4uLml0LG9uSXNzdWVLZXlVcGRhdGVkOnRPfSkoa08pO2FzeW5jIGZ1bmN0aW9uIFJPKCl7YXdhaXQgZmV0Y2goIi9hcGkvc3RvcCIse21ldGhvZDoiUE9TVCIsbW9kZToibm8tY29ycyJ9KSx3aW5kb3cub3BlbigiYWJvdXQ6YmxhbmsiLCJfc2VsZiIpLHdpbmRvdy5jbG9zZSgpfWNvbnN0IFRPPXtDTE9TRToiVGhlIGJhY2tlbmQgc2VydmVyIGlzIERPV04iLEVSUk9SOiJUaGUgYmFja2VuZCBzZXJ2ZXIgc3RhdHVzIGlzIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lICh1c2UgdGhlIC0td2FpdC1hbmQtY2xvc2UgcGFyYW1ldGVyKSBvciB0aGUgc2VydmVyIHdhcyBET1dOIGV2ZW4gYmVmb3JlIG9wZW5pbmcgdGhlIHBhZ2UiLE9QRU46IlRoZSBiYWNrZW5kIHNlcnZlciBpcyBjdXJyZW50bHkgVVAgYW5kIGNvbm5lY3RlZCIsVU5ERUZJTkVEOiJUaGUgYmFja2VuZCBzZXJ2ZXIgc3RhdHVzIGlzIHVuZGVmaW5lZCJ9LFBPPSh7d2Vic29ja2V0U3RhdGU6ZX0pPT5rLmpzeChrLkZyYWdtZW50LHtjaGlsZHJlbjplPT09IkNMT1NFIj9rLmpzeCh6aCx7dGl0bGU6IlJlc3RhcnQgdGhlIHNlcnZlciwgYW5kIHRoZW4gcmVmcmVzaCB0aGUgcGFnZSIsY2hpbGRyZW46ay5qc3hzKHp0LHt2YXJpYW50OiJjb250YWluZWQiLGNvbG9yOiJzZWNvbmRhcnkiLGNoaWxkcmVuOltrLmpzeChhJCx7c3R5bGU6e21hcmdpblJpZ2h0OjEwfX0pLCJUaGUgYmFja2VuZCBTZXJ2ZXIgaXMgZG93biAhIl19KX0pOmsuanN4KHpoLHt0aXRsZTpUT1tlXSxjaGlsZHJlbjprLmpzeHMoenQse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsc2l6ZToic21hbGwiLG9uQ2xpY2s6Uk8sY2hpbGRyZW46W2suanN4KHAkLHt9KSwiIFN0b3AgdGhlIFdlYiBBcHAiLCIgIixlPT09Ik9QRU4iP2suanN4KGkkLHtzdHlsZTp7Zm9udFNpemU6MjAsbWFyZ2luTGVmdDoxMCxjb2xvcjoiZ3JlZW4ifX0pOiIiXX0pfSl9KTtmdW5jdGlvbiAkTyh7Y2xlYXJEYXRhOmUsYWRkTGFzdDVEYXlzOnQsaGFtc3RlckltcG9ydDpuLGNyZWF0ZVdvcmtMb2dzOnIsY29uZmlnOm8sd2Vic29ja2V0U3RhdGU6aSxsb2dUaGlzV29ya0luUHJvZ3Jlc3M6c30pe3JldHVybiBrLmpzeHMoImRpdiIse2NsYXNzTmFtZToiYnRuLXBhcnQiLGNoaWxkcmVuOltrLmpzeHMoenQse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsc2l6ZToic21hbGwiLG9uQ2xpY2s6ZSxjaGlsZHJlbjpbay5qc3goZHAse30pLCIgQ2xlYXIgdGhlIGRhdGEiXX0pLGsuanN4cyh6dCx7dmFyaWFudDoiY29udGFpbmVkIixzaXplOiJzbWFsbCIsb25DbGljazp0LGNoaWxkcmVuOltrLmpzeChwdSx7fSksIiBhZGQgbGFzdCA1IGRheXMiXX0pLGsuanN4cyh6dCx7dmFyaWFudDoiY29udGFpbmVkIixzaXplOiJzbWFsbCIsb25DbGljazpuLGNoaWxkcmVuOltrLmpzeChsJCx7fSksIiBJbXBvcnQgZnJvbSBIYW1zdGVyIl19KSxrLmpzeHMoenQse3ZhcmlhbnQ6ImNvbnRhaW5lZCIsY29sb3I6InByaW1hcnkiLG9uQ2xpY2s6cixkaXNhYmxlZDpzLGNoaWxkcmVuOltrLmpzeChmJCx7fSksIiBMb2cgdGhpcyB3b3JrIGxvZ3MiXX0pLGsuanN4KFBPLHt3ZWJzb2NrZXRTdGF0ZTppfSksay5qc3goWmYse3RhcmdldDoiX2JsYW5rIixocmVmOmAke289PW51bGw/dm9pZCAwOm8uamlyYVVybH0vc2VjdXJlL1RpbWVzaGVldFJlcG9ydC5qc3BhP3JlcG9ydEtleT1qaXJhLXRpbWVzaGVldC1wbHVnaW46cmVwb3J0JnBhZ2U9MSZ3ZWVrZW5kcz10cnVlJnNob3dEZXRhaWxzPXRydWUmcmVwb3J0aW5nRGF5PTEmbnVtT2ZXZWVrcz0xJm9mZnNldD0wJnN1bT1kYXkmdGFyZ2V0VXNlcj0ke289PW51bGw/dm9pZCAwOm8udXNlcm5hbWV9fWAsY2hpbGRyZW46ay5qc3godSQse30pfSldfSl9Y29uc3QgT089KCk9PmFzeW5jKGUsdCk9PntlKGl0LnNldExvZ1RoaXNXb3JrSW5Qcm9ncmVzcyh7bmV3TG9nVGhpc1dvcmtJblByb2dyZXNzOiEwfSkpO3RyeXtjb25zdCBuPXQoKS5kYXRhLmlzc3Vlcy5tYXAoKHIsbyk9Pih7aXNzdWU6cix5Om99KSkuZmlsdGVyKCh7aXNzdWU6cn0pPT5yLmtleS5tYXRjaCgvXltBLVphLXowLTldKy1bMC05XSskLykpLmZsYXRNYXAoKHtpc3N1ZTpyLHk6b30pPT50KCkuZGF0YS5kYXRlcy5tYXAoKGkscyk9Pih7aXNzdWU6cixkYXRlOmksaG91cnM6dCgpLmRhdGEuaG91cnNbc11bb119KSkpLmZpbHRlcigoe2hvdXJzOnJ9KT0+cj4wKS5tYXAoKHtpc3N1ZTpyLGRhdGU6byxob3VyczppfSk9Pih7a2V5OnIua2V5LGNvbW1lbnQ6ci53b3JrTG9nQ29tbWVudHx8IiIsZGF0ZTpvLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDAsMTApLGhvdXJzOml9KSk7YXdhaXQgZmV0Y2goIi9hcGkvY3JlYXRlV29ya0xvZ3MiLHttZXRob2Q6IlBPU1QiLG1vZGU6Im5vLWNvcnMiLGJvZHk6SlNPTi5zdHJpbmdpZnkoe2NvbmZpZzp0KCkuY29uZmlnLHRvTG9nOm59KX0pLGUoaXQuc2V0V29ya3NMb2dnZWQoe3dvcmtzTG9nZ2VkOnowKGF3YWl0IHlkKHQoKS5jb25maWcpLHQoKS5jb25maWcudXNlcm5hbWUpfSkpLGUoaXQucmVzZXRIb3VycygpKX1maW5hbGx5e2UoaXQuc2V0TG9nVGhpc1dvcmtJblByb2dyZXNzKHtuZXdMb2dUaGlzV29ya0luUHJvZ3Jlc3M6ITF9KSl9fSxNTz1ocyhlPT5lLHsuLi5pdCxoYW1zdGVySW1wb3J0Om5PLGNyZWF0ZVdvcmtMb2dzOk9PfSkoJE8pO2Z1bmN0aW9uIF9PKCl7cmV0dXJuIGsuanN4cygiZGl2Iix7Y2xhc3NOYW1lOiJtYWluIixjaGlsZHJlbjpbay5qc3goTU8se30pLGsuanN4KEVPLHt9KSxrLmpzeChvTyx7fSksay5qc3goc08se30pXX0pfWNvbnN0IE5PPWhzKGU9PmUsaXQpKF9PKTt2YXIgZTEsb2c9WWY7ZTE9b2cuY3JlYXRlUm9vdCxvZy5oeWRyYXRlUm9vdDtjb25zdCBJTz1gd3M6Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfWFwaS9ldmVudHMtd3NgO2Z1bmN0aW9uIHQxKCl7Y29uc3QgZT1uZXcgV2ViU29ja2V0KElPKTtlLmFkZEV2ZW50TGlzdGVuZXIoIm9wZW4iLHQ9Pntjb25zb2xlLmxvZygiV2ViU29ja2V0OiBvcGVuIiksd2EuZGlzcGF0Y2goaXQud2Vic29ja2V0U3RhdHVzQ2hhbmdlKHt3ZWJzb2NrZXRTdGF0ZToiT1BFTiJ9KSl9KSxlLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLHQ9Pntjb25zb2xlLmxvZygiV2ViU29ja2V0OiBtZXNzYWdlIGZyb20gc2VydmVyIil9KSxlLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIix0PT57Y29uc29sZS5sb2coIldlYlNvY2tldDogZXJyb3IgZXZlbnQiLHQpLHdhLmRpc3BhdGNoKGl0LndlYnNvY2tldFN0YXR1c0NoYW5nZSh7d2Vic29ja2V0U3RhdGU6IkVSUk9SIn0pKX0pLGUuYWRkRXZlbnRMaXN0ZW5lcigiY2xvc2UiLHQ9Pntjb25zb2xlLmxvZygiV2ViU29ja2V0OiBjbG9zZSBldmVudCIsdCksd2EuZGlzcGF0Y2goaXQud2Vic29ja2V0U3RhdHVzQ2hhbmdlKHt3ZWJzb2NrZXRTdGF0ZToiQ0xPU0UifSkpLGNvbnNvbGUubG9nKCJSZXRyeSBXUyIpLHNldFRpbWVvdXQoKCk9PnQxKCksMWUzKX0pfXQxKCk7Y29uc3QgQU89ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoInJvb3QiKSx6Tz1lMShBTyk7ek8ucmVuZGVyKGsuanN4KCR3LHtzdG9yZTp3YSxjaGlsZHJlbjprLmpzeChOTyx7fSl9KSk7Cg=="
  },
  "/favicon.ico": {
    type: "image/vnd.microsoft.icon",
    route: "/favicon.ico",
    content: "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"
  },
  "/index.html": {
    type: "text/html; charset=UTF-8",
    route: "/index.html",
    content: "PCFkb2N0eXBlIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgPG1ldGEgY2hhcnNldD0iVVRGLTgiLz4KICA8bGluayByZWw9Imljb24iIHR5cGU9ImltYWdlL3N2Zyt4bWwiIGhyZWY9Ii92aXRlLnN2ZyIvPgogIDxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wIi8+CiAgPHRpdGxlPkppcmEtV29yay1Mb2dnZXItZ2l0aHViPC90aXRsZT4KICA8c2NyaXB0IHR5cGU9Im1vZHVsZSIgY3Jvc3NvcmlnaW4gc3JjPSIvYXNzZXRzL2luZGV4LXB6TFhnRFl1LmpzIj48L3NjcmlwdD4KICA8bGluayByZWw9InN0eWxlc2hlZXQiIGNyb3Nzb3JpZ2luIGhyZWY9Ii9hc3NldHMvaW5kZXgtQzJCcHJUNUUuY3NzIj4KPC9oZWFkPgo8Ym9keT4KPGRpdiBpZD0icm9vdCI+PC9kaXY+CjwvYm9keT4KPC9odG1sPgo="
  }
};
var { Deno: Deno5 } = globalThis;
var noColor4 = typeof Deno5?.noColor === "boolean" ? Deno5.noColor : false;
var enabled3 = !noColor4;
function code3(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run3(str, code4) {
  return enabled3 ? `${code4.open}${str.replace(code4.regexp, code4.open)}${code4.close}` : str;
}
function bold4(str) {
  return run3(str, code3([1], 22));
}
function italic2(str) {
  return run3(str, code3([3], 23));
}
function red3(str) {
  return run3(str, code3([31], 39));
}
function green3(str) {
  return run3(str, code3([32], 39));
}
function yellow2(str) {
  return run3(str, code3([33], 39));
}
function blue2(str) {
  return run3(str, code3([34], 39));
}
function cyan2(str) {
  return run3(str, code3([36], 39));
}
function white3(str) {
  return run3(str, code3([37], 39));
}
function gray4(str) {
  return brightBlack3(str);
}
function brightBlack3(str) {
  return run3(str, code3([90], 39));
}
var ANSI_PATTERN4 = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
function assertPath2(path) {
  if (typeof path !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path)}`
    );
  }
}
function stripSuffix2(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i = suffix.length - 1; i >= 0; --i) {
    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}
function lastPathSegment2(path, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path.length;
  for (let i = path.length - 1; i >= start; --i) {
    if (isSep(path.charCodeAt(i))) {
      if (matchedNonSeparator) {
        start = i + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i + 1;
    }
  }
  return path.slice(start, end);
}
function assertArgs3(path, suffix) {
  assertPath2(path);
  if (path.length === 0) return path;
  if (typeof suffix !== "string") {
    throw new TypeError(
      `Suffix must be a string. Received ${JSON.stringify(suffix)}`
    );
  }
}
var CHAR_UPPERCASE_A2 = 65;
var CHAR_LOWERCASE_A2 = 97;
var CHAR_UPPERCASE_Z2 = 90;
var CHAR_LOWERCASE_Z2 = 122;
var CHAR_DOT2 = 46;
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_BACKWARD_SLASH2 = 92;
var CHAR_COLON2 = 58;
function stripTrailingSeparators2(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i = segment.length - 1; i > 0; i--) {
    if (isSep(segment.charCodeAt(i))) {
      end = i;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}
function isPosixPathSeparator3(code4) {
  return code4 === CHAR_FORWARD_SLASH2;
}
function isPathSeparator2(code4) {
  return code4 === CHAR_FORWARD_SLASH2 || code4 === CHAR_BACKWARD_SLASH2;
}
function isWindowsDeviceRoot2(code4) {
  return code4 >= CHAR_LOWERCASE_A2 && code4 <= CHAR_LOWERCASE_Z2 || code4 >= CHAR_UPPERCASE_A2 && code4 <= CHAR_UPPERCASE_Z2;
}
function basename4(path, suffix = "") {
  assertArgs3(path, suffix);
  let start = 0;
  if (path.length >= 2) {
    const drive = path.charCodeAt(0);
    if (isWindowsDeviceRoot2(drive)) {
      if (path.charCodeAt(1) === CHAR_COLON2) start = 2;
    }
  }
  const lastSegment = lastPathSegment2(path, isPathSeparator2, start);
  const strippedSegment = stripTrailingSeparators2(lastSegment, isPathSeparator2);
  return suffix ? stripSuffix2(strippedSegment, suffix) : strippedSegment;
}
var SEPARATOR4 = "\\";
var SEPARATOR_PATTERN4 = /[\\/]+/;
function assertArg5(path) {
  assertPath2(path);
  if (path.length === 0) return ".";
}
function dirname4(path) {
  assertArg5(path);
  const len = path.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code4 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code4)) {
      rootEnd = offset = 1;
      if (isPathSeparator2(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return path;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code4)) {
      if (path.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator2(path.charCodeAt(2))) rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator2(code4)) {
    return path;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator2(path.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1) return ".";
    else end = rootEnd;
  }
  return stripTrailingSeparators2(path.slice(0, end), isPosixPathSeparator3);
}
function extname4(path) {
  assertPath2(path);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON2 && isWindowsDeviceRoot2(path.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path.length - 1; i >= start; --i) {
    const code4 = path.charCodeAt(i);
    if (isPathSeparator2(code4)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code4 === CHAR_DOT2) {
      if (startDot === -1) startDot = i;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function assertArg7(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return url;
}
function fromFileUrl4(url) {
  url = assertArg7(url);
  let path = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path = `\\\\${url.hostname}${path}`;
  }
  return path;
}
function isAbsolute4(path) {
  assertPath2(path);
  const len = path.length;
  if (len === 0) return false;
  const code4 = path.charCodeAt(0);
  if (isPathSeparator2(code4)) {
    return true;
  } else if (isWindowsDeviceRoot2(code4)) {
    if (len > 2 && path.charCodeAt(1) === CHAR_COLON2) {
      if (isPathSeparator2(path.charCodeAt(2))) return true;
    }
  }
  return false;
}
function assertArg8(path) {
  assertPath2(path);
  if (path.length === 0) return ".";
}
function normalizeString2(path, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code4;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) code4 = path.charCodeAt(i);
    else if (isPathSeparator3(code4)) break;
    else code4 = CHAR_FORWARD_SLASH2;
    if (isPathSeparator3(code4)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT2 || res.charCodeAt(res.length - 2) !== CHAR_DOT2) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += `${separator}..`;
          else res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
        else res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code4 === CHAR_DOT2 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function normalize4(path) {
  assertArg8(path);
  const len = path.length;
  let rootEnd = 0;
  let device;
  let isAbsolute7 = false;
  const code4 = path.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code4)) {
      isAbsolute7 = true;
      if (isPathSeparator2(path.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path.charCodeAt(j))) break;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path.charCodeAt(j))) break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot2(code4)) {
      if (path.charCodeAt(1) === CHAR_COLON2) {
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path.charCodeAt(2))) {
            isAbsolute7 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator2(code4)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString2(
      path.slice(rootEnd),
      !isAbsolute7,
      "\\",
      isPathSeparator2
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute7) tail = ".";
  if (tail.length > 0 && isPathSeparator2(path.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute7) {
      if (tail.length > 0) return `\\${tail}`;
      else return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute7) {
    if (tail.length > 0) return `${device}\\${tail}`;
    else return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function join4(...paths) {
  if (paths.length === 0) return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < paths.length; ++i) {
    const path = paths[i];
    assertPath2(path);
    if (path.length > 0) {
      if (joined === void 0) joined = firstPart = path;
      else joined += `\\${path}`;
    }
  }
  if (joined === void 0) return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert2(firstPart !== null);
  if (isPathSeparator2(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator2(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
    }
    if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize4(joined);
}
function resolve4(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path;
    const { Deno: Deno6 } = globalThis;
    if (i >= 0) {
      path = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno6?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path = Deno6.cwd();
    } else {
      if (typeof Deno6?.env?.get !== "function" || typeof Deno6?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path = Deno6.cwd();
      if (path === void 0 || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path = `${resolvedDevice}\\`;
      }
    }
    assertPath2(path);
    const len = path.length;
    if (len === 0) continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute7 = false;
    const code4 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator2(code4)) {
        isAbsolute7 = true;
        if (isPathSeparator2(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator2(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator2(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator2(path.charCodeAt(j))) break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot2(code4)) {
        if (path.charCodeAt(1) === CHAR_COLON2) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator2(path.charCodeAt(2))) {
              isAbsolute7 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator2(code4)) {
      rootEnd = 1;
      isAbsolute7 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute7;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0) break;
  }
  resolvedTail = normalizeString2(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator2
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function assertArgs4(from, to) {
  assertPath2(from);
  assertPath2(to);
  if (from === to) return "";
}
function relative4(from, to) {
  assertArgs4(from, to);
  const fromOrig = resolve4(from);
  const toOrig = resolve4(to);
  if (fromOrig === toOrig) return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to) return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH2) break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH2) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH2) break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH2) break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH2) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH2) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode) break;
    else if (fromCode === CHAR_BACKWARD_SLASH2) lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1) lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH2) {
      if (out.length === 0) out += "..";
      else out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH2) ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
var WHITESPACE_ENCODINGS2 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace2(string) {
  return string.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS2[c] ?? c;
  });
}
function toFileUrl4(path) {
  if (!isAbsolute4(path)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
  if (hostname !== void 0 && hostname !== "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}
var regExpEscapeChars = [
  "!",
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "=",
  "?",
  "[",
  "\\",
  "^",
  "{",
  "|"
];
var rangeEscapeChars = ["-", "\\", "]"];
function _globToRegExp2(c, glob, {
  extended = true,
  globstar: globstarOption = true,
  // os = osType,
  caseInsensitive = false
} = {}) {
  if (glob === "") {
    return /(?!)/;
  }
  let newLength = glob.length;
  for (; newLength > 1 && c.seps.includes(glob[newLength - 1]); newLength--) ;
  glob = glob.slice(0, newLength);
  let regExpString = "";
  for (let j = 0; j < glob.length; ) {
    let segment = "";
    const groupStack = [];
    let inRange = false;
    let inEscape = false;
    let endsWithSep = false;
    let i = j;
    for (; i < glob.length && !c.seps.includes(glob[i]); i++) {
      if (inEscape) {
        inEscape = false;
        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
        segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        continue;
      }
      if (glob[i] === c.escapePrefix) {
        inEscape = true;
        continue;
      }
      if (glob[i] === "[") {
        if (!inRange) {
          inRange = true;
          segment += "[";
          if (glob[i + 1] === "!") {
            i++;
            segment += "^";
          } else if (glob[i + 1] === "^") {
            i++;
            segment += "\\^";
          }
          continue;
        } else if (glob[i + 1] === ":") {
          let k = i + 1;
          let value = "";
          while (glob[k + 1] !== void 0 && glob[k + 1] !== ":") {
            value += glob[k + 1];
            k++;
          }
          if (glob[k + 1] === ":" && glob[k + 2] === "]") {
            i = k + 2;
            if (value === "alnum") segment += "\\dA-Za-z";
            else if (value === "alpha") segment += "A-Za-z";
            else if (value === "ascii") segment += "\0-\x7F";
            else if (value === "blank") segment += "	 ";
            else if (value === "cntrl") segment += "\0-\x7F";
            else if (value === "digit") segment += "\\d";
            else if (value === "graph") segment += "!-~";
            else if (value === "lower") segment += "a-z";
            else if (value === "print") segment += " -~";
            else if (value === "punct") {
              segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_\u2018{|}~`;
            } else if (value === "space") segment += "\\s\v";
            else if (value === "upper") segment += "A-Z";
            else if (value === "word") segment += "\\w";
            else if (value === "xdigit") segment += "\\dA-Fa-f";
            continue;
          }
        }
      }
      if (glob[i] === "]" && inRange) {
        inRange = false;
        segment += "]";
        continue;
      }
      if (inRange) {
        if (glob[i] === "\\") {
          segment += `\\\\`;
        } else {
          segment += glob[i];
        }
        continue;
      }
      if (glob[i] === ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
        segment += ")";
        const type2 = groupStack.pop();
        if (type2 === "!") {
          segment += c.wildcard;
        } else if (type2 !== "@") {
          segment += type2;
        }
        continue;
      }
      if (glob[i] === "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] === "+" && extended && glob[i + 1] === "(") {
        i++;
        groupStack.push("+");
        segment += "(?:";
        continue;
      }
      if (glob[i] === "@" && extended && glob[i + 1] === "(") {
        i++;
        groupStack.push("@");
        segment += "(?:";
        continue;
      }
      if (glob[i] === "?") {
        if (extended && glob[i + 1] === "(") {
          i++;
          groupStack.push("?");
          segment += "(?:";
        } else {
          segment += ".";
        }
        continue;
      }
      if (glob[i] === "!" && extended && glob[i + 1] === "(") {
        i++;
        groupStack.push("!");
        segment += "(?!";
        continue;
      }
      if (glob[i] === "{") {
        groupStack.push("BRACE");
        segment += "(?:";
        continue;
      }
      if (glob[i] === "}" && groupStack[groupStack.length - 1] === "BRACE") {
        groupStack.pop();
        segment += ")";
        continue;
      }
      if (glob[i] === "," && groupStack[groupStack.length - 1] === "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] === "*") {
        if (extended && glob[i + 1] === "(") {
          i++;
          groupStack.push("*");
          segment += "(?:";
        } else {
          const prevChar = glob[i - 1];
          let numStars = 1;
          while (glob[i + 1] === "*") {
            i++;
            numStars++;
          }
          const nextChar = glob[i + 1];
          if (globstarOption && numStars === 2 && [...c.seps, void 0].includes(prevChar) && [...c.seps, void 0].includes(nextChar)) {
            segment += c.globstar;
            endsWithSep = true;
          } else {
            segment += c.wildcard;
          }
        }
        continue;
      }
      segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
    }
    if (groupStack.length > 0 || inRange || inEscape) {
      segment = "";
      for (const c2 of glob.slice(j, i)) {
        segment += regExpEscapeChars.includes(c2) ? `\\${c2}` : c2;
        endsWithSep = false;
      }
    }
    regExpString += segment;
    if (!endsWithSep) {
      regExpString += i < glob.length ? c.sep : c.sepMaybe;
      endsWithSep = true;
    }
    while (c.seps.includes(glob[i])) i++;
    if (!(i > j)) {
      throw new Error("Assertion failure: i > j (potential infinite loop)");
    }
    j = i;
  }
  regExpString = `^${regExpString}$`;
  return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
var constants = {
  sep: "(?:\\\\|/)+",
  sepMaybe: "(?:\\\\|/)*",
  seps: ["\\", "/"],
  globstar: "(?:[^\\\\/]*(?:\\\\|/|$)+)*",
  wildcard: "[^\\\\/]*",
  escapePrefix: "`"
};
function globToRegExp4(glob, options = {}) {
  return _globToRegExp2(constants, glob, options);
}
function isGlob2(str) {
  const chars = { "{": "}", "(": ")", "[": "]" };
  const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if (str === "") {
    return false;
  }
  let match;
  while (match = regex.exec(str)) {
    if (match[2]) return true;
    let idx = match.index + match[0].length;
    const open = match[1];
    const close = open ? chars[open] : null;
    if (open && close) {
      const n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }
    str = str.slice(idx);
  }
  return false;
}
function normalizeGlob3(glob, { globstar = false } = {}) {
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize4(glob);
  }
  const s = SEPARATOR_PATTERN4.source;
  const badParentPattern = new RegExp(
    `(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`,
    "g"
  );
  return normalize4(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs4(globs, { extended = true, globstar = false } = {}) {
  if (!globstar || globs.length === 0) {
    return join4(...globs);
  }
  if (globs.length === 0) return ".";
  let joined;
  for (const glob of globs) {
    const path = glob;
    if (path.length > 0) {
      if (!joined) joined = path;
      else joined += `${SEPARATOR4}${path}`;
    }
  }
  if (!joined) return ".";
  return normalizeGlob3(joined, { extended, globstar });
}
function isPosixPathSeparator4(code4) {
  return code4 === CHAR_FORWARD_SLASH2;
}
function basename5(path, suffix = "") {
  assertArgs3(path, suffix);
  const lastSegment = lastPathSegment2(path, isPosixPathSeparator4);
  const strippedSegment = stripTrailingSeparators2(
    lastSegment,
    isPosixPathSeparator4
  );
  return suffix ? stripSuffix2(strippedSegment, suffix) : strippedSegment;
}
var SEPARATOR5 = "/";
var SEPARATOR_PATTERN5 = /\/+/;
function dirname5(path) {
  assertArg5(path);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i = path.length - 1; i >= 1; --i) {
    if (isPosixPathSeparator4(path.charCodeAt(i))) {
      if (matchedNonSeparator) {
        end = i;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator4(path.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators2(
    path.slice(0, end),
    isPosixPathSeparator4
  );
}
function extname5(path) {
  assertPath2(path);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path.length - 1; i >= 0; --i) {
    const code4 = path.charCodeAt(i);
    if (isPosixPathSeparator4(code4)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code4 === CHAR_DOT2) {
      if (startDot === -1) startDot = i;
      else if (preDotState !== 1) preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function fromFileUrl5(url) {
  url = assertArg7(url);
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function isAbsolute5(path) {
  assertPath2(path);
  return path.length > 0 && isPosixPathSeparator4(path.charCodeAt(0));
}
function normalize5(path) {
  assertArg8(path);
  const isAbsolute7 = isPosixPathSeparator4(path.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator4(
    path.charCodeAt(path.length - 1)
  );
  path = normalizeString2(path, !isAbsolute7, "/", isPosixPathSeparator4);
  if (path.length === 0 && !isAbsolute7) path = ".";
  if (path.length > 0 && trailingSeparator) path += "/";
  if (isAbsolute7) return `/${path}`;
  return path;
}
function join5(...paths) {
  if (paths.length === 0) return ".";
  let joined;
  for (let i = 0; i < paths.length; ++i) {
    const path = paths[i];
    assertPath2(path);
    if (path.length > 0) {
      if (!joined) joined = path;
      else joined += `/${path}`;
    }
  }
  if (!joined) return ".";
  return normalize5(joined);
}
function resolve5(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) path = pathSegments[i];
    else {
      const { Deno: Deno6 } = globalThis;
      if (typeof Deno6?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path = Deno6.cwd();
    }
    assertPath2(path);
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator4(path.charCodeAt(0));
  }
  resolvedPath = normalizeString2(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator4
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) return `/${resolvedPath}`;
    else return "/";
  } else if (resolvedPath.length > 0) return resolvedPath;
  else return ".";
}
function relative5(from, to) {
  assertArgs4(from, to);
  from = resolve5(from);
  to = resolve5(to);
  if (from === to) return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator4(from.charCodeAt(fromStart))) break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator4(to.charCodeAt(toStart))) break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (isPosixPathSeparator4(to.charCodeAt(toStart + i))) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (isPosixPathSeparator4(from.charCodeAt(fromStart + i))) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode) break;
    else if (isPosixPathSeparator4(fromCode)) lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || isPosixPathSeparator4(from.charCodeAt(i))) {
      if (out.length === 0) out += "..";
      else out += "/..";
    }
  }
  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator4(to.charCodeAt(toStart))) ++toStart;
    return to.slice(toStart);
  }
}
function toFileUrl5(path) {
  if (!isAbsolute5(path)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(
    path.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}
var constants2 = {
  sep: "/+",
  sepMaybe: "/*",
  seps: ["/"],
  globstar: "(?:[^/]*(?:/|$)+)*",
  wildcard: "[^/]*",
  escapePrefix: "\\"
};
function globToRegExp5(glob, options = {}) {
  return _globToRegExp2(constants2, glob, options);
}
function normalizeGlob4(glob, { globstar = false } = {}) {
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize5(glob);
  }
  const s = SEPARATOR_PATTERN5.source;
  const badParentPattern = new RegExp(
    `(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`,
    "g"
  );
  return normalize5(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs5(globs, { extended = true, globstar = false } = {}) {
  if (!globstar || globs.length === 0) {
    return join5(...globs);
  }
  if (globs.length === 0) return ".";
  let joined;
  for (const glob of globs) {
    const path = glob;
    if (path.length > 0) {
      if (!joined) joined = path;
      else joined += `${SEPARATOR5}${path}`;
    }
  }
  if (!joined) return ".";
  return normalizeGlob4(joined, { extended, globstar });
}
var osType = (() => {
  const { Deno: Deno6 } = globalThis;
  if (typeof Deno6?.build?.os === "string") {
    return Deno6.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows5 = osType === "windows";
function basename6(path, suffix = "") {
  return isWindows5 ? basename4(path, suffix) : basename5(path, suffix);
}
var SEPARATOR6 = isWindows5 ? "\\" : "/";
var SEPARATOR_PATTERN6 = isWindows5 ? /[\\/]+/ : /\/+/;
function dirname6(path) {
  return isWindows5 ? dirname4(path) : dirname5(path);
}
function extname6(path) {
  return isWindows5 ? extname4(path) : extname5(path);
}
function fromFileUrl6(url) {
  return isWindows5 ? fromFileUrl4(url) : fromFileUrl5(url);
}
function isAbsolute6(path) {
  return isWindows5 ? isAbsolute4(path) : isAbsolute5(path);
}
function join6(...paths) {
  return isWindows5 ? join4(...paths) : join5(...paths);
}
function normalize6(path) {
  return isWindows5 ? normalize4(path) : normalize5(path);
}
function relative6(from, to) {
  return isWindows5 ? relative4(from, to) : relative5(from, to);
}
function resolve6(...pathSegments) {
  return isWindows5 ? resolve4(...pathSegments) : resolve5(...pathSegments);
}
function toFileUrl6(path) {
  return isWindows5 ? toFileUrl4(path) : toFileUrl5(path);
}
function globToRegExp6(glob, options = {}) {
  return options.os === "windows" || !options.os && isWindows5 ? globToRegExp4(glob, options) : globToRegExp5(glob, options);
}
function joinGlobs6(globs, options = {}) {
  return isWindows5 ? joinGlobs4(globs, options) : joinGlobs5(globs, options);
}
var wasm2;
var heap2 = new Array(128).fill(void 0);
heap2.push(void 0, null, true, false);
function getObject2(idx) {
  return heap2[idx];
}
function isLikeNone2(x) {
  return x === void 0 || x === null;
}
var cachedFloat64Memory02 = null;
function getFloat64Memory02() {
  if (cachedFloat64Memory02 === null || cachedFloat64Memory02.byteLength === 0) {
    cachedFloat64Memory02 = new Float64Array(wasm2.memory.buffer);
  }
  return cachedFloat64Memory02;
}
var cachedInt32Memory02 = null;
function getInt32Memory02() {
  if (cachedInt32Memory02 === null || cachedInt32Memory02.byteLength === 0) {
    cachedInt32Memory02 = new Int32Array(wasm2.memory.buffer);
  }
  return cachedInt32Memory02;
}
var WASM_VECTOR_LEN2 = 0;
var cachedUint8Memory02 = null;
function getUint8Memory02() {
  if (cachedUint8Memory02 === null || cachedUint8Memory02.byteLength === 0) {
    cachedUint8Memory02 = new Uint8Array(wasm2.memory.buffer);
  }
  return cachedUint8Memory02;
}
var cachedTextEncoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : {
  encode: () => {
    throw Error("TextEncoder not available");
  }
};
var encodeString2 = function(arg, view) {
  return cachedTextEncoder2.encodeInto(arg, view);
};
function passStringToWasm02(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder2.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory02().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN2 = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory02();
  let offset = 0;
  for (; offset < len; offset++) {
    const code4 = arg.charCodeAt(offset);
    if (code4 > 127) break;
    mem[ptr + offset] = code4;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory02().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN2 = offset;
  return ptr;
}
var cachedTextDecoder2 = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : {
  decode: () => {
    throw Error("TextDecoder not available");
  }
};
if (typeof TextDecoder !== "undefined") cachedTextDecoder2.decode();
function getStringFromWasm02(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder2.decode(getUint8Memory02().subarray(ptr, ptr + len));
}
var heap_next2 = heap2.length;
function addHeapObject2(obj) {
  if (heap_next2 === heap2.length) heap2.push(heap2.length + 1);
  const idx = heap_next2;
  heap_next2 = heap2[idx];
  heap2[idx] = obj;
  return idx;
}
function dropObject2(idx) {
  if (idx < 132) return;
  heap2[idx] = heap_next2;
  heap_next2 = idx;
}
function takeObject2(idx) {
  const ret = getObject2(idx);
  dropObject2(idx);
  return ret;
}
var cachedBigInt64Memory02 = null;
function getBigInt64Memory02() {
  if (cachedBigInt64Memory02 === null || cachedBigInt64Memory02.byteLength === 0) {
    cachedBigInt64Memory02 = new BigInt64Array(wasm2.memory.buffer);
  }
  return cachedBigInt64Memory02;
}
function debugString2(val) {
  const type2 = typeof val;
  if (type2 == "number" || type2 == "boolean" || val == null) {
    return `${val}`;
  }
  if (type2 == "string") {
    return `"${val}"`;
  }
  if (type2 == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type2 == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString2(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString2(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function parse6(command) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(command, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.parse(retptr, ptr0, len0);
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    var r2 = getInt32Memory02()[retptr / 4 + 2];
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function static_text_render_text2(items, cols, rows) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.static_text_render_text(retptr, addHeapObject2(items), cols, rows);
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    var r2 = getInt32Memory02()[retptr / 4 + 2];
    var r3 = getInt32Memory02()[retptr / 4 + 3];
    if (r3) {
      throw takeObject2(r2);
    }
    let v1;
    if (r0 !== 0) {
      v1 = getStringFromWasm02(r0, r1).slice();
      wasm2.__wbindgen_free(r0, r1 * 1, 1);
    }
    return v1;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function static_text_clear_text2(cols, rows) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.static_text_clear_text(retptr, cols, rows);
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    let v1;
    if (r0 !== 0) {
      v1 = getStringFromWasm02(r0, r1).slice();
      wasm2.__wbindgen_free(r0, r1 * 1, 1);
    }
    return v1;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function static_text_render_once2(items, cols, rows) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.static_text_render_once(retptr, addHeapObject2(items), cols, rows);
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    var r2 = getInt32Memory02()[retptr / 4 + 2];
    var r3 = getInt32Memory02()[retptr / 4 + 3];
    if (r3) {
      throw takeObject2(r2);
    }
    let v1;
    if (r0 !== 0) {
      v1 = getStringFromWasm02(r0, r1).slice();
      wasm2.__wbindgen_free(r0, r1 * 1, 1);
    }
    return v1;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function strip_ansi_codes2(text) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(text, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.strip_ansi_codes(retptr, ptr0, len0);
    var r0 = getInt32Memory02()[retptr / 4 + 0];
    var r1 = getInt32Memory02()[retptr / 4 + 1];
    deferred2_0 = r0;
    deferred2_1 = r1;
    return getStringFromWasm02(r0, r1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
function handleError4(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm2.__wbindgen_exn_store(addHeapObject2(e));
  }
}
var imports2 = {
  __wbindgen_placeholder__: {
    __wbg_get_57245cc7d7c7619d: function(arg0, arg1) {
      const ret = getObject2(arg0)[arg1 >>> 0];
      return addHeapObject2(ret);
    },
    __wbindgen_jsval_loose_eq: function(arg0, arg1) {
      const ret = getObject2(arg0) == getObject2(arg1);
      return ret;
    },
    __wbg_instanceof_Uint8Array_971eeda69eb75003: function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof Uint8Array;
      } catch (_) {
        result = false;
      }
      const ret = result;
      return ret;
    },
    __wbg_instanceof_ArrayBuffer_e5e48f4762c5610b: function(arg0) {
      let result;
      try {
        result = getObject2(arg0) instanceof ArrayBuffer;
      } catch (_) {
        result = false;
      }
      const ret = result;
      return ret;
    },
    __wbg_new_8c3f0052272a457a: function(arg0) {
      const ret = new Uint8Array(getObject2(arg0));
      return addHeapObject2(ret);
    },
    __wbindgen_boolean_get: function(arg0) {
      const v = getObject2(arg0);
      const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
      return ret;
    },
    __wbindgen_number_get: function(arg0, arg1) {
      const obj = getObject2(arg1);
      const ret = typeof obj === "number" ? obj : void 0;
      getFloat64Memory02()[arg0 / 8 + 1] = isLikeNone2(ret) ? 0 : ret;
      getInt32Memory02()[arg0 / 4 + 0] = !isLikeNone2(ret);
    },
    __wbindgen_string_get: function(arg0, arg1) {
      const obj = getObject2(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      var len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    },
    __wbindgen_error_new: function(arg0, arg1) {
      const ret = new Error(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    },
    __wbindgen_string_new: function(arg0, arg1) {
      const ret = getStringFromWasm02(arg0, arg1);
      return addHeapObject2(ret);
    },
    __wbindgen_object_clone_ref: function(arg0) {
      const ret = getObject2(arg0);
      return addHeapObject2(ret);
    },
    __wbg_set_9182712abebf82ef: function(arg0, arg1, arg2) {
      getObject2(arg0)[takeObject2(arg1)] = takeObject2(arg2);
    },
    __wbg_new_0b9bfdd97583284e: function() {
      const ret = new Object();
      return addHeapObject2(ret);
    },
    __wbg_new_1d9a920c6bfc44a8: function() {
      const ret = new Array();
      return addHeapObject2(ret);
    },
    __wbg_set_a68214f35c417fa9: function(arg0, arg1, arg2) {
      getObject2(arg0)[arg1 >>> 0] = takeObject2(arg2);
    },
    __wbindgen_number_new: function(arg0) {
      const ret = arg0;
      return addHeapObject2(ret);
    },
    __wbg_length_6e3bbe7c8bd4dbd8: function(arg0) {
      const ret = getObject2(arg0).length;
      return ret;
    },
    __wbindgen_is_bigint: function(arg0) {
      const ret = typeof getObject2(arg0) === "bigint";
      return ret;
    },
    __wbg_isSafeInteger_dfa0593e8d7ac35a: function(arg0) {
      const ret = Number.isSafeInteger(getObject2(arg0));
      return ret;
    },
    __wbindgen_bigint_from_i64: function(arg0) {
      const ret = arg0;
      return addHeapObject2(ret);
    },
    __wbindgen_is_object: function(arg0) {
      const val = getObject2(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    },
    __wbg_iterator_6f9d4f28845f426c: function() {
      const ret = Symbol.iterator;
      return addHeapObject2(ret);
    },
    __wbindgen_in: function(arg0, arg1) {
      const ret = getObject2(arg0) in getObject2(arg1);
      return ret;
    },
    __wbg_entries_65a76a413fc91037: function(arg0) {
      const ret = Object.entries(getObject2(arg0));
      return addHeapObject2(ret);
    },
    __wbindgen_bigint_from_u64: function(arg0) {
      const ret = BigInt.asUintN(64, arg0);
      return addHeapObject2(ret);
    },
    __wbindgen_jsval_eq: function(arg0, arg1) {
      const ret = getObject2(arg0) === getObject2(arg1);
      return ret;
    },
    __wbg_new_abda76e883ba8a5f: function() {
      const ret = new Error();
      return addHeapObject2(ret);
    },
    __wbg_stack_658279fe44541cf6: function(arg0, arg1) {
      const ret = getObject2(arg1).stack;
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    },
    __wbg_error_f851667af71bcfc6: function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm02(arg0, arg1));
      } finally {
        wasm2.__wbindgen_free(deferred0_0, deferred0_1, 1);
      }
    },
    __wbindgen_object_drop_ref: function(arg0) {
      takeObject2(arg0);
    },
    __wbindgen_is_function: function(arg0) {
      const ret = typeof getObject2(arg0) === "function";
      return ret;
    },
    __wbg_next_aaef7c8aa5e212ac: function() {
      return handleError4(function(arg0) {
        const ret = getObject2(arg0).next();
        return addHeapObject2(ret);
      }, arguments);
    },
    __wbg_done_1b73b0672e15f234: function(arg0) {
      const ret = getObject2(arg0).done;
      return ret;
    },
    __wbg_value_1ccc36bc03462d71: function(arg0) {
      const ret = getObject2(arg0).value;
      return addHeapObject2(ret);
    },
    __wbg_get_765201544a2b6869: function() {
      return handleError4(function(arg0, arg1) {
        const ret = Reflect.get(getObject2(arg0), getObject2(arg1));
        return addHeapObject2(ret);
      }, arguments);
    },
    __wbg_call_97ae9d8645dc388b: function() {
      return handleError4(function(arg0, arg1) {
        const ret = getObject2(arg0).call(getObject2(arg1));
        return addHeapObject2(ret);
      }, arguments);
    },
    __wbg_next_579e583d33566a86: function(arg0) {
      const ret = getObject2(arg0).next;
      return addHeapObject2(ret);
    },
    __wbg_isArray_27c46c67f498e15d: function(arg0) {
      const ret = Array.isArray(getObject2(arg0));
      return ret;
    },
    __wbg_length_9e1ae1900cb0fbd5: function(arg0) {
      const ret = getObject2(arg0).length;
      return ret;
    },
    __wbindgen_memory: function() {
      const ret = wasm2.memory;
      return addHeapObject2(ret);
    },
    __wbg_buffer_3f3d764d4747d564: function(arg0) {
      const ret = getObject2(arg0).buffer;
      return addHeapObject2(ret);
    },
    __wbg_set_83db9690f9353e79: function(arg0, arg1, arg2) {
      getObject2(arg0).set(getObject2(arg1), arg2 >>> 0);
    },
    __wbindgen_bigint_get_as_i64: function(arg0, arg1) {
      const v = getObject2(arg1);
      const ret = typeof v === "bigint" ? v : void 0;
      getBigInt64Memory02()[arg0 / 8 + 1] = isLikeNone2(ret) ? BigInt(0) : ret;
      getInt32Memory02()[arg0 / 4 + 0] = !isLikeNone2(ret);
    },
    __wbindgen_debug_string: function(arg0, arg1) {
      const ret = debugString2(getObject2(arg1));
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    },
    __wbindgen_throw: function(arg0, arg1) {
      throw new Error(getStringFromWasm02(arg0, arg1));
    }
  }
};
function instantiate2() {
  return instantiateWithInstance2().exports;
}
var instanceWithExports2;
function instantiateWithInstance2() {
  if (instanceWithExports2 == null) {
    const instance = instantiateInstance2();
    wasm2 = instance.exports;
    cachedInt32Memory02 = new Int32Array(wasm2.memory.buffer);
    cachedUint8Memory02 = new Uint8Array(wasm2.memory.buffer);
    instanceWithExports2 = {
      instance,
      exports: { parse: parse6, static_text_render_text: static_text_render_text2, static_text_clear_text: static_text_clear_text2, static_text_render_once: static_text_render_once2, strip_ansi_codes: strip_ansi_codes2 }
    };
  }
  return instanceWithExports2;
}
function instantiateInstance2() {
  const wasmBytes = base64decode2(
    "AGFzbQEAAAAB7wEiYAAAYAABf2ABfwBgAX8Bf2ACf38AYAJ/fwF/YAN/f38AYAN/f38Bf2AEf39/fwBgBH9/f38Bf2AFf39/f38AYAV/f39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AHf39/f39/fwBgB39/f39/f38Bf2AJf39/f39/fn5+AGAEf39/fgBgA39/fgF/YAV/f35/fwBgBX9/fX9/AGAFf398f38AYAJ/fgBgBH9+f38AYAN/fn4AYAN/fn4Bf2AEf31/fwBgAn98AGADf3x/AX9gBH98f38AYAR/fH9/AX9gAX4Bf2ADfn9/AX9gAXwBfwL4Ei0YX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX2dldF81NzI0NWNjN2Q3Yzc2MTlkAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGV9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXEABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18sX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5Xzk3MWVlZGE2OWViNzUwMDMAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18tX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl9lNWU0OGY0NzYyYzU2MTBiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18VX193YmluZGdlbl9udW1iZXJfZ2V0AAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fc3RyaW5nX2dldAAEGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2Vycm9yX25ldwAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxVfX3diaW5kZ2VuX3N0cmluZ19uZXcABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18bX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85MTgyNzEyYWJlYmY4MmVmAAYYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld18wYjliZmRkOTc1ODMyODRlAAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF9hNjgyMTRmMzVjNDE3ZmE5AAYYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fbnVtYmVyX25ldwAhGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkOAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2lzX2JpZ2ludAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXyRfX3diZ19pc1NhZmVJbnRlZ2VyX2RmYTA1OTNlOGQ3YWMzNWEAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQAHxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18UX193YmluZGdlbl9pc19vYmplY3QAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18fX193YmdfaXRlcmF0b3JfNmY5ZDRmMjg4NDVmNDI2YwABGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXw1fX3diaW5kZ2VuX2luAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHl9fd2JnX2VudHJpZXNfNjVhNzZhNDEzZmM5MTAzNwADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diaW5kZ2VuX2JpZ2ludF9mcm9tX3U2NAAfGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxNfX3diaW5kZ2VuX2pzdmFsX2VxAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hYmRhNzZlODgzYmE4YTVmAAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHF9fd2JnX3N0YWNrXzY1ODI3OWZlNDQ1NDFjZjYABBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18cX193YmdfZXJyb3JfZjg1MTY2N2FmNzFiY2ZjNgAEGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZgACGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fG19fd2JnX25leHRfYWFlZjdjOGFhNWUyMTJhYwADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxtfX3diZ19kb25lXzFiNzNiMDY3MmUxNWYyMzQAAxhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18cX193YmdfdmFsdWVfMWNjYzM2YmMwMzQ2MmQ3MQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diZ19nZXRfNzY1MjAxNTQ0YTJiNjg2OQAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxtfX3diZ19jYWxsXzk3YWU5ZDg2NDVkYzM4OGIABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18bX193YmdfbmV4dF81NzllNTgzZDMzNTY2YTg2AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHl9fd2JnX2lzQXJyYXlfMjdjNDZjNjdmNDk4ZTE1ZAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19sZW5ndGhfOWUxYWUxOTAwY2IwZmJkNQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxFfX3diaW5kZ2VuX21lbW9yeQABGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfM2YzZDc2NGQ0NzQ3ZDU2NAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxpfX3diZ19zZXRfODNkYjk2OTBmOTM1M2U3OQAGGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxxfX3diaW5kZ2VuX2JpZ2ludF9nZXRfYXNfaTY0AAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nAAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABAPiA+ADHB4IBgMGBAYGBAcHDAYKBgYGCAoGBQUGAwYJBQkGCgIHBwQGCAoIBwYHCAcNBAcFBgIGBQYIBAYEBgUOBwYFAgQFEAwKBwgLDwUFBwggBgYGBQYFAgwFBAIFBQUIAwYLBQUFCgQECAgGBAQIAQQEBAQEBAQEBQYICAYIBAQKBgcIBQYFBAwEBQYEBgIGBQQEBgQEBAQEDAoEBAoKBAUSBAQHBwoEAAQDBgoECAYGBAQFBAsEBgYIBgUFAgYEBgQEBgYFAgICBAUACAYEBQICBAQEBAoEBAQECgcBBgYAChECBAQCAgQEAgICBAQEAgQHBgICBAMEBgQEFhYbDAIGBAYIBQQGAgULBgAEAwMHBQIFBQAEBgAEAgAGAwQFCQYCBAUCAgQJBAUEBAIFBAUFBQUFAgICBgIEBAQCBAQCAggFAgICDQQBCQkTCgoKCwsVFAIEGQUCGQgFAgICBwQFBgoKCgUKCAUFBQUFBQIFBQIDCAIDBAQFBAICAwIFBQYGAgICBAUCBAIFAgQCBAIFBQoFAgIEBgMEBAQFAgIGBAQEBAcGBQUGBAQEAgQFBAQEAgYCBwUHBwICBQcFAwUGAwcFBQIDBAUFBQcHBwcBAgQEBQUFBQICGAMAAgIGAgICBAUBcAF+fgUDAQARBgkBfwFBgIDAAAsH7AELBm1lbW9yeQIABXBhcnNlAD0Xc3RhdGljX3RleHRfcmVuZGVyX3RleHQAVxZzdGF0aWNfdGV4dF9jbGVhcl90ZXh0AHwXc3RhdGljX3RleHRfcmVuZGVyX29uY2UAUxBzdHJpcF9hbnNpX2NvZGVzAK8BEV9fd2JpbmRnZW5fbWFsbG9jALMCEl9fd2JpbmRnZW5fcmVhbGxvYwDSAh9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAOkDD19fd2JpbmRnZW5fZnJlZQDeAxRfX3diaW5kZ2VuX2V4bl9zdG9yZQDdAwn6AQEAQQELfbUDQoED6APtAr0ChwGqA7oB2QO+A9ID6gNrvAPhA7EDxwPmA90BgAHxAvsCsgH3AvoCiQOEA/gC+QL9AvwC9gLzA/QDqQP0AYcEmgOXA5UDlAOTA5gDxAPFA4gE5gLlAuQD4APKAdwCmwP7A84C3wPJAvUDlgOHAowEnAJ21AKLBOIDjQHuA4MEsAPOA4ADhAT/A6MD/QPNA8sDiQS7Av4DkwLMA5IC4wOIAc8D0QPvA4oE+QHUA35bjwHdAucDjgHYAuMCrgGiAdUD8AO+AoAEmALWA5cC1wOzA9gDgwODAXfaArQD2gPcA7cC2wP+ApEBvgEKstgH4AO/QAIcfxp+IwBBwAprIgMkACABvSEfAkACQCABIAFhDQBBAiEEDAELIB9C/////////weDIiBCgICAgICAgAiEIB9CAYZC/v///////w+DIB9CNIinQf8PcSIFGyIhQgGDISJBAyEEAkACQAJAQQFBAkEEIB9CgICAgICAgPj/AIMiI1AiBhsgI0KAgICAgICA+P8AURtBA0EEIAYbICBQG0F/ag4EAwABAgMLQQQhBAwCCyAFQc13aiEHICJQIQRCASEkDAELQoCAgICAgIAgICFCAYYgIUKAgICAgICACFEiBhshIUICQgEgBhshJEHLd0HMdyAGGyAFaiEHICJQIQQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEQX5qQf8BcSIGQQMgBkEDSRsiBUUNAEHQr8AAQdGvwAAgH0IAUyIGG0HQr8AAQfC7wQAgBhsgAhshCEEBIQZBASAfQj+IpyACGyEJAkAgBUF/ag4DAgMAAgsgIUIAUQ0DIAMgIUJ/fCIjNwP4ByADIAc7AYAIIAcgB0FgaiAHICQgIXwiJUKAgICAEFQiAhsiBkFwaiAGICVCIIYgJSACGyIfQoCAgICAgMAAVCICGyIGQXhqIAYgH0IQhiAfIAIbIh9CgICAgICAgIABVCICGyIGQXxqIAYgH0IIhiAfIAIbIh9CgICAgICAgIAQVCICGyIGQX5qIAYgH0IEhiAfIAIbIh9CgICAgICAgIDAAFQiAhsgH0IChiAfIAIbIiJCf1UiBWsiAmvBIgZBAEgNBCADQn8gBq0iIIgiHyAjgzcD0AYgIyAfVg0FIAMgBzsBgAggAyAhNwP4ByADIB8gIYM3A9AGICEgH1YNBkGgfyACa8FB0ABsQbCnBWpBzhBuQQR0IgZBqKLAAGopAwAiJkL/////D4MiHyAhICBCP4MiJ4YiIEIgiCIofiIpQiCIIiogJkIgiCIrICh+fCArICBC/////w+DIiB+IiZCIIgiLHwhLSApQv////8PgyAfICB+QiCIfCAmQv////8Pg3xCgICAgAh8QiCIIS5CAUEAIAIgBkGwosAAai8BAGprQT9xrSIghiIvQn98ISkgHyAjICeGIiNCIIgiJn4iJ0L/////D4MgHyAjQv////8PgyIjfkIgiHwgKyAjfiIjQv////8Pg3xCgICAgAh8QiCIITAgKyAmfiEmICNCIIghIyAnQiCIIScgBkGyosAAai8BACEGAkAgKyAiIAWthiIiQiCIIjF+IjIgHyAxfiIzQiCIIjR8ICsgIkL/////D4MiIn4iNUIgiCI2fCAzQv////8PgyAfICJ+QiCIfCA1Qv////8Pg3xCgICAgAh8QiCIIjV8QgF8IjMgIIinIgVBkM4ASQ0AIAVBwIQ9SQ0IAkAgBUGAwtcvSQ0AQQhBCSAFQYCU69wDSSICGyEKQYDC1y9BgJTr3AMgAhshAgwKC0EGQQcgBUGAreIESSICGyEKQcCEPUGAreIEIAIbIQIMCQsCQCAFQeQASQ0AQQJBAyAFQegHSSICGyEKQeQAQegHIAIbIQIMCQtBCkEBIAVBCUsiChshAgwICyADQQM2AqQJIANB0q/AADYCoAkgA0ECOwGcCUEBIQYgA0GcCWohAkEAIQlB8LvBACEIDAgLIANBAzYCpAkgA0HVr8AANgKgCSADQQI7AZwJIANBnAlqIQIMBwsgA0EBNgKkCSADQdivwAA2AqAJIANBAjsBnAkgA0GcCWohAgwGC0G4ocAAQRxBrK3AABCjAgALQaiewABBHUHInsAAEKMCAAsgA0EANgKcCSADQdAGaiADQfgHaiADQZwJahDLAgALIANBADYCnAkgA0HQBmogA0H4B2ogA0GcCWoQywIAC0EEQQUgBUGgjQZJIgIbIQpBkM4AQaCNBiACGyECCyAtIC58IS0gMyApgyEfIAogBmtBAWohCyAzICYgJ3wgI3wgMHwiN30iOEIBfCInICmDISNBACEGAkACQAJAAkACQANAIANBC2ogBmoiDCAFIAJuIg1BMGoiDjoAACAnIAUgDSACbGsiBa0gIIYiIiAffCImVg0BAkAgCiAGRw0AIAZBAWohD0IBISICQANAICIhJiAPQRFGDQEgA0ELaiAPaiAfQgp+Ih8gIIinQTBqIgI6AAAgJkIKfiEiIA9BAWohDyAjQgp+IiMgHyApgyIfWA0ACyAjIB99IiAgL1ohBiAiIDMgLX1+IikgInwhLiAgIC9UDQQgKSAifSIpIB9YDQQgA0ELaiAPakF/aiEFIC8gKX0hMyApIB99ISggIyAvIB98fSErQgAhIANAAkAgHyAvfCIiIClUDQAgKCAgfCAzIB98Wg0AQQEhBgwGCyAFIAJBf2oiAjoAACArICB8IicgL1ohBiAiIClaDQYgICAvfSEgICIhHyAnIC9aDQAMBgsLQRFBEUGcrcAAEOoBAAsgBkEBaiEGIAJBCkkhDSACQQpuIQIgDUUNAAtBgK3AAEEZQeiswAAQowIACyAnICZ9IikgAq0gIIYiIFohAiAzIC19IiNCAXwhMAJAICNCf3wiJyAmWA0AICkgIFQNACAfICB8IikgKnwgLHwgLnwgKyAoIDF9fnwgNH0gNn0gNX0hL0IAIC0gJnx9ISggNCA2fCA1fCAyfCEjQgIgNyApICJ8fH0hMwNAAkAgIiApfCImICdUDQAgKCAjfCAiIC98Wg0AICIgH3whJkEBIQIMAgsgDCAOQX9qIg46AAAgHyAgfCEfIDMgI3whKwJAICYgJ1oNACApICB8ISkgLyAgfCEvICMgIH0hIyArICBaDQELCyArICBaIQIgIiAffCEmCwJAIDAgJlgNACACRQ0AICYgIHwiHyAwVA0DIDAgJn0gHyAwfVoNAwsgJkICVA0CICYgOEJ9fFYNAiAGQQFqIQ8MAwsgHyEiCwJAIC4gIlgNACAGRQ0AICIgL3wiHyAuVA0BIC4gIn0gHyAufVoNAQsgJkIUfiAiVg0AICIgJkJYfiAjfFgNAQsgAyAhPgIcIANBAUECICFCgICAgBBUIgIbNgK8ASADQQAgIUIgiKcgAhs2AiAgA0EkakEAQZgBEPYDGiADQQE2AsABIANBATYC4AIgA0HAAWpBBGpBAEGcARD2AxogA0EBNgKEBCADICQ+AuQCIANB5AJqQQRqQQBBnAEQ9gMaIANBiARqQQRqQQBBnAEQ9gMaIANBATYCiAQgA0EBNgKoBSAHrcMgJUJ/fHl9QsKawegEfkKAoc2gtAJ8QiCIpyIGwSELAkACQCAHwUEASA0AIANBHGogB0H//wNxIgIQQxogA0HAAWogAhBDGiADQeQCaiACEEMaDAELIANBiARqQQAgB2vBEEMaCwJAAkAgC0F/Sg0AIANBHGpBACALa0H//wNxIgIQSBogA0HAAWogAhBIGiADQeQCaiACEEgaDAELIANBiARqIAZB//8DcRBIGgsgAyADKAK8ASIQNgK8CiADQZwJaiADQRxqQaABEPcDGgJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQIAMoAoQEIhEgECARSxsiEkEoSw0AAkACQAJAAkAgEg0AQQAhEgwBC0EAIQ5BACENAkACQAJAIBJBAUYNACASQQFxIRMgEkF+cSEUQQAhDSADQeQCaiEGIANBnAlqIQJBACEOA0AgAiACKAIAIgwgBigCAGoiBSANQQFxaiIKNgIAIAJBBGoiDSANKAIAIgcgBkEEaigCAGoiDSAFIAxJIAogBUlyaiIFNgIAIA0gB0kgBSANSXIhDSACQQhqIQIgBkEIaiEGIBQgDkECaiIORw0ACyATRQ0BCyADQZwJaiAOQQJ0IgJqIgYgBigCACIGIANB5AJqIAJqKAIAaiICIA1qIgU2AgAgAiAGSQ0BIAUgAkkNAQwCCyANRQ0BCyASQSdLDQEgA0GcCWogEkECdGpBATYCACASQQFqIRILIAMgEjYCvAogAygCqAUiDiASIA4gEksbIgJBKU8NASACQQJ0IQICQAJAA0AgAkUNAUF/IAJBfGoiAiADQZwJamooAgAiBiACIANBiARqaigCACIFRyAGIAVLGyIGRQ0ADAILC0F/QQAgA0GcCWogAmogA0GcCWpHGyEGCwJAIAYgBEgNAAJAIBANAEEAIRAMBgsgEEF/akH/////A3EiAkEBaiIFQQNxIQYCQCACQQNPDQAgA0EcaiECQgAhHwwFCyAFQfz///8HcSEFIANBHGohAkIAIR8DQCACIAI1AgBCCn4gH3wiHz4CACACQQRqIg0gDTUCAEIKfiAfQiCIfCIfPgIAIAJBCGoiDSANNQIAQgp+IB9CIIh8Ih8+AgAgAkEMaiINIA01AgBCCn4gH0IgiHwiHz4CACAfQiCIIR8gAkEQaiECIAVBfGoiBQ0ADAULCyALQQFqIQsMDAtBKEEoQZTKwAAQ6gEACyACQShBlMrAABDtAQALIBJBKEGUysAAEO0BAAsCQCAGRQ0AA0AgAiACNQIAQgp+IB98Ih8+AgAgAkEEaiECIB9CIIghHyAGQX9qIgYNAAsLIB+nIgJFDQAgEEEnSw0BIANBHGogEEECdGogAjYCACAQQQFqIRALIAMgEDYCvAEgAygC4AIiDEEpTw0BQQAhCkEAIQIgDEUNAyAMQX9qQf////8DcSICQQFqIgVBA3EhBgJAIAJBA08NACADQcABaiECQgAhHwwDCyAFQfz///8HcSEFIANBwAFqIQJCACEfA0AgAiACNQIAQgp+IB98Ih8+AgAgAkEEaiINIA01AgBCCn4gH0IgiHwiHz4CACACQQhqIg0gDTUCAEIKfiAfQiCIfCIfPgIAIAJBDGoiDSANNQIAQgp+IB9CIIh8Ih8+AgAgH0IgiCEfIAJBEGohAiAFQXxqIgUNAAwDCwsgEEEoQZTKwAAQ6gEACyAMQShBlMrAABDtAQALAkAgBkUNAANAIAIgAjUCAEIKfiAffCIfPgIAIAJBBGohAiAfQiCIIR8gBkF/aiIGDQALCwJAIB+nIgINACAMIQIMAQsgDEEnSw0BIANBwAFqIAxBAnRqIAI2AgAgDEEBaiECCyADIAI2AuACIBFFDQIgEUF/akH/////A3EiAkEBaiIFQQNxIQYCQCACQQNPDQAgA0HkAmohAkIAIR8MAgsgBUH8////B3EhBSADQeQCaiECQgAhHwNAIAIgAjUCAEIKfiAffCIfPgIAIAJBBGoiDSANNQIAQgp+IB9CIIh8Ih8+AgAgAkEIaiINIA01AgBCCn4gH0IgiHwiHz4CACACQQxqIg0gDTUCAEIKfiAfQiCIfCIfPgIAIB9CIIghHyACQRBqIQIgBUF8aiIFDQAMAgsLQShBKEGUysAAEOoBAAsCQCAGRQ0AA0AgAiACNQIAQgp+IB98Ih8+AgAgAkEEaiECIB9CIIghHyAGQX9qIgYNAAsLAkAgH6ciAg0AIAMgETYChAQMAgsgEUEnSw0CIANB5AJqIBFBAnRqIAI2AgAgEUEBaiEKCyADIAo2AoQECyADIA42AswGIANBrAVqIANBiARqQaABEPcDGiADQawFakEBEEMhFSADIAMoAqgFNgLwByADQdAGaiADQYgEakGgARD3AxogA0HQBmpBAhBDIRYgAyADKAKoBTYCmAkgA0H4B2ogA0GIBGpBoAEQ9wMaIANB+AdqQQMQQyEXAkACQCADKAK8ASIOIAMoApgJIhggDiAYSxsiEkEoSw0AIAMoAqgFIRkgAygCzAYhGiADKALwByEbQQAhDwNAIA8hHCASQQJ0IQICQAJAA0AgAkUNAUF/IAJBfGoiAiADQfgHamooAgAiBiACIANBHGpqKAIAIgVHIAYgBUsbIgZFDQAMAgsLQX9BACADQfgHaiACaiAXRxshBgtBACERAkAgBkEBSw0AAkAgEkUNAEEBIQ1BACEOAkACQCASQQFGDQAgEkEBcSEQIBJBfnEhFEEAIQ5BASENIANB+AdqIQYgA0EcaiECA0AgAiACKAIAIgwgBigCAEF/c2oiBSANQQFxaiIKNgIAIAJBBGoiDSANKAIAIgcgBkEEaigCAEF/c2oiDSAFIAxJIAogBUlyaiIFNgIAIA0gB0kgBSANSXIhDSACQQhqIQIgBkEIaiEGIBQgDkECaiIORw0ACyAQRQ0BCyADQRxqIA5BAnQiAmoiBiAGKAIAIgYgFyACaigCAEF/c2oiAiANaiIFNgIAIAIgBkkNASAFIAJJDQEMDAsgDUUNCwsgAyASNgK8AUEIIREgEiEOCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIA4gGyAOIBtLGyIUQSlPDQAgFEECdCECAkACQANAIAJFDQFBfyACQXxqIgIgA0HQBmpqKAIAIgYgAiADQRxqaigCACIFRyAGIAVLGyIGRQ0ADAILC0F/QQAgA0HQBmogAmogFkcbIQYLAkACQCAGQQFNDQAgDiEUDAELAkAgFEUNAEEBIQ1BACEOAkACQCAUQQFGDQAgFEEBcSEQIBRBfnEhEkEAIQ5BASENIANB0AZqIQYgA0EcaiECA0AgAiACKAIAIgwgBigCAEF/c2oiBSANQQFxaiIKNgIAIAJBBGoiDSANKAIAIgcgBkEEaigCAEF/c2oiDSAFIAxJIAogBUlyaiIFNgIAIA0gB0kgBSANSXIhDSACQQhqIQIgBkEIaiEGIBIgDkECaiIORw0ACyAQRQ0BCyADQRxqIA5BAnQiAmoiBiAGKAIAIgYgFiACaigCAEF/c2oiAiANaiIFNgIAIAIgBkkNASAFIAJJDQEMHgsgDUUNHQsgAyAUNgK8ASARQQRyIRELIBQgGiAUIBpLGyIQQSlPDQEgEEECdCECAkACQANAIAJFDQFBfyACQXxqIgIgA0GsBWpqKAIAIgYgAiADQRxqaigCACIFRyAGIAVLGyIGRQ0ADAILC0F/QQAgA0GsBWogAmogFUcbIQYLAkACQCAGQQFNDQAgFCEQDAELAkAgEEUNAEEBIQ1BACEOAkACQCAQQQFGDQAgEEEBcSESIBBBfnEhFEEAIQ5BASENIANBrAVqIQYgA0EcaiECA0AgAiACKAIAIgwgBigCAEF/c2oiBSANQQFxaiIKNgIAIAJBBGoiDSANKAIAIgcgBkEEaigCAEF/c2oiDSAFIAxJIAogBUlyaiIFNgIAIA0gB0kgBSANSXIhDSACQQhqIQIgBkEIaiEGIBQgDkECaiIORw0ACyASRQ0BCyADQRxqIA5BAnQiAmoiBiAGKAIAIgYgFSACaigCAEF/c2oiAiANaiIFNgIAIAIgBkkNASAFIAJJDQEMHQsgDUUNHAsgAyAQNgK8ASARQQJqIRELIBAgGSAQIBlLGyISQSlPDQIgEkECdCECAkACQANAIAJFDQFBfyACQXxqIgIgA0GIBGpqKAIAIgYgAiADQRxqaigCACIFRyAGIAVLGyIGRQ0ADAILC0F/QQAgA0GIBGogAmogA0GIBGpHGyEGCwJAAkAgBkEBTQ0AIBAhEgwBCwJAIBJFDQBBASENQQAhDgJAAkAgEkEBRg0AIBJBAXEhECASQX5xIRRBACEOQQEhDSADQYgEaiEGIANBHGohAgNAIAIgAigCACIMIAYoAgBBf3NqIgUgDUEBcWoiCjYCACACQQRqIg0gDSgCACIHIAZBBGooAgBBf3NqIg0gBSAMSSAKIAVJcmoiBTYCACANIAdJIAUgDUlyIQ0gAkEIaiECIAZBCGohBiAUIA5BAmoiDkcNAAsgEEUNAQsgA0EcaiAOQQJ0IgJqIgYgBigCACIGIANBiARqIAJqKAIAQX9zaiICIA1qIgU2AgAgAiAGSQ0BIAUgAkkNAQwcCyANRQ0bCyADIBI2ArwBIBFBAWohEQsgHEERRg0GIANBC2ogHGogEUEwajoAACASIAMoAuACIh0gEiAdSxsiAkEpTw0DIBxBAWohDyACQQJ0IQICQAJAA0AgAkUNAUF/IAJBfGoiAiADQcABamooAgAiBiACIANBHGpqKAIAIgVHIAYgBUsbIhRFDQAMAgsLQX9BACADQcABaiACaiADQcABakcbIRQLIAMgEjYCvAogA0GcCWogA0EcakGgARD3AxogEiADKAKEBCITIBIgE0sbIhFBKEsNCQJAAkAgEQ0AQQAhEQwBC0EAIQ5BACENAkACQAJAIBFBAUYNACARQQFxIR4gEUF+cSEQQQAhDSADQeQCaiEGIANBnAlqIQJBACEOA0AgAiACKAIAIgwgBigCAGoiBSANQQFxaiIKNgIAIAJBBGoiDSANKAIAIgcgBkEEaigCAGoiDSAFIAxJIAogBUlyaiIFNgIAIA0gB0kgBSANSXIhDSACQQhqIQIgBkEIaiEGIBAgDkECaiIORw0ACyAeRQ0BCyADQZwJaiAOQQJ0IgJqIgYgBigCACIGIANB5AJqIAJqKAIAaiICIA1qIgU2AgAgAiAGSQ0BIAUgAkkNAQwCCyANRQ0BCyARQSdLDQUgA0GcCWogEUECdGpBATYCACARQQFqIRELIAMgETYCvAogGSARIBkgEUsbIgJBKU8NBSACQQJ0IQICQAJAA0AgAkUNAUF/IAJBfGoiAiADQZwJamooAgAiBiACIANBiARqaigCACIFRyAGIAVLGyIGRQ0ADAILC0F/QQAgA0GcCWogAmogA0GcCWpHGyEGCwJAIBQgBEgNACAGIARIDQBBACEMQQAhDiASRQ0NIBJBf2pB/////wNxIgJBAWoiBUEDcSEGAkAgAkEDTw0AIANBHGohAkIAIR8MDQsgBUH8////B3EhBSADQRxqIQJCACEfA0AgAiACNQIAQgp+IB98Ih8+AgAgAkEEaiINIA01AgBCCn4gH0IgiHwiHz4CACACQQhqIg0gDTUCAEIKfiAfQiCIfCIfPgIAIAJBDGoiDSANNQIAQgp+IB9CIIh8Ih8+AgAgH0IgiCEfIAJBEGohAiAFQXxqIgUNAAwNCwsgBiAETg0KAkAgFCAETg0AIANBHGpBARBDGiADKAK8ASICIAMoAqgFIgYgAiAGSxsiAkEpTw0IIAJBAnQhAiADQRxqQXxqIQ0CQAJAA0AgAkUNASANIAJqIQZBfyACQXxqIgIgA0GIBGpqKAIAIgUgBigCACIGRyAFIAZLGyIGRQ0ADAILC0F/QQAgA0GIBGogAmogA0GIBGpHGyEGCyAGQQJPDQsLIANBC2ogD2ohDUF/IQYgDyECAkADQCACIgVFDQEgBkEBaiEGIAVBf2oiAiADQQtqai0AAEE5Rg0ACyADQQtqIAJqIgIgAi0AAEEBajoAACAFIBxLDQsgA0ELaiAFakEwIAYQ9gMaDAsLIANBMToACwJAIBxFDQAgA0EMakEwIBwQ9gMaIBxBD0sNCQsgDUEwOgAAIAtBAWohCyAcQQJqIQ8MFwsgFEEoQZTKwAAQ7QEACyAQQShBlMrAABDtAQALIBJBKEGUysAAEO0BAAsgAkEoQZTKwAAQ7QEAC0EoQShBlMrAABDqAQALIAJBKEGUysAAEO0BAAtBEUERQYihwAAQ6gEACyACQShBlMrAABDtAQALIA9BEUGYocAAEOoBAAsgEUEoQZTKwAAQ7QEACyAcQRFJDQwgD0ERQaihwAAQ7QEACwJAIAZFDQADQCACIAI1AgBCCn4gH3wiHz4CACACQQRqIQIgH0IgiCEfIAZBf2oiBg0ACwsCQCAfpyICDQAgEiEODAELIBJBJ0sNASADQRxqIBJBAnRqIAI2AgAgEkEBaiEOCyADIA42ArwBIB1FDQIgHUF/akH/////A3EiAkEBaiIFQQNxIQYCQCACQQNPDQAgA0HAAWohAkIAIR8MAgsgBUH8////B3EhBSADQcABaiECQgAhHwNAIAIgAjUCAEIKfiAffCIfPgIAIAJBBGoiDSANNQIAQgp+IB9CIIh8Ih8+AgAgAkEIaiINIA01AgBCCn4gH0IgiHwiHz4CACACQQxqIg0gDTUCAEIKfiAfQiCIfCIfPgIAIB9CIIghHyACQRBqIQIgBUF8aiIFDQAMAgsLIBJBKEGUysAAEOoBAAsCQCAGRQ0AA0AgAiACNQIAQgp+IB98Ih8+AgAgAkEEaiECIB9CIIghHyAGQX9qIgYNAAsLAkAgH6ciAg0AIB0hDAwBCyAdQSdLDQEgA0HAAWogHUECdGogAjYCACAdQQFqIQwLIAMgDDYC4AICQCATDQBBACETDAMLIBNBf2pB/////wNxIgJBAWoiBUEDcSEGAkAgAkEDTw0AIANB5AJqIQJCACEfDAILIAVB/P///wdxIQUgA0HkAmohAkIAIR8DQCACIAI1AgBCCn4gH3wiHz4CACACQQRqIg0gDTUCAEIKfiAfQiCIfCIfPgIAIAJBCGoiDSANNQIAQgp+IB9CIIh8Ih8+AgAgAkEMaiINIA01AgBCCn4gH0IgiHwiHz4CACAfQiCIIR8gAkEQaiECIAVBfGoiBQ0ADAILCyAdQShBlMrAABDqAQALAkAgBkUNAANAIAIgAjUCAEIKfiAffCIfPgIAIAJBBGohAiAfQiCIIR8gBkF/aiIGDQALCyAfpyICRQ0AIBNBJ0sNAyADQeQCaiATQQJ0aiACNgIAIBNBAWohEwsgAyATNgKEBCAOIBggDiAYSxsiEkEoTQ0ACwsgEkEoQZTKwAAQ7QEACyATQShBlMrAABDqAQALIBFBKEGUysAAEOoBAAsgAyADQQtqIA8gC0EAIANBnAlqEHAgAygCBCEGIAMoAgAhAgsgA0GECGogBjYCACADIAI2AoAIIAMgCTYC/AcgAyAINgL4ByAAIANB+AdqEFwhAiADQcAKaiQAIAIPC0GkysAAQRpBlMrAABCjAgALQaTKwABBGkGUysAAEKMCAAtBpMrAAEEaQZTKwAAQowIAC0GkysAAQRpBlMrAABCjAgALozUCHH8HfiMAQdAOayIEJAAgAb0hIAJAAkAgASABYQ0AQQIhBQwBCyAgQv////////8HgyIhQoCAgICAgIAIhCAgQgGGQv7///////8PgyAgQjSIp0H/D3EiBhsiIkIBgyEjQQMhBQJAAkACQAJAQQFBAkEEICBCgICAgICAgPj/AIMiJFAiBxsgJEKAgICAgICA+P8AURtBA0EEIAcbICFQG0F/ag4EBAABAgQLQQQhBQwDCyAGQc13aiEIDAELQoCAgICAgIAgICJCAYYgIkKAgICAgICACFEiBRshIkHLd0HMdyAFGyAGaiEICyAjUCEFCwJAAkACQAJAAkACQCAFQX5qQf8BcSIFQQMgBUEDSRsiB0UNAEHQr8AAQdGvwAAgIEIAUyIFG0HQr8AAQfC7wQAgBRsgAhshCUEBIQVBASAgQj+IpyACGyEKIAdBf2oOAwECAwELIARBAzYCtA0gBEHSr8AANgKwDSAEQQI7AawNQQEhBSAEQawNaiECQQAhCkHwu8EAIQkMBAsgBEEDNgK0DSAEQdWvwAA2ArANIARBAjsBrA0gBEGsDWohAgwDC0ECIQUgBEECOwGsDSADRQ0BIARBvA1qIAM2AgAgBEEAOwG4DSAEQQI2ArQNIARBjK/AADYCsA0gBEGsDWohAgwCCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQXRBBSAIwSILQQBIGyALbCIFQb/9AEsNAAJAAkAgIkIAUQ0AIAVBBHYiDEEVaiENQQAgA2tBgIB+IANBgIACSRvBIQ4CQEGgfyAIQWBqIAggIkKAgICAEFQiBRsiAkFwaiACICJCIIYgIiAFGyIgQoCAgICAgMAAVCIFGyICQXhqIAIgIEIQhiAgIAUbIiBCgICAgICAgIABVCIFGyICQXxqIAIgIEIIhiAgIAUbIiBCgICAgICAgIAQVCIFGyICQX5qIAIgIEIEhiAgIAUbIiBCgICAgICAgIDAAFQiBRsgIEIChiAgIAUbIiBCf1UiAmsiB2vBQdAAbEGwpwVqQc4QbkEEdCIFQaiiwABqKQMAIiFC/////w+DIiQgICACrYYiIEIgiCIjfiIlQiCIICFCIIgiISAjfnwgISAgQv////8PgyIgfiIhQiCIfCAlQv////8PgyAkICB+QiCIfCAhQv////8Pg3xCgICAgAh8QiCIfCIgQgFBQCAHIAVBsKLAAGovAQBqayICQT9xrSIkhiImQn98IiODIiFCAFINACAEQQA2ApAIDAULIAVBsqLAAGovAQAhBgJAICAgJIinIgdBkM4ASQ0AIAdBwIQ9SQ0CAkAgB0GAwtcvSQ0AQQhBCSAHQYCU69wDSSIFGyEPQYDC1y9BgJTr3AMgBRshBQwFC0EGQQcgB0GAreIESSIFGyEPQcCEPUGAreIEIAUbIQUMBAsCQCAHQeQASQ0AQQJBAyAHQegHSSIFGyEPQeQAQegHIAUbIQUMBAtBCkEBIAdBCUsiDxshBQwDC0G4ocAAQRxBqK7AABCjAgALQQRBBSAHQaCNBkkiBRshD0GQzgBBoI0GIAUbIQUMAQtB2a/AAEElQYCwwAAQowIACwJAAkAgDyAGa0EBasEiECAOTA0AIAJB//8DcSERIBAgDmsiAsEgDSACIA1JGyISQX9qIRNBACECAkACQAJAA0AgBEEQaiACaiAHIAVuIgZBMGo6AAAgByAGIAVsayEHIBMgAkYNAiAPIAJGDQEgAkEBaiECIAVBCkkhBiAFQQpuIQUgBkUNAAtBgK3AAEEZQYiuwAAQowIACyACQQFqIQVBbCAMayECIBFBf2pBP3GtISVCASEgA0ACQCAgICWIUA0AIARBADYCkAgMBgsgAiAFakEBRg0CIARBEGogBWogIUIKfiIhICSIp0EwajoAACAgQgp+ISAgISAjgyEhIBIgBUEBaiIFRw0ACyAEQZAIaiAEQRBqIA0gEiAQIA4gISAmICAQbwwDCyAEQZAIaiAEQRBqIA0gEiAQIA4gB60gJIYgIXwgBa0gJIYgJhBvDAILIAUgDUGYrsAAEOoBAAsgBEGQCGogBEEQaiANQQAgECAOICBCCoAgBa0gJIYgJhBvCyAEKAKQCCIFDQELIAQgIj4CnAggBEEBQQIgIkKAgICAEFQiBRs2ArwJIARBACAiQiCIpyAFGzYCoAggBEGkCGpBAEGYARD2AxogBEHECWpBAEGcARD2AxogBEEBNgLACSAEQQE2AuAKIAitwyAiQn98eX1CwprB6AR+QoChzaC0AnxCIIinIgXBIRECQAJAIAtBAEgNACAEQZwIaiAIQf//A3EQQxoMAQsgBEHACWpBACAIa8EQQxoLAkACQCARQX9KDQAgBEGcCGpBACARa0H//wNxEEgaDAELIARBwAlqIAVB//8DcRBIGgsgBCAEKALgCiILNgLMDiAEQawNaiAEQcAJakGgARD3AxoCQAJAAkAgC0EoTQ0AIAshBQwBCyAEQawNakF4aiEPIA0hCCALIQUDQAJAIAVFDQAgBUECdCEHAkACQCAFQX9qQf////8DcSIFDQAgBEGsDWogB2ohBUIAISAMAQsgBUEBaiIFQQFxIQYgBUH+////B3EhAiAPIAdqIQdCACEgA0AgByIFQQRqIgcgIEIghiAHNQIAhCIgQoCU69wDgCIiPgIAIAUgIkKA7JSjfH4gIHxCIIYgBTUCAIQiIEKAlOvcA4AiIj4CACAiQoDslKN8fiAgfCEgIAVBeGohByACQX5qIgINAAsgBkUNAQsgBUF8aiIFICBCIIYgBTUCAIRCgJTr3AOAPgIACyAIQXdqIghBCU0NAiAEKALMDiIFQSlJDQALCyAFQShBlMrAABDtAQALAkACQAJAAkACQCAIQQJ0QdiewABqKAIAIgJFDQAgBCgCzA4iBUEpTw0GAkAgBQ0AQQAhBQwFCyAFQQJ0IQcgAq0hICAFQX9qQf////8DcSIFDQEgBEGsDWogB2ohBUIAISIMAgtB28rAAEEbQZTKwAAQowIACyAFQQFqIgVBAXEhCCAFQf7///8HcSECIAcgBEGsDWpqQXhqIQdCACEiA0AgByIFQQRqIgcgIkIghiAHNQIAhCIiICCAIiE+AgAgBSAiICEgIH59QiCGIAU1AgCEIiIgIIAiIT4CACAiICEgIH59ISIgBUF4aiEHIAJBfmoiAg0ACyAIRQ0BCyAFQXxqIgUgIkIghiAFNQIAhCAggD4CAAsgBCgCzA4hBQsgBSAEKAK8CSIQIAUgEEsbIhRBKEsNBAJAAkAgFA0AQQAhFAwBC0EAIQZBACEIAkACQAJAIBRBAUYNACAUQQFxIRUgFEF+cSEMQQAhCCAEQZwIaiECIARBrA1qIQVBACEGA0AgBSAFKAIAIg8gAigCAGoiByAIQQFxaiITNgIAIAVBBGoiCCAIKAIAIhIgAkEEaigCAGoiCCAHIA9JIBMgB0lyaiIHNgIAIAggEkkgByAISXIhCCAFQQhqIQUgAkEIaiECIAwgBkECaiIGRw0ACyAVRQ0BCyAEQawNaiAGQQJ0IgVqIgIgAigCACICIARBnAhqIAVqKAIAaiIFIAhqIgc2AgAgBSACSQ0BIAcgBUkNAQwCCyAIRQ0BCyAUQSdLDQMgBEGsDWogFEECdGpBATYCACAUQQFqIRQLIAQgFDYCzA4gFCALIBQgC0sbIgVBKU8NAyAFQQJ0IQUCQAJAA0AgBUUNAUF/IAVBfGoiBSAEQcAJamooAgAiAiAFIARBrA1qaigCACIHRyACIAdLGyICRQ0ADAILC0F/QQAgBEHACWogBWogBEHACWpHGyECCwJAIAJBAUsNACARQQFqIREMCAsCQCAQDQBBACEQDAcLIBBBf2pB/////wNxIgVBAWoiB0EDcSECAkAgBUEDTw0AIARBnAhqIQVCACEgDAYLIAdB/P///wdxIQcgBEGcCGohBUIAISADQCAFIAU1AgBCCn4gIHwiID4CACAFQQRqIgggCDUCAEIKfiAgQiCIfCIgPgIAIAVBCGoiCCAINQIAQgp+ICBCIIh8IiA+AgAgBUEMaiIIIAg1AgBCCn4gIEIgiHwiID4CACAgQiCIISAgBUEQaiEFIAdBfGoiBw0ADAYLCyAELwGYCCERIAQoApQIIQYMDQsgBUEoQZTKwAAQ7QEAC0EoQShBlMrAABDqAQALIAVBKEGUysAAEO0BAAsgFEEoQZTKwAAQ7QEACwJAIAJFDQADQCAFIAU1AgBCCn4gIHwiID4CACAFQQRqIQUgIEIgiCEgIAJBf2oiAg0ACwsgIKciBUUNACAQQSdLDQIgBEGcCGogEEECdGogBTYCACAQQQFqIRALIAQgEDYCvAkLQQAhDwJAAkAgEcEiBSAOSCIWDQAgESAOa8EgDSAFIA5rIA1JGyIGDQFBACEPC0EAIQYMBgsgBCALNgKEDCAEQeQKaiAEQcAJakGgARD3AxogBEHkCmpBARBDIRcgBCAEKALgCjYCqA0gBEGIDGogBEHACWpBoAEQ9wMaIARBiAxqQQIQQyEYIAQgBCgC4Ao2AswOIARBrA1qIARBwAlqQaABEPcDGiAEQawNakEDEEMhGSAEKAK8CSEQIAQoAuAKIQsgBCgChAwhGiAEKAKoDSEbIAQoAswOIRxBACEdAkADQCAdIRQCQAJAAkACQAJAAkACQAJAIBBBKU8NACAUQQFqIR0gEEECdCEHQQAhBQJAAkACQAJAA0AgByAFRg0BIARBnAhqIAVqIQIgBUEEaiEFIAIoAgBFDQALIBAgHCAQIBxLGyIVQSlPDQUgFUECdCEFAkACQANAIAVFDQFBfyAFQXxqIgUgBEGsDWpqKAIAIgIgBSAEQZwIamooAgAiB0cgAiAHSxsiAkUNAAwCCwtBf0EAIARBrA1qIAVqIBlHGyECC0EAIR4gAkECTw0DIBVFDQJBASEIQQAhDwJAIBVBAUYNACAVQQFxIR4gFUF+cSEMQQAhD0EBIQggBEGsDWohAiAEQZwIaiEFA0AgBSAFKAIAIhMgAigCAEF/c2oiByAIQQFxaiISNgIAIAVBBGoiCCAIKAIAIhAgAkEEaigCAEF/c2oiCCAHIBNJIBIgB0lyaiIHNgIAIAggEEkgByAISXIhCCAFQQhqIQUgAkEIaiECIAwgD0ECaiIPRw0ACyAeRQ0CCyAEQZwIaiAPQQJ0IgVqIgIgAigCACICIBkgBWooAgBBf3NqIgUgCGoiBzYCACAFIAJJDQIgByAFSQ0CDBILIAYgDUsNBQJAIAYgFEYNACAEQRBqIBRqQTAgBiAUaxD2AxoLIARBEGohBQwTCyAIRQ0QCyAEIBU2ArwJQQghHiAVIRALIBAgGyAQIBtLGyIMQSlPDQMgDEECdCEFAkACQANAIAVFDQFBfyAFQXxqIgUgBEGIDGpqKAIAIgIgBSAEQZwIamooAgAiB0cgAiAHSxsiAkUNAAwCCwtBf0EAIARBiAxqIAVqIBhHGyECCwJAAkAgAkEBTQ0AIBAhDAwBCwJAIAxFDQBBASEIQQAhDwJAAkAgDEEBRg0AIAxBAXEhHyAMQX5xIRVBACEPQQEhCCAEQYgMaiECIARBnAhqIQUDQCAFIAUoAgAiEyACKAIAQX9zaiIHIAhBAXFqIhI2AgAgBUEEaiIIIAgoAgAiECACQQRqKAIAQX9zaiIIIAcgE0kgEiAHSXJqIgc2AgAgCCAQSSAHIAhJciEIIAVBCGohBSACQQhqIQIgFSAPQQJqIg9HDQALIB9FDQELIARBnAhqIA9BAnQiBWoiAiACKAIAIgIgGCAFaigCAEF/c2oiBSAIaiIHNgIAIAUgAkkNASAHIAVJDQEMEAsgCEUNDwsgBCAMNgK8CSAeQQRyIR4LIAwgGiAMIBpLGyIVQSlPDQQgFUECdCEFAkACQANAIAVFDQFBfyAFQXxqIgUgBEHkCmpqKAIAIgIgBSAEQZwIamooAgAiB0cgAiAHSxsiAkUNAAwCCwtBf0EAIARB5ApqIAVqIBdHGyECCwJAAkAgAkEBTQ0AIAwhFQwBCwJAIBVFDQBBASEIQQAhDwJAAkAgFUEBRg0AIBVBAXEhHyAVQX5xIQxBACEPQQEhCCAEQeQKaiECIARBnAhqIQUDQCAFIAUoAgAiEyACKAIAQX9zaiIHIAhBAXFqIhI2AgAgBUEEaiIIIAgoAgAiECACQQRqKAIAQX9zaiIIIAcgE0kgEiAHSXJqIgc2AgAgCCAQSSAHIAhJciEIIAVBCGohBSACQQhqIQIgDCAPQQJqIg9HDQALIB9FDQELIARBnAhqIA9BAnQiBWoiAiACKAIAIgIgFyAFaigCAEF/c2oiBSAIaiIHNgIAIAUgAkkNASAHIAVJDQEMDwsgCEUNDgsgBCAVNgK8CSAeQQJqIR4LIBUgCyAVIAtLGyIQQSlPDQUgEEECdCEFAkACQANAIAVFDQFBfyAFQXxqIgUgBEHACWpqKAIAIgIgBSAEQZwIamooAgAiB0cgAiAHSxsiAkUNAAwCCwtBf0EAIARBwAlqIAVqIARBwAlqRxshAgsCQAJAIAJBAU0NACAVIRAMAQsCQCAQRQ0AQQEhCEEAIQ8CQAJAIBBBAUYNACAQQQFxIR8gEEF+cSEVQQAhD0EBIQggBEHACWohAiAEQZwIaiEFA0AgBSAFKAIAIhMgAigCAEF/c2oiByAIQQFxaiISNgIAIAVBBGoiCCAIKAIAIgwgAkEEaigCAEF/c2oiCCAHIBNJIBIgB0lyaiIHNgIAIAggDEkgByAISXIhCCAFQQhqIQUgAkEIaiECIBUgD0ECaiIPRw0ACyAfRQ0BCyAEQZwIaiAPQQJ0IgVqIgIgAigCACICIARBwAlqIAVqKAIAQX9zaiIFIAhqIgc2AgAgBSACSQ0BIAcgBUkNAQwOCyAIRQ0NCyAEIBA2ArwJIB5BAWohHgsCQCAUIA1GDQAgBEEQaiAUaiAeQTBqOgAAAkAgEA0AQQAhEAwJCyAQQX9qQf////8DcSIFQQFqIgdBA3EhAgJAIAVBA08NACAEQZwIaiEFQgAhIAwICyAHQfz///8HcSEHIARBnAhqIQVCACEgA0AgBSAFNQIAQgp+ICB8IiA+AgAgBUEEaiIIIAg1AgBCCn4gIEIgiHwiID4CACAFQQhqIgggCDUCAEIKfiAgQiCIfCIgPgIAIAVBDGoiCCAINQIAQgp+ICBCIIh8IiA+AgAgIEIgiCEgIAVBEGohBSAHQXxqIgcNAAwICwsgDSANQYSiwAAQ6gEACyAQQShBlMrAABDtAQALIBVBKEGUysAAEO0BAAsgBiANQZSiwAAQ7QEACyAMQShBlMrAABDtAQALIBVBKEGUysAAEO0BAAsgEEEoQZTKwAAQ7QEACwJAIAJFDQADQCAFIAU1AgBCCn4gIHwiID4CACAFQQRqIQUgIEIgiCEgIAJBf2oiAg0ACwsgIKciBUUNACAQQSdLDQIgBEGcCGogEEECdGogBTYCACAQQQFqIRALIAQgEDYCvAkgHSAGRw0AC0EBIQ8MBgtBKEEoQZTKwAAQ6gEACyAQQShBlMrAABDqAQALQaTKwABBGkGUysAAEKMCAAtBpMrAAEEaQZTKwAAQowIAC0GkysAAQRpBlMrAABCjAgALQaTKwABBGkGUysAAEKMCAAsCQAJAAkACQAJAAkACQAJAIAtBKU8NAAJAIAsNAEEAIQsMAwsgC0F/akH/////A3EiBUEBaiIHQQNxIQICQCAFQQNPDQAgBEHACWohBUIAISAMAgsgB0H8////B3EhByAEQcAJaiEFQgAhIANAIAUgBTUCAEIFfiAgfCIgPgIAIAVBBGoiCCAINQIAQgV+ICBCIIh8IiA+AgAgBUEIaiIIIAg1AgBCBX4gIEIgiHwiID4CACAFQQxqIgggCDUCAEIFfiAgQiCIfCIgPgIAICBCIIghICAFQRBqIQUgB0F8aiIHDQAMAgsLIAtBKEGUysAAEO0BAAsCQCACRQ0AA0AgBSAFNQIAQgV+ICB8IiA+AgAgBUEEaiEFICBCIIghICACQX9qIgINAAsLICCnIgVFDQAgC0EnSw0BIARBwAlqIAtBAnRqIAU2AgAgC0EBaiELCyAEIAs2AuAKIBAgCyAQIAtLGyIFQSlPDQEgBUECdCEFAkACQANAIAVFDQFBfyAFQXxqIgUgBEHACWpqKAIAIgIgBSAEQZwIamooAgAiB0cgAiAHSxsiAkUNAAwCCwtBf0EAIARBwAlqIAVqIARBwAlqRxshAgsCQAJAIAJB/wFxDgIAAQYLIA9FDQUgBkF/aiIFIA1PDQMgBEEQaiAFai0AAEEBcUUNBQsgBiANSw0DIARBEGogBmohCEF/IQIgBiEFAkADQCAFIgdFDQEgAkEBaiECIAdBf2oiBSAEQRBqai0AAEE5Rg0ACyAEQRBqIAVqIgUgBS0AAEEBajoAACAHIAZPDQUgBEEQaiAHakEwIAIQ9gMaDAULAkACQCAGDQBBMSEFDAELIARBMToAEEEwIQUgBkEBRg0AQTAhBSAEQRBqQQFqQTAgBkF/ahD2AxoLIBFBAWohESAWDQQgBiANTw0EIAggBToAACAGQQFqIQYMBAtBKEEoQZTKwAAQ6gEACyAFQShBlMrAABDtAQALIAUgDUHUocAAEOoBAAsgBiANQeShwAAQ7QEACyAGIA1LDQEgBEEQaiEFCwJAIBHBIA5MDQAgBEEIaiAFIAYgESADIARBrA1qEHAgBCgCDCEFIAQoAgghAgwDC0ECIQUgBEECOwGsDQJAIAMNAEEBIQUgBEEBNgK0DSAEQdivwAA2ArANIARBrA1qIQIMAwsgBEG8DWogAzYCACAEQQA7AbgNIARBAjYCtA0gBEGMr8AANgKwDSAEQawNaiECDAILIAYgDUH0ocAAEO0BAAtBASEFIARBATYCtA0gBEHYr8AANgKwDSAEQawNaiECCyAEQZQMaiAFNgIAIAQgAjYCkAwgBCAKNgKMDCAEIAk2AogMIAAgBEGIDGoQXCEFIARB0A5qJAAgBQu3JwIWfwJ+IwBBwAJrIgQkACABLQAAIQUgBEEANgI4IARCBDcCMCAEQYgCakEMaiEGIARByAFqQQRqIQcgBEHoAWpBBGohCCAEQagBakEEaiEJIARBPGpBDGohCiAEQYgCakEEaiELIARBjAFqQRBqIQwgBEGMAWpBDGohDSAEQYwBakEEaiEOIARBPGpBBGohDyAEQdgAakEEaiEQIARBqAJqQQRqIREgBEH0AGpBBGohEkEAIQFBBCETAkACQAJAAkACQANAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMNAEEAIQMMAQsgBEIBNwKIAiAEQegBaiAEQYgCahDeASAELQDoAQ0CIAQtAOkBDQEgBCgCOCEBIAQoAjAhEwsgBCgCNCEUDBILIARBiAJqQSQgAiADEKcBIAQoApACIRUgBCgCjAIhAQJAAkACQAJAIAQoAogCDQAgBCABNgKMASAEIAEgFWo2ApABAkACQAJAIARBjAFqEMcCIhZBgIDEAEYNACAEIBY2AqgCQd3YwABBBCAWEDcNAQtBACEBDAELIARBAjYCjAIgBEGA2cAANgKIAiAEQgE3ApQCIARBBzYCrAEgBCAEQagBajYCkAIgBCAEQagCajYCqAEgBEHIAWogBEGIAmoQbSAEQegBaiABIBUgBEHIAWoQngMgBCgC7AEhASAEKALoAUUNAwsgBCkC+AEhGiAEKAL0ASEWIAQoAvABIRUMAQsgBCkCmAIhGiAEKAKUAiEWCyAEIBY2AoABIAQgFTYCfCAEIAE2AnggBEEBNgJ0IAQgGj4ChAEgBCAaQiCIPgKIAQJAIAENACAEQagBakHcAEEkIAIgAxCQAQJAAkACQAJAIAQoAqgBDQAgESAJKQIANwIAIBFBCGogCUEIaigCADYCACAEKAK0AiEWIAQoArACIRUgBCgCrAIhAQwBCyAEKAKsAQ0BIARBiAJqQSQgAiADEKcBIAQoApQCIRYgBCgCkAIhFSAEKAKMAiEBAkACQAJAAkAgBCgCiAINACAEQYgCaiABIBUQiwEgBCgCkAIhFCAEKAKMAiETAkACQCAEKAKIAg0AIAQgFDYC0AEgBCATNgLMAUEAIQEgBEEANgLIAUEAIRMMAQsgBCgClAIhFyAEIAQpApgCNwL4ASAEIBc2AvQBIAQgFDYC8AEgBCATNgLsASAEQQE2AugBAkACQCATDQAgBEGIAmpBKCABIBUQpwECQAJAIAQoAogCIhMNAEEAIRcMAQsgBCAEKQKYAjcC2AEgBCAEKAKUAjYC1AFBASEXCyAEKAKMAiEUIAQgBCgCkAI2AtABIAQgFDYCzAEgBCAXNgLIASAIEIgDIBMNAUEAIQFBACETDAILIAcgCCkCADcCACAHQRBqIAhBEGooAgA2AgAgB0EIaiAIQQhqKQIANwIAIARBATYCyAELQQEhEwsgBEHIAWoQqAMgEw0CDAELIAQpApgCIRoLIAQgGjcCuAIgBCAWNgK0AiAEIBU2ArACIAQgATYCrAJBASETQQAhFAwBCyAEIBY2ArQCIAQgFTYCsAIgBCABNgKsAkEAIRNBASEUCyAEIBM2AqgCIAkQiAMgFEUNAgsgEhCIAwwRCyARIAkpAgA3AgAgEUEQaiAJQRBqKAIANgIAIBFBCGogCUEIaikCADcCACAEQQE2AqgCIAQoAqwCIQELIAENAiAEQYwBakHcAEHgACACIAMQkAEgBCgCkAEhAQJAIAQoAowBDQBBACEYDA4LIAENBiAEQagBakHcAEEiIAIgAxCQASAEKAKsASEBAkAgBCgCqAENAEEAIRgMDAsgAQ0FIARByAFqQdwAQSggAiADEJABIAQoAswBIQECQCAEKALIAQ0AQQAhGAwKCyABDQQgBEHoAWpB3ABBKSACIAMQkAEgBCgC7AEhAQJAIAQoAugBDQBBACEYDAgLAkACQAJAIAENACAEQYgCakHcAEEnIAIgAxCQASAEKAKUAiEWIAQoApACIRUgBCgCjAIhASAEKAKIAg0BIBkgFiAFGyEWIBggFSAFGyEVQQAgASAFGyEBIAUhGAwCC0EBIRggBCkC+AEhGwwJCyAEKQKYAiEbQQEhGAsgCBCIAwwICyAEKQKEASEbDA8LIAQoAvQBIRYgBCgC8AEhFQwNCyAEKQK4AiEbIAQoArQCIRYgBCgCsAIhFSASEIgDDA0LIARB/AFqKAIAIRYgBEH4AWooAgAhAyAEQfQBaigCACEPIARB8AFqKAIAIQIgBCgC7AEhAQwSC0EBIRggBCkC2AEhGwwEC0EBIRggBCkCuAEhGwwFC0EBIRggBCkCnAEhGwwGCyAEKAL0ASEWIAQoAvABIRULIAcQiAMMAQsgBCgC1AEhFiAEKALQASEVCyAJEIgDDAELIAQoArQBIRYgBCgCsAEhFQsgDhCIAwwBCyAEKAKYASEWIAQoApQBIRULIBEQiAMgEhCIAyAYDQELIAQgFTYCYCAEIAE2AlwgDyAQKQIANwIAIAQgFjYCaCAEQQA2AmQgD0EIaiAQQQhqKQIANwIAIA9BEGogEEEQaikCADcCAAwBCyAEIBs3AmggBCAWNgJkIAQgFTYCYCAEIAE2AlwgBEEBNgJYAkACQAJAAkACQCABDQAgBEEoakECEOkBIAQoAiwhEyAEKAIoIhlBpNAAOwAAIARBiAJqIBlBAiACIAMQ0AEgBCgCkAIhGCAEKAKMAiEBIAQoAogCDQEgBEGIAmogASAYEDwgBEHoAWpBCGoiFCAGQQhqKAIANgIAIAQgBikCADcD6AEgBCgCkAIhGCAEKAKMAiEBIAQoAogCDQIgBEHIAWpBCGoiFyAUKAIANgIAIAQgBCkD6AE3A8gBIARBiAJqQSkgASAYEKcBIAQoApACIRggBCgCjAIhAQJAIAQoAogCDQAgBEGoAWpBCGogFygCADYCACAEIAQpA8gBNwOoAUEBIRQMBQsgBCAEKQKYAjcCrAEgBCAEKAKUAjYCqAEgBEHIAWoQuAMMAwsgDyAQKQIANwIAIA9BEGogEEEQaigCADYCACAPQQhqIBBBCGopAgA3AgAgBEEBNgI8DAYLIAQgBCgCnAI2ArABIAQgBCkClAI3A6gBDAELIARBqAFqQQhqIBQoAgA2AgAgBCAEKQPoATcDqAELQQAhFAsgGSATELcDIARBqAJqQQhqIhkgBEGoAWpBCGooAgA2AgAgBCAEKQOoATcDqAICQAJAAkACQCAURQ0AIARBiAJqQQhqIBkoAgAiGTYCACAEIAQpA6gCIho3A4gCIAwgGjcCACAMQQhqIBk2AgAgBEECNgKYASAEIBg2ApQBIAQgATYCkAEgD0EQaiAOQRBqKQIANwIAIA9BCGogDkEIaikCADcCACAPIA4pAgA3AgBBACEBDAELIA0gBCkDqAI3AgAgDUEIaiAZKAIANgIAIAQgGDYClAEgBCABNgKQASAEQQE2AowBIAFFDQEgDyAOKQIANwIAIA9BEGogDkEQaigCADYCACAPQQhqIA5BCGopAgA3AgBBASEBCyAEIAE2AjwMAQsgBEGIAmpBJCACIAMQpwEgBCgCkAIhGCAEKAKMAiEBAkACQAJAAkACQAJAAkACQAJAAkAgBCgCiAINACAEQYgCaiABIBgQiwEgBCgCmAIhGSAEKAKUAiETIAQoApACIRggBCgCjAIhAQJAIAQoAogCRQ0AIAQoApwCIRQMAgsgBCAYNgKwASAEIAE2AqwBIA8gCSkCADcCACAEIBM2ArgBIARBATYCtAEgD0EIaiAJQQhqKQIANwIAIAQgGTYCvAEgD0EQaiAJQRBqKQIANwIAQQAhASAEQQA2AqgBDAILIAQoApwCIRQgBCgCmAIhGSAEKAKUAiETCyAEIBQ2ArwBIAQgGTYCuAEgBCATNgK0ASAEIBg2ArABIAQgATYCrAEgBEEBNgKoAQJAIAENACAEQYgCakHgACACIAMQpwECQAJAIAQoAogCRQ0AIAcgCykCADcCACAHQRBqIAtBEGooAgA2AgAgB0EIaiALQQhqKQIANwIADAELIAcgAiADQZDZwABBMRDEAQsgBEEBNgLIAQJAIAQoAswBDQAgBEGIAmpB3ABBICACIAMQkAEgBCgClAIhGCAEKAKQAiEZIAQoAowCIQECQAJAIAQoAogCDQACQCAFDQBBACEBDAILIAQgGTYC8AEgBCABNgLsASAPIAgpAgA3AgAgBCAYNgL4AUEAIQEgBEEANgL0ASAPQQhqIAhBCGopAgA3AgAgD0EQaiAIQRBqKQIANwIAIARBADYC6AEMCAsgBCkCmAIhGgsgBCAaNwL4ASAEIBg2AvQBIAQgGTYC8AEgBCABNgLsASAEQQE2AugBAkAgAQ0AIARBqAJqIAIgAxC1ASAEKAK0AiEYIAQoArACIRkgBCgCrAIhEwJAAkACQAJAIAQoAqgCDQAgBUUNAUEAIQEgGBChAkUNAgwDCyAEKQK4AiEaIBMhAQwCC0EAIQEgGEEiRg0BDAYLQcHZwABBDCAYEDdFDQULIAQgGjcCmAIgBCAYNgKUAiAEIBk2ApACIAQgATYCjAIgBEEBNgKIAgJAAkACQAJAIAENAAJAIAUNACAEQgE3AjxBASEBDAQLIARBqAJqIAIgAxA6IAQoArwCIQEgBCgCuAIhGCAEKAK0AiEZIAQoArACIRMgBCgCrAIhFCAEKAKoAg0BQRAQpwMiFyABNgIMIBcgGDYCCCAXIBk2AgQgF0EDNgIAIARCgYCAgBA3AlAgBCAXNgJMIARBAzYCSCAEIBM2AkQgBCAUNgJAQQAhAQwCCyAPIAspAgA3AgAgD0EQaiALQRBqKAIANgIAIA9BCGogC0EIaikCADcCAEEBIQEMCAsgBCABNgJQIAQgGDYCTCAEIBk2AkggBCATNgJEIAQgFDYCQEEBIQELIAQgATYCPAsgCxCIAwwGCyAPIAgpAgA3AgAgD0EQaiAIQRBqKAIANgIAIA9BCGogCEEIaikCADcCAEEBIQEMBgsgDyAHKQIANwIAIA9BEGogB0EQaigCADYCACAPQQhqIAdBCGopAgA3AgBBASEBIARBATYCPAwHCyAPIAkpAgA3AgAgD0EQaiAJQRBqKAIANgIAIA9BCGogCUEIaikCADcCAEEBIQELIAQgATYCPAwGCyAEIBk2ApACIAQgEzYCjAIgDyALKQIANwIAIAQgGDYCmAJBACEBIARBADYClAIgD0EIaiALQQhqKQIANwIAIA9BEGogC0EQaikCADcCACAEQQA2AogCCyAEIAE2AjwLIAgQiAMMAQsgBCABNgI8CyAHEIgDCyAJEIgDCyAOEIgDCwJAIAQoAlhFDQAgEBCIAwsgAQ0CCyAEKAJEIQMgBCgCQCECAkAgBCgCOCIBIAQoAjRHDQAgBEEwaiABEKEBIAQoAjghAQsgBCgCMCITIAFBBHRqIhggCikCADcCACAYQQhqIApBCGopAgA3AgAgBCABQQFqIgE2AjggFSEYIBYhGQwACwsgBCgCQCIBDQEgBCgCOCEBIAQoAjQhFCAEKAIwIRMgDxCIAwsgBEEANgLwASAEQgQ3AugBIBMgAUEEdCIZaiEKQQAhFSATIQEDQAJAAkACQAJAAkACQAJAIBkgFUcNACAKIQEMAQsgASgCDCEYIAEoAgghDyABKAIEIRYCQCABKAIADgUFAgMEAAULIBMgFWpBEGohAQsgASAKIAFrQQR2ELACIBMgFBCiAyAAQQhqIAM2AgAgACACNgIEIABBADYCACAAQQxqIAQpAugBNwIAIABBFGogBEHoAWpBCGooAgA2AgAMCAsgBEEgaiAPEOkBIAQoAiQhGCAEKAIgIBYgDxD3AyEWIAQgDzYClAIgBCAYNgKQAiAEIBY2AowCIARBATYCiAIgBEHoAWogBEGIAmoQggIMAwsgBCAYNgKUAiAEIA82ApACIAQgFjYCjAIgBEECNgKIAiAEQegBaiAEQYgCahCCAgwCCyAEIBY2ApACIAQgDzYCjAIgBCAWNgKIAiAEQegBaiAYQf////8AcSIPEKICIAQoAugBIAQoAvABIg5BBHRqIBYgGEEEdBD3AxogBCAWNgKUAiAEIA4gD2o2AvABIARBiAJqEO4CDAELAkACQCAEKALwASIPRQ0AIA9BBHQgBCgC6AFqQXBqIg8oAgBFDQELIARBADYCyAEgBEEQaiAWIARByAFqEJUBIAQoAhAhDyAEQQhqIAQoAhQiFhDpASAEKAIMIRggBCgCCCAPIBYQ9wMhDyAEIBY2ApQCIAQgGDYCkAIgBCAPNgKMAiAEQQA2AogCIARB6AFqIARBiAJqEIICDAELIA9BBGohGAJAIBZBgAFJDQAgBEEANgKIAiAEQRhqIBYgBEGIAmoQlQEgGCAEKAIYIAQoAhwQ4gEMAQsCQCAPQQxqKAIAIg4gD0EIaigCAEcNACAYIA4Q0wIgDygCDCEOCyAPKAIEIA5qIBY6AAAgDyAPKAIMQQFqNgIMCyABQRBqIQEgFUEQaiEVDAALCyAEKAJQIRYgBCgCTCEDIAQoAkghDyAEKAJEIQILIAQoAjAiFSAEKAI4ELACIBUgBCgCNBCiAyAAQRRqIBY2AgAgAEEQaiADNgIAIABBDGogDzYCACAAQQhqIAI2AgAgACABNgIEIABBATYCAAsgBEHAAmokAAv/HAIUfwJ+IwBB4ANrIgMkACADQSRqIAI2AgAgA0EQakEQaiABNgIAIANBEGpBDGpBKTYCACADQRBqQQhqQc3ZwAA2AgAgA0KogICAkAU3AhAgA0GAAWpBKCABIAIQpwECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMoAoABDQAgA0GAAWogAygChAEgA0GAAWpBCGooAgAQtwECQCADKAKAAUUNACADQZABaikCACEXIANBjAFqKAIAIQQgA0GIAWooAgAhBSADKAKEASEGDAQLIANBgAFqIAMoAoQBIANBiAFqIgYoAgAQPCADKAKAAQ0BIAYoAgAhBiADQYABakEMaiIHKAIAIQUgAygChAEhBCADIANBkAFqIggpAgAiFzcCtAIgAyAFNgKwAiADQYABaiADQRRqIAQgBhBiIAMoAoABRQ0CIAgpAgAhFyAHKAIAIQQgA0GIAWooAgAhBSADKAKEASEGIANBsAJqELgDDAMLIANBgAFqQRBqKQIAIRcgA0GAAWpBDGooAgAhBCADQYABakEIaigCACEFIAMoAoQBIQYMAgsgA0GQAWopAgAhFyADQYwBaigCACEEIAYoAgAhBSADKAKEASEGDAELIANBiAFqKAIAIQYgAygChAEhB0EMEKcDIgQgFzcCBCAEIAU2AgAgAyAENgL0AiADKQL0AiEXQQAhBQwBCyADQfgCaiAXNwIAIANB9AJqIAQ2AgAgA0HwAmogBTYCACADIAY2AuwCIANBADYC6AIgBg0BIANBgAFqIAEgAhBBAkACQAJAAkACQAJAIAMoAoABDQAgA0GIAWoiBygCACEGIANBjAFqIggpAgAhGCADKAKEASEFIAMgA0GUAWoiBCgCADYCuAIgAyAYNwOwAiADQYABaiAFIAYQNCADKAKAAQ0BIAcoAgAhCSAIKQIAIRcgAygChAEhByADIAQoAgAiBjYCiAEgAyAXNwOAASAGDQQgA0GAAWoQlQJBACEGIAkhBUEAIQQMAgsgA0GUAWooAgAhBCADQYwBaikCACEXIANBiAFqKAIAIQUgAygChAEhBgwCCyAEKAIAIQQgCCkCACEXIAcoAgAhBSADKAKEASEGCyADQbACahCUAgtBACEHDAELIBinIQUgAyAGNgIYIAMgFzcDECADKQIUIRggF6chBCADKQK0AiEXIAkhBgsgA0HsAmoQiAMgB0UNAgsgAyAYNwKQASADIAQ2AowBIAMgFzcChAEgAyAFNgKAASADQegCaiAHIAYQtwECQCADKALoAkUNACADQfwCaigCACEEIANB9AJqKQIAIRcgA0HwAmooAgAhBSADKALsAiEGIANBgAFqEOACDAILIANB6AJqQQhqKAIAIQogAygC7AIhCyADIBg3AsACIAMgBDYCvAIgAyAXNwK0AiADIAU2ArACIANBADYCrAMgA0IENwKkAyADQYABakEUaiEMIANBgAFqQQxqIQ0gA0GAAWpBCGohCSADQegCakEMaiEOIANBEGpBDGohCCADQegCakEUaiEPQQQhEEEAIQYgCiEFIAshEQJAA0ACQAJAAkAgBQ0AQQAhBQwBCyADQgE3AugCIANBgAFqIANB6AJqEN4BIAMtAIABDQggAy0AgQENAQsgA0HYAmpBCGogA0GkA2pBCGooAgA2AgAgAyADKQKkAzcD2AIMBgsgA0HoAmogESAFEDUCQCADKALwAiISQQNGDQAgA0HQA2pBCGogD0EIaigCACIENgIAIAMgDykCACIXNwPQAyADKALsAiEHIAMoAugCIRMgAygC9AIhFCADKAL4AiEVIAhBCGoiFiAENgIAIAgg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A6gBIANBiAJqQQhqIgUoAgAhBiADKAKMAiEHIAUgBDYCACADIA83A4gCIAQNAiADQYgCahCUAkEAIQQMAQsgA0HIAGpBCGogA0GcAmooAgA2AgAgAyADQZQCaikCADcDSCADQYgCakEIaigCACEGIAMoAowCIQQLIANB5AJqIAMpA0g3AgAgA0HgAmogBjYCACADQQg2AtgCIANB7AJqIANByABqQQhqKAIANgIAIAMgBDYC3AIMAQsgA0H4AGpBCGogBSgCACIENgIAIAMgAykDiAIiDzcDeCADQcgAakEIaiAENgIAIAMgDzcDSCADQYgCaiAHIAYQNAJAAkAgAygCiAJFDQAgA0HQAmpBFGogA0GUAmopAgA3AgAgA0HsAmogA0GIAmpBFGooAgA2AgAgAyADKQKMAjcC3AIgA0EINgLYAgwBCyADQagBakEIaiADQZwCaigCACIGNgIAIAMgA0GUAmopAgAiDzcDqAEgA0GIAmpBCGoiBCgCACEFIAMoAowCIQcgBCAGNgIAIAMgDzcDiAICQCAGRQ0AIANCCDcC2AIgA0GIAmoQlQIMAQsCQAJAAkAgAygCUCIGQQFLDQAgBkUNAiADQeQCaiADKAJIIgRBCGopAgA3AgAgA0HsAmogBEEQaikCADcCACADIAQpAgA3AtwCIAQgBEEYaiAGQRhsQWhqEPgDGkEFIQggA0EFNgLYAiADIAU2AtQCIAMgBzYC0AIgAyAGQX9qNgJQDAELIANB0AJqIAEgAkH41cAAQc0AEI8DIAMoAtgCIQgLIANBiAJqEJUCIANByABqEJQCIAhBCEYNAiADQRBqQQhqIANB+AJqKQIANwMAIANBIGogA0GAA2opAgA3AwAgA0GSAWogA0GLA2otAAA6AAAgAyADKQLwAjcDECADIAMvAIkDOwGQASADKALsAiECIAMoAugCIQcgAygC5AIhBCADKALgAiEFIAMoAtwCIQYgAygC1AIhASADKALQAiEJIAMtAIgDIQoMAwsQ0gEACyADQcgAahCUAgsCQCADKALcAiIGRQ0AIANB7AJqKAIAIQIgA0HoAmooAgAhByADQeQCaigCACEEIANB4AJqKAIAIQUMAgsgA0EIakEBEOkBIAMoAgwhCSADKAIIIghBIToAACADQYgCaiAIQQEgASACENABAkACQAJAIAMoAogCDQAgA0GIAmpBEGoiBSgCACEHIANBiAJqQQxqIgsoAgAhBCADQYgCaiADKAKMAiADQYgCakEIaiIGKAIAEGQCQCADKAKIAkUNACADQZwCaigCACEKIAUoAgAhByALKAIAIQQgBigCACEFDAILIANBqAFqQRBqIAc2AgAgA0GoAWpBDGogBDYCACADQagBakEIaiAGKAIAIgU2AgAgAyADKAKMAiIGNgKsAUEAIQpBASELDAILIANBnAJqKAIAIQogA0GYAmooAgAhByADQZQCaigCACEEIANBkAJqKAIAIQULIAMoAowCIQYgA0G8AWogCjYCACADQbgBaiAHNgIAIANBtAFqIAQ2AgAgA0GwAWogBTYCACADIAY2AqwBQQEhCkEAIQsLIAMgCjYCqAEgCCAJELcDAkACQAJAAkACQCALRQ0AIAYhASAFIQIMAQsgBg0BIANBrAFqEIgDQQAhBAsgA0GIAmogASACEDACQCADKAKQAiIIQQVHDQAgA0GkAmooAgAhAiADQaACaigCACEHIANBnAJqKAIAIQQgA0GYAmooAgAhBSADKAKUAiEGDAILIANBGGogA0GwAmopAgA3AwAgA0EgaiADQbgCaikCADcDACADQZABakECaiADQcgAakECai0AADoAACADIAMpAqgCNwMQIAMgAy8ASDsBkAEgBEEARyEKIAMoAqQCIQIgAygCoAIhByADKAKcAiEEIAMoApgCIQUgAygClAIhBiADKAKMAiEBIAMoAogCIQkMAgsgA0G8AWooAgAhAgtBCCEICwJAIAMoAtgCQQhHDQAgA0HcAmoQiAMLIAhBCEYNAQsgA0HQAmpBKGogA0EQakEQaikDADcCACADQdACakEgaiADQRBqQQhqIgspAwA3AgAgA0GDA2ogA0GSAWotAAA6AAAgAyADKQMQNwLoAiADIAMvAZABOwCBAyADIAo6AIADIAMgAjYC5AIgAyAHNgLgAiADIAQ2AtwCIAMgBTYC2AIgAyAGNgLUAiADIAg2AtACIANBiAJqIAkgARC3ASADKAKIAkUNASADQZwCaigCACECIANBiAJqQRBqKAIAIQcgA0GUAmooAgAhBCADQYgCakEIaigCACEFIAMoAowCIQYgA0HQAmoQnwILIAAgBjYCDCAAQQg2AgggAEEcaiACNgIAIABBGGogBzYCACAAQRRqIAQ2AgAgAEEQaiAFNgIADAELIANBiAJqQQhqKAIAIQkgAygCjAIhCiADQegBakEIaiIMIANB0AJqQRhqIgFBCGopAgA3AwAgA0HoAWpBEGoiDSABQRBqKQIANwMAIANB6AFqQRhqIg4gAUEYaigCADYCACADIAEpAgA3A+gBIAMgAjYCJCADIAc2AiAgAyAENgIcIAMgBTYCGCADIAY2AhQgAyAINgIQIANBEGpBIGogDCkDADcCACADQRBqQShqIA0pAwA3AgAgA0HAAGogDigCADYCACADIAMpA+gBNwIoIANB+ABqIAogCRBqAkACQAJAAkAgAygCeCIFRQ0AAkAgAygCfA0AIANByABqIAtBLBD3AxoMAgsgAEEINgIIIAAgA0H8AGoiBikCADcCDCAAQRxqIAZBEGooAgA2AgAgAEEUaiAGQQhqKQIANwIADAMLIANBhAFqLQAAIQcgA0GIAmogAygCfCIGIANB+ABqQQhqKAIAIgQQMgJAAkAgAygCkAJBCEcNACADQdACaiAGIAQQMgJAAkACQCADKALYAiICQQhHDQACQCADKALcAiIBRQ0AIANB6AJqKAIAIQQgA0HgAmooAgAhAiADQewCaigCACEIIANB5AJqKAIAIQYgA0EsEOkBIAMoAgQhCSADKAIAQbzVwABBLBD3AyEKIANBLDYCzAIgAyAJNgLIAiADIAo2AsQCIANBxAJqQZDTwABBAhDiASADQcQCaiAGIAgQ4gEgA0G0AWogASACIANBxAJqENgBIANBCDYCsAEgBiAEELcDDAMLIANBqAFqIAYgBEG81cAAQSwQjwMgAkEIRw0BQQANAiADKALcAkUNAiADQeQCaigCACADQegCaigCABC3AwwCCyADQagBaiAGIARBvNXAAEEsEI8DCyADQdACahDwAgsgA0GIAmoQ8AIMAQsgA0GoAWogA0GIAmpBPBD3AxoLIAMoArABIgJBCEYNASADQZABakEIaiIGIANBvAFqKQIANwMAIANBkAFqQRBqIgQgA0HEAWooAgA2AgAgAyADKQK0ATcDkAEgAygCrAEhCSADKAKoASEKIANB6AJqIgEgA0HgAWooAgA2AgAgA0HQAmpBEGoiCCADQdgBaikCADcDACADQdACakEIaiILIANB0AFqKQIANwMAIAMgAykCyAE3A9ACIANBiAJqQRBqIgwgBCgCADYCACADQYgCakEIaiINIAYpAwA3AwAgAyADKQOQATcDiAJB7AAQpwMiBiADQRBqQTQQ9wMiBCACNgI0IAQgBzoAaCAEIAMpA4gCNwI4IARBwABqIA0pAwA3AgAgBEHIAGogDCgCADYCACAEIAMpA9ACNwJMIARB1ABqIAspAwA3AgAgBEHcAGogCCkDADcCACAEQeQAaiABKAIANgIAQQchCAsgACAGNgIMIAAgCDYCCCAAIAk2AgQgACAKNgIAIABBEGogA0HIAGpBLBD3AxogBUUNAiADQfwAahCIAwwCCyADQaABaiADQagBakEcaigCACIGNgIAIANBkAFqQQhqIANBqAFqQRRqKQIAIg83AwAgAyADKQK0ASIQNwOQASAAQRxqIAY2AgAgAEEUaiAPNwIAIAAgEDcCDCAAQQg2AggLIANBEGoQnwILIANBkANqJAALpRkDCn8BfgF8IwBBkAJrIgIkACACIAE2AoABAkACQAJAAkACQAJAIAEQoAMNAAJAIAEQBSIDQQFLDQAgAEEAOgAAIAAgA0EARzoAAQwECwJAAkACQAJAAkAgARARQQFGDQAgAkHwAGogARAGIAIoAnBFDQEgAisDeCENIAEQEg0CIAAgDTkDCCAAQQo6AAAMCAsgAiABNgKYASACQRhqIAEQwwIgAigCGEUNAyACIAIpAyAiDBATNgLQASACQZgBaiACQdABahC7AyEDIAIoAtABELYDIAIoApgBIQEgA0UNAyABELYDIAAgDDcDCCAAQQg6AAAMCQsgAkHoAGogARAHIAIoAmgiA0UNASACQeAAaiADIAIoAmwQqwIgAigCYCIERQ0BIAIoAmQhAyAAIAQ2AgQgAEEMOgAAIAAgAzYCDCAAIAM2AggMBgsgAEEIOgAAIA1EAAAAAAAA4MNmIQMCQAJAIA2ZRAAAAAAAAOBDY0UNACANsCEMDAELQoCAgICAgICAgH8hDAsgAEIAQv///////////wAgDEKAgICAgICAgIB/IAMbIA1E////////30NkGyANIA1iGzcDCAwFCwJAAkAgARDsAw0AIAJBhAFqIAJBgAFqEMABIAIoAoQBRQ0BIAJB2wFqIAJBhAFqQQhqKAIANgAAIABBDjoAACACIAIpAoQBNwDTASAAIAIpANABNwABIABBCGogAkHXAWopAAA3AAAMBgsgAiABNgKwAQJAIAJBsAFqEMMDIgFFDQBBCCEDIAJBgAJqQQhqIAEoAgAQEDYCACACQQA2AoQCIAJBADYCjAIgAiABNgKAAiACQThqIAJBgAJqEKwCAkAgAigCPCIBQYCABCABQYCABEkbQQAgAigCOBsiAUUNAEEIIAFBBHQQhQMiA0UNBQsgAkEANgL4ASACIAE2AvQBIAIgAzYC8AEgAkGYAWpBAXIhBCACQdABakEBciEFA0AgAkEwaiACQYACahCOAkEWIQECQCACKAIwRQ0AIAIoAjQhASACIAIoAowCQQFqNgKMAiACQdABaiABEDMgAi0A0AEiAUEWRg0HIAJBxAFqQQJqIAVBAmotAAA6AAAgAiAFLwAAOwHEASACKALUASEDIAIpA9gBIQwLIAQgAi8BxAE7AAAgBEECaiACQcQBakECai0AADoAACACIAw3A6ABIAIgAzYCnAEgAiABOgCYAQJAIAFBFkYNACACQfABaiACQZgBahD+AQwBCwsgAkGYAWoQrgMgAkHbAWogAkHwAWpBCGooAgA2AAAgAEEUOgAAIAIgAikC8AE3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAwHCyACQdABaiACKAKwARCaASACKALQASEBAkACQAJAIAItANQBIgNBfmoOAgIAAQsgAEEWOgAAIAAgATYCBAwICyACIAE2AvABIAIgA0EARzoA9AEgAkEANgKIAiACQgg3AoACIAJBmAFqQQFyIQMgAkHQAWpBAXIhBgJAAkACQAJAA0AgAkEoaiACQfABahC7ASACKAIsIQRBFiEBAkACQCACKAIoDgMABAEACyACQdABaiAEEDMgAi0A0AEiAUEWRg0CIAJBxAFqQQJqIAZBAmotAAA6AAAgAiAGLwAAOwHEASACKALUASEFIAIpA9gBIQwLIAMgAi8BxAE7AAAgA0ECaiACQcQBakECai0AADoAACACIAw3A6ABIAIgBTYCnAEgAiABOgCYASABQRZGDQMgAkGAAmogAkGYAWoQ/gEMAAsLIAIoAtQBIQQLIABBFjoAACAAIAQ2AgQgAkGAAmoQkAIMAQsgAkGYAWoQrgMgAkHbAWogAkGAAmpBCGooAgA2AAAgAEEUOgAAIAIgAikCgAI3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAsgAigC8AEQtgMMBwsgACACQbABahDRAgwGCwJAAkAgARAUQQFHDQAQFSIDIAEQFiEEIAMQtgMgBEEBRw0BCyAAIAJBgAFqENECIAIoAoABIQEMBQsgAiABNgKQASACQdABaiABEJoBIAIoAtABIQMCQAJAAkAgAi0A1AEiBEF+ag4CAgABCyAAQRY6AAAgACADNgIEDAYLIAJBvAFqIARBAEc6AAAgAiADNgK4ASACQQA2ArABIAJBADYCzAEgAkIINwLEASACQeABaiEFIAJB0AFqQQFyIQYgAkGAAmpBAXIhByACQZgBakEBciEIIAJBsAFqQQhqIQkCQANAIAJByABqIAkQuwEgAigCTCEKQQEhBEEWIQMCQAJAAkACQCACKAJIDgMAAQMACyACQcAAaiAKEOQCIAIoAkAhAyACKAJEIQQgAigCsAEgAigCtAEQxgMgAiAENgK0ASACQQE2ArABIAJBmAFqIAMQMwJAIAItAJgBIgNBFkcNACACKAKcASEKDAELIAcgCC8AADsAACAHQQJqIgogCEECai0AADoAACACIAIpA6ABIgw3A4gCIAIgAigCnAEiCzYChAIgAiADOgCAAiACQQA2ArABIAJBmAFqIAQQMyACLQCYAUEWRw0BIAIoApwBIQogAkGAAmoQ5wELIABBFjoAACAAIAo2AgQgAkHEAWoQkQIMAwsgAkHwAWpBCGogAkGYAWpBCGopAwA3AwAgAiACKQOYATcD8AEgAkGUAWpBAmogCi0AADoAACACIAcvAAA7AZQBQQAhBAsgBiACLwGUATsAACAFIAIpA/ABNwMAIAZBAmogAkGUAWpBAmotAAA6AAAgBUEIaiACQfABakEIaikDADcDACACIAw3A9gBIAIgCzYC1AEgAiADOgDQAQJAIAQNACACQcQBaiACQdABahDRAQwBCwsgAkHQAWoQrwMgAkHbAWogAkHEAWpBCGooAgA2AAAgAEEVOgAAIAIgAikCxAE3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAsgAigCuAEQtgMgAigCsAEgAigCtAEQxgMMBQsCQCABEBRBAUYNACAAIAJBkAFqENECIAIoApABIQEMBQsgAiABEBciAzYClAEgAkGYAWpBEGogAxAQIgM2AgAgAkGkAWpBADYCACACQQA2AqwBIAJBADYCmAEgAiACQZQBajYCoAFBCCEEAkAgA0GAgAIgA0GAgAJJGyIDRQ0AQQggA0EFdBCFAyIERQ0DCyACQZgBakEIaiEHIAJBADYCzAEgAiADNgLIASACIAQ2AsQBIAJB0AFqQRBqIQYgAkHQAWpBAXIhCiACQfABakEBciELIAJBlAFqIQUCQAJAAkACQANAQRYhAwJAIAVFDQAgAkHYAGogBxCbAkEWIQMgAigCWEUNACACQdAAaiACKAJcEOQCIAIgAigCrAFBAWo2AqwBIAIoAlQhAyACQYACaiACKAJQEDMgAi0AgAJBFkYNAiACQfABakEIaiACQYACakEIaiIEKQMANwMAIAIgAikDgAI3A/ABIAJBgAJqIAMQMwJAIAItAIACQRZHDQAgAigChAIhBCACQfABahDnAQwECyACQbABakEIaiAEKQMANwMAIAIgAikDgAI3A7ABIAJBwAFqQQJqIAtBAmotAAA6AAAgAiALLwAAOwHAASACKAL0ASEEIAItAPABIgNBF0YNAyACKQP4ASEMCyAKIAIvAcABOwAAIAYgAikDsAE3AwAgCkECaiACQcABakECai0AADoAACAGQQhqIAJBsAFqQQhqKQMANwMAIAIgDDcD2AEgAiAENgLUASACIAM6ANABIANBFkYNAyACQcQBaiACQdABahDRASACKAKgASEFDAALCyACKAKEAiEEIAMQtgMLIABBFjoAACAAIAQ2AgQgAkHEAWoQkQIMAQsgAkHQAWoQrwMgAkHbAWogAkHEAWpBCGooAgA2AAAgAEEVOgAAIAIgAikCxAE3ANMBIAAgAikA0AE3AAEgAEEIaiACQdcBaikAADcAAAsgAigCmAEgAigCnAEQxgMgAigClAEQtgMMBAsgAiABNgKYASACQQhqIAEQwwICQCACKAIIRQ0AIAIgAikDECIMEBg2AtABIAJBmAFqIAJB0AFqELsDIQMgAigC0AEQtgMgAigCmAEhASADRQ0AIAEQtgMgACAMNwMIIABBBDoAAAwGC0HricAAQc8AELABIQMgAEEWOgAAIAAgAzYCBAwDCyAAQRI6AAAMAgsACyACKALUASEBIABBFjoAACAAIAE2AgQgAkHwAWoQkAIMAQsgARC2AwwBCyACKAKwARC2AwsgAkGQAmokAAuUEgIUfwN+IwBBwAFrIgMkAEEAIQQgA0EANgIMIANCBDcCBCADQYgBakEMaiEFQQQhBiADQYgBakEEaiEHIANBoAFqQQxqIQggA0GIAWpBDWohCSADQaABakENaiEKIANB8ABqQQRqIQsgA0GgAWpBBGohDCADQcAAakEEaiENIANB2ABqQQRqIQ4gA0HwAGpBDWohD0EAIRACQAJAAkADQAJAAkAgAkUNACADQaABaiABIAIQaiADKAKoASERIAMoAqQBIRICQAJAAkACQCADKAKgAQ0AIAMgEjYCXAwBCyAPIAopAAA3AAAgD0EHaiAKQQdqIhMoAAA2AAAgAyADLQCsAToAfCADIBE2AnggAyASNgJ0IANBATYCcAJAAkACQCASDQAgA0GgAWogASACEH8CQAJAIAMoAqABDQAgByAMKQIANwIAIAdBCGogDEEIaikCADcCAAwBCwJAIAMoAqQBRQ0AIAcgDCkCADcCACAHQRBqIAxBEGooAgA2AgAgB0EIaiAMQQhqKQIANwIADAMLIANBiAFqIAEgAhC1AiAMEIgDIAMoAogBDQILIAMgAygCkAEiETYCYCADIAMoAowBIhI2AlxBACEUQQEhFQwCCyAOIAspAgA3AgAgDkEQaiALQRBqKAIANgIAIA5BCGogC0EIaikCADcCAEEBIRQgA0EBNgJYIAMoAlwhEgwDCyADIAMoApwBNgJsIAMgAykClAE3AmQgAyADKAKQASIRNgJgIAMgAygCjAEiEjYCXEEBIRRBACEVCyADIBQ2AlggCxCIAyAVRQ0BCyADIBE2AkggAyASNgJEIANBADYCQAwBCwJAAkACQCASDQAgA0GgAWogASACEDUCQCADKAKoASISQQNGDQAgA0GIAWpBCGogCEEIaikCACIXNwMAIANBiAFqQRBqIAhBEGooAgAiETYCACADIAgpAgAiGDcDiAEgAykCoAEhGSAMQRBqIBE2AgAgDEEIaiAXNwIAIAwgGDcCACADIBI2AqABIANBoAFqEKYDIAMgGTcCRCADQQA2AkAMAwsgA0GIAWpBEGogCEEQaigCACISNgIAIANBiAFqQQhqIAhBCGopAgAiFzcDACADIAgpAgAiGDcDiAEgC0EQaiIRIBI2AgAgC0EIaiISIBc3AgAgCyAYNwIAIANBATYCcCADKAJ0RQ0BIA0gCykCADcCACANQRBqIBEoAgA2AgAgDUEIaiASKQIANwIAIANBATYCQAwCCyANIA4pAgA3AgAgDUEQaiAOQRBqKAIANgIAIA1BCGogDkEIaikCADcCACADQQE2AkAMAgsgA0GgAWogASACEF8gAygCqAEhESADKAKkASESAkACQCADKAKgAQ0AIAMgETYCSCADIBI2AkQgA0EANgJADAELIAkgCikAADcAACAJQQdqIBMoAAA2AAAgAyADLQCsAToAlAEgAyARNgKQASADIBI2AowBIANBATYCiAECQAJAAkAgEg0AIANBoAFqQSkgASACEKcBIAMoAqABDQFBACESDAILIA0gBykCADcCACANQRBqIAdBEGooAgA2AgAgDUEIaiAHQQhqKQIANwIAIANBATYCQAwCCyADIAMpArABNwJQIAMgAygCrAE2AkxBASESCyADKAKkASERIAMgAygCqAE2AkggAyARNgJEIAMgEjYCQCAHEIgDCyALEIgDCyAURQ0AIA4QiAMLIANBKGogA0HAAGoQ3gEgAy0AKA0DIAMtACkNASACIQQLIAAgATYCBCAAQQA2AgAgAEEIaiAENgIAIABBDGogAykCBDcCACAAQRRqIANBBGpBCGooAgA2AgAMBAsgA0GgAWogASACEEogA0HwAGpBCGoiEyAIQQhqKAIANgIAIAMgCCkCADcDcCADKAKoASERIAMoAqQBIRICQAJAAkACQAJAAkACQCADKAKgAQ0AIANBoAFqQQhqIhQgEygCACITNgIAIAMgAykDcDcDoAECQCATDQAgA0GgAWoQnANBACESIBYhEQwCCyADQcAAakEIaiAUKAIAIhM2AgAgAyADKQOgASIXNwNAIANB2ABqQQhqIhYgEzYCACADIBc3A1ggA0GgAWogEiAREL0BIAMoAqgBIRMgAygCpAEhEiADKAKgAQ0CIANBoAFqIBIgExC3ASADKAKoASETIAMoAqQBIRIgAygCoAFFDQUgA0HwAGpBCGogCEEIaigCADYCACADIAgpAgA3A3AgEyERDAMLIANB2ABqQQhqIANB8ABqQQhqKAIANgIAIAMgAykDcDcDWAsgA0EoakEIaiADQdgAakEIaigCADYCACADIAMpA1g3AygMAgsgA0HwAGpBCGogCEEIaigCADYCACADIAgpAgA3A3AgEyERCyADQShqQQhqIANB8ABqQQhqKAIANgIAIAMgAykDcDcDKCADQdgAahCcAwsgA0EQakEIaiADQShqQQhqKAIAIhA2AgAgAyADKQMoIhc3AxAgBUEIaiAQNgIAIAUgFzcCACADIBE2ApABIAMgEjYCjAEgA0EBNgKIASASDQEgACABNgIEIABBADYCACAAQQhqIAI2AgAgAEEMaiADKQIENwIAIABBFGogA0EEakEIaigCADYCACAHEIgDDAULIANBEGpBCGogFigCACICNgIAIAMgAykDWCIXNwMQIBQgAjYCACADIBc3A6ABIAUgFzcCACAFQQhqIgEgAjYCACADIBI2AowBIAMgEzYCkAECQCAQIAMoAghHDQAgA0EEaiAQEJ4BIAMoAgQhBiADKAIMIRALIAEoAgAhAiAGIBBBDGxqIgEgBSkCADcCACABQQhqIAI2AgAgAyADKAIMQQFqIhA2AgwgESEWIBMhAiASIQEMAQsLIABBATYCACAAIAcpAgA3AgQgAEEUaiAHQRBqKAIANgIAIABBDGogB0EIaikCADcCAAwBCyADQSJqIANBKGpBFGooAgAiEjYBACADQRpqIANBKGpBDGopAgAiFzcBACADIAMpAiwiGDcBEiAAQRRqIBI2AQAgAEEMaiAXNwEAIAAgGDcBBCAAQQE2AgALIANBBGoQlQILIANBwAFqJAALmBACCn8BfiMAQeABayIDJAAgA0EYaiABIAIQqwECQAJAAkACQCADKAIYIgRFDQACQCADKAIcIgVFDQAgA0EgaikCACENIABBGGogA0EYakEQaikCADcCACAAQRBqIA03AgAgACAFNgIMIABBAzYCCAwECyADQRxqEIgDIANBGGpBJiABIAIQpwECQAJAIAMoAhgNACADQSRqKAIAIQYgA0EgaigCACECIAMoAhwhAQwBCyADKAIcIgUNAiADQRxqEIgDQYCAxAAhBgsMAgsgA0EkaigCACEHIANBIGooAgAhAiADKAIcIQFBgIDEACEGDAELIANBIGopAgAhDSAAQRhqIANBGGpBEGopAgA3AgAgAEEQaiANNwIAIAAgBTYCDCAAQQM2AggMAQsgA0EQakECEOkBIAMoAhQhCCADKAIQIgVBvvwAOwAAIANBCGpBARDpASADKAIMIQkgAygCCCIKQT46AAAgA0ECEOkBIAMoAgQhCyADKAIAIgxBvvgBOwAAIANBPGpBAjYCACADQThqIAg2AgAgAyAFNgI0IANBAjYCMCADIAs2AiwgAyAMNgIoIANBATYCJCADIAk2AiAgAyAKNgIcIANBPDYCGCADQagBaiAFQQIgASACENABAkACQAJAAkACQAJAAkAgAygCqAENACADQewAaiICQQE6AAAgA0GwAWooAgAhCCADKAKsASEFIAIoAgAhCQwBCyADQeAAakEQaiADQagBakEQaikCADcCACADQeAAakEMaiADQagBakEMaigCACIJNgIAIANB4ABqQQhqIANBqAFqQQhqKAIAIgg2AgAgAyADKAKsASIFNgJkIANBATYCYAJAAkACQCAFDQAgA0HkAGohCyADQagBaiAKQQEgASACENABAkACQCADKAKoAQ0AIANBkAFqQQxqIANBqAFqQQxqKQIANwIAIAMgAykCrAE3ApQBDAELIANBrAFqIQUCQCADKAKsAUUNACADQaQBaiAFQRBqKAIANgIAIANBnAFqIAVBCGopAgA3AgAgAyAFKQIANwKUAQwDCyADQZABaiAMQQIgASACENABIAUQiAMgAygCkAENAgtBACEKIANBhAFqIgJBADoAACADQfgAakEIaiADQZABakEIaigCACIINgIAIAMgAygClAEiBTYCfCACKAIAIglBCHYhAgwCCyAJQQh2IQIgAykCcCENDAMLIANB+ABqQRBqIANBkAFqQRBqKQIANwIAIANB+ABqQQxqIANBkAFqQQxqKAIAIgk2AgAgA0H4AGpBCGogA0GQAWpBCGooAgAiCDYCACADIAMoApQBIgU2AnxBASEKIANBATYCeAJAIAUNACADQfwAaiEMIANBqAFqQTwgASACEKcBAkACQCADKAKoAQ0AIANBsAFqKAIAIQggAygCrAEhBUEAIQpBAiEJDAELIANBtAFqKAIAIglBCHYhAiADQbgBaikCACENIANBqAFqQQhqKAIAIQggAygCrAEhBUEBIQoLIAwQiAMMAQsgCUEIdiECIAMpAogBIQ0LIAsQiAMgCg0BCyADQRhqEMwCIANBGGpBJiAFIAgQpwECQAJAIAMoAhgNACADQRhqIAMoAhwgA0EYakEIaiICKAIAEKsBIAMoAhhFDQMgA0EoaikCACENIANBJGooAgAhDCACKAIAIQEMAQsgA0EoaikCACENIANBJGooAgAhDCADQSBqKAIAIQELIAMoAhwhAiADQbgBaiANNwIAIANBtAFqIgogDDYCACADQagBakEIaiABNgIAIAMgAjYCrAEgA0EBNgKoASACDQMgA0GsAWohCiADQRhqIAUgCBC3AQJAAkACQAJAIAMoAhgNACADQRhqIAMoAhwgA0EYakEIaiICKAIAEEogAygCGEUNAiADQfgAakEIaiADQSxqKAIANgIAIAMgA0EkaikCADcDeCACKAIAIQEMAQsgA0H4AGpBCGogA0EsaigCADYCACADIANBJGopAgA3A3ggA0EYakEIaigCACEBCyADKAIcIQIgA0HQAGpBCGogA0H4AGpBCGooAgA2AgAgAyADKQN4NwNQQQAhBQwBCyADQcABakEIaiIFIANBLGooAgA2AgAgAyADQSRqKQIANwPAASACKAIAIQEgAygCHCECIANB0ABqQQhqIAUoAgA2AgAgAyADKQPAATcDUEEBIQULIAoQiAMgBQ0CDAQLIAAgAjsAFSAAIAU2AgwgAEEDNgIIIABBF2ogAkEQdjoAACAAQRhqIA03AgAgAEEUaiAJOgAAIABBEGogCDYCACADQRhqEMwCDAQLIANBqAFqQQxqIgFBADYCACADQbgBaiADQRhqQQxqKAIANgIAIANB0ABqQQhqIANBvAFqKAIANgIAIAMgASkCADcDUCACKAIAIQEgAygCHCECCyADQcAAakEIaiADQdAAakEIaigCACIFNgIAIAMgAykDUCINNwNAIANBGGpBCGogBTYCACADIA03AxggACAHNgIMIABBAkEBIAZBgIDEAEYbQQAgBBs2AgggACABNgIEIAAgAjYCACAAIA03AhAgAEEYaiAFNgIAIAAgCToAHAwCCyADQdAAakEIaiAKQQhqKAIANgIAIAMgCikCADcDUAsgA0HAAGpBCGogA0HQAGpBCGooAgAiBTYCACADIAMpA1AiDTcDQCAAQRxqIAU2AgAgAEEUaiANNwIAIABBEGogATYCACAAIAI2AgwgAEEDNgIICyADQeABaiQAC+wPAgh/An4jAEHQAGsiAiQAIAJBwABqIAEQMwJAAkACQAJAAkACQAJAAkACQAJAAkAgAi0AQCIBQRZGDQAgAiACLQBDOgATIAIgAi8AQTsAESACIAIpA0giCjcDGCACIAIoAkQiAzYCFCAC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IANByAFqIQcgA0HgAGpBBGohCCADQfgAakEEaiEJIANBJGpBBGohCgJAAkACQAJAAkACQAJAAkADQAJAAkACQAJAAkACQAJAAkAgAg0AQQAhAgwBCyADQgE3ArABIANBJGogA0GwAWoQ3gEgAy0AJA0CIAMtACUNAQsgAygCXCELIAMoAlghDCADKAJUIQ0MCAsgAyACNgI4IAMgATYCNCADQR42AjAgA0Gh2MAANgIsIANCp4CAgPAENwIkIANBsAFqQScgASACEKcBIAMoArgBIQwgAygCtAEhDQJAAkACQAJAIAMoArABDQAgA0EANgK4ASADIA02ArABIAMgDSAMajYCtAECQAJAA0AgA0EYaiADQbABahDJASADKAIcIgtBJ0YNASALQYCAxABHDQALQQAhC0Hwu8EAIQ4MAQsgA0EQaiANIAwgAygCGEGA08AAEIACIAMoAhQhCyADKAIQIQ4LIANBCGogDSAMIAwgC2tBtNPAABCLAiADKAIMIQ0gAygCCCEMIANBsAFqIAogDiALEGIgAygCsAFFDQIgAykCwAEhDyADKAK8ASELIAMoArgBIQwgAygCtAEhDQwBCyADKQLAASEPIAMoArwBIQsLIAMgCzYChAEgAyAMNgKAASADIA02AnwgA0EBNgJ4IAMgDz4CiAEgAyAPQiCIPgKMASANDQEgA0EAOgDIASADQqKAgICgBDcCsAEgAyACNgLEASADIAE2AsABIANBHjYCvAEgA0G/2MAANgK4ASADQSRqQSIgASACEKcBIAMoAiwhDSADKAIoIQsCQAJAAkAgAygCJA0AIANBJGogByALIA0QLyADQaABakEIaiIMIARBCGooAgA2AgAgAyAEKQIANwOgASADKAIsIQ0gAygCKCELIAMoAiQNASADQZABakEIaiIOIAwoAgA2AgAgAyADKQOgATcDkAEgA0EkaiAGIAsgDRBiIAMoAiwhDSADKAIoIQsgAygCJA0CIAUgAykDkAE3AgAgBUEIaiAOKAIANgIAIAMgDTYCaCADIAs2AmQgA0EANgJgQQEhDAwICyADIAMpAjQ3AnAgAyADKAIwNgJsDAULIAUgAykDoAE3AgAgBUEIaiAMKAIANgIADAQLIAMgAykCNDcCcCADIAMoAjA2AmwgAyANNgJoIAMgCzYCZCADQQE2AmAgA0GQAWoQnAMMBAsgAykCtAEhD0EQEKcDIQsgAyANEOkBIAMoAgQhAiADKAIAIAwgDRD3AyEBIAsgDTYCDCALIAI2AgggCyABNgIEIAtBADYCACADQoGAgIAQNwKIASADIAs2AoQBIAMgDzcCfCAIQRBqIAlBEGooAgA2AgAgCEEIaiAJQQhqKQIANwIAIAggCSkCADcCACADKAJoIQ0gAygCZCELDAULIAggCSkCADcCACAIQRBqIAlBEGooAgA2AgAgCEEIaiAJQQhqKQIANwIAIANBATYCYCADKAJkIQsMBgsgA0E4aigCACEBIANBNGooAgAhDCADQTBqKAIAIQ0gA0EsaigCACECIAMoAighCwwKCyADIA02AmggAyALNgJkIANBATYCYAtBACEMCyAJEIgDIAxFDQILIANB1ABqIAUQgQIgDSECIAshAQwACwsgCw0BIAMoAlwhCyADKAJYIQwgAygCVCENIAgQiAMLIAMgCzYCuAEgAyAMNgK0ASADIA02ArABAkAgCw0AIANBsAFqEJ8DQQAhC0EAIQEMBQtBACEFIANBADYCRCADQQA2AjQgAyANNgIsIAMgDDYCKCADIA02AiQgAyANIAtBDGxqNgIwIANBsAFqIANBJGoQqQFBBCELAkACQCADKAKwAUEERw0AIANBJGoQsgJBACENDAELIANB+ABqIANBJGoQxQEgAygCeEEBaiILQX8gCxsiC0EEIAtBBEsbIg1B////P0sNAiANQQR0IgtBf0wNAiALEJ0DIgtFDQMgCyADKQKwATcCACALQQhqIANBsAFqQQhqKQIANwIAIANBATYCaCADIA02AmQgAyALNgJgIANBsAFqIANBJGpBMBD3AxogA0HgAGogA0GwAWoQswEgAygCYCELIAMoAmQhDSADKAJoIQULIAAgATYCBCAAQRRqIAU2AgAgAEEQaiANNgIAIABBDGogCzYCACAAQQhqIAI2AgBBACELDAULIANB9ABqKAIAIQEgAygCcCEMIAMoAmwhDSADKAJoIQIMAgsQwgIACwALIANB1ABqEJ8DCyAAIAs2AgQgAEEUaiABNgIAIABBEGogDDYCACAAQQxqIA02AgAgAEEIaiACNgIAQQEhCwsgACALNgIAIANB4AFqJAALpw0CDX8DfiMAQYABayIFJAAgBCABEK8CIQYgBUEcaiABIAQQ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IANBATYC4AEgAQ0EIANBMGogEiAQELUCAkACQCADKAIwIhANAAwBCyADKAJEIRQgAygCQCEVCyADKAI8IRMgAygCOCECIAMoAjQhASAFEIgDIBANBAsgAyACNgK0ASADIAE2ArABIANBADYCrAEgA0GsAWoQqAMMAQsLIAMoAvwBIQogAygC+AEhCyADKAL0ASENIAMoAvABIQ4gAygC7AEhDwwDCyADQcQAaigCACEUIANBwABqKAIAIRUgA0E8aigCACETIBAhAiASIQELIANBwAFqIBQ2AgAgA0G8AWogFTYCACADQbgBaiIKIBM2AgAgAyACNgK0ASADIAE2ArABIANBATYCrAECQCABDQAgA0GsAWoQqAMMBAsgA0EYakEIaiAKQQhqKAIANgIAIAMgCikCADcDGAwCCyADKAL0ASEKIAMoAvABIQsgAygC7AEhDSADKALoASEOIANBrAFqEJ8CCyADIAo2AkwgAyALNgJIIAMgDTYCRCADIA42AkAgAyAPNgI8IANBCDYCOAJAIA8NACADQRhqQQhqIANBJGpBCGooAgA2AgAgAyADKQIkNwMYIAgQiAMgASEPIAIhDgwDCyADQRhqQQhqIAdBCGooAgA2AgAgAyAHKQIANwMYIA4hAiAPIQELIANBJGoQuAMgA0EIakEIaiADQRhqQQhqKAIAIgo2AgAgAyADKQMYIhs3AwggAEEUaiAKNgIAIABBDGogGzcCACAAQQhqIAI2AgAgACABNgIEIABBATYCAAwCCyADQRhqQQhqIANBJGpBCGooAgA2AgAgAyADKQIkNwMYCyADQQhqQQhqIANBGGpBCGooAgAiCjYCACADIAMpAxgiGzcDCCADQTBqQQhqIAo2AgAgAyAbNwMwIABBCGogDjYCACAAIA82AgQgAEEMaiAbNwIAIABBFGogCjYCACAAQQA2AgALIANBoAJqJAALogsBDn8jAEHwAGsiAyQAIANBIGogASACEKsCIAMoAiQhBCADKAIgIQUCQAJAAkACQAJAAkACQAJAAkACQEEALQCwvEEiAkEDRg0AAkAgAg4DAAMCAAtBAEECOgCwvEFBAEEBEJADIQECQAJAAkACQAJAQQAoAsC8QUH/////B3FFDQAQ+gNFDQELQQAoArS8QSECQQBBfzYCtLxBIAINCUEAKALAvEFB/////wdxDQFBACABNgK8vEEMAgsgA0HkAGpCADcCACADQQE2AlwgA0Gk58AANgJYIANB8LvBADYCYCADQdgAakHI58AAEMACAAsQ+gMhAkEAIAE2Ary8QSACRQ0BC0EAKALAvEFB/////wdxRQ0AEPoDDQBBAEEBOgC4vEELQQBBAzoAsLxBQQBBADYCtLxBCyADQSxqIAUgBBA8IAMoAiwNBSADQcAAaigCACEGIANBLGpBCGooAgAhByADKAIwIQggA0EANgJoIAMgCCAHajYCZCADIAg2AmAgAyAHNgJcIAMgCDYCWCADQdgAakEIaiEBIANBOGohCQNAIAMoAmQhCiADKAJgIQsgA0EYaiABEMkBIAMoAhwiAkGAgMQARg0DIAMoAhghDCACEKECDQALIAogC2sgDGogAygCYCINaiADKAJkIgJrIQ4MAwsgA0HkAGpCADcCACADQQE2AlwgA0HchsAANgJYIANB8LvBADYCYCADQdgAakHghcAAEMACAAsgA0HkAGpCADcCACADQQE2AlwgA0GchsAANgJYIANB8LvBADYCYCADQdgAakHghcAAEMACAAtBACEMIAMoAmQhAiADKAJgIQ1BACEOCwJAA0AgDSACIgFGDQECQCABQX9qIgItAAAiCsAiC0F/Sg0AAkACQCABQX5qIgItAAAiCsAiD0FASA0AIApBH3EhCgwBCwJAAkAgAUF9aiICLQAAIgrAIhBBQEgNACAKQQ9xIQoMAQsgAUF8aiICLQAAQQdxQQZ0IBBBP3FyIQoLIApBBnQgD0E/cXIhCgsgCkEGdCALQT9xciIKQYCAxABGDQILIAoQoQINAAsgASANayADKAJoaiEOCwJAAkACQCAOIAxGDQAgA0HEAGogCCAHEMIDIANB2ABqIANBxABqEGMgAygCWA0BIANB5ABqKAIAIQYgA0HgAGooAgAhASADKAJcIQIMAgsCQCAGRQ0AIANBPGooAgAhASADKAI4IQIMBQsgA0EIakEEQQwQ4gIgAygCCCIBRQ0CIAFBDjYCCCABQdTUwAA2AgQgAUHEj8AANgIAIAkQuAMMBQtBACECIANB2ABqELkCIQELIAkQuAMMAgsACwJAAkAgAygCMEUNACADQdgAaiADQTBqEGMCQCADKAJYDQAgA0HkAGooAgAhBiADQeAAaigCACEBIAMoAlwhAgwD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A0HSAGogA0HoAGpBFGooAgAiDTYBACADQcoAaiADQegAakEMaikCACIRNwEAIAMgAykCbCISNwFCIABBFGogDTYBACAAQQxqIBE3AQAgACASNwEEIABBATYCAAsgA0EUahCUAgsgA0GAAWokAAuYCgEBfyMAQTBrIgIkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAtAAAOEgABAgMEBQYHCAkKCwwNDg8QEQALIAIgAC0AAToACCACQSRqQgE3AgAgAkECNgIcIAJBlOLAADYCGCACQQM2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDBELIAIgACkDCDcDCCACQSRqQgE3AgAgAkECNgIcIAJBsOLAADYCGCACQQQ2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDBALIAIgACkDCDcDCCACQSRqQgE3AgAgAkECNgIcIAJBsOLAADYCGCACQQU2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDA8LIAIgACsDCDkDCCACQSRqQgE3AgAgAkECNgIcIAJB0OLAADYCGCACQQY2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDA4LIAIgACgCBDYCCCACQSRqQgE3AgAgAkECNgIcIAJB7OLAADYCGCACQQc2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDA0LIAIgACkCBDcCCCACQSRqQgE3AgAgAkEBNgIcIAJBhOPAADYCGCACQQg2AhQgAiACQRBqNgIgIAIgAkEIajYCECABKAIUIAEoAhggAkEYahDtAyEBDAwLIAJBJGpCADcCACACQQE2AhwgAkGM48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAsLIAJBJGpCADcCACACQQE2AhwgAkGg48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAoLIAJBJGpCADcCACACQQE2AhwgAkG048AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAkLIAJBJGpCADcCACACQQE2AhwgAkHM48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAgLIAJBJGpCADcCACACQQE2AhwgAkHc48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAcLIAJBJGpCADcCACACQQE2AhwgAkHo48AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAYLIAJBJGpCADcCACACQQE2AhwgAkH048AANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAULIAJBJGpCADcCACACQQE2AhwgAkGI5MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAQLIAJBJGpCADcCACACQQE2AhwgAkGg5MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAMLIAJBJGpCADcCACACQQE2AhwgAkG45MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAILIAJBJGpCADcCACACQQE2AhwgAkHQ5MAANgIYIAJB8LvBADYCICABKAIUIAEoAhggAkEYahDtAyEBDAELIAEoAhQgACgCBCAAQQhqKAIAIAFBGGooAgAoAgwRBwAhAQsgAkEwaiQAIAELqAgBB38CQAJAIAFB/wlLDQAgAUEFdiECAkACQAJAIAAoAqABIgNFDQAgA0F/aiEEIANBAnQgAGpBfGohBSADIAJqQQJ0IABqQXxqIQYgA0EpSSEDA0AgA0UNAiACIARqIgdBKE8NAyAGIAUoAgA2AgAgBkF8aiEGIAVBfGohBSAEQX9qIgRBf0cNAAsLIAFBIEkNAyAAQQA2AgAgAUHAAEkNAyAAQQA2AgQgAkEBIAJBAUsbIgRBAkYNAyAAQQA2AgggBEEDRg0DIABBADYCDCAEQQRGDQMgAEEANgIQIARBBUYNAyAAQQA2AhQgBEEGRg0DIABBADYCGCAEQQdGDQMgAEEANgIcIARBCEYNAyAAQQA2AiAgBEEJRg0DIABBADYCJCAEQQpGDQMgAEEANgIoIARBC0YNAyAAQQA2AiwgBEEMRg0DIABBADYCMCAEQQ1GDQMgAEEANgI0IARBDkYNAyAAQQA2AjggBEEPRg0DIABBADYCPCAEQRBGDQMgAEEANgJAIARBEUYNAyAAQQA2AkQgBEESRg0DIABBADYCSCAEQRNGDQMgAEEANgJMIARBFEYNAyAAQQA2AlAgBEEVRg0DIABBADYCVCAEQRZGDQMgAEEANgJYIARBF0YNAyAAQQA2AlwgBEEYRg0DIABBADYCYCAEQRlGDQMgAEEANgJkIARBGkYNAyAAQQA2AmggBEEbRg0DIABBADYCbCAEQRxGDQMgAEEANgJwIARBHUYNAyAAQQA2AnQgBEEeRg0DIABBADYCeCAEQR9GDQMgAEEANgJ8IARBIEYNAyAAQQA2AoABIARBIUYNAyAAQQA2AoQBIARBIkYNAyAAQQA2AogBIARBI0YNAyAAQQA2AowBIARBJEYNAyAAQQA2ApABIARBJUYNAyAAQQA2ApQBIARBJkYNAyAAQQA2ApgBIARBJ0YNAyAAQQA2ApwBIARBKEYNA0EoQShBlMrAABDqAQALIARBKEGUysAAEOoBAAsgB0EoQZTKwAAQ6gEAC0G+ysAAQR1BlMrAABCjAgALIAAoAqABIAJqIQUCQCABQR9xIgMNACAAIAU2AqABIAAPCwJAAkAgBUF/aiIEQSdLDQAgBSEIIAAgBEECdGooAgAiBkEAIAFrIgF2IgRFDQECQCAFQSdLDQAgACAFQQJ0aiAENgIAIAVBAWohCAwCCyAFQShBlMrAABDqAQALIARBKEGUysAAEOoBAAsCQAJAIAJBAWoiByAFTw0AIAFBH3EhASAFQQJ0IABqQXhqIQQDQCAFQX5qQShPDQIgBEEEaiAGIAN0IAQoAgAiBiABdnI2AgAgBEF8aiEEIAcgBUF/aiIFSQ0ACwsgACACQQJ0aiIEIAQoAgAgA3Q2AgAgACAINgKgASAADwtBf0EoQZTKwAAQ6gEAC4MJAgd/An4jAEHwAGsiAyQAIANByABqIAEgAhA6AkACQCADKAJIDQAgA0EwakEIaiADQcgAakEUaigCACICNgIAIAMgA0HIAGpBDGopAgAiCjcDMCADKQJMIQsgA0HIAGpBCGoiASACNgIAIAMgCjcDSEEQEKcDIgJBAzYCACACIAMpA0g3AgQgAkEMaiABKAIANgIAIANBDGpBEGpCgYCAgBA3AgAgA0EMakEMaiIBIAI2AgAgACALNwIEIABBDGogASkCADcCACAAQRRqQQE2AgAgAEEANgIAIAMgCzcCEAwBCyADQQxqQQxqIANByABqQQxqKQIANwIAIANBDGpBFGogA0HIAGpBFGooAgA2AgAgA0EMakEIaiADQcgAakEIaigCADYCACADIAMoAkwiBDYCECADQQE2AgwgA0EQaiEFAkAgBEUNACAAQQE2AgAgACAFKQIANwIEIABBFGogBUEQaigCADYCACAAQQxqIAVBCGopAgA3AgAMAQsgA0EaNgIoIANBh9jAADYCJCADQQE6ACwgA0EwaiADQSRqQQhqIgYgASACEC9BAiEEAkAgAygCMA0AQQEhBCADQcQAaigCAEEBRw0AIANBMGpBDGooAgAiBygCAA0AQQAhBCAHKAIEIgggB0EMaigCACIHQYjawABBAhD0Ag0AIAggB0GK2sAAQQQQ9AINACAIIAdBjtrAAEEEEPQCDQAgCCAHQZLawABBBBD0Ag0AIAggB0GW2sAAQQIQ9AINACAIIAdBmNrAAEECEPQCDQAgCCAHQZrawABBBBD0Ag0AIAggB0Ge2sAAQQQQ9AINACAIIAdBotrAAEEEEPQCDQAgCCAHQabawABBBRD0Ag0AIAggB0Gr2sAAQQUQ9AINACAIIAdBsNrAAEEDEPQCDQAgCCAHQbPawABBAhD0AkEBcyEECwJAAkACQCAEQQJGDQAgBEEBcQ0AIANByABqIAYgASACEC8CQAJAIAMoAkgiBEUNAAJAIAMoAkwiBkUNACADQcgAakEQaigCACEEIANByABqQQhqKAIAIQcgA0HcAGooAgAhCCADQdQAaigCACEBIANBGhDpASADKAIEIQkgAygCACICQQApAIfYQDcAACACQRhqQQAvAJ/YQDsAACACQRBqQQApAJfYQDcAACACQQhqQQApAI/YQDcAACADQRo2AmwgAyAJNgJoIAMgAjYCZCADQeQAakGQ08AAQQIQ4gEgA0HkAGogASAIEOIBIABBBGogBiAHIANB5ABqENgBIABBATYCACABIAQQtwMMBAsgAEEEaiABIAJBh9jAAEEaEMQBIABBATYCACAERQ0BQQANAyADKAJMRQ0DIANB1ABqKAIAIANB2ABqKAIAELcDDAMLIABBBGogASACQYfYwABBGhDEASAAQQE2AgALIANByABqEIIDDAELIAAgAykCMDcCACAAQRBqIANBMGpBEGopAgA3AgAgAEEIaiAD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ACABQcAAahBWDQACQCAAKAIMIgJFDQAgAUE0akHssMAAQQIQ4wMNASABQdgAakEQaiACQRBqKQIANwMAIAFB2ABqQQhqIAJBCGopAgA3AwAgASACKQIANwNYIAFBNGpB/JDAACABQdgAahBWDQEMAgsgAUEgaiAAKAIAIgIgACgCBCgCDBEEACABKQMgQsH3+ejMk7LRQYUgAUEoaikDAELk3seFkNCF3n2FhFBFDQEgAUE0akHssMAAQQIQ4wMNACABQTRqIAIoAgAgAigCBBDjA0UNAQtBlJHAAEE3IAFB2ABqQcyRwABBqJLAABDWAQALIAFBwABqQQhqIgAgAUE0akEIaigCADYCACABIAEpAjQ3A0AgAUHAAGpB0JLAAEHaksAAENoBIAFBGGoQGiICEBsgAUEQaiABKAIYIAEoAhwQqwIgAUHAAGogASgCECIDIAEoAhQiBBDQAyABQcAAakGQ08AAQZLTwAAQ2gEgAUHYAGpBCGogACgCADYCACABIAEpA0A3A1ggAUEIaiABQdgAahDXASABKAIIIAEoAgwQHCADIAQQtwMCQCACQYQBSQ0AIAIQHQsgAUHwAGokAAumBAIHfwF+IwBBwABrIgMkACADQQhqQQIQ6QEgAygCDCEEIAMoAggiBUH8zAA7AAAgA0EoaiAFQQIgASACENABAkACQAJAAkACQCADKAIoDQAgA0EcaiIGQQE6AAAgA0EwaigCACEHIAMoAiwhCCAGKAIAIQYMAQsgA0EQakEQaiADQShqQRBqKQIANwIAIANBEGpBDGogA0EoakEMaigCACIGNgIAIANBEGpBCGogA0EoakEIaigCACIHNgIAIAMgAygCLCIINgIUIANBATYCECAIDQEgA0EUaiEJIANBKGpB/AAgASACEKcBAkACQCADKAIoIgENACADQTBqKAIAIQcgAygCLCEIQQAhBgwBCyADQTRqKAIAIgZBCHYhAiADQThqKQIAIQogA0EoakEIaigCACEHIAMoAiwhCAsgCRCIAyABDQILIANBKGpB4tfAAEECIAggBxBxAkAgAygCKEUNACADLwA1IANBN2otAABBEHRyIQIgA0EoakEQaikCACEKIANBNGotAAAhBiADQTBqKAIAIQcgAygCLCEIDAILIAAgAykCLDcCBEEAIQggAEEMaiAGQf8BcUEARzoA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f2oiCiAFTw0IIAogDGoiESADTw0GIAQgCmotAAAgAiARai0AAEYNAAsgASAIIAxqIgw2AhQgBg0EIAkhCgwICyAMIApqIhIgA08NBSAQIApqIREgBCAKaiETIApBAWohCiATLQAAIBEtAABGDQALIBIgC2tBAWohDAwBCyAMIAVqIQwLIAEgDDYCFCAGDQALQQAhCgwDCyARIANBuNLAABDqAQALIBIgA0HI0sAAEOoBAAsgCiAFQajSwAAQ6gEACyABIAo2AhwMAQsLIAAgDDYCBCAAQQhqIAo2AgBBASEKCyAAIAo2AgAL0wMCB38BfCMAQeAAayIDJAACQAJAAkAgACgCACIEEKADRQ0AQQchBUEAIQZBACEADAELQQAhBgJAQQFBAiAEEAUiB0EBRhtBACAHGyIHQQJGDQBBACEAQQAhBQwCCyADQRhqIAQQBgJAIAMoAhhFDQAgAysDICEKQQMhBUEAIQZBACEADAELIANBEGogBBAHAkACQCADKAIQIgRFDQAgA0EIaiAEIAMoAhQQqwIgAygCCCIERQ0AIAMoAgwhByADIAQ2AiggAyAHNgIwIAMgBzYCLEEFIQVBASEAQQAhBgwBCyADQTRqIAAQwAECQAJAIAMoAjQiCEUNAEEGIQUgAygCPCEHIAMoAjghCSAIIQQMAQsgA0HMAGpCATcCACADQQE2AkQgA0Gg38AANgJAIANBCTYCXCADIAA2AlggAyADQdgAajYCSCADQShqIANBwABqEL8BQREhBSADKAIoIQQgAygCMCEHCyAIQQBHIQYgCEUhAAsgB62/IQoLCyADIAo5A0ggAyAENgJEIAMgBzoAQSADIAU6AEAgA0HAAGogASACEM4BIQcCQCAGRQ0AIAggCRC3AwsCQCAARQ0AIAQgAygCLBC3AwsgA0HgAGokACAHC9wDAgN/An4jAEHgAGsiAyQAIANBCGpB0NTAAEECENUBIANByABqQdLUwABBAhDVASADQSxqIANByABqQRBqIgQoAgA2AgAgA0EkaiADQcgAakEIaiIFKQMANwIAIAMgAykDSDcCHCADQcgAaiADQQhqIAEgAhCJAQJAAkAgAygCSA0AIANBMGpBDGoiAkEAOgAAIAAgAykCTCIGNwIEIABBADYCACAAQQxqIAIoAgA2AgAgAyAGNwI0DAELIANBMGpBEGog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AyQAIAMgATYCCCADIAEgAmo2AgwCQAJAIANBCGoQxwIiBEGAgMQARg0AQQEhBQJAIARBgAFJDQBBAiEFIARBgBBJDQBBA0EEIARBgIAESRshBQsgAyABIAIgBUGE4MAAEIUCIAMpAwAhBiAAQQxqIAQ2AgAgACAGNwIEQQAhAQwBCyAAQQA2AgRBASEBCyAAIAE2AgAgA0EQaiQAC6MBAQJ/IwBBEGsiAiQAAkACQAJAIAEoAgBFDQACQCABKAIIIgMgASgCDEYNACABIANBEGo2AgggAkEIaiADQQxqKAIANgIAIAIgAykCBDcDACADKAIAIgNBBEcNAgsgARC/AyABQQA2AgBBBCEDDAELIABBBDYCAAwBCyAAIAM2AgAgACACKQMANwIEIABBDGogAkEIaigCADYCAAsgAkEQaiQAC50BAQF/IwBBIGsiAyQAIANBCGogASACEGQCQAJAAkACQCADKAIIDQAgA0EQaigCACECIAMoAgwhAQwBCyADKAIMDQELIAAgATYCBCAAQQhqIAI2AgBBACECDAELIAAgA0EMaiICKQIANwIEIABBFGogAkEQaigCADYCACAAQQxqIAJBCGopAgA3AgBBASECCyAAIAI2AgAgA0EgaiQAC7QBAQN/IwBBEGsiASQAIAAoAgAiAkEMaigCACEDAkACQAJAAkAgAigCBA4CAAEDCyADDQJB8LvBACECQQAhAwwBCyADDQEgAigCACICKAIEIQMgAigCACECCyABIAM2AgQgASACNgIAIAFBiOjAACAAKAIEIgIoAgwgACgCCCACLQAQEKoBAAsgAUEANgIEIAEgAjYCACABQZzowAAgACgCBCICKAIMIAAoAgggAi0AEBCqAQALowEAAkACQAJAAkAgAkF8ag4DAAIBAgsgAS0AAEH0AEcNASABLQABQeUARw0BIAEtAAJB+ABHDQFBACECIAEtAANB9ABHDQEMAgsgAS0AAEHpAEcNACABLQABQe4ARw0AIAEtAAJB5ABHDQAgAS0AA0HlAEcNACABLQAEQe4ARw0AQQEhAiABLQAFQfQARg0BC0ECIQILIABBADoAACAAIAI6AAELnwEBAX8jAEHAAGsiAiQAIAJCADcDOCACQThqIAAoAgAQKyACQRhqQgE3AgAgAiACKAI8IgA2AjQgAiAANgIwIAIgAigCODYC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IAJBMGokACABC2QBAX8jAEEwayICJAAgAiABNgIMIAIgADYCCCACQRxqQgE3AgAgAkECNgIUIAJBnInAADYCECACQRI2AiwgAiACQShqNgIYIAIgAkEIajYCKCACQRBqELgCIQEgAkEwaiQAIAELeQACQAJAAkACQAJAAkACQCAALQAADhUBAQEBAQEBAQEBAQECAQMBAQQBBQYACyAAQQRqEJECCw8LIAAoAgQgAEEIaigCABC3Aw8LIAAoAgQgAEEIaigCABC3Aw8LIABBBGoQyAMPCyAAQQRqEMgDDwsgAEEEahCQAgtkAQF/IwBBEGsiAyQAAkAgASgCAA0AIAAgASgCBDYCACAAIAFBCGotAAA6AAQgA0EQaiQADwsgAyABKAIENgIIIAMgAUEIai0AADoADEH7lsAAQSsgA0EIakHAiMAAIAIQ1gEAC1sBAn8jAEEQayICJAACQAJAAkACQCABDQBBASEDDAELIAFBf0wNASACQQhqQQEgARDiAiACKAIIIgNFDQILIAAgATYCBCAAIAM2AgAgAkEQaiQADwsQwgIACwALXgEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBLGpBEDYCACADQRA2AiQgAyADNgIoIAMgA0EEajYCICADQQhqQbSxwABBAiADQSBqQQIQxwEgA0EIaiACEMACAAthAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEsakEQNgIAIAJBEDYCJCACIAI2AiggAiACQQRqNgIgIAJBCGpBlLjAAEEDIAJBIGpBAhDHASACQQhqQciYwAAQwAIAC2IBA38CQCAAKAIMIgIgACgCECIDTw0AAkAgACgCCCIEIAAoAgRHDQAgACAEEJ4BIAAoAgghBAsgACAEQQFqNgIIIAAoAgAgBEEMbGoiACABOgAIIAAgAzYCBCAAIAI2AgALC14BAX8jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQSxqQRA2AgAgA0EQNgIkIAMgA0EEajYCKCADIAM2AiAgA0EIakGQt8AAQQIgA0EgakECEMcBIANBCGogAhDAAgALXgEBfyMAQTBrIgMkACADIAA2AgAgAyABNgIEIANBLGpBEDYCACADQRA2AiQgAyADQQRqNgIoIAMgAzYCICADQQhqQcS3wABBAiADQSBqQQIQxwEgA0EI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AgwBCyABQf///z9LDQEgAUEEdCICQX9MDQFBBCACEIUDIgJFDQILIAAgATYCBCAAIAI2AgAPCxDCAgALAAtRAQJ/IwBBEGsiAiQAAkACQCABKAIADQBBACEBQQAhAwwBCyACQQhqIAEQjwIgAigCDCEBIAIoAgghAwsgACABNgIEIAAgAzYCACACQRBqJAALSwACQAJAAkAgAiADSw0AIAIgA0cNAQwCCyABIANqLAAAQb9/Sg0BCyABIAIgAyACIAQQvQMACyAAIAIgA2s2AgQgACABIANqNgIAC0oBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASAAQQFqIQAgAUEBaiEBIAJBf2oiAkUNAgwACwsgBCAFayEDCyADC1wBAn9BAEEBEJADIQBBLEEEEJADIgFBAToAKCABQQA2ASQgAUIENwEcIAFBwITAADYBGCABIAA2ARQgAUEAOwEQIAFBADsBDCABQQA7AQggAUKBgICAEDcCACABC04BAX8jAEEgayIDJAAgA0EQaiACNgIAIAMgATYCDCADQQU6AAggA0EIaiADQR9qQdCJwAAQzgEhAiAAQQI7AQAgACACNgIEIANBIGokAAtOAQF/IwBBIGsiAyQAIANBEGogAjYCACADIAE2AgwgA0EGOgAIIANBCGogA0EfakHQicAAEM4BIQIgAEECOwEAIAAgAjYCBCADQSBqJAALUwEBfyMAQTBrIgAkACAAQTU2AgwgAEG4l8AANgIIIABBDDYCLCAAIABBCGo2AiggAEEQakGg38AAQQEgAEEoakEBEMcBIABBEGpBuJjAABDAAgALSgACQCADRQ0AAkACQCADIAJJDQAgAyACRw0BDAILIAEgA2osAABBv39KDQELIAEgAkEAIAMgBBC9AwALIAAgAzYCBCAAIAE2AgALRwEEfyABIAEgAiADEMsBIgRqIgUtAAAhBiAFIAOnQRl2Igc6AAAgBEF4aiACcSABakEIaiAHOgAAIAAgBjoABCAAIAQ2AgALSwEDfyAAKAIIIQEgACgCACICIQMCQANAIAFFDQEgAUF/aiEBIAMQugMgA0EQaiEDDAALCwJAIAAoAgQiAUUNACACIAFBBHQQwQMLC00BAn8jAEEQayICJAACQAJAIAEoAgANAEEAIQEMAQsgAkEIaiABEJsCIAIoAgwh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QgEBfwJAAkACQCACQYCAxABGDQBBASEFIAAgAiABKAIQEQUADQELIAMNAUEAIQULIAUPCyAAIAMgBCABKAIMEQcACz4BAX8jAEEgayIDJAAgA0EMakHh18AAQQEQ1QEgACADQQxqIAEgAhCJASADKAIMIAMoAhAQtwMgA0EgaiQAC0EBAn9BACEAAkBBACgC2L1BIgFFDQBBACEAA0AgAEEBaiEAIAEoAggiAQ0ACwtBACAAQf8fIABB/x9LGzYCkMBBC0UBAn9BAC0ApMBBGiABKAIEIQIgASgCACEDAkBBCBAxIgENAAALIAEgAjYCBCABIAM2AgAgAEH458AANgIEIAAgATYCAAs6AQJ/IwBBEGsiASQAIAFBBGogABC/ASABKAIEIgAgASgCDBAIIQIgACABKAIIELcDIAFBEGokACACCz8BAX9BHBCnAyIBQbzUwAA2AgAgASAAKQIANwIEIAFBDGogAEEIaikCADcCACABQRRqIABBEGopAgA3AgAgAQs8AQF/IwBBEGsiAyQAAkAgAA0AIANBEGokACABDwsgAyABNgIMQfuWwABBKyADQQxqQbCIwAAgAhDWAQALPAEBfyMAQRBrIgIkACACQQhqIAAgACgCACgCBBEEACACKAIIIAEgAigCDCgCEBEFACEAIAJBEGokACAAC0IBAn8gACgCBCEBIABB8LvBADYCBCAAKAIAIQIgAEHwu8EANgIAAkAgASACRg0AIAIgASACa0EEdhDVAgsgABDxAQs7AgF/AXwgASgCHEEBcSECIAArAwAhAwJAIAEoAghFDQAgASADIAIgAUEMaigCABAuDwsgASADIAIQLQs8AQF/IwBBEGsiAiQAIAJBCGogACAAKAIAKAIEEQQAIAIoAgggASACKAIMKAIQEQUAIQAgAkEQaiQAIAALQAEBfyMAQSBrIgAkACAAQRRqQgA3AgAgAEEBNgIMIABB6NrAADYCCCAAQfC7wQA2AhAgAEEIakHE28AAEMACAAs/AQF/IwBBIGsiAiQAIAIgADYCGCACQfCwwAA2AhAgAkHwu8EANgIMIAJBAToAHCACIAE2AhQgAkEMahCqAgALNwEBfyMAQRBrIgMkACADQQhqIAEgAhB9IAMoAgwhAiAAIAMoAgg2AgAgACACNgIEIANBEGokAAtAAQF/IwBBIGsiACQAIABBFGpCADcCACAAQQE2AgwgAEHojcAANgIIIABB8LvBADYCECAAQQhqQfCNwAAQwAIACzYBAX8jAEEQayICJAAgAiABECogAigCACEBIAAgAikDCDcDCCAAIAFBAEetNwMAIAJBEGokAAs/AAJAIAAtABgNACAAQQAQ7AEgAEEBOgAYIAAgACgCEDYCDAsgACAAKAIUNgIQIABBARDsASAAIAAoAhQ2AgwLQAEBfyMAQSBrIgAkACAAQRRqQgA3AgAgAEEBNgIMIABB/OXAADYCCCAAQfC7wQA2AhAgAEEIakGE5sAAEMACAAs3AQF/IwBBEGsiAyQAIANBCGogASACEKsDIAMoAgwhAiAAQe2BwABBBBBnIAIQ6wMgA0EQaiQACzYBAn8jAEEQayIBJAAgAUEIaiAAEJYBIAEoAgghACABKAIMIQIgAUEQaiQAIAJBgIDEACAAGws9AQF/IwBBEGsiAiQAIAJB5IbAADYCDCACIAA2AgggAkEIakHQiMAAIAJBDGpB0IjAACABQfiHwAAQggEACz0BAn9BASECAkAgASgCFCIDQeCJwABBCyABQRhqKAIAKAIMIgERBwANACADQZazwABBByABEQcAIQILIAILMAAgAUH//wNxIANB//8DcUYgAiAAckH//wNxRSIDIAJB//8DcRsgAyAAQf//A3EbCzoBAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCADQQhqQcSxwAAgA0EMakHEscAAIAJBmJ7AABCCAQALNQAgACgCHCAAQSBqKAIAELcDIAAoAgQgAEEIaigCABC3AyAAQRBqKAIAIABBFGooAgAQtwMLPQEBfyMAQRBrIgIkACACQfDgwAA2AgwgAiAANgIIIAJBCGpB4ODAACACQQxqQeDgwAAgAUHo4cAAEIIBAAsyAQF/IwBBEGsiAiQAIAIgADYCDCABQfbKwABBBSACQQxqQQ0QjAEhACACQRBqJAAgAAsyAQF/IAAoAgghASAAKAIAIQACQANAIAFFDQEgAUF/aiEBIAAQnwIgAEE4aiEADAALCwswAQF/IABBDGoQmgICQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQTAsLMgEBfyMAQRBrIgIkACABIAJBD2pBsITAABBpIQEgAEEWOgAAIAAgATYCBCACQRBqJAALLwACQAJA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ACIAEOcBIAAQTAsPACAAEOcBIABBEGoQ5wELDgAgACABIAEgAmoQ2QELEwAgAEEoNgIEIABB2NLAADYCAAsgACAAQpuomM3bgtTUfDcDCCAAQpa3iIC6l+SpEjcDAAsiACAAQubG5dbLj/f/5AA3AwggAELznNq2t8OlnY9/NwMACxMAIABBpJDAADYCBCAAIAE2AgALEAAgACgCACABIAIQ0ANBAAsOACAAIAEgASACahDaAQsPACAAKAIAIAEQiAEaQQALEAAgASAAKAIAIAAoAgQQOAsQACAAIAIQ+AEgAUEMOgAACyAAIABCq/3xnKmDxYRkNwMIIABC+P3H/oOGtog5NwMACyEAIABCzOOog7P46rB0NwMIIABC/ZCAh5Cx88TRADcDAAsgACAAQraSm5Smo42H8AA3AwggAEKMibeF4+rZTzcDAAsOACAAQQRqEOMCIAAQTAsTACAAQZDUwAA2AgQgACABNgIACxAAIAEgACgCACAAKAIIEDgLIQAgAELCw5vOrZDA3qZ/NwMIIABC0oKx+Pqs5712NwMACxMAIABB+OfAADYCBCAAIAE2AgALIAAgAELk3seFkNCF3n03AwggAELB9/nozJOy0UE3AwALFABBACAANgKswEFBAEEBOgCowEELDgACQCABRQ0AIAAQTAsLDwAgACgCACAALQAEEPICCw0AIAAgASACEOIBQQALDQAgADUCAEEBIAEQegsNACAAKAIAIAEgAhBYCw0AIAAgASACENADQQALDwAgACgCACAAKAIEELcDCw8AIAAoAgAgACgCBBCkAwsNACAAKAIAGgN/DAALCw0AIAAoAgAgASACEFsLDQAgACkDAEEBIAEQegsLACAAIwBqJAAjAAsMACAAKAIAIAEQugELCgAgACABIAIQCwsJACAAECVBAEcLCgAgACABIAIQVgsMACAAKAIAIAEQ2wILDAAgACgCACABENwCCwoAIABBBGoQ4wILCQAgABAeQQFGCwkAIAAgARAsAAsMACAAKAIAIAEQqQMLDAAgACgCACABENkDCwwAIAAoAgAgARCBAwsLACAAIAEgAhCsAQsKACAAIAEgAhB4CwoAIAAgASACEE0LCwAgACABIAIQhgILCgBBACgClMBBRQsKACAAKAIAELYDCwkAIAAgARDVAgsJACAAQQA2AgALCAAgACABEGALCQAgACABEMcDCwgAIAAgARBgCwgAIAAgARAACwgAIAAQuAEACwYAIAAQTAsGACAAEEwLBgAgABAmCwMAAAsCAAsCAAsCAAsCAAsCAAsCAAsLq7wBAgBBgIDAAAuMvAEmAAAAAAAAAAEAAAAnAAAAaW52YWxpZCB0eXBlOiAAABAAEAAOAAAAbwQQAAsAAAD//////////0M6XFVzZXJzXGRhdmlkXC5jYXJnb1xyZWdpc3RyeVxzcmNcaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWZcc2VyZGUtd2FzbS1iaW5kZ2VuLTAuNi4zXHNyY1xsaWIucnMAOAAQAGcAAAA1AAAADgAAACYAAAAAAAAAAQAAACgAAAAmAAAAAAAAAAEAAAApAAAAJgAAAAAAAAABAAAAKgAAAG5hbWV2YWx1ZXdvcmRraW5kZmRDb21tYW5kaW5uZXJyZWRpcmVjdFBpcGVsaW5lbmVnYXRlZG1heWJlRmRvcGlvRmlsZVNlcXVlbmNlU2hlbGxWYXJzaGVsbFZhcnBpcGVsaW5lQm9vbGVhbkxpc3Rib29sZWFuTGlzdHRleHR2YXJpYWJsZWNvbW1hbmRxdW90ZWRzdGRvdXRTdGRlcnJpbnB1dG91dHB1dGN1cnJlbnRuZXh0Q29tbWFuZElubmVyU2ltcGxlc2ltcGxlU3Vic2hlbGxzdWJzaGVsbFBpcGVTZXF1ZW5jZVBpcGVsaW5lSW5uZXJwaXBlU2VxdWVuY2VlbnZWYXJzYXJnc2l0ZW1zb3ZlcndyaXRlYXBwZW5kaXNBc3luY2FuZG9yc3Rkb3V0YSBzZXF1ZW5jZQAAJgAAAAAAAAABAAAAKwAAACYAAAAAAAAAAQAAACwAAAAmAAAAAAAAAAEAAAAtAAAALgAAAC4AAAAvAAAACAAAAAQAAAAwAAAAMQAAADEAAABDOlxVc2Vyc1xkYXZpZFwuY2FyZ29ccmVnaXN0cnlcc3JjXGluZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmXGNvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuN1xzcmNcbGliLnJzAAAAcAIQAG0AAACVAAAADgAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAA8AIQACoAAABvbmUtdGltZSBpbml0aWFsaXphdGlvbiBtYXkgbm90IGJlIHBlcmZvcm1lZCByZWN1cnNpdmVseSQDEAA4AAAAAGNhbm5vdCByZWN1cnNpdmVseSBhY3F1aXJlIG11dGV4AAAAZQMQACAAAAAvcnVzdGMvY2M2NmFkNDY4OTU1NzE3YWI5MjYwMGM3NzBkYThjMTYwMWE0ZmYzMy9saWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbG9ja3MvbXV0ZXgucnMAAJADEABmAAAAFAAAAAkAAAAyAAAADAAAAAQAAAAzAAAANAAAADUAAAAmAAAAAAAAAAEAAAA2AAAANwAAAAQAAAAEAAAAOAAAADkAAAAIAAAABAAAADoAAAAvAAAABAAAAAQAAAA7AAAAaW52YWxpZCB2YWx1ZTogLCBleHBlY3RlZCAAAGAEEAAPAAAAbwQQAAsAAABtaXNzaW5nIGZpZWxkIGAAjAQQAA8AAAATMRAAAQAAAGR1cGxpY2F0ZSBmaWVsZCBgAAAArAQQABEAAAATMRAAAQAAACYAAAAAAAAAAQAAADwAAABQb2lzb25FcnJvckNvdWxkbid0IGRlc2VyaWFsaXplIGk2NCBvciB1NjQgZnJvbSBhIEJpZ0ludCBvdXRzaWRlIGk2NDo6TUlOLi51NjQ6Ok1BWCBib3VuZHNMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ6BRAAKgAAAEM6XFVzZXJzXGRhdmlkXC5jYXJnb1xyZWdpc3RyeVxzcmNcaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWZcb25jZV9jZWxsLTEuMTYuMFxzcmNcbGliLnJzAGwFEABfAAAA9gQAABkAAABzcmNccnNfbGliXHNyY1xsaWIucnMAAADcBRAAFQAAABEAAAA4AAAAZGF0YSBkaWQgbm90IG1hdGNoIGFueSB2YXJpYW50IG9mIHVudGFnZ2VkIGVudW0gV2FzbVRleHRJdGVtZmllbGQgaWRlbnRpZmllcmluZGVudHN0cnVjdCB2YXJpYW50IFdhc21UZXh0SXRlbTo6SGFuZ2luZ1RleHQAANwFEAAVAAAAOAAAABkAAADcBRAAFQAAAEUAAAAGAAAAPgAAAAQAAAAEAAAAPwAAAEAAAABBAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA1AYQABEAAAC4BhAAHAAAABYCAAAFAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yAEIAAAAAAAAAAQAAADYAAABsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnNEBxAAGAAAAGICAAAgAAAAKSBzaG91bGQgYmUgPCBsZW4gKGlzIHJlbW92YWwgaW5kZXggKGlzIIIHEAASAAAAbAcQABYAAAD4XRAAAQAAAC8AAAAEAAAABAAAAEMAAABEAAAARQAAAEYAAABHAAAASAAAAEkAAABKAAAALwAAAAgAAAAEAAAASwAAAC8AAAAIAAAABAAAAEwAAABLAAAA2AcQAE0AAABOAAAATwAAAE0AAABQAAAALwAAAAwAAAAEAAAAUQAAAC8AAAAMAAAABAAAAFIAAABRAAAAFAgQAFMAAABUAAAATwAAAFUAAABQAAAAXBkQAAIAAAAKCkNhdXNlZCBieTpYCBAADAAAAM8OEAABAAAAICAgICAgIAAyAAAADAAAAAQAAABWAAAAVwAAADUAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5ACYAAAAAAAAAAQAAADYAAAAvcnVzdGMvY2M2NmFkNDY4OTU1NzE3YWI5MjYwMGM3NzBkYThjMTYwMWE0ZmYzMy9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMA3AgQAEsAAACcCQAADgAAAC8AAAAEAAAABAAAAFgAAABZAAAAWgAAAAoKU3RhY2s6CgpDOlxVc2Vyc1xkYXZpZFwuY2FyZ29ccmVnaXN0cnlcc3JjXGluZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmXHVuaWNvZGUtd2lkdGgtMC4xLjExXHNyY1x0YWJsZXMucnNaCRAAZgAAACcAAAAZAAAAWgkQAGYAAAAtAAAAHQAAAEM6XFVzZXJzXGRhdmlkXC5jYXJnb1xyZWdpc3RyeVxzcmNcaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWZcdnRlLTAuMTMuMFxzcmNcbGliLnJzAAAA4AkQAFkAAADlAAAAIQAAAOAJEABZAAAA4AAAADQAAADgCRAAWQAAAHkAAAAcAAAA4AkQAFkAAABOAQAAFQAAAOAJEABZAAAAMAEAACQAAADgCRAAWQAAADIBAAAZAAAA4AkQAFkAAAAVAQAAKAAAAOAJEABZAAAAFwEAAB0AAABDOlxVc2Vyc1xkYXZpZFwuY2FyZ29ccmVnaXN0cnlcc3JjXGluZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmXHZ0ZS0wLjEzLjBcc3JjXHBhcmFtcy5yc7wKEABcAAAAPgAAAAkAAAC8ChAAXAAAAD8AAAAJAAAAvAoQAFwAAABHAAAACQAAALwKEABcAAAASAAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKWNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAFsAAAABAAAAAQAAAFwAAABhdHRlbXB0IHRvIGpvaW4gaW50byBjb2xsZWN0aW9uIHdpdGggbGVuID4gdXNpemU6Ok1BWC9ydXN0Yy9jYzY2YWQ0Njg5NTU3MTdhYjkyNjAwYzc3MGRhOGMxNjAxYTRmZjMzL2xpYnJhcnkvYWxsb2Mvc3JjL3N0ci5ycwAAAO0LEABIAAAAmQAAAAoAAADtCxAASAAAALAAAAAWAAAAQ2FwYWNpdHlFcnJvcjogAFgMEAAPAAAAaW5zdWZmaWNpZW50IGNhcGFjaXR5AAAAcAwQABUAAADXKBAATwAAALgBAAA3AAAAQzpcVXNlcnNcZGF2aWRcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxhcnJheXZlYy0wLjcuMlxzcmNcYXJyYXl2ZWNfaW1wbC5ycwCgDBAAZwAAACcAAAAgAAAAQzpcVXNlcnNcZGF2aWRcLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxjb25zb2xlX3N0YXRpY190ZXh0LTAuOC4yXHNyY1xhbnNpLnJzAAAAGA0QAGkAAAATAAAAHQAAABtbMUNDOlxVc2Vyc1xkYXZpZFwuY2FyZ29c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AABmAAAAZQAAABgAAAAEAAAAZwAAAGYAAADEKRAATQAAAGgAAABPAAAATQAAAFAAAABpAAAAHAAAAAQAAABqAAAAaQAAABwAAAAEAAAAawAAAGoAAAAAKhAAbAAAAG0AAABPAAAAbgAAAFAAAABvAAAAcAAAAHEAAAByAAAASgAAACYmfHxFbXB0eSBjb21tYW5kLkM6XFVzZXJzXGRhdmlkXC5jYXJnb1xnaXRcY2hlY2tvdXRzXGRlbm9fdGFza19zaGVsbC0yYjA3MDlmYzcxZjcxY2QzXGVkM2Q0ZDBcc3JjXHBhcnNlci5yc0V4cGVjdGVkIGNvbW1hbmQgZm9sbG93aW5nIGJvb2xlYW4gb3BlcmF0b3IuYioQAFoAAACVAQAAOQAAAENhbm5vdCBzZXQgbXVsdGlwbGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdoZW4gdGhlcmUgaXMgbm8gZm9sbG93aW5nIGNvbW1hbmQuRXhwZWN0ZWQgY29tbWFuZCBmb2xsb3dpbmcgcGlwZWxpbmUgb3BlcmF0b3IuUmVkaXJlY3RzIGluIHBpcGUgc2VxdWVuY2UgY29tbWFuZHMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLk11bHRpcGxlIHJlZGlyZWN0cyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJnwmSW52YWxpZCBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZS5VbnN1cHBvcnRlZCByZXNlcnZlZCB3b3JkLkV4cGVjdGVkIGNsb3Npbmcgc2luZ2xlIHF1b3RlLkV4cGVjdGVkIGNsb3NpbmcgZG91YmxlIHF1b3RlLiQ/IyokIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLgAAYSwQAAEAAABiLBAAHAAAAEJhY2sgdGlja3MgaW4gc3RyaW5ncyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5+KCl7fTw+fCY7IidFeHBlY3RlZCBjbG9zaW5nIHBhcmVudGhlc2lzIG9uIHN1YnNoZWxsLgAAYioQAFoAAABkAwAADQAAAGlmdGhlbmVsc2VlbGlmZmlkb2RvbmVjYXNlZXNhY3doaWxldW50aWxmb3JpblVuZXhwZWN0ZWQgY2hhcmFjdGVyLkhhc2ggdGFi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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O4gGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgZdXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dOzs7Ozs7OzuJBgYGBgYGBgYGBgaKiwYBcYwGjQYGBgYGBgaOBgYGjwaQBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgaRBgaSBgYGBgYGBgaTBgYGBgaUlQaWlwaYmZqbnJ2en6AuBqEsogYGo6SlpgYGp6ipqqsGrAYGBq0GBgaurwawsbKzBgYGBga0BrUGtre4BgYGBrm6uwYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgZHvAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBga9vgYGBgYGBgYGBgYGBgYGBga/wME7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O8I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7w8QGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgbFOzs7O8bHOzs7OzvIBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgbJBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBsrLBgYGBgYGBszNBgbOBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGz9DRBgYGBgYGBgYGBgYGBgYGBgYGBgYG0ga/Br4GBgYGBtPUBgYGBgYGBtQGBgYGBgYGBgYGBgYGBgbVBtYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBtcGBtjZ2tsG3N0GBt7f4OHi4zvk5ebn6DvpO+oGBgbrBgYGBuztOzsG7u/wBgYGBgYGBgYGBgYGBgYGBgYGBgY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs75fEKBgYKCgoLBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1d8gAAAAAAAAAAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVAAAAAAAAAABd13d1//d//1V1VVVX1Vf1X3V/X/fVf3ddVVVV3VXVVVX11VX9VVfVf1f/XfVVVVVV9dVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV1d3d3V1VVVVVVVVVVVVVVVV1VVVVdVVVVVVVVVVXX/V1XVf/dVVVVVVVVVVUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVVVVVVVVVVX9////3/9fVf3////f/19VVVVVVVVVVVVVVVVVXVVVVf////////////////////9dVVVVVVVVVVVVVVUVAFBVVVVVVVVVVVVVVVVVVVVVVQEAAAAAAAAAAAAAEEEQVVVVVVVVVVVVVVVVVVUAUFVVAABAVFVVVVVVVVVVVVUVAAAAAABVVVVVVFVVVVVVVVVVBQAQABQEUFVVVVVVVVUVUVVVVVVVVVUAAAAAAABAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQUAAFRVVVVVVVVVVVVVVVVVFQAAVVVRVVVVVVUFEAAAAQFQVVVVVVVVVVVVVQFVVVVVVVVVVVVVVVVVUFUAAFVVVVVVVVVVVVUFAAAAAAAAAAAAAAAAAEBVVVVVVVVVVVVVVVVVRVQBAFRRAQBVVQVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVAFUVVFVVVVVBVVVVVVVVUVBVVVVVVVVVVVVVVVVVVVUQRUUUFFVVVVVVVVVUFFVVQEQVFFVVVVVBVVVVVVVBQBRVVVVVVVVVVVVVVVVVVUUAVRVUVVBVVUFVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVUVVVRVVVVVVVVVVVVVVVVVFRVVVVVVVVVVVVVVVVVBFQFBFBVQVVVBVVVVVVVVVVVRVVQVVVVVQVVVVVVVVVVUFVVVVVVVVVVVVVVVVUVVAFUVVFVVVVVBVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVVVFVQVEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVEAQFVVFQBAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUQAAVFVVAEBVVVVVVVVVVVVVVVVVVVVVVVVQVVVVVVVVEVFVVVVVVVVVVVVVVVVVAQAAQAAEVQEAAAEAAAAAAAAAAFRVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUBBABBQVVVVVVVVVAFVFVVVQFUVVVFQVVRVVVVUVVVVVVVVVVVqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqAAAAAAAAAABVVVVVVVVVAVVVVVVVVVVVVVVVVQVUVVVVVVVVBVVVVVVVVVUFVVVVVVVVVQVVVVVVVVVVVVVVVVVVVVVVEABQVUUBAABVVVFVVVVVVVVVVVVVFQBVVVVVVVVVVVVVVVVVQVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVAFVRVRVUBVVVVVVVVFRRVVVVVVVVVVVVVVVVVVUUAQEQBAFQVAAAUVVVVVVVVVVVVVVVVAAAAAAAAAEBVVVVVVVVVVVVVVVUAVVVVVVVVVVVVVVVVBEBURVVVVVVVVVVVVRUAAFVVVVBVVVVVVVVVBVAQUFVVVVVVVVVVVVVVVVVFUBFQVVVVVVVVVVVVVVVVVVUAAAVVVVVVVVVAAAAABABUUVVUUFVVVRUA139fX3//BUD3XdV1VVVVVVVVVVUABAAAVVdV1f1XVVVVVVVVVVVVV1VVVVVVVVVVAAAAAAAAAABUVVVV1V1dVdV1VVV9ddVVVVVVVVVVVVXVV9V/////Vf//X1VVVV1V//9fVVVVVVVVVV9VVVVVVXVXVVVV1VVVVVVVVffV19VdXXX9193/d1X/VV9VVVdXdVVVVV//9fVVVVVV9fVVVVVdXVVVXVVVVVVV1VVVVVV1VaVVVVVpVVVVVVVVVVVVVVVVVVVVqVaWVVVVVVVVVVVVVVX/////////////////////////////////////////////3///////////Vf///////////1VVVf/////1X1VV3/9fVfX1VV9f9df1X1VVVfVfVdVVVVVpVX1d9VVaVXdVVVVVVVVVVXdVqqqqVVVV399/31VVVZVVVVVVlVVV9VlVpVVVVVXpVfr/7//+///fVe//r/vv+1VZpVVVVVVVVVVWVVVVVV1VVVVmlZpVVVVVVVVV9f//VVVVVVWpVVVVVVVVVlVVlVVVVVVVVZVWVVVVVVVVVVVVVVVVVvlfVVVVVVVVVVVVVVVVVVVVVVVVVVUVUFVVVVVVVVVVVVVVAAAAAAAAAACqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqlVVVaqqqqqqWlVVVVVVVaqqqqqqqqqqqqqqqqqqCqCqqqpqqaqqqqqqqqqqqqqqqqqqqqqqqqqqaoGqqqqqqqqqqqpVqaqqqqqqqqqqqqqpqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqlVVlaqqqqqqqqqqqqqqaqqqqqqqqqqqqqr//6qqqqqqqqqqqqqqqqqqqlaqqqqqqqqqqqqqqqqqalVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVQAAAUFVVVVVVVVUFVVVVVVVVVVVVVVVVVVVVVVVVVVVQVVVVRUUVVVVVVVVVQVVUVVVVVVVQVVVVVVVVAAAAAFBVVRVVVVVVVVVVVVUFAFBVVVVVVRUAAFBVVVWqqqqqqqqqVkBVVVVVVVVVVVVVVRUFUFBVVVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVQFAQUFVVRVVVVRVVVVVVVVVVVVVVVRVVVVVVVVVVVVVVVUEFFQFUVVVVVVVVVVVVVVQVUVVVVVVVVVVVVVVVVFUUVVVVVWqqqqqqqqqqqpVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVQAAAACqqlpVAAAAAKqqqqqqqqqqaqqqqqpqqlVVVVVVqqqqqqqqqqpWVVVVVVVVVVVVVVVVVVVVqmpVVVVVAV1VVVVVVVVVVVVVVVVVVVVRVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVUFQFUBQVUAVVVVVVVVVVVVVUAVVVVVVVVVVVVVQVVVVVVVVVVVVVVVVVVVVQBVVVVVVVVVVVVVVVVVVVVVFVRVVVVVVVVVVVVVVVVVVVVVVVVVAVUFAABUVVVVVVVVVVVVVVUFUFVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVUAAABAVVVVVVVVVVVVVRRUVRVQVVVVVVVVVVVVVVUVQEFRRVVVUVVVVVVVVVVVVVVVVUBVVVVVVVVVVRUAAQBUVVVVVVVVVVVVVVVVVVUVVVVVUFVVVVVVVVVVVVVVVQUAQFVVARRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQBFVFVVVVVVVVVRUVAEBVVVVVVVRVVVVVVVVVVQUAVABUVVVVVVVVVVVVVVVVVVVVVQAABURVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVVRUARBUEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBVBVEFRVVVVVVVVQVVVVVVVVVVVVVVVVVVVVVVVVVVUVAEARVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVUQAQVVVVVVVVVVVVAQUQAFVVVVVVVVVVVVVVVVVVVVUVAABBVVVVVVVVVVVVVVVVVVVVFUQVVVVVVVVVVVVVVVVVVVVVVVVVVVUABVVUVVVVVVVVVQEAQFVVVVVVVVVVVRUAFEBVFVVVAUABVVVVVVVVVVVVVVUFAABAUFVVVVVVVVVVVVVVVVVVVVVVVVVVVQBAABBVVVVVBQAAAAAABQAEQVVVVVVVVVVVVVVVVVVVAUBFEAAQVVVVVVVVVVVVVVVVVVVVVVVVUBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVRVVVBVVVVVVVVVVVVVVVUFQFVEVVVVVVVVVVVVVVVVVVVVVBUAAABQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQBUVVVVVVVVVVVVVVVVVVUAQFVVVVVVFVVVVVVVVVVVVVVVVVVVVRVAVVVVVVVVVVVVVVVVVVVVVVVVVapUVVVaVVVVqqqqqqqqqqqqqqqqqqpVVaqqqqqqWlVVVVVVVVVVVVWqqlZVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVqqmqaaqqqqqqqqqqalVVVWVVVVVVVVVVallVVVWqVVWqqqqqqqqqqqqqqqqqqqqqqqqqVVVVVVVVVVVBAFVVVVVVVVUAAAAAAAAAAAAAAFAAAAAAAEBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQVRUAAABAAQBVVVVVVVVVBVBVVVVVBVRVVVVVVVVVVVVVVVVVVQAAAAAAAAAAAAAAAABAFQAAAAAAAAAAAAAAAFRVUVVVVVRVVVVVFQABAAAAVVVVVQBAAAAAABQAEARAVVVVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVUAVVVVVVVVVVUAQFVVVVVVVVVVVVVVAEBVVVVVVVVVVVVVVVVVVVZVVVVVVVVVVVVVVVVVVVVVVZVVVVVVVVVVVVVVVVX//39V/////////1///////////////////19V/////////++rqur/////V1VVVVVqVVVVqqqqqqqqqqqqqqpVqqpWVVpVVVWqWlVVVVVVVaqqqqqqqqqqVlVVqaqaqqqqqqqqqqqqqqqqqqqqqqqmqqqqqqpVVVWqqqqqqqqqqqqqapWqVVVVqqqqqlZWqqqqqqqqqqqqqqqqqqqqqqpqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpaqqqqqqqqqqqqqqqqqqqpaVVWVaqqqqqqqqlVVVVVlVVVVVVVVaVVVVVZVVVVVVVVVVVVVVVVVVVVVVVVVVZWqqqqqqlVVVVVVVVVVVVVVVapaVVZqqVWqVVWVVlWqqlZVVVVVVVVVVaqqqlVWVVVVVVVVqqqqqqqqqqqqqqpqqqqaqqqqqqqqqqqqqqqqqqpVVVVVVVVVVVVVVVWqqqpWqqpWVaqqqqqqqqqqqqqqmqpaVaWqqqpVqqpWVaqqVlVRVVVVVVVVVQAAAAAAAAAA////////////////////XwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAXAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUAAAUFBQUCMjIyMjIyMjIyMjIyMjIyO0tLS0tLS0tLS0tLQkJCQkPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAAFBQUFBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAABQUFBQICAgICAgICAgICAgICAgIAICAgICAgICAgICAgICAgI8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDxwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUAAAUFBQUCMjIyMjIyMjIyMjIyMjIyOwsLCwsLCwsLCwsLACAgICPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHAAAHBwcHAnJycnJycnJycnJycnJycnuLi4uLi4uLi4uLi4KCgoKAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcAAAcHBwcCAgICAgICAgICAgICAgICAGBgYGBgYGBgYGBgYGBgYGCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHAAAHBwcHAnJycnJycnJycnJycnJycnsLCwsLCwsLCwsLCwBgYGBgkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ADQAADQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAUAAAUFBQUCsrKysrKysrKysrKysrKytMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAVMTExMTExMDkxMAUwNDg5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAAFBQUFAgICAgICAgICAgICAgICAgTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAABQUFBQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAUFBQUFBQUFBQUFBQUFBQUABQUFBQUFBQUFBQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////////////////////////////////////////////////////////AAAAAAAAAAAAAABwcHBwcHBwDHBwcHBwcHBwcHBwcHBwcHAAcAAAcHBwcJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKc1ZhbHVlKCkAAADwXRAACAAAAPhdEAABAAAAAEGMvMEACwwAAAAAAAAAAD0AAAAAqaMCBG5hbWUBoKMCjQQAQWpzX3N5czo6QXJyYXk6OmdldDo6X193YmdfZ2V0XzU3MjQ1Y2M3ZDdjNzYxOWQ6Omg4MmE0ZGFhNDA3NjU3NTUzATp3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fanN2YWxfbG9vc2VfZXE6Omg2YjYyNTI1ZWQ0OGRkOTc0ApABanNfc3lzOjpfOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNhc3Q6OkpzQ2FzdCBmb3IganNfc3lzOjpVaW50OEFycmF5Pjo6aW5zdGFuY2VvZjo6X193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5Xzk3MWVlZGE2OWViNzUwMDM6OmhmYTA5N2I3YWEzOGUxNjliA5IBanNfc3lzOjpfOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNhc3Q6OkpzQ2FzdCBmb3IganNfc3lzOjpBcnJheUJ1ZmZlcj46Omluc3RhbmNlb2Y6Ol9fd2JnX2luc3RhbmNlb2ZfQXJyYXlCdWZmZXJfZTVlNDhmNDc2MmM1NjEwYjo6aDk2ZGViYTA5MmFjN2M5ZGEERmpzX3N5czo6VWludDhBcnJheTo6bmV3OjpfX3diZ19uZXdfOGMzZjAwNTIyNzJhNDU3YTo6aGIzMDI1NzBjYWQ4NTY4ODYFN3dhc21fYmluZGdlbjo6X193YmluZGdlbl9ib29sZWFuX2dldDo6aDE2NDhmMWFiNjRjZjk1NTIGNndhc21fYmluZGdlbjo6X193YmluZGdlbl9udW1iZXJfZ2V0OjpoNjMxZTg0MDYzZjBjYjE2Ngc2d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3N0cmluZ19nZXQ6OmgxZjM1ZDA1ZTIyYjQ5ZDRhCDV3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fZXJyb3JfbmV3OjpoZTA3OTNjNTU5MTE4MWE0Ngk2d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3N0cmluZ19uZXc6OmgxNGU0MmZjOTZkMjFmOTUzCjx3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZjo6aDVkOTNkZTUxMDFmZThjYTcLUXNlcmRlX3dhc21fYmluZGdlbjo6T2JqZWN0RXh0OjpzZXQ6Ol9fd2JnX3NldF85MTgyNzEyYWJlYmY4MmVmOjpoZmM4MGQ5OTAyZGZhNThmNQxCanNfc3lzOjpPYmplY3Q6Om5ldzo6X193YmdfbmV3XzBiOWJmZGQ5NzU4MzI4NGU6OmhiMzZmYzllZDJmMDc0ZDRjDUFqc19zeXM6OkFycmF5OjpuZXc6Ol9fd2JnX25ld18xZDlhOTIwYzZiZmM0NGE4OjpoYzE0YTk5MGIzOGE0ZjJmMQ5BanNfc3lzOjpBcnJheTo6c2V0OjpfX3diZ19zZXRfYTY4MjE0ZjM1YzQxN2ZhOTo6aGU0MmJhZmJkYzNlYTFhNGUPNndhc21fYmluZGdlbjo6X193YmluZGdlbl9udW1iZXJfbmV3OjpoZjE3NjI1ZDU1Y2FiNWU3YxBHanNfc3lzOjpBcnJheTo6bGVuZ3RoOjpfX3diZ19sZW5ndGhfNmUzYmJlN2M4YmQ0ZGJkODo6aGUxMTFiYjM5NjM5MjBjYTgRNXdhc21fYmluZGdlbjo6X193YmluZGdlbl9pc19iaWdpbnQ6OmhhNzUyNzY0NDZjZGY1OTE2Elhqc19zeXM6Ok51bWJlcjo6aXNfc2FmZV9pbnRlZ2VyOjpfX3diZ19pc1NhZmVJbnRlZ2VyX2RmYTA1OTNlOGQ3YWMzNWE6OmhjZjg2YWQ4N2Q4ZjE2NzRkEzt3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fYmlnaW50X2Zyb21faTY0OjpoNTZhZWY5MjE4N2E1YzIxZhQ1d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2lzX29iamVjdDo6aDI1NmMxNTYwZGVkNDY2ZjEVTGpzX3N5czo6U3ltYm9sOjppdGVyYXRvcjo6X193YmdfaXRlcmF0b3JfNmY5ZDRmMjg4NDVmNDI2Yzo6aDkyNTgwY2M5ZDM0NWQ1MTIWLndhc21fYmluZGdlbjo6X193YmluZGdlbl9pbjo6aGM2Y2VmZTJiNjFhMjIyMjkXSmpzX3N5czo6T2JqZWN0OjplbnRyaWVzOjpfX3diZ19lbnRyaWVzXzY1YTc2YTQxM2ZjOTEwMzc6OmhjM2VjODkyZjFhYmE2NzQwGDt3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fYmlnaW50X2Zyb21fdTY0OjpoMWFhNDU4MmRhNjM2NGIxOBk0d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2pzdmFsX2VxOjpoOGY5ZTU3Y2E5ZTc4M2MxNxpTY29uc29sZV9lcnJvcl9wYW5pY19ob29rOjpFcnJvcjo6bmV3OjpfX3diZ19uZXdfYWJkYTc2ZTg4M2JhOGE1Zjo6aDRhNjdmNzI0ZDU4MmNmZGEbV2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vazo6RXJyb3I6OnN0YWNrOjpfX3diZ19zdGFja182NTgyNzlmZTQ0NTQxY2Y2OjpoYWE1NjU3ZmQ3OGQ0YzNmNhxQY29uc29sZV9lcnJvcl9wYW5pY19ob29rOjplcnJvcjo6X193YmdfZXJyb3JfZjg1MTY2N2FmNzFiY2ZjNjo6aDBiNzFiMjEyMjU1MDNiYzEdO3dhc21fYmluZGdlbjo6X193YmluZGdlbl9vYmplY3RfZHJvcF9yZWY6Omg0Mjg2MmM3OGVkMWI2NjFhHjd3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5faXNfZnVuY3Rpb246Omg3Zjk4ZjQ5ZGExN2ZlYTNjH0Zqc19zeXM6Okl0ZXJhdG9yOjpuZXh0OjpfX3diZ19uZXh0X2FhZWY3YzhhYTVlMjEyYWM6OmgwMzU2MDJhMTk1M2VhMmQwIEpqc19zeXM6Okl0ZXJhdG9yTmV4dDo6ZG9uZTo6X193YmdfZG9uZV8xYjczYjA2NzJlMTVmMjM0OjpoNTk0MmQwOTY2NDI3NzU1NCFManNfc3lzOjpJdGVyYXRvck5leHQ6OnZhbHVlOjpfX3diZ192YWx1ZV8xY2NjMzZiYzAzNDYyZDcxOjpoOWExMzNjNDIzNjU3ZmQyNiJDanNfc3lzOjpSZWZsZWN0OjpnZXQ6Ol9fd2JnX2dldF83NjUyMDE1NDRhMmI2ODY5OjpoNjk0YjYyZDgwMjBmY2VlNSNHanNfc3lzOjpGdW5jdGlvbjo6Y2FsbDA6Ol9fd2JnX2NhbGxfOTdhZTlkODY0NWRjMzg4Yjo6aDJmYzg2OGU1NjAwNjg2NGIkampzX3N5czo6SXRlcmF0b3I6Omxvb2tzX2xpa2VfaXRlcmF0b3I6Ok1heWJlSXRlcmF0b3I6Om5leHQ6Ol9fd2JnX25leHRfNTc5ZTU4M2QzMzU2NmE4Njo6aGQ2OTE5M2Q0YzQzMzViOGUlSmpzX3N5czo6QXJyYXk6OmlzX2FycmF5OjpfX3diZ19pc0FycmF5XzI3YzQ2YzY3ZjQ5OGUxNWQ6Omg0MjhhYWI0OTMwZmNmODNiJkxqc19zeXM6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzllMWFlMTkwMGNiMGZiZDU6OmgwYWQ1ZTVjYjNhMzE3ZTA3JzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoZTQ4NzUwM2IxZTEyMTk2ZihVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl8zZjNkNzY0ZDQ3NDdkNTY0OjpoYzMzZGVhYWZiM2RmZDQ0ZilGanNfc3lzOjpVaW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF84M2RiOTY5MGY5MzUzZTc5OjpoZTFiODBiZmE1N2UzMjMyOCo9d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2JpZ2ludF9nZXRfYXNfaTY0OjpoYTBiMTkyYmQ3ZGYwNDVlZCs4d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX2RlYnVnX3N0cmluZzo6aGQ5MTQzYTM5YzczZjUzNDEsMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDAxZDY5Mjk2Y2IxM2ZkMjMtRWNvcmU6OmZtdDo6ZmxvYXQ6OmZsb2F0X3RvX2RlY2ltYWxfY29tbW9uX3Nob3J0ZXN0OjpoNmU3OGFiNTJhMjc2NWJiOC5CY29yZTo6Zm10OjpmbG9hdDo6ZmxvYXRfdG9fZGVjaW1hbF9jb21tb25fZXhhY3Q6OmgwMmRmYjJhODYyNjIxMjllL0lkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2Vfd29yZF9wYXJ0czo6e3tjbG9zdXJlfX06OmgxYjdkZTcyNTUzOWI1OGZkMEBkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfcGlwZWxpbmVfaW5uZXI6OmgzZDY2YmFjYjdiNjcyMWE3MTpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmhmODI3YmQ2MGNkOGFkYTczMjpkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2Vfc2VxdWVuY2U6Omg0NjQ4M2U3ZjAzY2NlNmEwM2U8c2VyZGVfd2FzbV9iaW5kZ2VuOjpkZTo6RGVzZXJpYWxpemVyIGFzIHNlcmRlOjpkZTo6RGVzZXJpYWxpemVyPjo6ZGVzZXJpYWxpemVfYW55OjpoMDUwMGZiYjAwYmRjY2MyZDQ+ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX2NvbW1hbmRfYXJnczo6aGE3MDk3MmE3NWJlYjA2NjQ1OmRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV9yZWRpcmVjdDo6aGE0NGEwYzM3MTFmMjA3YWY2XDxjb3JlOjptYXJrZXI6OlBoYW50b21EYXRhPFQ+IGFzIHNlcmRlOjpkZTo6RGVzZXJpYWxpemVTZWVkPjo6ZGVzZXJpYWxpemU6OmhkYTJiMGVhZTRiMjc4ZDZmNzJjb3JlOjpzdHI6OjxpbXBsIHN0cj46OmNvbnRhaW5zOjpoZmIwYzNhM2I4NDdkYWRjNTgsY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDgzZjkzM2UwODU2YzBiMjQ5PGNvbnNvbGVfc3RhdGljX3RleHQ6OnJlbmRlcl90ZXh0X3RvX2xpbmVzOjpoOWY5YTgzYmRmNTQ2OTU4NTo/ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3F1b3RlZF9zdHJpbmc6Omg1NzYzN2ViZDhjOWQyMGFmO1Fjb25zb2xlX3N0YXRpY190ZXh0OjpDb25zb2xlU3RhdGljVGV4dDo6cmVuZGVyX2l0ZW1zX3dpdGhfc2l6ZTo6aDBhODEyZTgwNTZkZjcyOGQ8QWRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV9zZXF1ZW50aWFsX2xpc3Q6Omg1MmJmOGZhN2VhMDQ5MWY5PQVwYXJzZT5FY29yZTo6Y2hhcjo6bWV0aG9kczo6PGltcGwgY2hhcj46OmVzY2FwZV9kZWJ1Z19leHQ6Omg0YTQ3ZDA2NzI3ZjQ4ZDUwPzF2dGU6OlBhcnNlcjxfPjo6cGVyZm9ybV9hY3Rpb246OmhhZWVhMzcyNGJiNTkzZWFhQDFjb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWxfcnQ6Omg2M2VlNjdhMmY2ZTc0MDg2QTpkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfZW52X3ZhcnM6OmgzMTQ5YjU1ZTliY2NkOGQ0QkU8c2VyZGU6OmRlOjpVbmV4cGVjdGVkIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGRkZDc5ZjZkOThjMjY1OTBDOGNvcmU6Om51bTo6YmlnbnVtOjpCaWczMng0MDo6bXVsX3BvdzI6OmgxZjhlZjExNmNiYjg5MWNiRCltb25jaDo6b3I6Ont7Y2xvc3VyZX19OjpoNGQ0MjhlM2YxY2JhYzk1ZUVAaGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlPFQsQT46OnJlc2VydmVfcmVoYXNoOjpoZjE4ZTEzMTc2ZmZiYzk1MkZJY29uc29sZV9zdGF0aWNfdGV4dDo6Q29uc29sZVN0YXRpY1RleHQ6OmdldF9sYXN0X2xpbmVzOjpoYTdlMGZjMjgzNTE0OWI0N0cxPHN0ciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNmFmYjE3OGQ1MjAzYzEzNEhCY29yZTo6bnVtOjpmbHQyZGVjOjpzdHJhdGVneTo6ZHJhZ29uOjptdWxfcG93MTA6Omg0NzhkNmUwOTBjOGQ5YzZkSQ5fX3J1c3RfcmVhbGxvY0o2ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3dvcmQ6OmhiN2FlMjY3OGE4ODJkOWY4S248c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoZTdkNzhmMTliZjhhNDc3ZEw4ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZnJlZTo6aDRhNjAwOWJmY2Y3NjBlODFNMmNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbW1vdmU6OmhmZDIzOWQ5NGU0NWI5M2I0Tjpjb3JlOjpudW06OmJpZ251bTo6QmlnMzJ4NDA6Om11bF9kaWdpdHM6Omg5MmZkZDlmOGMzNDdkN2RhTzFzZXJkZV93YXNtX2JpbmRnZW46OmZyb21fdmFsdWU6OmhiMTRjZWNhMTgxZWFmYmViUFc8c2VyZGU6OmRlOjppbXBsczo6U3RyaW5nVmlzaXRvciBhcyBzZXJkZTo6ZGU6OlZpc2l0b3I+Ojp2aXNpdF9ieXRlczo6aGI2Y2M0MzJjNWE3ZWFlNGRRPWNvbnNvbGVfc3RhdGljX3RleHQ6OnJhd19yZW5kZXJfbGFzdF9pdGVtczo6aDYwOTM5NGY1Yzc2MGYzYTdSbjxzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6T2JqZWN0U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVTdHJ1Y3Q+OjpzZXJpYWxpemVfZmllbGQ6Omg1YjVlN2IwNmQyODJhMTBhUxdzdGF0aWNfdGV4dF9yZW5kZXJfb25jZVQ+Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OndyaXRlX2Zvcm1hdHRlZF9wYXJ0czo6aGNkMmE0OWRkYTY5M2I1YTRVbjxzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6T2JqZWN0U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVTdHJ1Y3Q+OjpzZXJpYWxpemVfZmllbGQ6OmhmZjQzYjUyODgwOWRhNDMzViNjb3JlOjpmbXQ6OndyaXRlOjpoNzFmYWEyNTE5Y2JiOTg3NVcXc3RhdGljX3RleHRfcmVuZGVyX3RleHRYTDxhbnlob3c6OmZtdDo6SW5kZW50ZWQ8VD4gYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGFiNGNhOWFlNjIxMzNhODlZNWNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6Omg1OTBjNTRmZmUyYzNhYTUyWkFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3NlX2NodW5rOjpoYzExOTVlNmNiZmNlMDBmNVtTPGNvcmU6OmZtdDo6YnVpbGRlcnM6OlBhZEFkYXB0ZXIgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDBmMjY1Y2I4MDc2ZTVkNWRcPGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfZm9ybWF0dGVkX3BhcnRzOjpoYzJiMDc3NTI5Zjc0ZDE5ZV0vdnRlOjpQYXJzZXI8Xz46OnByb2Nlc3NfdXRmODo6aDZlNjZmNzc1NWM2NDI4MDZeMWNvbnNvbGVfZXJyb3JfcGFuaWNfaG9vazo6aG9vazo6aGRjNGM1OGUzMjk0ZjI1NGFfQmRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV9waXBlX3NlcXVlbmNlX29wOjpoZmFlZmQzY2I2MTNhZmUxYmBGYW55aG93OjpmbXQ6OjxpbXBsIGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbD46OmRlYnVnOjpoOTg5Yzk4NDkzZDFjY2FiYmE2Y29uc29sZV9zdGF0aWNfdGV4dDo6YW5zaTo6dG9rZW5pemU6Omg2YjczZWFhMzY0NDBkZWRmYjltb25jaDo6d2l0aF9mYWlsdXJlX2lucHV0Ojp7e2Nsb3N1cmV9fTo6aDIyOTQ2NWIwNjRkZThlMTVjN21vbmNoOjpQYXJzZUVycm9yRmFpbHVyZTo6aW50b19lcnJvcjo6aDY4ZDMwMTljMjcyN2M1ZDlkJG1vbmNoOjp3aGl0ZXNwYWNlOjpoMjI3MmJhYjBjMzYwYmE5YmVePGNvcmU6OnN0cjo6aXRlcjo6U3BsaXQ8UD4gYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoOThkZmIwY2FlNTlmNzMwZmZuPHNlcmRlX3dhc21fYmluZGdlbjo6c2VyOjpPYmplY3RTZXJpYWxpemVyIGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZVN0cnVjdD46OnNlcmlhbGl6ZV9maWVsZDo6aGEwOWJmNWVmODVkYjVlYzdnN3NlcmRlX3dhc21fYmluZGdlbjo6c3RhdGljX3N0cl90b19qczo6aDNkYTE4NzQxZTBkZGRiMThoO2NvcmU6OnN0cjo6cGF0dGVybjo6VHdvV2F5U2VhcmNoZXI6Om5leHQ6OmgxNWY2OTc3NzIzMTY2OTU2aUZzZXJkZV93YXNtX2JpbmRnZW46OmRlOjpEZXNlcmlhbGl6ZXI6OmludmFsaWRfdHlwZV86OmgyMDdkMDRhZmU4MzBiMjNiakFkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfYm9vbGVhbl9saXN0X29wOjpoZmM0MzQyNGVmY2NmZjMwOWtSYW55aG93OjplcnJvcjo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciBhbnlob3c6OkVycm9yPjo6Zm10OjpoZTYyMWYwNGFmOTdjOWEzMmw1b25jZV9jZWxsOjppbXA6OmluaXRpYWxpemVfb3Jfd2FpdDo6aDBmZTk1YmIwMGE2ZTBlMmVtM2FsbG9jOjpmbXQ6OmZvcm1hdDo6Zm9ybWF0X2lubmVyOjpoYzk0NGFlOGJjYmEyYWI1OW48ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWVtYWxpZ246OmhhZjQ1Zjk5MmIzMWVmNzZib1hjb3JlOjpudW06OmZsdDJkZWM6OnN0cmF0ZWd5OjpncmlzdTo6Zm9ybWF0X2V4YWN0X29wdDo6cG9zc2libHlfcm91bmQ6OmhiMDlmZDU3MDg2ODg2MmQxcDhjb3JlOjpudW06OmZsdDJkZWM6OmRpZ2l0c190b19kZWNfc3RyOjpoMjA0NWFkN2RhOGY5ZDBlZHEqbW9uY2g6Om1hcDo6e3tjbG9zdXJlfX06OmhjZTVlYjM1OTU2ZWQ3ZWNhcllzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudFJlZkRlc2VyaWFsaXplcjxFPjo6aW52YWxpZF90eXBlOjpoMzdmMzYzODE3MjUyNzAzZHM9Y29uc29sZV9zdGF0aWNfdGV4dDo6dHJ1bmNhdGVfbGluZXNfaGVpZ2h0OjpoYzFjYmQ2OTUzZjViNWMzZnQ6Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdTdHJ1Y3Q6OmZpZWxkOjpoODczZWRmNWZiMWNkMThiMnUyY29yZTo6dW5pY29kZTo6cHJpbnRhYmxlOjpjaGVjazo6aGQyODkwMmJmNDIzMzFkYjF2OzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg1YjM5MGNmZDRkN2E5ZDdidzs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoMTViZmMxMWY2YTU2MGZjZHgxY29tcGlsZXJfYnVpbHRpbnM6Om1lbTo6bWVtY3B5OjpoMGNmNDc0OTU5MDFkMDY4NHk2Y29yZTo6c2xpY2U6Om1lbWNocjo6bWVtY2hyX2FsaWduZWQ6OmhkZjJlNDBmYzFjYzA3MjZiei9jb3JlOjpmbXQ6Om51bTo6aW1wOjpmbXRfdTY0OjpoZTVmN2NmNWU5ZTAyZGE0MHs+Y29uc29sZV9zdGF0aWNfdGV4dDo6YW5zaTo6c3RyaXBfYW5zaV9jb2Rlczo6aGIyNmE5ZWY5NWI1Y2YwZTJ8FnN0YXRpY190ZXh0X2NsZWFyX3RleHR9ZHNlcmRlOjpzZXI6OmltcGxzOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGFsbG9jOjp2ZWM6OlZlYzxUPj46OnNlcmlhbGl6ZTo6aDM0NjcxMjQxMjRiMGU3YjJ+MDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMDBlNjNiNjIyYzM3NjlhYn8wY29yZTo6b3BzOjpmdW5jdGlvbjo6Rm46OmNhbGw6OmhjMDBlZGUyMjE2NzE5ODBlgAEyPGNoYXIgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDA4MDc0NDVjNWRmZWZkZWGBAUZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojp1bmxpbmtfbGFyZ2VfY2h1bms6OmgxYjg3OTllNDEzMTI3NGU3ggE3Y29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkX2lubmVyOjpoZWY4YWE5MTQwZWQzYjE1Y4MBMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMjAyMmM5NTgxYTBmMjFiZYQBRmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46Omluc2VydF9sYXJnZV9jaHVuazo6aDZkZjg3ODczZGJiYTQ2NDaFAekBY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGNvcmU6OmNlbGw6OlJlZkNlbGw8c3RkOjpjb2xsZWN0aW9uczo6aGFzaDo6bWFwOjpIYXNoTWFwPCpjb25zdCBzdHIsanNfc3lzOjpKc1N0cmluZyxjb3JlOjpoYXNoOjpCdWlsZEhhc2hlckRlZmF1bHQ8c2VyZGVfd2FzbV9iaW5kZ2VuOjpzdGF0aWNfc3RyX3RvX2pzOjpQdHJIYXNoZXI+Pj4+Pjo6aGJlZmEyNGY1MGYxNzZiYTaGAUdjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpEZWJ1ZyBmb3IgdTMyPjo6Zm10OjpoNDRlZmU5OTJhYzZhYmE4Y4cBNDxjaGFyIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDYxNDlmOGIxODUxZGMwMzOIAU08YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoODIzMThkOThhZjhhNTcyMS40NokBKm1vbmNoOjptYXA6Ont7Y2xvc3VyZX19OjpoNDZlNDljMDc1ZDY4NmE0NooBR3NlcmRlX3dhc21fYmluZGdlbjo6c3RhdGljX3N0cl90b19qczo6Q0FDSEU6Ol9fZ2V0aXQ6Omg1YjJlYWZhMGQ3OTc1YzRmiwE+ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX2Vudl92YXJfbmFtZTo6aGQxOWY3NGVjNTM1MGNlMjOMAUJjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfdHVwbGVfZmllbGQxX2ZpbmlzaDo6aDQ3ZGI3ZmI2NTRjZjdmZDmNATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoNzUwM2NmMmU0MzNmMjViMI4BOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6OmgzNzIzODI3OGEyZDI1NDVmjwEvY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfY2hhcjo6aDE5OGY1MTg3NjY3N2I5ZDOQASptb25jaDo6bWFwOjp7e2Nsb3N1cmV9fTo6aDQ4NWI4NjJjYjU1NTA3ZjeRAWg8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMzQ5MWU3MGMwZjA2MDI3MpIBMGFsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZXNlcnZlOjpoN2RiOWYzZTljYjFlOGM1MJMBLmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aDZmYzBhY2JhZDMxYzdjOGSUAS5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmgzNzJmNDExOWUwZjhjNTM3lQE3Y29yZTo6Y2hhcjo6bWV0aG9kczo6ZW5jb2RlX3V0ZjhfcmF3OjpoY2E2NTg3MTZlMzhhYzMwOZYBOmNvcmU6OnN0cjo6dmFsaWRhdGlvbnM6Om5leHRfY29kZV9wb2ludDo6aDMyODc3NjNjNTVkNzM4MGGXATp1bmljb2RlX3dpZHRoOjp0YWJsZXM6OmNoYXJ3aWR0aDo6d2lkdGg6OmhhYTBmODA4NTVmY2E5ZGFkmAE+YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+Ojpncm93X2Ftb3J0aXplZDo6aDQ2ZmVlMTE5ZmJjY2FiMDWZAT9zdGQ6OnN5c19jb21tb246OnRocmVhZF9pbmZvOjpjdXJyZW50X3RocmVhZDo6aDhhYTEyM2U4ZmJjMjdkNTeaASNqc19zeXM6OnRyeV9pdGVyOjpoYmI3MTRhYWJjMDJlNWVjZZsBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDQ0NWU2N2UzZDVkYTFhMTicAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6Omg3NGIyNDQwNGZkNWRmNmQ0nQFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoYWQxM2IyMTAxNTE5YjMyNZ4BQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDRmNGI5ZmM2ZmMxN2NmY2KfAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmgyMDkzYjliYTNjZWQ2NWQ3oAFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoODkwNjllNjQ3Y2FhNTNiZKEBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDUzMjg4MDViODg1MzJkOGGiAUs8bW9uY2g6OlBhcnNlRXJyb3JGYWlsdXJlRXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGRmMjU3ZTc1YzhiOTc0M2OjAW48c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoOWNhZTZkZjVjOWI1ZTRkY6QBPmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6Z3Jvd19hbW9ydGl6ZWQ6OmgwNzU0NzEwNDhmYTNkYjhmpQE+YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+Ojpncm93X2Ftb3J0aXplZDo6aDIzOTllMjc3MWE0MDk0NGGmAU5hbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmU6OmRvX3Jlc2VydmVfYW5kX2hhbmRsZTo6aDA4ODA0MjU3YWU5NWI5NzSnAS5tb25jaDo6aWZfdHJ1ZTo6e3tjbG9zdXJlfX06Omg4ZTQ1M2VkYjBiNmJjODQwqAFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoMWIxZTYyYzcyOTMyMDcyYakBbjxjb3JlOjppdGVyOjphZGFwdGVyczo6ZmxhdHRlbjo6RmxhdHRlbjxJPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmhmYTkyZmFlOTVkY2YyN2RkqgE3c3RkOjpwYW5pY2tpbmc6OnJ1c3RfcGFuaWNfd2l0aF9ob29rOjpoM2FhMDU0ZDM1YTA4MTdkN6sBMGNvcmU6Om9wczo6ZnVuY3Rpb246OkZuOjpjYWxsOjpoY2Q2OTMwZWRjOGNkYjA2MqwBMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbXNldDo6aDNlZjQyM2I5MmRjZmRmYjetAS5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmgwOGMxM2Q0YjFkNWY5ZGY4rgFNPG1vbmNoOjpQYXJzZUVycm9yRmFpbHVyZUVycm9yIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDg3NjE3YmVhMDU1MGEzOGSvARBzdHJpcF9hbnNpX2NvZGVzsAFRPHNlcmRlX3dhc21fYmluZGdlbjo6ZXJyb3I6OkVycm9yIGFzIHNlcmRlOjpkZTo6RXJyb3I+OjpjdXN0b206OmhmNjZlZjQxMDFlZmI0NjA4sQExYWxsb2M6OnN0cjo6PGltcGwgc3RyPjo6cmVwZWF0OjpoNjI3ZGY3MWUxNzcxZjZjNLIBP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZDdhMTc3MGU5ODU1NWU1YbMBOWFsbG9jOjp2ZWM6OlZlYzxULEE+OjpleHRlbmRfZGVzdWdhcmVkOjpoODMxNWQ0ODVkZDdjNjJmZLQBR29uY2VfY2VsbDo6aW1wOjpPbmNlQ2VsbDxUPjo6aW5pdGlhbGl6ZTo6e3tjbG9zdXJlfX06Omg1MmI1ODBkODNlYmRkOWQ3tQEjbW9uY2g6Om5leHRfY2hhcjo6aGVhMmE1ZTExZWQ0OTQ0YjW2AUNjb3JlOjppdGVyOjphZGFwdGVyczo6ZmxhdHRlbjo6YW5kX3RoZW5fb3JfY2xlYXI6OmgxMjFmOGFmNmQ5OGEzNWQxtwEpbW9uY2g6OnNraXBfd2hpdGVzcGFjZTo6aGM3YzE3ZDJiZWMxMzdiNjK4AUNzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6e3tjbG9zdXJlfX06OmgyZjczZTRjZjZjZDYzMTlhuQGWATxyc19saWI6Ol86OjxpbXBsIHNlcmRlOjpkZTo6RGVzZXJpYWxpemUgZm9yIHJzX2xpYjo6V2FzbVRleHRJdGVtPjo6ZGVzZXJpYWxpemU6Ol9fRmllbGRWaXNpdG9yIGFzIHNlcmRlOjpkZTo6VmlzaXRvcj46OnZpc2l0X2J5dGVzOjpoMzhhNDgyNGQ5N2FjYTViZroBQzx3YXNtX2JpbmRnZW46OkpzVmFsdWUgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJkMzljMDU4MTc5N2I4ODa7AVU8anNfc3lzOjpJbnRvSXRlciBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmgxMTZiZDM5ZTkzZTRlZjZlvAFpc2VyZGU6OmRlOjppbXBsczo6PGltcGwgc2VyZGU6OmRlOjpEZXNlcmlhbGl6ZSBmb3IgYWxsb2M6OnN0cmluZzo6U3RyaW5nPjo6ZGVzZXJpYWxpemU6OmgxZDYxNzY5YjUyNWVjZGM1vQEwY29yZTo6b3BzOjpmdW5jdGlvbjo6Rm46OmNhbGw6OmhlMzAwZDdmMjQxZDY3Yjk2vgFjPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+OjpnZXQ6Omg1M2UzZDk4YzUzMTk3Yjk2vwElYWxsb2M6OmZtdDo6Zm9ybWF0OjpoNDIxNjgxNmM1YTExNWM1M8ABQXNlcmRlX3dhc21fYmluZGdlbjo6ZGU6OkRlc2VyaWFsaXplcjo6YXNfYnl0ZXM6OmgxMDQ1OTY5NDlmZmQwODg5wQEoYWxsb2M6OmZtdDo6Zm9ybWF0OjpoNDIxNjgxNmM1YTExNWM1My42NsIBZ2FueWhvdzo6Y2hhaW46OjxpbXBsIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yIGZvciBhbnlob3c6OkNoYWluPjo6bmV4dDo6aGMzZGI5NDJlNzU1MTE1ZTDDAVZjb3JlOjpzdHI6OnRyYWl0czo6PGltcGwgY29yZTo6b3BzOjppbmRleDo6SW5kZXg8ST4gZm9yIHN0cj46OmluZGV4OjpoYmI4MzhkYjljNGRhMjBjZcQBMG1vbmNoOjpQYXJzZUVycm9yRmFpbHVyZTo6bmV3OjpoYWU0YTNjNmRjZWM0NDdjNsUBczxjb3JlOjppdGVyOjphZGFwdGVyczo6ZmxhdHRlbjo6RmxhdHRlbjxJPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OnNpemVfaGludDo6aGQ0OWRhY2UwNjlkYThiMjHGAURoYXNoYnJvd246OnJhdzo6VGFibGVMYXlvdXQ6OmNhbGN1bGF0ZV9sYXlvdXRfZm9yOjpoZWE5NDU5MzE4NDA4OWI5YccBMmNvcmU6OmZtdDo6QXJndW1lbnRzOjpuZXdfdjE6OmhkNTVkZWY0NjRmOGQyMWU3Ljc5yAEzY29yZTo6Zm10OjpBcmd1bWVudHM6Om5ld192MTo6aGQ1NWRlZjQ2NGY4ZDIxZTcuMzI0yQFhPGNvcmU6OnN0cjo6aXRlcjo6Q2hhckluZGljZXMgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoZjMzZmZkZmI1YzFkOWEzN8oBSjxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg4MjMxOGQ5OGFmOGE1NzIxywFFaGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlSW5uZXI8QT46OmZpbmRfaW5zZXJ0X3Nsb3Q6OmhiMTNlNjA5Yjk4ODg5Y2IyzAEzc3RkOjpzeW5jOjptdXRleDo6TXV0ZXg8VD46OmxvY2s6OmhlOTk4Mzg0Y2VmNzEwMTg5zQExYWxsb2M6OnN0cmluZzo6U3RyaW5nOjpwdXNoOjpoYTY1YzIyOTQxNWFmZjEyNC42NM4BMXNlcmRlOjpkZTo6RXJyb3I6OmludmFsaWRfdHlwZTo6aDQyN2E3ZTE4NjljZWQ3MmXPATJzZXJkZTo6ZGU6OkVycm9yOjppbnZhbGlkX3ZhbHVlOjpoZjllZTlmOTI1MGJjMGE2Y9ABKm1vbmNoOjp0YWc6Ont7Y2xvc3VyZX19OjpoZDg4YTBjNDY5Y2JlMjExY9EBLWFsbG9jOjp2ZWM6OlZlYzxULEE+OjpwdXNoOjpoZDdlNDQwYzQ1MDQ5ODhlONIBPmFsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZW1vdmU6OmFzc2VydF9mYWlsZWQ6Omg0MjVhZDczNDlkODgxZjMz0wEsdnRlOjpwYXJhbXM6OlBhcmFtczo6cHVzaDo6aDdiMjgyMTlkZTdiM2E5MGLUAUNjb3JlOjp1bmljb2RlOjp1bmljb2RlX2RhdGE6OndoaXRlX3NwYWNlOjpsb29rdXA6OmgzODZjZTAxMjE3NDllYzg01QE4ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX29wX3N0cjo6aDU1NDdmNzI1NjNhYzQ0M2PWAS5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6Omg4YjNkYjBmMTExNzFiNTdi1wE5YWxsb2M6OnZlYzo6VmVjPFQsQT46OmludG9fYm94ZWRfc2xpY2U6OmgyZmJhNmExOTczNzZmZmY42AEwbW9uY2g6OlBhcnNlRXJyb3JGYWlsdXJlOjpuZXc6Omg1MjFjM2E5ODNlMGM1ZDM52QF8PGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGFsbG9jOjp2ZWM6OnNwZWNfZXh0ZW5kOjpTcGVjRXh0ZW5kPCZULGNvcmU6OnNsaWNlOjppdGVyOjpJdGVyPFQ+Pj46OnNwZWNfZXh0ZW5kOjpoYmYzOTM1NGZlMzQzMWRkMtoBfDxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBhbGxvYzo6dmVjOjpzcGVjX2V4dGVuZDo6U3BlY0V4dGVuZDwmVCxjb3JlOjpzbGljZTo6aXRlcjo6SXRlcjxUPj4+OjpzcGVjX2V4dGVuZDo6aGVkODdkYzU0NmJiOTA0OTXbATFjb25zb2xlX3N0YXRpY190ZXh0OjpMaW5lOjpuZXc6OmhiYWMxNTIwNmYyZWEyODRl3AFbPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6Y29sbGVjdDo6RXh0ZW5kPFQ+Pjo6ZXh0ZW5kOjpoYzU3OTUwZmFiYjNhYjA4MN0BSjxjb3JlOjpvcHM6OnJhbmdlOjpSYW5nZTxJZHg+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhjMTc2ZjkyMzliMzVhMzJm3gEmbW9uY2g6OmlzX2JhY2t0cmFjZTo6aGViMGNhMDA4NjdkY2I3NmLfAUs8YWxsb2M6OmFsbG9jOjpHbG9iYWwgYXMgY29yZTo6YWxsb2M6OkFsbG9jYXRvcj46OnNocmluazo6aGFhYTM4YjFjZGQ5N2ZjZGTgAS1qc19zeXM6OlVpbnQ4QXJyYXk6OnRvX3ZlYzo6aDU4MTRmZWFkZDFkMjc5YWbhAWs8c2VyZGU6Ol9fcHJpdmF0ZTo6c2VyOjpUYWdnZWRTZXJpYWxpemVyPFM+IGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZXI+OjpzZXJpYWxpemVfc3RydWN0OjpoYmU2NGJkMjg1ODQyYmJjNuIBOmFsbG9jOjp2ZWM6OlZlYzxULEE+OjpleHRlbmRfZnJvbV9zbGljZTo6aDg4ZjE2MDEwMjQzNmFjMTXjAXxjb3JlOjpzdHI6OnRyYWl0czo6PGltcGwgY29yZTo6c2xpY2U6OmluZGV4OjpTbGljZUluZGV4PHN0cj4gZm9yIGNvcmU6Om9wczo6cmFuZ2U6OlJhbmdlRnJvbTx1c2l6ZT4+OjpnZXQ6OmhiNTVjNDZhODlkOTI2NDEx5AGCAWRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpfOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpTZXF1ZW50aWFsTGlzdD46OnNlcmlhbGl6ZTo6aGIzY2VjOWMwM2I1NmQ3ZGLlATRzZXJkZTo6ZGU6OkVycm9yOjpkdXBsaWNhdGVfZmllbGQ6Omg4Y2JiYWZmZjUwZDM0OTFh5gEyc2VyZGU6OmRlOjpFcnJvcjo6bWlzc2luZ19maWVsZDo6aGE4MzJiNmJkNTE0YzI2M2bnAVNjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGU6Ol9fcHJpdmF0ZTo6ZGU6OmNvbnRlbnQ6OkNvbnRlbnQ+OjpoOTQ0MjkxYjY2YjUyNjA1ZegBNGNvcmU6OnJlc3VsdDo6UmVzdWx0PFQsRT46OnVud3JhcDo6aDQxZDc3OTViMTU1OTgzZDLpATthbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OmFsbG9jYXRlX2luOjpoMDk3Njg2YzQ4OGE0ZDE0MOoBNmNvcmU6OnBhbmlja2luZzo6cGFuaWNfYm91bmRzX2NoZWNrOjpoOTI0NWQ0YTgyNWNjNTEwN+sBTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRjaF9mYWlsOjpoMjYzOGZjYjVhZWJkZTRlNewBQWNvbnNvbGVfc3RhdGljX3RleHQ6OmFuc2k6OlBlcmZvcm1lcjo6ZmluYWxpemU6Omg4OTZlOWNkZWUzODJlOWE07QE/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6Omg4OGZhYjU5ZjM1OWMzYjgz7gE9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoMTM0YWI2MWM5ODBhZjYzNu8BQTxzdHIgYXMgdW5pY29kZV93aWR0aDo6VW5pY29kZVdpZHRoU3RyPjo6d2lkdGg6OmgzZDMzNzczMjI2ZmFlZmZj8AFBY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aGY3ZmMyMDI1MzY5MDQxMmTxAYIBPDxhbGxvYzo6dmVjOjpkcmFpbjo6RHJhaW48VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpEcm9wR3VhcmQ8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoMTdmZWQwZGFkMjJhMmNiNfIBW2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8Y29uc29sZV9zdGF0aWNfdGV4dDo6VGV4dEl0ZW0+Pjo6aDliYzA3Y2U3NTcwYTk3ZTPzATNjb25zb2xlX3N0YXRpY190ZXh0Ojp2dHNfbW92ZV91cDo6aGVmNGM1YWNlZjFiM2YxZjP0ATA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGUwMTBjOWNlMDU4MGNkMjH1AVE8b25jZV9jZWxsOjpzeW5jOjpMYXp5PFQsRj4gYXMgY29yZTo6b3BzOjpkZXJlZjo6RGVyZWY+OjpkZXJlZjo6aDFkMWJlMmU1ZDc5MTVkOTX2ATRjb3JlOjpzbGljZTo6bWVtY2hyOjptZW1jaHJfbmFpdmU6Omg1MmNkMWQ0OWNiNzQ2Yzll9wFuPHNlcmRlX3dhc21fYmluZGdlbjo6c2VyOjpPYmplY3RTZXJpYWxpemVyIGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZVN0cnVjdD46OnNlcmlhbGl6ZV9maWVsZDo6aGU0NThhNGQ5Mzg3NWI0NDH4AUJjb25zb2xlX3N0YXRpY190ZXh0OjphbnNpOjpQZXJmb3JtZXI6Om1hcmtfY2hhcjo6aDgyNjM0Y2E5NmYwMWFmZGT5AVA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMzkxYjM4MzYzMzcxMTdjNvoBM2FsbG9jOjpzeW5jOjpBcmM8VCxBPjo6ZHJvcF9zbG93OjpoZTQzZmNiM2M4ZTk4OTFhOPsBM2FsbG9jOjpzeW5jOjpBcmM8VCxBPjo6ZHJvcF9zbG93OjpoNWQ2MzU4ZTE4MzlkNzUxY/wBjgF3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmltcGxzOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OnRyYWl0czo6UmV0dXJuV2FzbUFiaSBmb3IgY29yZTo6cmVzdWx0OjpSZXN1bHQ8VCxFPj46OnJldHVybl9hYmk6Omg5Nzg0OTkwMzNlZWQxMGI5/QEtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg2ZTA5Mzc5MThmNjBkODlm/gEtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg1OGE3ZThhYTI2YjM1Nzk0/wEtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6OmgxOTdkMTBmYjEyODZlZTAxgAJWY29yZTo6c3RyOjp0cmFpdHM6OjxpbXBsIGNvcmU6Om9wczo6aW5kZXg6OkluZGV4PEk+IGZvciBzdHI+OjppbmRleDo6aGU1Y2VmYTc5YzNmMWNmOGGBAi1hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cHVzaDo6aDNmMGQ2NDg1ZGNjYzE4NDKCAi1hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cHVzaDo6aDM5ODA3NzEwNWE0YmY0NTaDAjthbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OmFsbG9jYXRlX2luOjpoNTY1ZTY2OWUzNDFiNWQ0YoQCiAF3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmltcGxzOjo8aW1wbCB3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OnRyYWl0czo6SW50b1dhc21BYmkgZm9yIGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+Pjo6aW50b19hYmk6OmhlZTI1ZTU2MWNhMWVjYjNihQJWY29yZTo6c3RyOjp0cmFpdHM6OjxpbXBsIGNvcmU6Om9wczo6aW5kZXg6OkluZGV4PEk+IGZvciBzdHI+OjppbmRleDo6aGIxYThjOTBjY2VmMTBkYTGGAjFjb21waWxlcl9idWlsdGluczo6bWVtOjptZW1jbXA6OmgxNDc2OWRiY2RkNTRlODc1hwI5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6Omg1OTI2NGI2ZjEzOTFhMDA3iAIwc2VyZGU6OmRlOjpWaXNpdG9yOjp2aXNpdF9zdHI6Omg4MjQwM2Y3OGNlNGQyMmY4iQIyc2VyZGU6OmRlOjpWaXNpdG9yOjp2aXNpdF9ieXRlczo6aDQyNDIzMTVjNWRkOWY5YWKKAi5jb3JlOjpvcHRpb246OmV4cGVjdF9mYWlsZWQ6OmhlYTIyY2YxMzVhZDY0ZTk4iwJWY29yZTo6c3RyOjp0cmFpdHM6OjxpbXBsIGNvcmU6Om9wczo6aW5kZXg6OkluZGV4PEk+IGZvciBzdHI+OjppbmRleDo6aDVkMzhhNTgyYmQ2ZWUzZDGMAkhoYXNoYnJvd246OnJhdzo6UmF3VGFibGVJbm5lcjxBPjo6cHJlcGFyZV9pbnNlcnRfc2xvdDo6aDg4OGM3MDJmNjNkNjU2NjONAlJjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPHJzX2xpYjo6V2FzbVRleHRJdGVtPj46OmgwMTk4OThhZTU3NjdhOGEwjgJoPGNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpmdXNlOjpGdXNlPEk+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6bmV4dDo6aDYyNzI5MWRjYTg3MmZhZjePAocBd2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpzbGljZXM6OjxpbXBsIHdhc21fYmluZGdlbjo6Y29udmVydDo6dHJhaXRzOjpJbnRvV2FzbUFiaSBmb3IgYWxsb2M6OnN0cmluZzo6U3RyaW5nPjo6aW50b19hYmk6OmgzOGJkMGQyYjM1MTYzYjE3kAJkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjp2ZWM6OlZlYzxzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudD4+OjpoMzVkODc2ZTU0ZDA5ZTkwYZECjQFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPChzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCxzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCk+Pjo6aDBjMWM2Y2I1NzBjOTY0OTmSAixjb3JlOjplcnJvcjo6RXJyb3I6OmNhdXNlOjpoZmNiMzIyZTcyYTI0ZDc0Y5MCTjxhbnlob3c6OmVycm9yOjpFcnJvckltcGw8RT4gYXMgY29yZTo6ZXJyb3I6OkVycm9yPjo6c291cmNlOjpoZmUyZWM4NmJlMDJjODQ2ZpQCXWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OkVudlZhcj4+OjpoN2RmNDAyZTJiMmVkYTUyY5UCW2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmQ+Pjo6aGRlNGZiYThhMWE1YTFhZTGWAl9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpSZWRpcmVjdD4+OjpoNDg2NzAwZmE0N2RhZmIyOJcCLGNvcmU6OmVycm9yOjpFcnJvcjo6Y2F1c2U6OmhjOTBkYzliN2FlMWVmYzRmmAJOPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxFPiBhcyBjb3JlOjplcnJvcjo6RXJyb3I+Ojpzb3VyY2U6OmhjZmJhMWU2ZjczMDFhZjllmQI8ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6aW5pdF90b3A6Omg1Y2NlNjI5NmExODMyYmFhmgJTY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvbnNvbGVfc3RhdGljX3RleHQ6OkNvbnNvbGVTdGF0aWNUZXh0Pjo6aDc0MDgzMTI5YWZmOWE0ODmbAlY8anNfc3lzOjpBcnJheUl0ZXIgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoNzAyMzRiZjZkNDIwYTU1NJwCOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDdiMTNjZDc5YTk2YjRmNTSdAlU8c2VyZGU6OmRlOjppbXBsczo6U3RyaW5nVmlzaXRvciBhcyBzZXJkZTo6ZGU6OlZpc2l0b3I+Ojp2aXNpdF9zdHI6OmhjOWQyYjBiMTY3M2JhZDQxngJOY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD46Omg2YzZhZDczNmU5NWZlZGU2nwJOY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpTZXF1ZW5jZT46OmhjZTA1NzVlZTk4M2U5NDAyoAI7YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjphbGxvY2F0ZV9pbjo6aGFmZTA0NDAxNTM2MjJhZWGhAkJjb3JlOjpjaGFyOjptZXRob2RzOjo8aW1wbCBjaGFyPjo6aXNfd2hpdGVzcGFjZTo6aDBhZTczZDkzYWRjOWZiYTOiAjBhbGxvYzo6dmVjOjpWZWM8VCxBPjo6cmVzZXJ2ZTo6aGM0ZWQyYzkwM2RiOTNlNzOjAiljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoMGYwYzA1YjIwZGE5M2RkN6QCMGFsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZXNlcnZlOjpoYTBiZjgxZTc3NzUxMGIyOKUCaTxoYXNoYnJvd246OnJhdzo6Yml0bWFzazo6Qml0TWFza0l0ZXIgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+OjpuZXh0OjpoMDA0MmMzMGJiZjQwZjQwYqYCMHNlcmRlOjpkZTo6VmlzaXRvcjo6dmlzaXRfdTY0OjpoZDNlOTc5NTk5YzE0NzAzNqcCMHNlcmRlOjpkZTo6VmlzaXRvcjo6dmlzaXRfaTY0OjpoOTBlYzVmN2Y3ZjYyMDQ2N6gCMHNlcmRlOjpkZTo6VmlzaXRvcjo6dmlzaXRfZjY0OjpoYmJhOGQyMzI4MjlmOTJjMKkCYTxjb3JlOjpvcHM6OnJhbmdlOjpSYW5nZTx1c2l6ZT4gYXMgY29yZTo6c2xpY2U6OmluZGV4OjpTbGljZUluZGV4PFtUXT4+OjppbmRleDo6aDU3NWNmNDg5ZGRhODRkOGaqAhFydXN0X2JlZ2luX3Vud2luZKsCiAF3YXNtX2JpbmRnZW46OmNvbnZlcnQ6OnNsaWNlczo6PGltcGwgd2FzbV9iaW5kZ2VuOjpjb252ZXJ0Ojp0cmFpdHM6OkZyb21XYXNtQWJpIGZvciBhbGxvYzo6Ym94ZWQ6OkJveDxbVF0+Pjo6ZnJvbV9hYmk6OmgxMzg2OGVmYmVkMzQ3MDM5rAJePHNlcmRlOjpkZTo6dmFsdWU6OlNlcURlc2VyaWFsaXplcjxJLEU+IGFzIHNlcmRlOjpkZTo6U2VxQWNjZXNzPjo6c2l6ZV9oaW50OjpoNWQ5NjE4MWFjZjY1ZmFhNq0ClAE8cnNfbGliOjpfOjo8aW1wbCBzZXJkZTo6ZGU6OkRlc2VyaWFsaXplIGZvciByc19saWI6Oldhc21UZXh0SXRlbT46OmRlc2VyaWFsaXplOjpfX0ZpZWxkVmlzaXRvciBhcyBzZXJkZTo6ZGU6OlZpc2l0b3I+Ojp2aXNpdF9zdHI6OmhkOWNjMmQzMzU2Mzk1Y2JkrgI4Y29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OnNwbGl0X2F0X211dDo6aDg3NTJlNmQ2MDc4N2E0MjCvAlE8Y29uc29sZV9zdGF0aWNfdGV4dDo6Q29uc29sZVNpemUgYXMgY29yZTo6Y21wOjpQYXJ0aWFsRXE+OjplcTo6aDNiMzMyMjRjNmFkYjNkZDOwAnJjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8W2Rlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpwYXJzZV93b3JkX3BhcnRzOjp7e2Nsb3N1cmV9fTo6UGVuZGluZ1BhcnRdPjo6aDE5N2M1ZjJiZTdiNGIzYWOxAkRoYXNoYnJvd246OnJhdzo6UmF3VGFibGVJbm5lcjxBPjo6YWxsb2NhdGlvbl9pbmZvOjpoOWNiMWIxY2IzYjM5NTJkOLICqAFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6aXRlcjo6YWRhcHRlcnM6OmZsYXR0ZW46OkZsYXR0ZW48YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0Pj4+Pjo6aGQwZWY4ODAzNDgxOTJjZDCzAhFfX3diaW5kZ2VuX21hbGxvY7QCQ2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OndyaXRlX3ByZWZpeDo6aDhiNDQ3ZDFkNzIzOTVhZDO1AjBjb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbjo6Y2FsbDo6aDhlMzIxNGE3NTYzZGZjNGW2AktkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpyZWxlYXNlX3VudXNlZF9zZWdtZW50czo6aDcwYWJlNmJmMThjMzZiZGG3Ams8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoNTcyNjFmMzcyZTk4Yzg2NLgCOHNlcmRlX3dhc21fYmluZGdlbjo6ZXJyb3I6OkVycm9yOjpuZXc6OmgzYjM4OTFmZTM2M2U4NzQzuQJAYW55aG93OjplcnJvcjo6PGltcGwgYW55aG93OjpFcnJvcj46OmZyb21fc3RkOjpoYTI4MmE0OGIxNmQxYzZmM7oCNGNvcmU6OnJlc3VsdDo6UmVzdWx0PFQsRT46OnVud3JhcDo6aDA0ZTY4NWU4YmZkYWU3NWK7Aks8YW55aG93OjplcnJvcjo6RXJyb3JJbXBsPEU+IGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDgyMjk5ZTAyZmZhM2VmMzK8AlE8YWxsb2M6OnZlYzo6ZHJhaW46OkRyYWluPFQsQT4gYXMgY29yZTo6b3BzOjpkcm9wOjpEcm9wPjo6ZHJvcDo6aDMyNTgzNDM4ZTVmYTA2N2K9Aktjb3JlOjpmbXQ6OmZsb2F0Ojo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIGY2ND46OmZtdDo6aGI3OGJiMThmZGUwNjE5NWG+Aks8YW55aG93OjplcnJvcjo6RXJyb3JJbXBsPEU+IGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGJmMWEyYzIxYjY3ZDJlODC/AkFoYXNoYnJvd246OnJhdzo6RmFsbGliaWxpdHk6OmNhcGFjaXR5X292ZXJmbG93OjpoMTE0ODBmNGE2YjdkYWQxNcACLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm10OjpoM2UxZGQzZDA4Mjg4NTY5ZcECeGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpfOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkPjo6c2VyaWFsaXplOjpoOTZhNzc2MmI5MjhlN2RiN8ICNGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDk1NmViZTZiZjA0YjljNzPDAjJ3YXNtX2JpbmRnZW46OmJpZ2ludF9nZXRfYXNfaTY0OjpoOTdhNzkzNjcyYTg3N2FmMsQCRGNvbnNvbGVfc3RhdGljX3RleHQ6OmFuc2k6OlBlcmZvcm1lcjo6bWFya19lc2NhcGU6Omg2OWYxYjY3N2EyNTdiYzBjxQI4c3RkOjp0aHJlYWQ6OlRocmVhZElkOjpuZXc6OmV4aGF1c3RlZDo6aDQyODYyODIzNWRhNDQ4MmTGAm48c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoODlkYTI0ODM4MzAyNGNkMMcCWzxjb3JlOjpzdHI6Oml0ZXI6OkNoYXJzIGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6bmV4dDo6aDYzZWE3N2U5MDlhYTgxNTjIAjFjb3JlOjpwYW5pY2tpbmc6OmFzc2VydF9mYWlsZWQ6Omg3OGU2NDhkYTU5YTE1YzdkyQJPPHN0ZDo6c3luYzo6cG9pc29uOjpQb2lzb25FcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZTRkZTZhZDQ0MWE3NjFlY8oCSDxjb3JlOjpvcHRpb246Ok9wdGlvbjxUPiBhcyBjb3JlOjpjbXA6OlBhcnRpYWxFcT46OmVxOjpoYWJmMzcyZDFmYTM0MjdlMcsCMWNvcmU6OnBhbmlja2luZzo6YXNzZXJ0X2ZhaWxlZDo6aDhiN2E3MzE1N2ZhYjg5NjXMAsoFY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPG1vbmNoOjpvcjxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UmVkaXJlY3RPcCxtb25jaDo6bWFwPCZzdHIsZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlJlZGlyZWN0T3AsbW9uY2g6OnRhZzwmc3RyPjo6e3tjbG9zdXJlfX0sZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3JlZGlyZWN0Ojp7e2Nsb3N1cmV9fT46Ont7Y2xvc3VyZX19LG1vbmNoOjpvcjxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UmVkaXJlY3RPcCxtb25jaDo6bWFwPCZzdHIsZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlJlZGlyZWN0T3AsbW9uY2g6Om9yPCZzdHIsbW9uY2g6OnRhZzwmc3RyPjo6e3tjbG9zdXJlfX0sbW9uY2g6OnRhZzwmc3RyPjo6e3tjbG9zdXJlfX0+Ojp7e2Nsb3N1cmV9fSxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6cGFyc2VfcmVkaXJlY3Q6Ont7Y2xvc3VyZX19Pjo6e3tjbG9zdXJlfX0sbW9uY2g6Om1hcDxjaGFyLGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpSZWRpcmVjdE9wLG1vbmNoOjppZl90cnVlPGNoYXIsbW9uY2g6Om5leHRfY2hhcixtb25jaDo6Y2g6Ont7Y2xvc3VyZX19Pjo6e3tjbG9zdXJlfX0sZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OnBhcnNlX3JlZGlyZWN0Ojp7e2Nsb3N1cmV9fT46Ont7Y2xvc3VyZX19Pjo6e3tjbG9zdXJlfX0+Ojp7e2Nsb3N1cmV9fT46Omg2MzQyNDdhODU0ZTRjMjMwzQIxY29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkOjpoYmI2YzgwY2RjNTA2NTBhN84CTjxzZXJkZV93YXNtX2JpbmRnZW46OmVycm9yOjpFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNDdkZDI5ODQ0YzA5YmVkY88CSDxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoNmQzOWFiYTE2YmJiZTlhOdACM2FsbG9jOjpzeW5jOjpBcmM8VCxBPjo6ZHJvcF9zbG93OjpoZjIyMTZjNGMwZjA3MTBhZdECRXNlcmRlX3dhc21fYmluZGdlbjo6ZGU6OkRlc2VyaWFsaXplcjo6aW52YWxpZF90eXBlOjpoNjEzY2RlN2Y1NDFmZWYzMtICEl9fd2JpbmRnZW5fcmVhbGxvY9MCQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDNiYmJhMWE2N2VmZTE0ZGPUAjo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6OmhlNDgxNjMxM2YyNGNlM2Qy1QJIY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPFtjb25zb2xlX3N0YXRpY190ZXh0OjpMaW5lXT46Omg2ZDQ0ZTM0NjYxMjcyNDc11gJAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoNWUzYjAzMzJiNGEwNmY4ZtcCMHZ0ZTo6UGFyc2VyPF8+OjppbnRlcm1lZGlhdGVzOjpoZTFiMjQ5MDk1OGVkNDA0MtgCOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aDUwZWIyZGEyMTE1Yjg3OTTZAkBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmhkMzQ1YTk0YmY3NWNjOTll2gI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoOGMwMWEyZTFjNDc0MDUzMNsCLmNvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2ZtdDo6aDRiNWZhYjExNmEwODM5OGbcAi5jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9mbXQ6OmhlM2MyZGI3ODA0N2IwMGEy3QIuY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfZm10OjpoODU1NjcxM2E4ZDMzZTk3M94CZ3NlcmRlOjpzZXI6OmltcGxzOjo8aW1wbCBzZXJkZTo6c2VyOjpTZXJpYWxpemUgZm9yIGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OnNlcmlhbGl6ZTo6aDYxMTFhY2JkZjI1YzFlNzDfAlNjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlBpcGVsaW5lSW5uZXI+OjpoZDk1NDE0YjZkNzc4NGQ3ZOACUmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6Q29tbWFuZElubmVyPjo6aGE3NWJiMzc3YzViNGQ4MTHhAjp3YXNtX2JpbmRnZW46Ol9fcnQ6OnRha2VfbGFzdF9leGNlcHRpb246OmhmZWNjM2U0ZTE2MjQyYTgw4gI2YWxsb2M6OmFsbG9jOjpHbG9iYWw6OmFsbG9jX2ltcGw6OmhmZjJmNWE4ODkzODYyMjRkLjE54wJKY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPG1vbmNoOjpQYXJzZUVycm9yRmFpbHVyZUVycm9yPjo6aGI0YzY3MmUyNDExMzhhNjbkAjdzZXJkZV93YXNtX2JpbmRnZW46OmRlOjpjb252ZXJ0X3BhaXI6Omg4NWU1OTcxMDFkOTU3YzE25QI/cnNfbGliOjpzdGF0aWNfdGV4dF9yZW5kZXJfb25jZTo6e3tjbG9zdXJlfX06Omg3NzM2YjAxZDVhMDUyZjU45gJIY29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2V7e3Z0YWJsZS5zaGltfX06OmgxMjM5NGFhMzg4NTU2NGZl5wJGY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFueWhvdzo6Y2hhaW46OkNoYWluU3RhdGU+OjpoYzZjZDEzNTBmMTUyYzMyNOgCYWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxbYWxsb2M6OnZlYzo6VmVjPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD5dPjo6aDM2NDg2OGU1ZDgwN2IxYWbpAlBjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8W2Rlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydF0+OjpoM2IwYTkxODdiMTU0Y2E0N+oCQGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdGQ6OnRocmVhZDo6VGhyZWFkPjo6aDcxYTRlOTU2NTdhYWVhNzbrAlg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg4Nzk4YTYxZTQ0M2JkOGMz7AI7Y29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6aDY3ODc5ZWRkMTA5NDk0YzftAk5jb3JlOjpmbXQ6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIGk2ND46OmZtdDo6aGE5ZTQzZGI0YjQ5NjdlYzPuAlg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmhhNGIxMWY3MDA2OGMwYjRh7wKCAWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpyZXN1bHQ6OlJlc3VsdDwoJnN0cixkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UGlwZWxpbmVJbm5lciksbW9uY2g6OlBhcnNlRXJyb3I+Pjo6aGEwYWVjZGQ1ZjEwYWM3NDXwAn1jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6cmVzdWx0OjpSZXN1bHQ8KCZzdHIsZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OlNlcXVlbmNlKSxtb25jaDo6UGFyc2VFcnJvcj4+OjpoNWRiOGJlMmZiNTU2ZjBhOfECP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoY2I1ODg5Zjc3Y2FmNWRkZfICcWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdGQ6OnN5bmM6Om11dGV4OjpNdXRleEd1YXJkPGNvbnNvbGVfc3RhdGljX3RleHQ6OkNvbnNvbGVTdGF0aWNUZXh0Pj46OmhhMjc5MTE2ODYxNzcyZTk38wIsc3RkOjpwYW5pY2tpbmc6OnBhbmlja2luZzo6aDBjMjNlY2Y4NDk0OTJlZGP0AkY8W0FdIGFzIGNvcmU6OnNsaWNlOjpjbXA6OlNsaWNlUGFydGlhbEVxPEI+Pjo6ZXF1YWw6OmgwYzhkOTI4MTExYjhlNjNl9QI1Y29yZTo6c3RyOjo8aW1wbCBzdHI+OjpzdGFydHNfd2l0aDo6aGNmYWQ4N2Q4YWY0NjRjYjH2Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDEwNWUxYjUzMjAyZDRkOTL3Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDE1Mzc0ZTQxZjk5MjJkOGX4Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDE4YTg3M2I4ZjBmZmE3ODb5Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDFiNjM2ZDhlNTY5ZDdkYTj6Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDI0ZGE3ZWEzN2Y3ZTkxM2T7Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDNhMzM0NjhhZTk1MjE0Yzn8Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGI0YzlkNzc1ZTlkY2RhZTf9Aj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGY1M2Q3YzcyOTBkOGQ2ZjT+Al5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlBhbmljUGF5bG9hZD46OmgzMDlhYTViMTlmYzJmODcz/wIxYWxsb2M6OnJhd192ZWM6OmhhbmRsZV9yZXNlcnZlOjpoNWUyMGI1MGMxMGM4YTJlOYADMWFueWhvdzo6ZXJyb3I6Om9iamVjdF9kb3duY2FzdDo6aDIwZTYzNGRhMTRmYzk0Y2OBAzQ8Ym9vbCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyOTY2YWYyODdhZjBlY2Q5ggOOAWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpyZXN1bHQ6OlJlc3VsdDwoJnN0cixhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0PiksbW9uY2g6OlBhcnNlRXJyb3I+Pjo6aGI1MzJhYzgzZDcyOGViNTGDAzFhbnlob3c6OmVycm9yOjpvYmplY3RfZG93bmNhc3Q6OmhiM2NmYTI4MzViN2M2MTkwhAM/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMl9tdXQ6OmgzNDVmM2EzZTM1MzBmMzdjhQMzYWxsb2M6OmFsbG9jOjpHbG9iYWw6OmFsbG9jX2ltcGw6OmhmZjJmNWE4ODkzODYyMjRkhgN4Y29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6OnJlc3VsdDo6UmVzdWx0PHJzX2xpYjo6V2FzbVRleHRJdGVtLHNlcmRlX3dhc21fYmluZGdlbjo6ZXJyb3I6OkVycm9yPj46Omg1YjMyY2NhNDhmNTg4MjM5hwNNY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpDb21tYW5kPjo6aDEzODJjYjMzZDBlOTFjNTKIAz5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8bW9uY2g6OlBhcnNlRXJyb3I+OjpoMDZlMjFiZmM1NTE5M2Q1YokDP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTFfbXV0OjpoMzk1Yzg5ZTIwMjUyNmIyZooDN2FsbG9jOjphbGxvYzo6R2xvYmFsOjphbGxvY19pbXBsOjpoZmYyZjVhODg5Mzg2MjI0ZC4zMTSLAwxfX3J1c3RfYWxsb2OMA248c2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6Ok9iamVjdFNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplU3RydWN0Pjo6c2VyaWFsaXplX2ZpZWxkOjpoOTQ5NjExNTcxZTEzYzM5MY0DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoZGZhNTkwZGRiZjY3NTRhOI4DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoYTIzOWZmZTM1ZmI3YjE4OI8DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoYzFhNTNjMWUyZjFhZmRlNJADMGFsbG9jOjphbGxvYzo6ZXhjaGFuZ2VfbWFsbG9jOjpoMGVkZDRjOTFlMWU1NmQ4OZEDbjxzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6T2JqZWN0U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVTdHJ1Y3Q+OjpzZXJpYWxpemVfZmllbGQ6OmgxY2YyZmFkZDFkZGQ1ZWNlkgNuPHNlcmRlX3dhc21fYmluZGdlbjo6c2VyOjpPYmplY3RTZXJpYWxpemVyIGFzIHNlcmRlOjpzZXI6OlNlcmlhbGl6ZVN0cnVjdD46OnNlcmlhbGl6ZV9maWVsZDo6aGQ1Y2E1ZWQzNDQ2MjUwZjiTAzI8VCBhcyBzZXJkZTo6ZGU6OkV4cGVjdGVkPjo6Zm10OjpoMzMyYWU1OWFlNTY5NDU1OJQDMjxUIGFzIHNlcmRlOjpkZTo6RXhwZWN0ZWQ+OjpmbXQ6Omg5YmU3ZWEwNjhhYTBlZjc1lQMyPFQgYXMgc2VyZGU6OmRlOjpFeHBlY3RlZD46OmZtdDo6aGM3MzYzMjFlODY4NGM0MmKWAzI8VCBhcyBzZXJkZTo6ZGU6OkV4cGVjdGVkPjo6Zm10OjpoNTVmZTc0ZDMxZmYwOTVkZpcDMjxUIGFzIHNlcmRlOjpkZTo6RXhwZWN0ZWQ+OjpmbXQ6OmgxZGQwYWY2MWI5NmY2ODUzmAMyPFQgYXMgc2VyZGU6OmRlOjpFeHBlY3RlZD46OmZtdDo6aGFiYTk1MGQ4MDhmN2Q5NmWZA1djb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnZlYzo6VmVjPGNvbnNvbGVfc3RhdGljX3RleHQ6OkxpbmU+Pjo6aDViNDhmODFiZjgwNTI5YzGaA0g8Y29yZTo6Y2VsbDo6Qm9ycm93TXV0RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDQ1YWU2ODgyZTkyNTk3NmGbAz48Y29yZTo6Zm10OjpFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWIyNWU4Y2I0MDliM2Y4YpwDX2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0Pj46Omg1YjA3YzQ0ODJlOWNiNTg5nQM3YWxsb2M6OmFsbG9jOjpHbG9iYWw6OmFsbG9jX2ltcGw6OmhmZjJmNWE4ODkzODYyMjRkLjIyOJ4DKm1vbmNoOjpQYXJzZUVycm9yOjpmYWlsOjpoNjcxNzY4NTdmNDE5NWY1ZJ8DcGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6dmVjOjpWZWM8YWxsb2M6OnZlYzo6VmVjPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD4+Pjo6aDZhMmNkZWIwNjRjZDNkYzegA0NzZXJkZV93YXNtX2JpbmRnZW46OmRlOjpEZXNlcmlhbGl6ZXI6OmlzX251bGxpc2g6OmhlZDlhZDA5NDQ1MjRiODJmoQNPPGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoNzM0ZjYwNGY2MzJkZWI4NaIDTzxhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT4gYXMgY29yZTo6b3BzOjpkcm9wOjpEcm9wPjo6ZHJvcDo6aDVmMTAyNWU3NzRjYWRlOGKjA048YW55aG93Ojp3cmFwcGVyOjpNZXNzYWdlRXJyb3I8TT4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGZjYTQzZWQ5YzNhZTNiOGakA088YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg2YmRiMmJjNWJmNmEzMWNmpQNMY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpFbnZWYXI+OjpoZDgyN2I5MzdhYjQ2NWFiYaYDTmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6UmVkaXJlY3Q+OjpoNzAzYjdhNWUzYjY4ZTRjMKcDNGFsbG9jOjphbGxvYzo6ZXhjaGFuZ2VfbWFsbG9jOjpoMGVkZDRjOTFlMWU1NmQ4OS4yMzCoA2Bjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6cmVzdWx0OjpSZXN1bHQ8KCZzdHIsY2hhciksbW9uY2g6OlBhcnNlRXJyb3I+Pjo6aDRhNDMwNDY0NDMyMzI0N2GpA0c8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhMGM4YWNkYTZiYWFmNDVmLjMxNqoDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMWNkODQzMDE0ZTQwNTY0OasDazwmc2VyZGVfd2FzbV9iaW5kZ2VuOjpzZXI6OlNlcmlhbGl6ZXIgYXMgc2VyZGU6OnNlcjo6U2VyaWFsaXplcj46OnNlcmlhbGl6ZV91bml0X3ZhcmlhbnQ6OmhlZjVhNjI4NzJhY2U5ZDE3rANiPCZzZXJkZV93YXNtX2JpbmRnZW46OnNlcjo6U2VyaWFsaXplciBhcyBzZXJkZTo6c2VyOjpTZXJpYWxpemVyPjo6c2VyaWFsaXplX3N0cjo6aDZkMTA2MWRlNmI4YTMzYzKtA1djb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248cnNfbGliOjpXYXNtVGV4dEl0ZW0+Pjo6aDQyZjg2NDhmMjMzZTVjZjWuA2ljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248c2VyZGU6Ol9fcHJpdmF0ZTo6ZGU6OmNvbnRlbnQ6OkNvbnRlbnQ+Pjo6aDY3ODYwZGQ1MWQ5Mzk5YjevA5IBY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPChzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCxzZXJkZTo6X19wcml2YXRlOjpkZTo6Y29udGVudDo6Q29udGVudCk+Pjo6aDc4Njg0ZjhkZTY5NWM1NjiwAyxhbnlob3c6OmVycm9yOjpvYmplY3RfcmVmOjpoNDlhNzVhOTYyNmQ3MzIyN7EDRDxjb3JlOjpmbXQ6OkFyZ3VtZW50cyBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyMDAyYTFlMDllZjk3ZDk4sgNkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGRlbm9fdGFza19zaGVsbDo6cGFyc2VyOjpXb3JkUGFydD4+OjpoZDU4OGJhMGZkZjRhM2RlZLMDLGFueWhvdzo6ZXJyb3I6Om9iamVjdF9yZWY6OmhhMTM0NzIzYmU0NDhmNDVjtANCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OmhmY2Y2YmVmMjg1MGFmOTE2tQMyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGZhMzQwMThmNWRhMjNjYTO2A0Jjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8d2FzbV9iaW5kZ2VuOjpKc1ZhbHVlPjo6aDZhNTNkYTRkY2YzNTJkYzS3A088YWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmgwN2ZkOWFmMDA3MGJjYjdjuANpY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjp2ZWM6OlZlYzxkZW5vX3Rhc2tfc2hlbGw6OnBhcnNlcjo6U2VxdWVudGlhbExpc3RJdGVtPj46OmgzODNkMGM5ZDQ1ZmE4OTMzuQNEY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpib3Jyb3c6OkNvdzxzdHI+Pjo6aGE4MGQxNjc2OTQ5NmRiZWO6A0Fjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8cnNfbGliOjpXYXNtVGV4dEl0ZW0+OjpoN2VkY2NkMTM3OTc1NzkzNbsDT2NvcmU6OmNtcDo6aW1wbHM6OjxpbXBsIGNvcmU6OmNtcDo6UGFydGlhbEVxPCZCPiBmb3IgJkE+OjplcTo6aDIzODM2Mzk0MWFkNzY1ODK8AzI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoMTE0MTkxMTdkOWQ0MTdmML0DLmNvcmU6OnN0cjo6c2xpY2VfZXJyb3JfZmFpbDo6aGExZTNlMDI5MzVjYzEwNGS+AzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDMxMDc5MzliZGVmMjI3MWO/A4UBY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGFsbG9jOjp2ZWM6OmludG9faXRlcjo6SW50b0l0ZXI8ZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OldvcmRQYXJ0Pj4+OjpoZjQ1NWJiMjc5MzQxZWJiMcADQ2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxvbmNlX2NlbGw6OmltcDo6V2FpdGVyPjo6aGM0Y2I4YjQ0M2JjMDZiODXBA088YWxsb2M6OmFsbG9jOjpHbG9iYWwgYXMgY29yZTo6YWxsb2M6OkFsbG9jYXRvcj46OmRlYWxsb2NhdGU6OmgxYzQzNjY5OGFjNzZjNjVjwgNDZGVub190YXNrX3NoZWxsOjpwYXJzZXI6OmZhaWxfZm9yX3RyYWlsaW5nX2lucHV0OjpoYTFmMTAyMzNlMmNlZjgwOMMDNndhc21fYmluZGdlbjo6Y2FzdDo6SnNDYXN0OjpkeW5fcmVmOjpoY2Q5ZTY4Njg1YTJhOTIzMsQDSGNvcmU6Om9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNle3t2dGFibGUuc2hpbX19OjpoZTM4YTc2NjViNDNjMGY0OMUDQHJzX2xpYjo6U1RBVElDX1RFWFQ6Ont7Y2xvc3VyZX19Ojp7e2Nsb3N1cmV9fTo6aDAwMGRlMjJlNzQ2MWVlYTDGA2djb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248c2VyZGVfd2FzbV9iaW5kZ2VuOjpkZTo6RGVzZXJpYWxpemVyPj46Omg2NWFmMzYwNjViMTQ0MmRmxwMyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDg4OTAxMzBjMmJmNjYwMDDIA2Zjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OmJveGVkOjpCb3g8c2VyZGU6Ol9fcHJpdmF0ZTo6ZGU6OmNvbnRlbnQ6OkNvbnRlbnQ+Pjo6aGM2NDY0OWI3MTE0MzU2MmXJA3xjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8KHNlcmRlOjpfX3ByaXZhdGU6OmRlOjpjb250ZW50OjpDb250ZW50LHNlcmRlOjpfX3ByaXZhdGU6OmRlOjpjb250ZW50OjpDb250ZW50KT46OmhjYjlmZTJlMjkwNWYxMzliygM6YWxsb2M6OnZlYzo6VmVjPFQsQT46OmV4dGVuZF9mcm9tX3NsaWNlOjpoOTcyZTc5NjMwNTg5YTQ1YssDMmNvcmU6OmVycm9yOjpFcnJvcjo6ZGVzY3JpcHRpb246Omg0NzZiZDJkNWUyMGY3NGZjzAMuY29yZTo6ZXJyb3I6OkVycm9yOjp0eXBlX2lkOjpoMTdkMWEwNTQ0ZjQzNGJjNs0DLmNvcmU6OmVycm9yOjpFcnJvcjo6dHlwZV9pZDo6aGE3YjQ2ODQ1MjViZjVlMDTOAy5hbnlob3c6OmVycm9yOjpvYmplY3RfYm94ZWQ6OmhlODI0ZDhlZTZkMTZiNzQ5zwM6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoYjg0YWJhNzg1ZjJjMGE4ZtADOmFsbG9jOjp2ZWM6OlZlYzxULEE+OjpleHRlbmRfZnJvbV9zbGljZTo6aGU4ODMxMzczZTRkZTYxNDTRAzs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoNWY2NDhiZmViZjc3OGRjYdIDMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhlOGE2MzVkYzc2OGFiMzZl0wNNPHZ0ZTo6VnRVdGY4UmVjZWl2ZXI8UD4gYXMgdXRmOHBhcnNlOjpSZWNlaXZlcj46OmNvZGVwb2ludDo6aDBjM2IyNmU4YmNkOGNjMWTUAzE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6OmgzNTA5OWNjMDRlMzMxMDlk1QMuY29yZTo6ZXJyb3I6OkVycm9yOjp0eXBlX2lkOjpoNDFlMjliNWE3YmQ3ZGE0OdYDLmNvcmU6OmVycm9yOjpFcnJvcjo6dHlwZV9pZDo6aGY3ODcwZTY0NmVhMzYwYzDXAy1hbnlob3c6OmVycm9yOjpvYmplY3RfZHJvcDo6aDI2N2IwM2RjNzc0Mjc3OTPYAy5hbnlob3c6OmVycm9yOjpvYmplY3RfYm94ZWQ6Omg0ODQ5ZDJjNTNiOWMyYmQ22QNFPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg2ZjNkMzQwYTViZWE3NmUx2gMxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYWU0MTkzNzUwYTE2NzE1NdsDZjxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6U3RyUGFuaWNQYXlsb2FkIGFzIGNvcmU6OnBhbmljOjpCb3hNZVVwPjo6Z2V0OjpoOWVhZjUzZWE5YTUyOWFhONwDMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGJiYmVmYjBkMDExYTlkZjXdAxRfX3diaW5kZ2VuX2V4bl9zdG9yZd4DD19fd2JpbmRnZW5fZnJlZd8DkQFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjpzeW5jOjpwb2lzb246OlBvaXNvbkVycm9yPHN0ZDo6c3luYzo6bXV0ZXg6Ok11dGV4R3VhcmQ8Y29uc29sZV9zdGF0aWNfdGV4dDo6Q29uc29sZVN0YXRpY1RleHQ+Pj46OmgxNTk5N2JiNmRjM2E2YWRk4ANJPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNTRlZGE3NWM3YWJlM2UyNOEDTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoN2Y1MjZhNGIyZjMyZjc0M+IDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGRiMDU2YTQ5YWQwZmRjZjDjA0w8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9zdHI6Omg1NGVkYTc1YzdhYmUzZTI0LjQ55ANCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OmgyNTk4ODU4NmM3YjFjOTdm5QNYPGFsbG9jOjp2ZWM6OmludG9faXRlcjo6SW50b0l0ZXI8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoMmI0MzMyMjdlNDNiODRhNOYDOWNvcmU6Om9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNlOjpoNzc3NDg3NzA4MGYzZjlmNecDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDhmMDAxOTM5MzE4YTcwZTboA05jb3JlOjpmbXQ6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIHU2ND46OmZtdDo6aGMxNjI4MThkMDBhNjcxYzbpAx9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVy6gMwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg0Mzk5ZDg1MDFmMmQzZmIz6wM1c2VyZGVfd2FzbV9iaW5kZ2VuOjpPYmplY3RFeHQ6OnNldDo6aGNlYzAxYmQ0NTBhNmMwOGTsAypqc19zeXM6OkFycmF5Ojppc19hcnJheTo6aGNkZjIwMjAxZGJmNDcyYmTtAzJjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6d3JpdGVfZm10OjpoZDlkZDE0ZDZkYzgwMjkzOO4DOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aGZlYWZlNTU2YzE2OTE2MTnvAzo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6Omg5OTMwNTI4OTg1Zjc3MmYx8ANkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxtb25jaDo6UGFyc2VFcnJvckZhaWx1cmVFcnJvcj4+OjpoNThlMDNiNjYxYjA4Yjc4OPEDNXdhc21fYmluZGdlbjo6SnNWYWx1ZTo6aXNfZnVuY3Rpb246Omg1OTg2OTMxNjgwZjUxZTQ08gMqd2FzbV9iaW5kZ2VuOjp0aHJvd19zdHI6Omg5NDg4MDQyMDM2ZDM2Y2Qw8wMwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmZGZlNGFjMmY5ZGI4NGJh9AMyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDgzMmUxMTYzZDM4M2NiZDf1AzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGE4NGFjZDQwZTE4MmRjZGL2AwZtZW1zZXT3AwZtZW1jcHn4AwdtZW1tb3Zl+QMGbWVtY21w+gNBc3RkOjpwYW5pY2tpbmc6OnBhbmljX2NvdW50Ojppc196ZXJvX3Nsb3dfcGF0aDo6aDljMTM3MzM0ZTZiYmVmOWb7A01jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGVfd2FzbV9iaW5kZ2VuOjplcnJvcjo6RXJyb3I+OjpoZmUzN2UzYzI2M2Q1ZWYyNvwDSDxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpoNmQ1MDM5ZTc5MTM4NjNkYv0DLGNvcmU6OmVycm9yOjpFcnJvcjo6Y2F1c2U6Omg2NGQwMzc1YWQ4YWQzYmRk/gNJPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxFPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNzIxYjNiN2YwNzM5MTEyM/8DUDxhbnlob3c6OndyYXBwZXI6Ok1lc3NhZ2VFcnJvcjxNPiBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhiZTExM2UwODk2MWRhMjkzgARJPGFueWhvdzo6ZXJyb3I6OkVycm9ySW1wbDxFPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNmExOWIyYWZlNGJlZmVmYYEEJWpzX3N5czo6QXJyYXk6OmdldDo6aGMwZjgyNzczN2ZmYWJlM2KCBElzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg5OGFjNjFhNmFiYmZmN2U5gwQtYW55aG93OjplcnJvcjo6b2JqZWN0X2Ryb3A6Omg0NjBiZTQ5YTQzMzE1MDRjhAQzYW55aG93OjplcnJvcjo6b2JqZWN0X2Ryb3BfZnJvbnQ6OmgxYjlhYjFjMWUyYTM1N2Y1hQQtanNfc3lzOjpVaW50OEFycmF5OjpsZW5ndGg6Omg0NWFkZDcxZjdiY2U5ZmMzhgQKcnVzdF9wYW5pY4cEgwFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGU6OmRlOjppbXBsczo6PGltcGwgc2VyZGU6OmRlOjpEZXNlcmlhbGl6ZSBmb3IgdTE2Pjo6ZGVzZXJpYWxpemU6OlByaW1pdGl2ZVZpc2l0b3I+OjpoNDRhODRhODliNjA0ZDhkNIgEMmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmYm9vbD46Omg5ZGNjMjM4YmIwNzczMmFiiQQuY29yZTo6ZXJyb3I6OkVycm9yOjpwcm92aWRlOjpoNTJiOGViZGYwODNiODFhN4oEUGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhcnJheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPHU4Pj46Omg5ZDgwOGM5Mzc3NTE0ZjAyiwQvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCgpPjo6aDhiMjEwZjViNjljMzM4MjiMBGljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm11dCBzdGQ6OmlvOjpXcml0ZTo6d3JpdGVfZm10OjpBZGFwdGVyPGFsbG9jOjp2ZWM6OlZlYzx1OD4+Pjo6aGU3MDZhMTE5NjAwZDVjYTgAbwlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNzMuMCAoY2M2NmFkNDY4IDIwMjMtMTAtMDMpBndhbHJ1cwYwLjIwLjMMd2FzbS1iaW5kZ2VuBjAuMi45MAAsD3RhcmdldF9mZWF0dXJlcwIrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQ=    "
  );
  const wasmModule = new WebAssembly.Module(wasmBytes);
  return new WebAssembly.Instance(wasmModule, imports2);
}
function base64decode2(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
var wasmInstance2 = instantiate2();
var refreshItems2 = {
  [
    0
    /* ProgressBars */
  ]: void 0,
  [
    1
    /* Selection */
  ]: void 0
};
function setItems2(kind, items, size) {
  refreshItems2[kind] = items;
  refresh2(size);
}
function refresh2(size) {
  if (!isOutputTty2) {
    return;
  }
  const items = Object.values(refreshItems2).flatMap((items2) => items2 ?? []);
  staticText2.set(items, size);
}
function logAboveStaticText2(inner, providedSize) {
  if (!isOutputTty2) {
    inner();
    return;
  }
  const size = providedSize ?? safeConsoleSize2();
  if (size != null) {
    staticText2.clear(size);
  }
  inner();
  refresh2(size);
}
function logOnce2(items, size) {
  logAboveStaticText2(() => {
    staticText2.outputItems(items, size);
  }, size);
}
var logger2 = {
  setItems: setItems2,
  logOnce: logOnce2,
  logAboveStaticText: logAboveStaticText2
};
var encoder4 = new TextEncoder();
var decoder3 = new TextDecoder();
async function* readKeys2() {
  const { strip_ansi_codes: strip_ansi_codes3 } = wasmInstance2;
  while (true) {
    const buf = new Uint8Array(8);
    const byteCount = await Deno.stdin.read(buf);
    if (byteCount == null) {
      break;
    }
    if (byteCount === 3) {
      if (buf[0] === 27 && buf[1] === 91) {
        if (buf[2] === 65) {
          yield 0;
          continue;
        } else if (buf[2] === 66) {
          yield 1;
          continue;
        } else if (buf[2] === 67) {
          yield 3;
          continue;
        } else if (buf[2] === 68) {
          yield 2;
          continue;
        }
      }
    } else if (byteCount === 1) {
      if (buf[0] === 3) {
        break;
      } else if (buf[0] === 13) {
        yield 4;
        continue;
      } else if (buf[0] === 32) {
        yield 5;
        continue;
      } else if (buf[0] === 127) {
        yield 6;
        continue;
      }
    }
    const text = strip_ansi_codes3(decoder3.decode(buf.slice(0, byteCount ?? 0)));
    if (text.length > 0) {
      yield text;
    }
  }
}
function hideCursor2() {
  Deno.stderr.writeSync(encoder4.encode("\x1B[?25l"));
}
function showCursor2() {
  Deno.stderr.writeSync(encoder4.encode("\x1B[?25h"));
}
var isOutputTty2 = safeConsoleSize2() != null && isTerminal2(Deno.stderr);
function isTerminal2(pipe) {
  if (typeof pipe.isTerminal === "function") {
    return pipe.isTerminal();
  } else if (pipe.rid != null && // deno-lint-ignore no-deprecated-deno-api
  typeof Deno.isatty === "function") {
    return Deno.isatty(pipe.rid);
  } else {
    throw new Error("Unsupported pipe.");
  }
}
function resultOrExit2(result) {
  if (result == null) {
    Deno.exit(130);
  } else {
    return result;
  }
}
function createSelection2(options) {
  if (!isOutputTty2 || !isTerminal2(Deno.stdin)) {
    throw new Error(`Cannot prompt when not a tty. (Prompt: '${options.message}')`);
  }
  if (safeConsoleSize2() == null) {
    throw new Error(`Cannot prompt when can't get console size. (Prompt: '${options.message}')`);
  }
  return ensureSingleSelection2(async () => {
    logger2.setItems(1, options.render());
    for await (const key of readKeys2()) {
      const keyResult = options.onKey(key);
      if (keyResult != null) {
        const size = Deno.consoleSize();
        logger2.setItems(1, [], size);
        if (options.noClear) {
          logger2.logOnce(options.render(), size);
        }
        return keyResult;
      }
      logger2.setItems(1, options.render());
    }
    logger2.setItems(1, []);
    return void 0;
  });
}
var lastPromise2 = Promise.resolve();
function ensureSingleSelection2(action) {
  const currentLastPromise = lastPromise2;
  const currentPromise = (async () => {
    try {
      await currentLastPromise;
    } catch {
    }
    hideCursor2();
    try {
      Deno.stdin.setRaw(true);
      try {
        return await action();
      } finally {
        Deno.stdin.setRaw(false);
      }
    } finally {
      showCursor2();
    }
  })();
  lastPromise2 = currentPromise;
  return currentPromise;
}
function safeConsoleSize2() {
  try {
    return Deno.consoleSize();
  } catch {
    return void 0;
  }
}
var staticText2 = {
  set(items, size) {
    if (items.length === 0) {
      return this.clear(size);
    }
    const { columns, rows } = size ?? Deno.consoleSize();
    const newText = wasmInstance2.static_text_render_text(items, columns, rows);
    if (newText != null) {
      Deno.stderr.writeSync(encoder4.encode(newText));
    }
  },
  outputItems(items, size) {
    const { columns, rows } = size ?? Deno.consoleSize();
    const newText = wasmInstance2.static_text_render_once(items, columns, rows);
    if (newText != null) {
      Deno.stderr.writeSync(encoder4.encode(newText + "\n"));
    }
  },
  clear(size) {
    const { columns, rows } = size ?? Deno.consoleSize();
    const newText = wasmInstance2.static_text_clear_text(columns, rows);
    if (newText != null) {
      Deno.stderr.writeSync(encoder4.encode(newText));
    }
  }
};
function confirm2(optsOrMessage, options) {
  return maybeConfirm2(optsOrMessage, options).then(resultOrExit2);
}
function maybeConfirm2(optsOrMessage, options) {
  const opts = typeof optsOrMessage === "string" ? { message: optsOrMessage, ...options } : optsOrMessage;
  return createSelection2({
    message: opts.message,
    noClear: opts.noClear,
    ...innerConfirm2(opts)
  });
}
function innerConfirm2(opts) {
  const drawState = {
    title: opts.message,
    default: opts.default,
    inputText: "",
    hasCompleted: false
  };
  return {
    render: () => render5(drawState),
    onKey: (key) => {
      switch (key) {
        case "Y":
        case "y":
          drawState.inputText = "Y";
          break;
        case "N":
        case "n":
          drawState.inputText = "N";
          break;
        case 6:
          drawState.inputText = "";
          break;
        case 4:
          if (drawState.inputText.length === 0) {
            if (drawState.default == null) {
              return void 0;
            }
            drawState.inputText = drawState.default ? "Y" : "N";
          }
          drawState.hasCompleted = true;
          return drawState.inputText === "Y" ? true : drawState.inputText === "N" ? false : drawState.default;
      }
    }
  };
}
function render5(state) {
  return [
    bold4(blue2(state.title)) + " " + (state.hasCompleted ? "" : state.default == null ? "(Y/N) " : state.default ? "(Y/n) " : "(y/N) ") + state.inputText + (state.hasCompleted ? "" : "\u2588")
    // (block character)
  ];
}
function multiSelect2(opts) {
  return maybeMultiSelect2(opts).then(resultOrExit2);
}
function maybeMultiSelect2(opts) {
  if (opts.options.length === 0) {
    throw new Error(`You must provide at least one option. (Prompt: '${opts.message}')`);
  }
  return createSelection2({
    message: opts.message,
    noClear: opts.noClear,
    ...innerMultiSelect2(opts)
  });
}
function innerMultiSelect2(opts) {
  const drawState = {
    title: opts.message,
    activeIndex: 0,
    items: opts.options.map((option) => {
      if (typeof option === "string") {
        option = {
          text: option
        };
      }
      return {
        selected: option.selected ?? false,
        text: option.text
      };
    }),
    hasCompleted: false
  };
  return {
    render: () => render6(drawState),
    onKey: (key) => {
      switch (key) {
        case 0:
          if (drawState.activeIndex === 0) {
            drawState.activeIndex = drawState.items.length - 1;
          } else {
            drawState.activeIndex--;
          }
          break;
        case 1:
          drawState.activeIndex = (drawState.activeIndex + 1) % drawState.items.length;
          break;
        case 5: {
          const item = drawState.items[drawState.activeIndex];
          item.selected = !item.selected;
          break;
        }
        case 4:
          drawState.hasCompleted = true;
          return drawState.items.map((value, index) => [value, index]).filter(([value]) => value.selected).map(([, index]) => index);
      }
      return void 0;
    }
  };
}
function render6(state) {
  const items = [];
  items.push(bold4(blue2(state.title)));
  if (state.hasCompleted) {
    if (state.items.some((i) => i.selected)) {
      for (const item of state.items) {
        if (item.selected) {
          items.push({
            text: ` - ${item.text}`,
            indent: 3
          });
        }
      }
    } else {
      items.push(italic2(" <None>"));
    }
  } else {
    for (const [i, item] of state.items.entries()) {
      const prefix = i === state.activeIndex ? "> " : "  ";
      items.push({
        text: `${prefix}[${item.selected ? "x" : " "}] ${item.text}`,
        indent: 6
      });
    }
  }
  return items;
}
var units2 = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
function humanDownloadSize2(byteCount, totalBytes) {
  const exponent = Math.min(units2.length - 1, Math.floor(Math.log(totalBytes) / Math.log(1024)));
  const unit = units2[exponent];
  const prettyBytes = (Math.floor(byteCount / Math.pow(1024, exponent) * 100) / 100).toFixed(exponent === 0 ? 0 : 2);
  return `${prettyBytes} ${unit}`;
}
var intervalMs2 = 60;
var progressBars2 = [];
var renderIntervalId2;
function addProgressBar2(render9) {
  const pb = {
    render: render9
  };
  progressBars2.push(pb);
  if (renderIntervalId2 == null && isOutputTty2) {
    renderIntervalId2 = setInterval(forceRender2, intervalMs2);
  }
  return pb;
}
function removeProgressBar2(pb) {
  const index = progressBars2.indexOf(pb);
  if (index === -1) {
    return false;
  }
  progressBars2.splice(index, 1);
  if (progressBars2.length === 0) {
    clearInterval(renderIntervalId2);
    logger2.setItems(0, []);
    renderIntervalId2 = void 0;
  }
  return true;
}
function forceRender2() {
  if (!isShowingProgressBars2()) {
    return;
  }
  const size = Deno.consoleSize();
  const items = progressBars2.map((p) => p.render(size)).flat();
  logger2.setItems(0, items, size);
}
function isShowingProgressBars2() {
  return isOutputTty2 && progressBars2.length > 0;
}
var ProgressBar2 = class {
  #state;
  #pb;
  #withCount = 0;
  #onLog;
  #noClear;
  /** @internal */
  constructor(onLog, opts) {
    if (arguments.length !== 2) {
      throw new Error("Invalid usage. Create the progress bar via `$.progress`.");
    }
    this.#onLog = onLog;
    this.#state = {
      message: opts.message,
      prefix: opts.prefix,
      length: opts.length,
      currentPos: 0,
      tickCount: 0,
      hasCompleted: false,
      kind: "raw"
    };
    this.#pb = addProgressBar2((size) => {
      this.#state.tickCount++;
      return renderProgressBar2(this.#state, size);
    });
    this.#noClear = opts.noClear ?? false;
    this.#logIfNonInteractive();
  }
  /** Sets the prefix message/word, which will be displayed in green. */
  prefix(prefix) {
    this.#state.prefix = prefix;
    if (prefix != null && prefix.length > 0) {
      this.#logIfNonInteractive();
    }
    return this;
  }
  /** Sets the message the progress bar will display after the prefix in white. */
  message(message) {
    this.#state.message = message;
    if (message != null && message.length > 0) {
      this.#logIfNonInteractive();
    }
    return this;
  }
  /** Sets how to format the length values. */
  kind(kind) {
    this.#state.kind = kind;
    return this;
  }
  #logIfNonInteractive() {
    if (isOutputTty2) {
      return;
    }
    let text = this.#state.prefix ?? "";
    if (text.length > 0) {
      text += " ";
    }
    text += this.#state.message ?? "";
    if (text.length > 0) {
      this.#onLog(text);
    }
  }
  /** Sets the current position of the progress bar. */
  position(position) {
    this.#state.currentPos = position;
    return this;
  }
  /** Increments the position of the progress bar. */
  increment(inc = 1) {
    this.#state.currentPos += inc;
    return this;
  }
  /** Sets the total length of the progress bar. */
  length(size) {
    this.#state.length = size;
    return this;
  }
  /** Whether the progress bar should output a summary when finished. */
  noClear(value = true) {
    this.#noClear = value;
    return this;
  }
  /** Forces a render to the console. */
  forceRender() {
    return forceRender2();
  }
  /** Finish showing the progress bar. */
  finish() {
    if (removeProgressBar2(this.#pb)) {
      this.#state.hasCompleted = true;
      if (this.#noClear) {
        const text = renderProgressBar2(this.#state, safeConsoleSize2()).map((item) => typeof item === "string" ? item : item.text).join("\n");
        this.#onLog(text);
      }
    }
  }
  with(action) {
    this.#withCount++;
    let wasAsync = false;
    try {
      const result = action();
      if (result instanceof Promise) {
        wasAsync = true;
        return result.finally(() => {
          this.#decrementWith();
        });
      } else {
        return result;
      }
    } finally {
      if (!wasAsync) {
        this.#decrementWith();
      }
    }
  }
  #decrementWith() {
    this.#withCount--;
    if (this.#withCount === 0) {
      this.finish();
    }
  }
};
var tickStrings2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
function renderProgressBar2(state, size) {
  if (state.hasCompleted) {
    let text = "";
    if (state.prefix != null) {
      text += green3(state.prefix);
    }
    if (state.message != null) {
      if (text.length > 0) {
        text += " ";
      }
      text += state.message;
    }
    return text.length > 0 ? [text] : [];
  } else if (state.length == null || state.length === 0) {
    let text = green3(tickStrings2[Math.abs(state.tickCount) % tickStrings2.length]);
    if (state.prefix != null) {
      text += ` ${green3(state.prefix)}`;
    }
    if (state.message != null) {
      text += ` ${state.message}`;
    }
    return [text];
  } else {
    let firstLine = "";
    if (state.prefix != null) {
      firstLine += green3(state.prefix);
    }
    if (state.message != null) {
      if (firstLine.length > 0) {
        firstLine += " ";
      }
      firstLine += state.message;
    }
    const percent = Math.min(state.currentPos / state.length, 1);
    const currentPosText = state.kind === "bytes" ? humanDownloadSize2(state.currentPos, state.length) : state.currentPos.toString();
    const lengthText = state.kind === "bytes" ? humanDownloadSize2(state.length, state.length) : state.length.toString();
    const maxWidth = size == null ? 75 : Math.max(10, Math.min(75, size.columns - 5));
    const sameLineTextWidth = 6 + lengthText.length * 2 + state.length.toString().length * 2;
    const totalBars = Math.max(1, maxWidth - sameLineTextWidth);
    const completedBars = Math.floor(totalBars * percent);
    let secondLine = "";
    secondLine += "[";
    if (completedBars != totalBars) {
      if (completedBars > 0) {
        secondLine += cyan2("#".repeat(completedBars - 1) + ">");
      }
      secondLine += blue2("-".repeat(totalBars - completedBars));
    } else {
      secondLine += cyan2("#".repeat(completedBars));
    }
    secondLine += `] (${currentPosText}/${lengthText})`;
    const result = [];
    if (firstLine.length > 0) {
      result.push(firstLine);
    }
    result.push(secondLine);
    return result;
  }
}
var defaultMask2 = { char: "*", lastVisible: false };
function prompt2(optsOrMessage, options) {
  return maybePrompt2(optsOrMessage, options).then(resultOrExit2);
}
function maybePrompt2(optsOrMessage, options) {
  const opts = typeof optsOrMessage === "string" ? {
    message: optsOrMessage,
    ...options
  } : optsOrMessage;
  return createSelection2({
    message: opts.message,
    noClear: opts.noClear,
    ...innerPrompt2(opts)
  });
}
function innerPrompt2(opts) {
  let mask = opts.mask ?? false;
  if (mask && typeof mask === "boolean") {
    mask = defaultMask2;
  }
  const drawState = {
    title: opts.message,
    inputText: opts.default ?? "",
    mask,
    hasCompleted: false
  };
  return {
    render: () => render7(drawState),
    onKey: (key) => {
      if (typeof key === "string") {
        drawState.inputText += key;
      } else {
        switch (key) {
          case 5:
            drawState.inputText += " ";
            break;
          case 6:
            drawState.inputText = drawState.inputText.slice(0, -1);
            break;
          case 4:
            drawState.hasCompleted = true;
            return drawState.inputText;
        }
      }
      return void 0;
    }
  };
}
function render7(state) {
  let { inputText } = state;
  if (state.mask) {
    const char = state.mask.char ?? defaultMask2.char;
    const lastVisible = state.mask.lastVisible ?? defaultMask2.lastVisible;
    const shouldShowLast = lastVisible && !state.hasCompleted;
    const safeLengthMinusOne = Math.max(0, inputText.length - 1);
    const masked = char.repeat(shouldShowLast ? safeLengthMinusOne : inputText.length);
    const unmasked = shouldShowLast ? inputText.slice(safeLengthMinusOne) : "";
    inputText = `${masked}${unmasked}`;
  }
  return [
    bold4(blue2(state.title)) + " " + inputText + (state.hasCompleted ? "" : "\u2588")
    // (block character)
  ];
}
function select2(opts) {
  return maybeSelect2(opts).then(resultOrExit2);
}
function maybeSelect2(opts) {
  if (opts.options.length <= 1) {
    throw new Error(`You must provide at least two options. (Prompt: '${opts.message}')`);
  }
  return createSelection2({
    message: opts.message,
    noClear: opts.noClear,
    ...innerSelect2(opts)
  });
}
function innerSelect2(opts) {
  const drawState = {
    title: opts.message,
    activeIndex: (opts.initialIndex ?? 0) % opts.options.length,
    items: opts.options,
    hasCompleted: false
  };
  return {
    render: () => render8(drawState),
    onKey: (key) => {
      switch (key) {
        case 0:
          if (drawState.activeIndex === 0) {
            drawState.activeIndex = drawState.items.length - 1;
          } else {
            drawState.activeIndex--;
          }
          break;
        case 1:
          drawState.activeIndex = (drawState.activeIndex + 1) % drawState.items.length;
          break;
        case 4:
          drawState.hasCompleted = true;
          return drawState.activeIndex;
      }
    }
  };
}
function render8(state) {
  const items = [];
  items.push(bold4(blue2(state.title)));
  if (state.hasCompleted) {
    items.push({
      text: ` - ${state.items[state.activeIndex]}`,
      indent: 3
    });
  } else {
    for (const [i, text] of state.items.entries()) {
      const prefix = i === state.activeIndex ? "> " : "  ";
      items.push({
        text: `${prefix}${text}`,
        indent: 4
      });
    }
  }
  return items;
}
var symbols2 = {
  writable: Symbol.for("dax.writableStream"),
  readable: Symbol.for("dax.readableStream")
};
var TimeoutError2 = class extends Error {
  constructor(message) {
    super(message);
  }
  get name() {
    return "TimeoutError";
  }
};
function formatMillis2(ms) {
  if (ms < 1e3) {
    return `${formatValue(ms)} millisecond${ms === 1 ? "" : "s"}`;
  } else if (ms < 60 * 1e3) {
    const s = ms / 1e3;
    return `${formatValue(s)} ${pluralize("second", s)}`;
  } else {
    const mins = ms / 60 / 1e3;
    return `${formatValue(mins)} ${pluralize("minute", mins)}`;
  }
  function formatValue(value) {
    const text = value.toFixed(2);
    if (text.endsWith(".00")) {
      return value.toFixed(0);
    } else if (text.endsWith("0")) {
      return value.toFixed(1);
    } else {
      return text;
    }
  }
  function pluralize(text, value) {
    const suffix = value === 1 ? "" : "s";
    return text + suffix;
  }
}
function delayToIterator2(delay) {
  if (typeof delay !== "number" && typeof delay !== "string") {
    return delay;
  }
  const ms = delayToMs2(delay);
  return {
    next() {
      return ms;
    }
  };
}
function delayToMs2(delay) {
  if (typeof delay === "number") {
    return delay;
  } else if (typeof delay === "string") {
    const msMatch = delay.match(/^([0-9]+)ms$/);
    if (msMatch != null) {
      return parseInt(msMatch[1], 10);
    }
    const secondsMatch = delay.match(/^([0-9]+\.?[0-9]*)s$/);
    if (secondsMatch != null) {
      return Math.round(parseFloat(secondsMatch[1]) * 1e3);
    }
    const minutesMatch = delay.match(/^([0-9]+\.?[0-9]*)m$/);
    if (minutesMatch != null) {
      return Math.round(parseFloat(minutesMatch[1]) * 1e3 * 60);
    }
    const minutesSecondsMatch = delay.match(/^([0-9]+\.?[0-9]*)m([0-9]+\.?[0-9]*)s$/);
    if (minutesSecondsMatch != null) {
      return Math.round(
        parseFloat(minutesSecondsMatch[1]) * 1e3 * 60 + parseFloat(minutesSecondsMatch[2]) * 1e3
      );
    }
    const hoursMatch = delay.match(/^([0-9]+\.?[0-9]*)h$/);
    if (hoursMatch != null) {
      return Math.round(parseFloat(hoursMatch[1]) * 1e3 * 60 * 60);
    }
    const hoursMinutesMatch = delay.match(/^([0-9]+\.?[0-9]*)h([0-9]+\.?[0-9]*)m$/);
    if (hoursMinutesMatch != null) {
      return Math.round(
        parseFloat(hoursMinutesMatch[1]) * 1e3 * 60 * 60 + parseFloat(hoursMinutesMatch[2]) * 1e3 * 60
      );
    }
    const hoursMinutesSecondsMatch = delay.match(/^([0-9]+\.?[0-9]*)h([0-9]+\.?[0-9]*)m([0-9]+\.?[0-9]*)s$/);
    if (hoursMinutesSecondsMatch != null) {
      return Math.round(
        parseFloat(hoursMinutesSecondsMatch[1]) * 1e3 * 60 * 60 + parseFloat(hoursMinutesSecondsMatch[2]) * 1e3 * 60 + parseFloat(hoursMinutesSecondsMatch[3]) * 1e3
      );
    }
  }
  throw new Error(`Unknown delay value: ${delay}`);
}
function filterEmptyRecordValues2(record) {
  const result = {};
  for (const [key, value] of Object.entries(record)) {
    if (value != null) {
      result[key] = value;
    }
  }
  return result;
}
function resolvePath2(cwd, arg) {
  return resolve6(isAbsolute6(arg) ? arg : join6(cwd, arg));
}
var Box2 = class {
  constructor(value) {
    this.value = value;
  }
};
var TreeBox2 = class _TreeBox2 {
  #value;
  constructor(value) {
    this.#value = value;
  }
  getValue() {
    let tree = this;
    while (tree.#value instanceof _TreeBox2) {
      tree = tree.#value;
    }
    return tree.#value;
  }
  setValue(value) {
    this.#value = value;
  }
  createChild() {
    return new _TreeBox2(this);
  }
};
var LoggerTreeBox2 = class extends TreeBox2 {
  getValue() {
    const innerValue = super.getValue();
    return (...args) => {
      return logger2.logAboveStaticText(() => {
        innerValue(...args);
      });
    };
  }
};
async function safeLstat2(path) {
  try {
    return await Deno.lstat(path);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return void 0;
    } else {
      throw err;
    }
  }
}
function getFileNameFromUrl2(url) {
  const parsedUrl = url instanceof URL ? url : new URL(url);
  const fileName = parsedUrl.pathname.split("/").at(-1);
  return fileName?.length === 0 ? void 0 : fileName;
}
async function getExecutableShebangFromPath2(path) {
  try {
    const file = await Deno.open(path, { read: true });
    try {
      return await getExecutableShebang2(file);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}
var decoder4 = new TextDecoder();
async function getExecutableShebang2(reader) {
  const text = "#!/usr/bin/env ";
  const buffer = new Uint8Array(text.length);
  const bytesReadCount = await reader.read(buffer);
  if (bytesReadCount !== text.length || decoder4.decode(buffer) !== text) {
    return void 0;
  }
  const bufReader = new BufReader(reader);
  const line = await bufReader.readLine();
  if (line == null) {
    return void 0;
  }
  const result = decoder4.decode(line.line).trim();
  const dashS = "-S ";
  if (result.startsWith(dashS)) {
    return {
      stringSplit: true,
      command: result.slice(dashS.length)
    };
  } else {
    return {
      stringSplit: false,
      command: result
    };
  }
}
var nodeENotEmpty2 = "ENOTEMPTY: ";
var nodeENOENT2 = "ENOENT: ";
function errorToString2(err) {
  let message;
  if (err instanceof Error) {
    message = err.message;
  } else {
    message = String(err);
  }
  if (message.startsWith(nodeENotEmpty2)) {
    return message.slice(nodeENotEmpty2.length);
  } else if (message.startsWith(nodeENOENT2)) {
    return message.slice(nodeENOENT2.length);
  } else {
    return message;
  }
}
function parseArgKinds2(flags) {
  const result = [];
  let had_dash_dash = false;
  for (const arg of flags) {
    if (had_dash_dash) {
      result.push({ arg, kind: "Arg" });
    } else if (arg == "-") {
      result.push({ arg: "-", kind: "Arg" });
    } else if (arg == "--") {
      had_dash_dash = true;
    } else if (arg.startsWith("--")) {
      result.push({ arg: arg.replace(/^--/, ""), kind: "LongFlag" });
    } else if (arg.startsWith("-")) {
      const flags2 = arg.replace(/^-/, "");
      if (!isNaN(parseFloat(flags2))) {
        result.push({ arg, kind: "Arg" });
      } else {
        for (const c of flags2) {
          result.push({ arg: c, kind: "ShortFlag" });
        }
      }
    } else {
      result.push({ arg, kind: "Arg" });
    }
  }
  return result;
}
function bailUnsupported4(arg) {
  switch (arg.kind) {
    case "Arg":
      throw Error(`unsupported argument: ${arg.arg}`);
    case "ShortFlag":
      throw Error(`unsupported flag: -${arg.arg}`);
    case "LongFlag":
      throw Error(`unsupported flag: --${arg.arg}`);
  }
}
async function catCommand2(context) {
  try {
    const code4 = await executeCat2(context);
    return { code: code4 };
  } catch (err) {
    return context.error(`cat: ${errorToString2(err)}`);
  }
}
async function executeCat2(context) {
  const flags = parseCatArgs2(context.args);
  let exitCode = 0;
  const buf = new Uint8Array(1024);
  for (const path of flags.paths) {
    if (path === "-") {
      if (typeof context.stdin === "object") {
        while (!context.signal.aborted) {
          const size = await context.stdin.read(buf);
          if (!size || size === 0) {
            break;
          } else {
            const maybePromise = context.stdout.write(buf.slice(0, size));
            if (maybePromise instanceof Promise) {
              await maybePromise;
            }
          }
        }
        exitCode = context.signal.abortedExitCode ?? 0;
      } else {
        const _assertValue = context.stdin;
        throw new Error(`not supported. stdin was '${context.stdin}'`);
      }
    } else {
      let file;
      try {
        file = await Deno.open(resolvePath2(context.cwd, path), { read: true });
        while (!context.signal.aborted) {
          const size = file.readSync(buf);
          if (!size || size === 0) {
            break;
          } else {
            const maybePromise = context.stdout.write(buf.slice(0, size));
            if (maybePromise instanceof Promise) {
              await maybePromise;
            }
          }
        }
        exitCode = context.signal.abortedExitCode ?? 0;
      } catch (err) {
        const maybePromise = context.stderr.writeLine(`cat ${path}: ${errorToString2(err)}`);
        if (maybePromise instanceof Promise) {
          await maybePromise;
        }
        exitCode = 1;
      } finally {
        file?.close();
      }
    }
  }
  return exitCode;
}
function parseCatArgs2(args) {
  const paths = [];
  for (const arg of parseArgKinds2(args)) {
    if (arg.kind === "Arg") {
      paths.push(arg.arg);
    } else {
      bailUnsupported4(arg);
    }
  }
  if (paths.length === 0) {
    paths.push("-");
  }
  return { paths };
}
async function cdCommand2(context) {
  try {
    const dir = await executeCd2(context.cwd, context.args);
    return {
      code: 0,
      changes: [{
        kind: "cd",
        dir
      }]
    };
  } catch (err) {
    return context.error(`cd: ${errorToString2(err)}`);
  }
}
async function executeCd2(cwd, args) {
  const arg = parseArgs12(args);
  const result = resolvePath2(cwd, arg);
  if (!await isDirectory2(result)) {
    throw new Error(`${result}: Not a directory`);
  }
  return result;
}
async function isDirectory2(path) {
  try {
    const info = await Deno.stat(path);
    return info.isDirectory;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    } else {
      throw err;
    }
  }
}
function parseArgs12(args) {
  if (args.length === 0) {
    throw new Error("expected at least 1 argument");
  } else if (args.length > 1) {
    throw new Error("too many arguments");
  } else {
    return args[0];
  }
}
async function cpCommand2(context) {
  try {
    await executeCp2(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`cp: ${errorToString2(err)}`);
  }
}
async function executeCp2(cwd, args) {
  const flags = await parseCpArgs2(cwd, args);
  for (const { from, to } of flags.operations) {
    await doCopyOperation2(flags, from, to);
  }
}
async function parseCpArgs2(cwd, args) {
  const paths = [];
  let recursive = false;
  for (const arg of parseArgKinds2(args)) {
    if (arg.kind === "Arg") paths.push(arg.arg);
    else if (arg.arg === "recursive" && arg.kind === "LongFlag" || arg.arg === "r" && arg.kind == "ShortFlag" || arg.arg === "R" && arg.kind === "ShortFlag") {
      recursive = true;
    } else bailUnsupported4(arg);
  }
  if (paths.length === 0) throw Error("missing file operand");
  else if (paths.length === 1) throw Error(`missing destination file operand after '${paths[0]}'`);
  return { recursive, operations: await getCopyAndMoveOperations2(cwd, paths) };
}
async function doCopyOperation2(flags, from, to) {
  const fromInfo = await safeLstat2(from.path);
  if (fromInfo?.isDirectory) {
    if (flags.recursive) {
      const toInfo = await safeLstat2(to.path);
      if (toInfo?.isFile) {
        throw Error("destination was a file");
      } else if (toInfo?.isSymlink) {
        throw Error("no support for copying to symlinks");
      } else if (fromInfo.isSymlink) {
        throw Error("no support for copying from symlinks");
      } else {
        await copyDirRecursively2(from.path, to.path);
      }
    } else {
      throw Error("source was a directory; maybe specify -r");
    }
  } else {
    await Deno.copyFile(from.path, to.path);
  }
}
async function copyDirRecursively2(from, to) {
  await Deno.mkdir(to, { recursive: true });
  const readDir = Deno.readDir(from);
  for await (const entry of readDir) {
    const newFrom = join6(from, basename6(entry.name));
    const newTo = join6(to, basename6(entry.name));
    if (entry.isDirectory) {
      await copyDirRecursively2(newFrom, newTo);
    } else if (entry.isFile) {
      await Deno.copyFile(newFrom, newTo);
    }
  }
}
async function mvCommand2(context) {
  try {
    await executeMove2(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`mv: ${errorToString2(err)}`);
  }
}
async function executeMove2(cwd, args) {
  const flags = await parseMvArgs2(cwd, args);
  for (const { from, to } of flags.operations) {
    await Deno.rename(from.path, to.path);
  }
}
async function parseMvArgs2(cwd, args) {
  const paths = [];
  for (const arg of parseArgKinds2(args)) {
    if (arg.kind === "Arg") paths.push(arg.arg);
    else bailUnsupported4(arg);
  }
  if (paths.length === 0) throw Error("missing operand");
  else if (paths.length === 1) throw Error(`missing destination file operand after '${paths[0]}'`);
  return { operations: await getCopyAndMoveOperations2(cwd, paths) };
}
async function getCopyAndMoveOperations2(cwd, paths) {
  const specified_destination = paths.splice(paths.length - 1, 1)[0];
  const destination = resolvePath2(cwd, specified_destination);
  const fromArgs = paths;
  const operations = [];
  if (fromArgs.length > 1) {
    if (!await safeLstat2(destination).then((p) => p?.isDirectory)) {
      throw Error(`target '${specified_destination}' is not a directory`);
    }
    for (const from of fromArgs) {
      const fromPath = resolvePath2(cwd, from);
      const toPath = join6(destination, basename6(fromPath));
      operations.push(
        {
          from: {
            specified: from,
            path: fromPath
          },
          to: {
            specified: specified_destination,
            path: toPath
          }
        }
      );
    }
  } else {
    const fromPath = resolvePath2(cwd, fromArgs[0]);
    const toPath = await safeLstat2(destination).then((p) => p?.isDirectory) ? calculateDestinationPath2(destination, fromPath) : destination;
    operations.push({
      from: {
        specified: fromArgs[0],
        path: fromPath
      },
      to: {
        specified: specified_destination,
        path: toPath
      }
    });
  }
  return operations;
}
function calculateDestinationPath2(destination, from) {
  return join6(destination, basename6(from));
}
function echoCommand2(context) {
  try {
    const maybePromise = context.stdout.writeLine(context.args.join(" "));
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => ({ code: 0 })).catch((err) => handleFailure2(context, err));
    } else {
      return { code: 0 };
    }
  } catch (err) {
    return handleFailure2(context, err);
  }
}
function handleFailure2(context, err) {
  return context.error(`echo: ${errorToString2(err)}`);
}
function exitCommand2(context) {
  try {
    const code4 = parseArgs13(context.args);
    return {
      kind: "exit",
      code: code4
    };
  } catch (err) {
    return context.error(2, `exit: ${errorToString2(err)}`);
  }
}
function parseArgs13(args) {
  if (args.length === 0) return 1;
  if (args.length > 1) throw new Error("too many arguments");
  const exitCode = parseInt(args[0], 10);
  if (isNaN(exitCode)) throw new Error("numeric argument required.");
  if (exitCode < 0) {
    const code4 = -exitCode % 256;
    return 256 - code4;
  }
  return exitCode % 256;
}
function exportCommand2(context) {
  const changes = [];
  for (const arg of context.args) {
    const equalsIndex = arg.indexOf("=");
    if (equalsIndex >= 0) {
      changes.push({
        kind: "envvar",
        name: arg.substring(0, equalsIndex),
        value: arg.substring(equalsIndex + 1)
      });
    }
  }
  return {
    code: 0,
    changes
  };
}
async function mkdirCommand2(context) {
  try {
    await executeMkdir2(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`mkdir: ${errorToString2(err)}`);
  }
}
async function executeMkdir2(cwd, args) {
  const flags = parseArgs14(args);
  for (const specifiedPath of flags.paths) {
    const path = resolvePath2(cwd, specifiedPath);
    const info = await safeLstat2(path);
    if (info?.isFile || !flags.parents && info?.isDirectory) {
      throw Error(`cannot create directory '${specifiedPath}': File exists`);
    }
    if (flags.parents) {
      await Deno.mkdir(path, { recursive: true });
    } else {
      await Deno.mkdir(path);
    }
  }
}
function parseArgs14(args) {
  const result = {
    parents: false,
    paths: []
  };
  for (const arg of parseArgKinds2(args)) {
    if (arg.arg === "parents" && arg.kind === "LongFlag" || arg.arg === "p" && arg.kind == "ShortFlag") {
      result.parents = true;
    } else {
      if (arg.kind !== "Arg") bailUnsupported4(arg);
      result.paths.push(arg.arg.trim());
    }
  }
  if (result.paths.length === 0) {
    throw Error("missing operand");
  }
  return result;
}
function printEnvCommand2(context) {
  let args;
  if (Deno.build.os === "windows") {
    args = context.args.map((arg) => arg.toUpperCase());
  } else {
    args = context.args;
  }
  try {
    const result = executePrintEnv2(context.env, args);
    const code4 = args.some((arg) => context.env[arg] === void 0) ? 1 : 0;
    const maybePromise = context.stdout.writeLine(result);
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => ({ code: code4 })).catch((err) => handleError5(context, err));
    } else {
      return { code: code4 };
    }
  } catch (err) {
    return handleError5(context, err);
  }
}
function handleError5(context, err) {
  return context.error(`printenv: ${errorToString2(err)}`);
}
function executePrintEnv2(env, args) {
  const isWindows8 = Deno.build.os === "windows";
  if (args.length === 0) {
    return Object.entries(env).map(([key, val]) => `${isWindows8 ? key.toUpperCase() : key}=${val}`).join("\n");
  } else {
    if (isWindows8) {
      args = args.map((arg) => arg.toUpperCase());
    }
    return Object.entries(env).filter(([key]) => args.includes(key)).map(([_key, val]) => val).join("\n");
  }
}
function pwdCommand2(context) {
  try {
    const output = executePwd2(context.cwd, context.args);
    const maybePromise = context.stdout.writeLine(output);
    const result = { code: 0 };
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => result).catch((err) => handleError6(context, err));
    } else {
      return result;
    }
  } catch (err) {
    return handleError6(context, err);
  }
}
function handleError6(context, err) {
  return context.error(`pwd: ${errorToString2(err)}`);
}
function executePwd2(cwd, args) {
  const flags = parseArgs15(args);
  if (flags.logical) {
    return resolve6(cwd);
  } else {
    return cwd;
  }
}
function parseArgs15(args) {
  let logical = false;
  for (const arg of parseArgKinds2(args)) {
    if (arg.arg === "L" && arg.kind === "ShortFlag") {
      logical = true;
    } else if (arg.arg === "P" && arg.kind == "ShortFlag") {
    } else if (arg.kind === "Arg") {
    } else {
      bailUnsupported4(arg);
    }
  }
  return { logical };
}
async function rmCommand2(context) {
  try {
    await executeRemove2(context.cwd, context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`rm: ${errorToString2(err)}`);
  }
}
async function executeRemove2(cwd, args) {
  const flags = parseArgs16(args);
  await Promise.all(flags.paths.map((specifiedPath) => {
    if (specifiedPath.length === 0) {
      throw new Error("Bug in dax. Specified path should have not been empty.");
    }
    const path = resolvePath2(cwd, specifiedPath);
    if (path === "/") {
      throw new Error("Cannot delete root directory. Maybe bug in dax? Please report this.");
    }
    return Deno.remove(path, { recursive: flags.recursive }).catch((err) => {
      if (flags.force && err instanceof Deno.errors.NotFound) {
        return Promise.resolve();
      } else {
        return Promise.reject(err);
      }
    });
  }));
}
function parseArgs16(args) {
  const result = {
    recursive: false,
    force: false,
    dir: false,
    paths: []
  };
  for (const arg of parseArgKinds2(args)) {
    if (arg.arg === "recursive" && arg.kind === "LongFlag" || arg.arg === "r" && arg.kind == "ShortFlag" || arg.arg === "R" && arg.kind === "ShortFlag") {
      result.recursive = true;
    } else if (arg.arg == "dir" && arg.kind === "LongFlag" || arg.arg == "d" && arg.kind === "ShortFlag") {
      result.dir = true;
    } else if (arg.arg == "force" && arg.kind === "LongFlag" || arg.arg == "f" && arg.kind === "ShortFlag") {
      result.force = true;
    } else {
      if (arg.kind !== "Arg") bailUnsupported5(arg);
      result.paths.push(arg.arg.trim());
    }
  }
  if (result.paths.length === 0) {
    throw Error("missing operand");
  }
  return result;
}
function bailUnsupported5(arg) {
  switch (arg.kind) {
    case "Arg":
      throw Error(`unsupported argument: ${arg.arg}`);
    case "ShortFlag":
      throw Error(`unsupported flag: -${arg.arg}`);
    case "LongFlag":
      throw Error(`unsupported flag: --${arg.arg}`);
  }
}
function getAbortedResult2() {
  return {
    kind: "exit",
    code: 124
    // same as timeout command
  };
}
async function sleepCommand2(context) {
  try {
    const ms = parseArgs17(context.args);
    await new Promise((resolve7) => {
      const timeoutId = setTimeout(finish, ms);
      context.signal.addListener(signalListener);
      function signalListener(_signal) {
        if (context.signal.aborted) {
          finish();
        }
      }
      function finish() {
        resolve7();
        clearInterval(timeoutId);
        context.signal.removeListener(signalListener);
      }
    });
    if (context.signal.aborted) {
      return getAbortedResult2();
    }
    return { code: 0 };
  } catch (err) {
    return context.error(`sleep: ${errorToString2(err)}`);
  }
}
function parseArgs17(args) {
  let totalTimeMs = 0;
  if (args.length === 0) {
    throw new Error("missing operand");
  }
  for (const arg of args) {
    if (arg.startsWith("-")) {
      throw new Error(`unsupported: ${arg}`);
    }
    const value = parseFloat(arg);
    if (isNaN(value)) {
      throw new Error(`error parsing argument '${arg}' to number.`);
    }
    totalTimeMs = value * 1e3;
  }
  return totalTimeMs;
}
async function exists2(path, options) {
  try {
    const stat = await Deno.stat(path);
    if (options && (options.isReadable || options.isDirectory || options.isFile)) {
      if (options.isDirectory && options.isFile) {
        throw new TypeError(
          "ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together."
        );
      }
      if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
        return false;
      }
      if (options.isReadable) {
        if (stat.mode === null) {
          return true;
        }
        if (Deno.uid() === stat.uid) {
          return (stat.mode & 256) === 256;
        } else if (Deno.gid() === stat.gid) {
          return (stat.mode & 32) === 32;
        }
        return (stat.mode & 4) === 4;
      }
    }
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error instanceof Deno.errors.PermissionDenied) {
      if ((await Deno.permissions.query({ name: "read", path })).state === "granted") {
        return !options?.isReadable;
      }
    }
    throw error;
  }
}
function existsSync2(path, options) {
  try {
    const stat = Deno.statSync(path);
    if (options && (options.isReadable || options.isDirectory || options.isFile)) {
      if (options.isDirectory && options.isFile) {
        throw new TypeError(
          "ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together."
        );
      }
      if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
        return false;
      }
      if (options.isReadable) {
        if (stat.mode === null) {
          return true;
        }
        if (Deno.uid() === stat.uid) {
          return (stat.mode & 256) === 256;
        } else if (Deno.gid() === stat.gid) {
          return (stat.mode & 32) === 32;
        }
        return (stat.mode & 4) === 4;
      }
    }
    return true;
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    if (error instanceof Deno.errors.PermissionDenied) {
      if (Deno.permissions.querySync({ name: "read", path }).state === "granted") {
        return !options?.isReadable;
      }
    }
    throw error;
  }
}
async function testCommand2(context) {
  try {
    const [testFlag, testPath] = parseArgs18(context.cwd, context.args);
    let result;
    switch (testFlag) {
      case "-f":
        result = (await safeLstat2(testPath))?.isFile ?? false;
        break;
      case "-d":
        result = (await safeLstat2(testPath))?.isDirectory ?? false;
        break;
      case "-e":
        result = await exists2(testPath);
        break;
      case "-s":
        result = ((await safeLstat2(testPath))?.size ?? 0) > 0;
        break;
      case "-L":
        result = (await safeLstat2(testPath))?.isSymlink ?? false;
        break;
      default:
        throw new Error("unsupported test type");
    }
    return { code: result ? 0 : 1 };
  } catch (err) {
    return context.error(2, `test: ${errorToString2(err)}`);
  }
}
function parseArgs18(cwd, args) {
  if (args.length !== 2) {
    throw new Error("expected 2 arguments");
  }
  if (args[0] == null || !args[0].startsWith("-")) {
    throw new Error("missing test type flag");
  }
  return [args[0], resolvePath2(cwd, args[1])];
}
async function touchCommand2(context) {
  try {
    await executetouch2(context.args);
    return { code: 0 };
  } catch (err) {
    return context.error(`touch: ${errorToString2(err)}`);
  }
}
async function executetouch2(args) {
  const flags = parseArgs19(args);
  for (const path of flags.paths) {
    const f = await Deno.create(path);
    f.close();
  }
}
function parseArgs19(args) {
  const paths = [];
  for (const arg of parseArgKinds2(args)) {
    if (arg.kind === "Arg") paths.push(arg.arg);
    else bailUnsupported4(arg);
  }
  if (paths.length === 0) throw Error("missing file operand");
  return { paths };
}
function unsetCommand2(context) {
  try {
    return {
      code: 0,
      changes: parseNames2(context.args).map((name) => ({ kind: "unsetvar", name }))
    };
  } catch (err) {
    return context.error(`unset: ${errorToString2(err)}`);
  }
}
function parseNames2(args) {
  if (args[0] === "-f") {
    throw Error(`unsupported flag: -f`);
  } else if (args[0] === "-v") {
    return args.slice(1);
  } else {
    return args;
  }
}
var encoder5 = new TextEncoder();
var NullPipeReader2 = class {
  read(_p) {
    return Promise.resolve(null);
  }
};
var NullPipeWriter2 = class {
  writeSync(p) {
    return p.length;
  }
};
var ShellPipeWriter2 = class {
  #kind;
  #inner;
  constructor(kind, inner) {
    this.#kind = kind;
    this.#inner = inner;
  }
  get kind() {
    return this.#kind;
  }
  get inner() {
    return this.#inner;
  }
  write(p) {
    if ("write" in this.#inner) {
      return this.#inner.write(p);
    } else {
      return this.#inner.writeSync(p);
    }
  }
  writeAll(data) {
    if ("write" in this.#inner) {
      return writeAll2(this.#inner, data);
    } else {
      return writeAllSync2(this.#inner, data);
    }
  }
  writeText(text) {
    return this.writeAll(encoder5.encode(text));
  }
  writeLine(text) {
    return this.writeText(text + "\n");
  }
};
var CapturingBufferWriter2 = class {
  #buffer;
  #innerWriter;
  constructor(innerWriter, buffer) {
    this.#innerWriter = innerWriter;
    this.#buffer = buffer;
  }
  getBuffer() {
    return this.#buffer;
  }
  async write(p) {
    const nWritten = await this.#innerWriter.write(p);
    this.#buffer.writeSync(p.slice(0, nWritten));
    return nWritten;
  }
};
var CapturingBufferWriterSync2 = class {
  #buffer;
  #innerWriter;
  constructor(innerWriter, buffer) {
    this.#innerWriter = innerWriter;
    this.#buffer = buffer;
  }
  getBuffer() {
    return this.#buffer;
  }
  writeSync(p) {
    const nWritten = this.#innerWriter.writeSync(p);
    this.#buffer.writeSync(p.slice(0, nWritten));
    return nWritten;
  }
};
var lineFeedCharCode2 = "\n".charCodeAt(0);
var InheritStaticTextBypassWriter2 = class {
  #buffer;
  #innerWriter;
  constructor(innerWriter) {
    this.#innerWriter = innerWriter;
    this.#buffer = new Buffer();
  }
  writeSync(p) {
    const index = p.findLastIndex((v) => v === lineFeedCharCode2);
    if (index === -1) {
      this.#buffer.writeSync(p);
    } else {
      this.#buffer.writeSync(p.slice(0, index + 1));
      this.flush();
      this.#buffer.writeSync(p.slice(index + 1));
    }
    return p.byteLength;
  }
  flush() {
    const bytes = this.#buffer.bytes({ copy: false });
    logger2.logAboveStaticText(() => {
      writeAllSync2(this.#innerWriter, bytes);
    });
    this.#buffer.reset();
  }
};
var PipedBuffer2 = class {
  #inner;
  #hasSet = false;
  constructor() {
    this.#inner = new Buffer();
  }
  getBuffer() {
    if (this.#inner instanceof Buffer) {
      return this.#inner;
    } else {
      return void 0;
    }
  }
  setError(err) {
    if ("setError" in this.#inner) {
      this.#inner.setError(err);
    }
  }
  close() {
    if ("close" in this.#inner) {
      this.#inner.close();
    }
  }
  writeSync(p) {
    return this.#inner.writeSync(p);
  }
  setListener(listener) {
    if (this.#hasSet) {
      throw new Error("Piping to multiple outputs is currently not supported.");
    }
    if (this.#inner instanceof Buffer) {
      writeAllSync2(listener, this.#inner.bytes({ copy: false }));
    }
    this.#inner = listener;
    this.#hasSet = true;
  }
};
var PipeSequencePipe2 = class {
  #inner = new Buffer();
  #readListener;
  #closed = false;
  close() {
    this.#readListener?.();
    this.#closed = true;
  }
  writeSync(p) {
    const value = this.#inner.writeSync(p);
    if (this.#readListener !== void 0) {
      const listener = this.#readListener;
      this.#readListener = void 0;
      listener();
    }
    return value;
  }
  read(p) {
    if (this.#readListener !== void 0) {
      throw new Error("Misuse of PipeSequencePipe");
    }
    if (this.#inner.length === 0) {
      if (this.#closed) {
        return Promise.resolve(null);
      } else {
        return new Promise((resolve7) => {
          this.#readListener = () => {
            resolve7(this.#inner.readSync(p));
          };
        });
      }
    } else {
      return Promise.resolve(this.#inner.readSync(p));
    }
  }
};
async function pipeReadableToWriterSync2(readable, writer, signal) {
  const reader = readable.getReader();
  while (!signal.aborted) {
    const result = await reader.read();
    if (result.done) {
      break;
    }
    const maybePromise = writer.writeAll(result.value);
    if (maybePromise) {
      await maybePromise;
    }
  }
}
var spawnCommand2 = (path, options) => {
  const child = new Deno.Command(path, options).spawn();
  child.status;
  return {
    stdin() {
      return child.stdin;
    },
    kill(signo) {
      child.kill(signo);
    },
    waitExitCode() {
      return child.status.then((status) => status.code);
    },
    stdout() {
      return child.stdout;
    },
    stderr() {
      return child.stderr;
    }
  };
};
var neverAbortedSignal2 = new AbortController().signal;
var RealEnv2 = class {
  setCwd(cwd) {
    Deno.chdir(cwd);
  }
  getCwd() {
    return Deno.cwd();
  }
  setEnvVar(key, value) {
    if (value == null) {
      Deno.env.delete(key);
    } else {
      Deno.env.set(key, value);
    }
  }
  getEnvVar(key) {
    return Deno.env.get(key);
  }
  getEnvVars() {
    return Deno.env.toObject();
  }
  clone() {
    return cloneEnv2(this);
  }
};
var ShellEnv2 = class {
  #cwd;
  #envVars = {};
  setCwd(cwd) {
    this.#cwd = cwd;
  }
  getCwd() {
    if (this.#cwd == null) {
      throw new Error("The cwd must be initialized.");
    }
    return this.#cwd;
  }
  setEnvVar(key, value) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (value == null) {
      delete this.#envVars[key];
    } else {
      this.#envVars[key] = value;
    }
  }
  getEnvVar(key) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    return this.#envVars[key];
  }
  getEnvVars() {
    return { ...this.#envVars };
  }
  clone() {
    return cloneEnv2(this);
  }
};
var RealEnvWriteOnly2 = class {
  real = new RealEnv2();
  shell = new ShellEnv2();
  setCwd(cwd) {
    this.real.setCwd(cwd);
    this.shell.setCwd(cwd);
  }
  getCwd() {
    return this.shell.getCwd();
  }
  setEnvVar(key, value) {
    this.real.setEnvVar(key, value);
    this.shell.setEnvVar(key, value);
  }
  getEnvVar(key) {
    return this.shell.getEnvVar(key);
  }
  getEnvVars() {
    return this.shell.getEnvVars();
  }
  clone() {
    return cloneEnv2(this);
  }
};
function initializeEnv2(env, opts) {
  env.setCwd(opts.cwd);
  for (const [key, value] of Object.entries(opts.env)) {
    env.setEnvVar(key, value);
  }
}
function cloneEnv2(env) {
  const result = new ShellEnv2();
  initializeEnv2(result, {
    cwd: env.getCwd(),
    env: env.getEnvVars()
  });
  return result;
}
var StreamFds2 = class {
  #readers = /* @__PURE__ */ new Map();
  #writers = /* @__PURE__ */ new Map();
  insertReader(fd, stream) {
    this.#readers.set(fd, stream);
  }
  insertWriter(fd, stream) {
    this.#writers.set(fd, stream);
  }
  getReader(fd) {
    return this.#readers.get(fd)?.();
  }
  getWriter(fd) {
    return this.#writers.get(fd)?.();
  }
};
var Context2 = class _Context2 {
  stdin;
  stdout;
  stderr;
  #env;
  #shellVars;
  #static;
  constructor(opts) {
    this.stdin = opts.stdin;
    this.stdout = opts.stdout;
    this.stderr = opts.stderr;
    this.#env = opts.env;
    this.#shellVars = opts.shellVars;
    this.#static = opts.static;
  }
  get signal() {
    return this.#static.signal;
  }
  applyChanges(changes) {
    if (changes == null) {
      return;
    }
    for (const change of changes) {
      switch (change.kind) {
        case "cd":
          this.#env.setCwd(change.dir);
          break;
        case "envvar":
          this.setEnvVar(change.name, change.value);
          break;
        case "shellvar":
          this.setShellVar(change.name, change.value);
          break;
        case "unsetvar":
          this.setShellVar(change.name, void 0);
          this.setEnvVar(change.name, void 0);
          break;
        default: {
          const _assertNever = change;
          throw new Error(`Not implemented env change: ${change}`);
        }
      }
    }
  }
  setEnvVar(key, value) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (key === "PWD") {
      if (value != null && isAbsolute6(value)) {
        this.#env.setCwd(resolve6(value));
      }
    } else {
      delete this.#shellVars[key];
      this.#env.setEnvVar(key, value);
    }
  }
  setShellVar(key, value) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (this.#env.getEnvVar(key) != null || key === "PWD") {
      this.setEnvVar(key, value);
    } else if (value == null) {
      delete this.#shellVars[key];
    } else {
      this.#shellVars[key] = value;
    }
  }
  getEnvVars() {
    return this.#env.getEnvVars();
  }
  getCwd() {
    return this.#env.getCwd();
  }
  getVar(key) {
    if (Deno.build.os === "windows") {
      key = key.toUpperCase();
    }
    if (key === "PWD") {
      return this.#env.getCwd();
    }
    return this.#env.getEnvVar(key) ?? this.#shellVars[key];
  }
  getCommand(command) {
    return this.#static.commands[command] ?? null;
  }
  getFdReader(fd) {
    return this.#static.fds?.getReader(fd);
  }
  getFdWriter(fd) {
    return this.#static.fds?.getWriter(fd);
  }
  asCommandContext(args) {
    const context = this;
    return {
      get args() {
        return args;
      },
      get cwd() {
        return context.getCwd();
      },
      get env() {
        return context.getEnvVars();
      },
      get stdin() {
        return context.stdin;
      },
      get stdout() {
        return context.stdout;
      },
      get stderr() {
        return context.stderr;
      },
      get signal() {
        return context.signal;
      },
      error(codeOrText, maybeText) {
        return context.error(codeOrText, maybeText);
      }
    };
  }
  error(codeOrText, maybeText) {
    let code4;
    let text;
    if (typeof codeOrText === "number") {
      code4 = codeOrText;
      text = maybeText;
    } else {
      code4 = 1;
      text = codeOrText;
    }
    const maybePromise = this.stderr.writeLine(text);
    if (maybePromise instanceof Promise) {
      return maybePromise.then(() => ({ code: code4 }));
    } else {
      return { code: code4 };
    }
  }
  withInner(opts) {
    return new _Context2({
      stdin: opts.stdin ?? this.stdin,
      stdout: opts.stdout ?? this.stdout,
      stderr: opts.stderr ?? this.stderr,
      env: this.#env.clone(),
      shellVars: { ...this.#shellVars },
      static: this.#static
    });
  }
  clone() {
    return new _Context2({
      stdin: this.stdin,
      stdout: this.stdout,
      stderr: this.stderr,
      env: this.#env.clone(),
      shellVars: { ...this.#shellVars },
      static: this.#static
    });
  }
};
function parseCommand2(command) {
  return wasmInstance2.parse(command);
}
async function spawn2(list, opts) {
  const env = opts.exportEnv ? opts.clearedEnv ? new RealEnvWriteOnly2() : new RealEnv2() : new ShellEnv2();
  initializeEnv2(env, opts);
  const context = new Context2({
    env,
    stdin: opts.stdin,
    stdout: opts.stdout,
    stderr: opts.stderr,
    shellVars: {},
    static: {
      commands: opts.commands,
      fds: opts.fds,
      signal: opts.signal
    }
  });
  const result = await executeSequentialList2(list, context);
  return result.code;
}
async function executeSequentialList2(list, context) {
  let finalExitCode = 0;
  const finalChanges = [];
  for (const item of list.items) {
    if (item.isAsync) {
      throw new Error("Async commands are not supported. Run a command concurrently in the JS code instead.");
    }
    const result = await executeSequence2(item.sequence, context);
    switch (result.kind) {
      case void 0:
        if (result.changes) {
          context.applyChanges(result.changes);
          finalChanges.push(...result.changes);
        }
        finalExitCode = result.code;
        break;
      case "exit":
        return result;
      default: {
        const _assertNever = result;
      }
    }
  }
  return {
    code: finalExitCode,
    changes: finalChanges
  };
}
function executeSequence2(sequence, context) {
  if (context.signal.aborted) {
    return Promise.resolve(getAbortedResult2());
  }
  switch (sequence.kind) {
    case "pipeline":
      return executePipeline2(sequence, context);
    case "booleanList":
      return executeBooleanList2(sequence, context);
    case "shellVar":
      return executeShellVar2(sequence, context);
    default: {
      const _assertNever = sequence;
      throw new Error(`Not implemented: ${sequence}`);
    }
  }
}
function executePipeline2(pipeline, context) {
  if (pipeline.negated) {
    throw new Error("Negated pipelines are not implemented.");
  }
  return executePipelineInner2(pipeline.inner, context);
}
async function executeBooleanList2(list, context) {
  const changes = [];
  const firstResult = await executeSequence2(
    list.current,
    context.clone()
  );
  let exitCode = 0;
  switch (firstResult.kind) {
    case "exit":
      return firstResult;
    case void 0:
      if (firstResult.changes) {
        context.applyChanges(firstResult.changes);
        changes.push(...firstResult.changes);
      }
      exitCode = firstResult.code;
      break;
    default: {
      const _assertNever = firstResult;
      throw new Error("Not handled.");
    }
  }
  const next = findNextSequence(list, exitCode);
  if (next == null) {
    return {
      code: exitCode,
      changes
    };
  } else {
    const nextResult = await executeSequence2(
      next,
      context.clone()
    );
    switch (nextResult.kind) {
      case "exit":
        return nextResult;
      case void 0:
        if (nextResult.changes) {
          changes.push(...nextResult.changes);
        }
        return {
          code: nextResult.code,
          changes
        };
      default: {
        const _assertNever = nextResult;
        throw new Error("Not Implemented");
      }
    }
  }
  function findNextSequence(current, exitCode2) {
    if (opMovesNextForExitCode(current.op, exitCode2)) {
      return current.next;
    } else {
      let next2 = current.next;
      while (next2.kind === "booleanList") {
        if (opMovesNextForExitCode(next2.op, exitCode2)) {
          return next2.next;
        } else {
          next2 = next2.next;
        }
      }
      return void 0;
    }
  }
  function opMovesNextForExitCode(op, exitCode2) {
    switch (op) {
      case "or":
        return exitCode2 !== 0;
      case "and":
        return exitCode2 === 0;
    }
  }
}
async function executeShellVar2(sequence, context) {
  const value = await evaluateWord2(sequence.value, context);
  return {
    code: 0,
    changes: [{
      kind: "shellvar",
      name: sequence.name,
      value
    }]
  };
}
function executePipelineInner2(inner, context) {
  switch (inner.kind) {
    case "command":
      return executeCommand2(inner, context);
    case "pipeSequence":
      return executePipeSequence2(inner, context);
    default: {
      const _assertNever = inner;
      throw new Error(`Not implemented: ${inner.kind}`);
    }
  }
}
async function executeCommand2(command, context) {
  if (command.redirect != null) {
    const redirectResult = await resolveRedirectPipe2(command.redirect, context);
    let redirectPipe;
    if (redirectResult.kind === "input") {
      const { pipe } = redirectResult;
      context = context.withInner({
        stdin: pipe
      });
      redirectPipe = pipe;
    } else if (redirectResult.kind === "output") {
      const { pipe, toFd } = redirectResult;
      const writer = new ShellPipeWriter2("piped", pipe);
      redirectPipe = pipe;
      if (toFd === 1) {
        context = context.withInner({
          stdout: writer
        });
      } else if (toFd === 2) {
        context = context.withInner({
          stderr: writer
        });
      } else {
        const _assertNever = toFd;
        throw new Error(`Not handled fd: ${toFd}`);
      }
    } else {
      return redirectResult;
    }
    const result = await executeCommandInner2(command.inner, context);
    try {
      if (isAsyncDisposable2(redirectPipe)) {
        await redirectPipe[Symbol.asyncDispose]();
      } else if (isDisposable2(redirectPipe)) {
        redirectPipe[Symbol.dispose]();
      }
    } catch (err) {
      if (result.code === 0) {
        return context.error(`failed disposing redirected pipe. ${errorToString2(err)}`);
      }
    }
    return result;
  } else {
    return executeCommandInner2(command.inner, context);
  }
}
async function resolveRedirectPipe2(redirect, context) {
  function handleFileOpenError(outputPath, err) {
    return context.error(`failed opening file for redirect (${outputPath}). ${errorToString2(err)}`);
  }
  const toFd = resolveRedirectToFd2(redirect, context);
  if (typeof toFd !== "number") {
    return toFd;
  }
  const { ioFile } = redirect;
  if (ioFile.kind === "fd") {
    switch (redirect.op.kind) {
      case "input": {
        if (ioFile.value === 0) {
          return {
            kind: "input",
            pipe: getStdinReader2(context.stdin)
          };
        } else if (ioFile.value === 1 || ioFile.value === 2) {
          return context.error(`redirecting stdout or stderr to a command input is not supported`);
        } else {
          const pipe = context.getFdReader(ioFile.value);
          if (pipe == null) {
            return context.error(`could not find fd reader: ${ioFile.value}`);
          } else {
            return {
              kind: "input",
              pipe
            };
          }
        }
      }
      case "output": {
        if (ioFile.value === 0) {
          return context.error(`redirecting output to stdin is not supported`);
        } else if (ioFile.value === 1) {
          return {
            kind: "output",
            pipe: context.stdout.inner,
            toFd
          };
        } else if (ioFile.value === 2) {
          return {
            kind: "output",
            pipe: context.stderr.inner,
            toFd
          };
        } else {
          const pipe = context.getFdWriter(ioFile.value);
          if (pipe == null) {
            return context.error(`could not find fd: ${ioFile.value}`);
          } else {
            return {
              kind: "output",
              pipe,
              toFd
            };
          }
        }
      }
      default: {
        const _assertNever = redirect.op;
        throw new Error("not implemented redirect op.");
      }
    }
  } else if (ioFile.kind === "word") {
    const words = await evaluateWordParts2(ioFile.value, context);
    if (words.length === 0) {
      return context.error("redirect path must be 1 argument, but found 0");
    } else if (words.length > 1) {
      return context.error(
        `redirect path must be 1 argument, but found ${words.length} (${words.join(" ")}). Did you mean to quote it (ex. "${words.join(" ")}")?`
      );
    }
    switch (redirect.op.kind) {
      case "input": {
        const outputPath = isAbsolute6(words[0]) ? words[0] : join6(context.getCwd(), words[0]);
        try {
          const file = await Deno.open(outputPath, {
            read: true
          });
          return {
            kind: "input",
            pipe: file
          };
        } catch (err) {
          return handleFileOpenError(outputPath, err);
        }
      }
      case "output": {
        if (words[0] === "/dev/null") {
          return {
            kind: "output",
            pipe: new NullPipeWriter2(),
            toFd
          };
        }
        const outputPath = isAbsolute6(words[0]) ? words[0] : join6(context.getCwd(), words[0]);
        try {
          const file = await Deno.open(outputPath, {
            write: true,
            create: true,
            append: redirect.op.value === "append",
            truncate: redirect.op.value !== "append"
          });
          return {
            kind: "output",
            pipe: file,
            toFd
          };
        } catch (err) {
          return handleFileOpenError(outputPath, err);
        }
      }
      default: {
        const _assertNever = redirect.op;
        throw new Error("not implemented redirect op.");
      }
    }
  } else {
    const _assertNever = ioFile;
    throw new Error("not implemented redirect io file.");
  }
}
function getStdinReader2(stdin) {
  if (stdin === "inherit") {
    return Deno.stdin;
  } else if (stdin === "null") {
    return new NullPipeReader2();
  } else {
    return stdin;
  }
}
function resolveRedirectToFd2(redirect, context) {
  const maybeFd = redirect.maybeFd;
  if (maybeFd == null) {
    return 1;
  }
  if (maybeFd.kind === "stdoutStderr") {
    return context.error("redirecting to both stdout and stderr is not implemented");
  }
  if (maybeFd.fd !== 1 && maybeFd.fd !== 2) {
    return context.error(`only redirecting to stdout (1) and stderr (2) is supported`);
  } else {
    return maybeFd.fd;
  }
}
function executeCommandInner2(command, context) {
  switch (command.kind) {
    case "simple":
      return executeSimpleCommand2(command, context);
    case "subshell":
      return executeSubshell2(command, context);
    default: {
      const _assertNever = command;
      throw new Error(`Not implemented: ${command.kind}`);
    }
  }
}
async function executeSimpleCommand2(command, parentContext) {
  const context = parentContext.clone();
  for (const envVar of command.envVars) {
    context.setEnvVar(envVar.name, await evaluateWord2(envVar.value, context));
  }
  const commandArgs = await evaluateArgs2(command.args, context);
  return await executeCommandArgs2(commandArgs, context);
}
function checkMapCwdNotExistsError2(cwd, err) {
  if (err.code === "ENOENT" && !existsSync2(cwd)) {
    throw new Error(`Failed to launch command because the cwd does not exist (${cwd}).`, {
      cause: err
    });
  } else {
    throw err;
  }
}
function executeCommandArgs2(commandArgs, context) {
  const commandName = commandArgs.shift();
  const command = context.getCommand(commandName);
  if (command != null) {
    return Promise.resolve(command(context.asCommandContext(commandArgs)));
  }
  const unresolvedCommand = {
    name: commandName,
    baseDir: context.getCwd()
  };
  return executeUnresolvedCommand2(unresolvedCommand, commandArgs, context);
}
async function executeUnresolvedCommand2(unresolvedCommand, commandArgs, context) {
  const resolvedCommand = await resolveCommand2(unresolvedCommand, context);
  if (resolvedCommand === false) {
    context.stderr.writeLine(`dax: ${unresolvedCommand.name}: command not found`);
    return { code: 127 };
  }
  if (resolvedCommand.kind === "shebang") {
    return executeUnresolvedCommand2(resolvedCommand.command, [...resolvedCommand.args, ...commandArgs], context);
  }
  const _assertIsPath = resolvedCommand.kind;
  return executeCommandAtPath2(resolvedCommand.path, commandArgs, context);
}
async function executeCommandAtPath2(commandPath, commandArgs, context) {
  const pipeStringVals = {
    stdin: getStdioStringValue(context.stdin),
    stdout: getStdioStringValue(context.stdout.kind),
    stderr: getStdioStringValue(context.stderr.kind)
  };
  let p;
  const cwd = context.getCwd();
  try {
    p = spawnCommand2(commandPath, {
      args: commandArgs,
      cwd,
      env: context.getEnvVars(),
      clearEnv: true,
      ...pipeStringVals
    });
  } catch (err) {
    throw checkMapCwdNotExistsError2(cwd, err);
  }
  const listener = (signal) => p.kill(signal);
  context.signal.addListener(listener);
  const completeController = new AbortController();
  const completeSignal = completeController.signal;
  let stdinError;
  const stdinPromise = writeStdin(context.stdin, p, completeSignal).catch(async (err) => {
    if (completeSignal.aborted) {
      return;
    }
    const maybePromise = context.stderr.writeLine(`stdin pipe broken. ${errorToString2(err)}`);
    if (maybePromise != null) {
      await maybePromise;
    }
    stdinError = err;
    try {
      p.kill("SIGKILL");
    } catch (err2) {
      if (!(err2 instanceof Deno.errors.PermissionDenied || err2 instanceof Deno.errors.NotFound)) {
        throw err2;
      }
    }
  });
  try {
    const readStdoutTask = pipeStringVals.stdout === "piped" ? readStdOutOrErr(p.stdout(), context.stdout) : Promise.resolve();
    const readStderrTask = pipeStringVals.stderr === "piped" ? readStdOutOrErr(p.stderr(), context.stderr) : Promise.resolve();
    const [exitCode] = await Promise.all([
      p.waitExitCode().catch((err) => Promise.reject(checkMapCwdNotExistsError2(cwd, err))),
      readStdoutTask,
      readStderrTask
    ]);
    if (stdinError != null) {
      return {
        code: 1,
        kind: "exit"
      };
    } else {
      return { code: exitCode };
    }
  } finally {
    completeController.abort();
    context.signal.removeListener(listener);
    await stdinPromise;
  }
  async function writeStdin(stdin, p2, signal) {
    if (typeof stdin === "string") {
      return;
    }
    const processStdin = p2.stdin();
    await pipeReaderToWritable2(stdin, processStdin, signal);
    try {
      await processStdin.close();
    } catch {
    }
  }
  async function readStdOutOrErr(readable, writer) {
    if (typeof writer === "string") {
      return;
    }
    await pipeReadableToWriterSync2(readable, writer, neverAbortedSignal2);
  }
  function getStdioStringValue(value) {
    if (value === "inheritPiped") {
      return "piped";
    } else if (value === "inherit" || value === "null" || value === "piped") {
      return value;
    } else {
      return "piped";
    }
  }
}
async function executeSubshell2(subshell, context) {
  const result = await executeSequentialList2(subshell, context);
  return { code: result.code };
}
async function pipeReaderToWritable2(reader, writable, signal) {
  const abortedPromise = new Promise((resolve7) => {
    signal.addEventListener("abort", listener);
    function listener() {
      signal.removeEventListener("abort", listener);
      resolve7();
    }
  });
  const writer = writable.getWriter();
  try {
    while (!signal.aborted) {
      const buffer = new Uint8Array(1024);
      const length = await Promise.race([abortedPromise, reader.read(buffer)]);
      if (length === 0 || length == null) {
        break;
      }
      await writer.write(buffer.subarray(0, length));
    }
  } finally {
    await writer.close();
  }
}
async function pipeReaderToWriterSync2(reader, writer, signal) {
  const buffer = new Uint8Array(1024);
  while (!signal.aborted) {
    const bytesRead = await reader.read(buffer);
    if (bytesRead == null || bytesRead === 0) {
      break;
    }
    const maybePromise = writer.writeAll(buffer.slice(0, bytesRead));
    if (maybePromise) {
      await maybePromise;
    }
  }
}
function pipeCommandPipeReaderToWriterSync2(reader, writer, signal) {
  switch (reader) {
    case "inherit":
      return pipeReadableToWriterSync2(Deno.stdin.readable, writer, signal);
    case "null":
      return Promise.resolve();
    default: {
      return pipeReaderToWriterSync2(reader, writer, signal);
    }
  }
}
async function resolveCommand2(unresolvedCommand, context) {
  if (unresolvedCommand.name.includes("/")) {
    const commandPath2 = isAbsolute6(unresolvedCommand.name) ? unresolvedCommand.name : resolve6(unresolvedCommand.baseDir, unresolvedCommand.name);
    const result = await getExecutableShebangFromPath2(commandPath2);
    if (result === false) {
      return false;
    } else if (result != null) {
      const args = await parseShebangArgs2(result, context);
      const name = args.shift();
      args.push(commandPath2);
      return {
        kind: "shebang",
        command: {
          name,
          baseDir: dirname6(commandPath2)
        },
        args
      };
    } else {
      const _assertUndefined = result;
      return {
        kind: "path",
        path: commandPath2
      };
    }
  }
  const commandPath = await whichFromContext2(unresolvedCommand.name, context);
  if (commandPath == null) {
    return false;
  }
  return {
    kind: "path",
    path: commandPath
  };
}
var WhichEnv2 = class extends RealEnvironment {
  requestPermission(folderPath) {
    Deno.permissions.requestSync({
      name: "read",
      path: folderPath
    });
  }
};
var denoWhichRealEnv2 = new WhichEnv2();
async function whichFromContext2(commandName, context) {
  if (commandName.toUpperCase() === "DENO") {
    return Deno.execPath();
  }
  return await which(commandName, {
    os: Deno.build.os,
    stat: denoWhichRealEnv2.stat,
    env(key) {
      return context.getVar(key);
    },
    requestPermission: denoWhichRealEnv2.requestPermission
  });
}
async function executePipeSequence2(sequence, context) {
  const waitTasks = [];
  let lastOutput = context.stdin;
  let nextInner = sequence;
  while (nextInner != null) {
    let innerCommand;
    switch (nextInner.kind) {
      case "pipeSequence":
        switch (nextInner.op) {
          case "stdout": {
            innerCommand = nextInner.current;
            break;
          }
          case "stdoutstderr": {
            return context.error(`piping to both stdout and stderr is not implemented (ex. |&)`);
          }
          default: {
            const _assertNever = nextInner.op;
            return context.error(`not implemented pipe sequence op: ${nextInner.op}`);
          }
        }
        nextInner = nextInner.next;
        break;
      case "command":
        innerCommand = nextInner;
        nextInner = void 0;
        break;
    }
    const buffer = new PipeSequencePipe2();
    const newContext = context.withInner({
      stdout: new ShellPipeWriter2("piped", buffer),
      stdin: lastOutput
    });
    const commandPromise = executeCommand2(innerCommand, newContext);
    waitTasks.push(commandPromise);
    commandPromise.finally(() => {
      buffer.close();
    });
    lastOutput = buffer;
  }
  waitTasks.push(
    pipeCommandPipeReaderToWriterSync2(lastOutput, context.stdout, context.signal).then(() => ({ code: 0 }))
  );
  const results = await Promise.all(waitTasks);
  const secondLastResult = results[results.length - 2];
  return secondLastResult;
}
async function parseShebangArgs2(info, context) {
  function throwUnsupported() {
    throw new Error("Unsupported shebang. Please report this as a bug.");
  }
  if (!info.stringSplit) {
    return [info.command];
  }
  const command = parseCommand2(info.command);
  if (command.items.length !== 1) {
    throwUnsupported();
  }
  const item = command.items[0];
  if (item.sequence.kind !== "pipeline" || item.isAsync) {
    throwUnsupported();
  }
  const sequence = item.sequence;
  if (sequence.negated) {
    throwUnsupported();
  }
  if (sequence.inner.kind !== "command" || sequence.inner.redirect != null) {
    throwUnsupported();
  }
  const innerCommand = sequence.inner.inner;
  if (innerCommand.kind !== "simple") {
    throwUnsupported();
  }
  if (innerCommand.envVars.length > 0) {
    throwUnsupported();
  }
  return await evaluateArgs2(innerCommand.args, context);
}
async function evaluateArgs2(args, context) {
  const result = [];
  for (const arg of args) {
    result.push(...await evaluateWordParts2(arg, context));
  }
  return result;
}
async function evaluateWord2(word, context) {
  const result = await evaluateWordParts2(word, context);
  return result.join(" ");
}
async function evaluateWordParts2(wordParts, context, quoted = false) {
  const result = [];
  let currentText = "";
  let hasQuoted = false;
  for (const stringPart of wordParts) {
    let evaluationResult = void 0;
    switch (stringPart.kind) {
      case "text":
        currentText += stringPart.value;
        break;
      case "variable":
        evaluationResult = context.getVar(stringPart.value);
        break;
      case "quoted": {
        const text = (await evaluateWordParts2(stringPart.value, context, true)).join("");
        currentText += text;
        hasQuoted = true;
        continue;
      }
      case "command":
      default:
        throw new Error(`Not implemented: ${stringPart.kind}`);
    }
    if (evaluationResult != null) {
      if (quoted) {
        currentText += evaluationResult;
      } else {
        const parts = evaluationResult.split(" ").map((t) => t.trim()).filter((t) => t.length > 0);
        if (parts.length > 0) {
          currentText += parts[0];
          result.push(currentText);
          result.push(...parts.slice(1));
          currentText = result.pop();
        }
      }
    }
  }
  if (hasQuoted || currentText.length !== 0) {
    result.push(currentText);
  }
  return result;
}
function isDisposable2(value) {
  return value != null && typeof value[Symbol.dispose] === "function";
}
function isAsyncDisposable2(value) {
  return value != null && typeof value[Symbol.asyncDispose] === "function";
}
async function whichCommand2(context) {
  try {
    return await executeWhich2(context);
  } catch (err) {
    return context.error(`which: ${errorToString2(err)}`);
  }
}
async function executeWhich2(context) {
  let flags;
  try {
    flags = parseArgs20(context.args);
  } catch (err) {
    return await context.error(2, `which: ${errorToString2(err)}`);
  }
  if (flags.commandName == null) {
    return { code: 1 };
  }
  const path = await whichFromContext2(flags.commandName, {
    getVar(key) {
      return context.env[key];
    }
  });
  if (path != null) {
    await context.stdout.writeLine(path);
    return { code: 0 };
  } else {
    return { code: 1 };
  }
}
function parseArgs20(args) {
  let commandName;
  for (const arg of parseArgKinds2(args)) {
    if (arg.kind === "Arg") {
      if (commandName != null) {
        throw Error("unsupported too many arguments");
      }
      commandName = arg.arg;
    } else {
      bailUnsupported6(arg);
    }
  }
  return {
    commandName
  };
}
function bailUnsupported6(arg) {
  switch (arg.kind) {
    case "Arg":
      throw Error(`unsupported argument: ${arg.arg}`);
    case "ShortFlag":
      throw Error(`unsupported flag: -${arg.arg}`);
    case "LongFlag":
      throw Error(`unsupported flag: --${arg.arg}`);
  }
}
function getFileInfoType2(fileInfo) {
  return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : void 0;
}
async function ensureDir2(dir) {
  try {
    const fileInfo = await Deno.lstat(dir);
    if (!fileInfo.isDirectory) {
      throw new Error(
        `Ensure path exists, expected 'dir', got '${getFileInfoType2(fileInfo)}'`
      );
    }
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    await Deno.mkdir(dir, { recursive: true });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = await Deno.lstat(dir);
    if (!fileInfo.isDirectory) {
      throw new Error(
        `Ensure path exists, expected 'dir', got '${getFileInfoType2(fileInfo)}'`
      );
    }
  }
}
function ensureDirSync2(dir) {
  try {
    const fileInfo = Deno.lstatSync(dir);
    if (!fileInfo.isDirectory) {
      throw new Error(
        `Ensure path exists, expected 'dir', got '${getFileInfoType2(fileInfo)}'`
      );
    }
    return;
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
  }
  try {
    Deno.mkdirSync(dir, { recursive: true });
  } catch (err) {
    if (!(err instanceof Deno.errors.AlreadyExists)) {
      throw err;
    }
    const fileInfo = Deno.lstatSync(dir);
    if (!fileInfo.isDirectory) {
      throw new Error(
        `Ensure path exists, expected 'dir', got '${getFileInfoType2(fileInfo)}'`
      );
    }
  }
}
function toPathString2(pathUrl) {
  return pathUrl instanceof URL ? fromFileUrl6(pathUrl) : pathUrl;
}
function isSubdir2(src, dest, sep = SEPARATOR6) {
  if (src === dest) {
    return false;
  }
  src = toPathString2(src);
  const srcArray = src.split(sep);
  dest = toPathString2(dest);
  const destArray = dest.split(sep);
  return srcArray.every((current, i) => destArray[i] === current);
}
var isWindows6 = Deno.build.os === "windows";
async function ensureValidCopy2(src, dest, options) {
  let destStat;
  try {
    destStat = await Deno.lstat(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options.isFolder && !destStat.isDirectory) {
    throw new Error(
      `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
    );
  }
  if (!options.overwrite) {
    throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
  }
  return destStat;
}
function ensureValidCopySync2(src, dest, options) {
  let destStat;
  try {
    destStat = Deno.lstatSync(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options.isFolder && !destStat.isDirectory) {
    throw new Error(
      `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
    );
  }
  if (!options.overwrite) {
    throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
  }
  return destStat;
}
async function copyFile2(src, dest, options) {
  await ensureValidCopy2(src, dest, options);
  await Deno.copyFile(src, dest);
  if (options.preserveTimestamps) {
    const statInfo = await Deno.stat(src);
    assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
  }
}
function copyFileSync2(src, dest, options) {
  ensureValidCopySync2(src, dest, options);
  Deno.copyFileSync(src, dest);
  if (options.preserveTimestamps) {
    const statInfo = Deno.statSync(src);
    assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copySymLink2(src, dest, options) {
  await ensureValidCopy2(src, dest, options);
  const originSrcFilePath = await Deno.readLink(src);
  const type2 = getFileInfoType2(await Deno.lstat(src));
  if (isWindows6) {
    await Deno.symlink(originSrcFilePath, dest, {
      type: type2 === "dir" ? "dir" : "file"
    });
  } else {
    await Deno.symlink(originSrcFilePath, dest);
  }
  if (options.preserveTimestamps) {
    const statInfo = await Deno.lstat(src);
    assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    await Deno.utime(dest, statInfo.atime, statInfo.mtime);
  }
}
function copySymlinkSync2(src, dest, options) {
  ensureValidCopySync2(src, dest, options);
  const originSrcFilePath = Deno.readLinkSync(src);
  const type2 = getFileInfoType2(Deno.lstatSync(src));
  if (isWindows6) {
    Deno.symlinkSync(originSrcFilePath, dest, {
      type: type2 === "dir" ? "dir" : "file"
    });
  } else {
    Deno.symlinkSync(originSrcFilePath, dest);
  }
  if (options.preserveTimestamps) {
    const statInfo = Deno.lstatSync(src);
    assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copyDir2(src, dest, options) {
  const destStat = await ensureValidCopy2(src, dest, {
    ...options,
    isFolder: true
  });
  if (!destStat) {
    await ensureDir2(dest);
  }
  if (options.preserveTimestamps) {
    const srcStatInfo = await Deno.stat(src);
    assert2(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert2(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    await Deno.utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  src = toPathString2(src);
  dest = toPathString2(dest);
  const promises = [];
  for await (const entry of Deno.readDir(src)) {
    const srcPath = join6(src, entry.name);
    const destPath = join6(dest, basename6(srcPath));
    if (entry.isSymlink) {
      promises.push(copySymLink2(srcPath, destPath, options));
    } else if (entry.isDirectory) {
      promises.push(copyDir2(srcPath, destPath, options));
    } else if (entry.isFile) {
      promises.push(copyFile2(srcPath, destPath, options));
    }
  }
  await Promise.all(promises);
}
function copyDirSync2(src, dest, options) {
  const destStat = ensureValidCopySync2(src, dest, {
    ...options,
    isFolder: true
  });
  if (!destStat) {
    ensureDirSync2(dest);
  }
  if (options.preserveTimestamps) {
    const srcStatInfo = Deno.statSync(src);
    assert2(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert2(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    Deno.utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  src = toPathString2(src);
  dest = toPathString2(dest);
  for (const entry of Deno.readDirSync(src)) {
    const srcPath = join6(src, entry.name);
    const destPath = join6(dest, basename6(srcPath));
    if (entry.isSymlink) {
      copySymlinkSync2(srcPath, destPath, options);
    } else if (entry.isDirectory) {
      copyDirSync2(srcPath, destPath, options);
    } else if (entry.isFile) {
      copyFileSync2(srcPath, destPath, options);
    }
  }
}
async function copy3(src, dest, options = {}) {
  src = resolve6(toPathString2(src));
  dest = resolve6(toPathString2(dest));
  if (src === dest) {
    throw new Error("Source and destination cannot be the same.");
  }
  const srcStat = await Deno.lstat(src);
  if (srcStat.isDirectory && isSubdir2(src, dest)) {
    throw new Error(
      `Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`
    );
  }
  if (srcStat.isSymlink) {
    await copySymLink2(src, dest, options);
  } else if (srcStat.isDirectory) {
    await copyDir2(src, dest, options);
  } else if (srcStat.isFile) {
    await copyFile2(src, dest, options);
  }
}
function copySync2(src, dest, options = {}) {
  src = resolve6(toPathString2(src));
  dest = resolve6(toPathString2(dest));
  if (src === dest) {
    throw new Error("Source and destination cannot be the same.");
  }
  const srcStat = Deno.lstatSync(src);
  if (srcStat.isDirectory && isSubdir2(src, dest)) {
    throw new Error(
      `Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`
    );
  }
  if (srcStat.isSymlink) {
    copySymlinkSync2(src, dest, options);
  } else if (srcStat.isDirectory) {
    copyDirSync2(src, dest, options);
  } else if (srcStat.isFile) {
    copyFileSync2(src, dest, options);
  }
}
async function emptyDir2(dir) {
  try {
    const items = await Array.fromAsync(Deno.readDir(dir));
    await Promise.all(items.map((item) => {
      if (item && item.name) {
        const filepath = join6(toPathString2(dir), item.name);
        return Deno.remove(filepath, { recursive: true });
      }
    }));
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    await Deno.mkdir(dir, { recursive: true });
  }
}
function emptyDirSync2(dir) {
  try {
    const items = [...Deno.readDirSync(dir)];
    while (items.length) {
      const item = items.shift();
      if (item && item.name) {
        const filepath = join6(toPathString2(dir), item.name);
        Deno.removeSync(filepath, { recursive: true });
      }
    }
  } catch (err) {
    if (!(err instanceof Deno.errors.NotFound)) {
      throw err;
    }
    Deno.mkdirSync(dir, { recursive: true });
  }
}
async function ensureFile2(filePath) {
  try {
    const stat = await Deno.lstat(filePath);
    if (!stat.isFile) {
      throw new Error(
        `Ensure path exists, expected 'file', got '${getFileInfoType2(stat)}'`
      );
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      await ensureDir2(dirname6(toPathString2(filePath)));
      await Deno.writeFile(filePath, new Uint8Array());
      return;
    }
    throw err;
  }
}
function ensureFileSync2(filePath) {
  try {
    const stat = Deno.lstatSync(filePath);
    if (!stat.isFile) {
      throw new Error(
        `Ensure path exists, expected 'file', got '${getFileInfoType2(stat)}'`
      );
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      ensureDirSync2(dirname6(toPathString2(filePath)));
      Deno.writeFileSync(filePath, new Uint8Array());
      return;
    }
    throw err;
  }
}
function createWalkEntrySync2(path) {
  path = toPathString2(path);
  path = normalize6(path);
  const name = basename6(path);
  const info = Deno.statSync(path);
  return {
    path,
    name,
    isFile: info.isFile,
    isDirectory: info.isDirectory,
    isSymlink: info.isSymlink
  };
}
async function createWalkEntry2(path) {
  path = toPathString2(path);
  path = normalize6(path);
  const name = basename6(path);
  const info = await Deno.stat(path);
  return {
    path,
    name,
    isFile: info.isFile,
    isDirectory: info.isDirectory,
    isSymlink: info.isSymlink
  };
}
var WalkError = class extends Error {
  /** File path of the root that's being walked. */
  root;
  /** Constructs a new instance. */
  constructor(cause, root) {
    super(
      `${cause instanceof Error ? cause.message : cause} for path "${root}"`
    );
    this.cause = cause;
    this.name = this.constructor.name;
    this.root = root;
  }
};
function include2(path, exts, match, skip) {
  if (exts && !exts.some((ext) => path.endsWith(ext))) {
    return false;
  }
  if (match && !match.some((pattern) => !!path.match(pattern))) {
    return false;
  }
  if (skip && skip.some((pattern) => !!path.match(pattern))) {
    return false;
  }
  return true;
}
function wrapErrorWithPath(err, root) {
  if (err instanceof WalkError) return err;
  return new WalkError(err, root);
}
async function* walk2(root, {
  maxDepth = Infinity,
  includeFiles = true,
  includeDirs = true,
  includeSymlinks = true,
  followSymlinks = false,
  canonicalize = true,
  exts = void 0,
  match = void 0,
  skip = void 0
} = {}) {
  if (maxDepth < 0) {
    return;
  }
  root = toPathString2(root);
  if (includeDirs && include2(root, exts, match, skip)) {
    yield await createWalkEntry2(root);
  }
  if (maxDepth < 1 || !include2(root, void 0, void 0, skip)) {
    return;
  }
  try {
    for await (const entry of Deno.readDir(root)) {
      let path = join6(root, entry.name);
      let { isSymlink, isDirectory: isDirectory3 } = entry;
      if (isSymlink) {
        if (!followSymlinks) {
          if (includeSymlinks && include2(path, exts, match, skip)) {
            yield { path, ...entry };
          }
          continue;
        }
        const realPath = await Deno.realPath(path);
        if (canonicalize) {
          path = realPath;
        }
        ({ isSymlink, isDirectory: isDirectory3 } = await Deno.lstat(realPath));
      }
      if (isSymlink || isDirectory3) {
        yield* walk2(path, {
          maxDepth: maxDepth - 1,
          includeFiles,
          includeDirs,
          includeSymlinks,
          followSymlinks,
          exts,
          match,
          skip
        });
      } else if (includeFiles && include2(path, exts, match, skip)) {
        yield { path, ...entry };
      }
    }
  } catch (err) {
    throw wrapErrorWithPath(err, normalize6(root));
  }
}
function* walkSync2(root, {
  maxDepth = Infinity,
  includeFiles = true,
  includeDirs = true,
  includeSymlinks = true,
  followSymlinks = false,
  canonicalize = true,
  exts = void 0,
  match = void 0,
  skip = void 0
} = {}) {
  root = toPathString2(root);
  if (maxDepth < 0) {
    return;
  }
  if (includeDirs && include2(root, exts, match, skip)) {
    yield createWalkEntrySync2(root);
  }
  if (maxDepth < 1 || !include2(root, void 0, void 0, skip)) {
    return;
  }
  let entries;
  try {
    entries = Deno.readDirSync(root);
  } catch (err) {
    throw wrapErrorWithPath(err, normalize6(root));
  }
  for (const entry of entries) {
    let path = join6(root, entry.name);
    let { isSymlink, isDirectory: isDirectory3 } = entry;
    if (isSymlink) {
      if (!followSymlinks) {
        if (includeSymlinks && include2(path, exts, match, skip)) {
          yield { path, ...entry };
        }
        continue;
      }
      const realPath = Deno.realPathSync(path);
      if (canonicalize) {
        path = realPath;
      }
      ({ isSymlink, isDirectory: isDirectory3 } = Deno.lstatSync(realPath));
    }
    if (isSymlink || isDirectory3) {
      yield* walkSync2(path, {
        maxDepth: maxDepth - 1,
        includeFiles,
        includeDirs,
        includeSymlinks,
        followSymlinks,
        exts,
        match,
        skip
      });
    } else if (includeFiles && include2(path, exts, match, skip)) {
      yield { path, ...entry };
    }
  }
}
var isWindows7 = Deno.build.os === "windows";
function split(path) {
  const s = SEPARATOR_PATTERN6.source;
  const segments = path.replace(new RegExp(`^${s}|${s}$`, "g"), "").split(SEPARATOR_PATTERN6);
  const isAbsolute_ = isAbsolute6(path);
  return {
    segments,
    isAbsolute: isAbsolute_,
    hasTrailingSep: !!path.match(new RegExp(`${s}$`)),
    winRoot: isWindows7 && isAbsolute_ ? segments.shift() : void 0
  };
}
function throwUnlessNotFound(error) {
  if (!(error instanceof Deno.errors.NotFound)) {
    throw error;
  }
}
function comparePath(a, b) {
  if (a.path < b.path) return -1;
  if (a.path > b.path) return 1;
  return 0;
}
async function* expandGlob(glob, {
  root,
  exclude = [],
  includeDirs = true,
  extended = true,
  globstar = true,
  caseInsensitive,
  followSymlinks,
  canonicalize
} = {}) {
  const {
    segments,
    isAbsolute: isGlobAbsolute,
    hasTrailingSep,
    winRoot
  } = split(toPathString2(glob));
  root ??= isGlobAbsolute ? winRoot ?? "/" : Deno.cwd();
  const globOptions = { extended, globstar, caseInsensitive };
  const absRoot = isGlobAbsolute ? root : resolve6(root);
  const resolveFromRoot = (path) => resolve6(absRoot, path);
  const excludePatterns = exclude.map(resolveFromRoot).map((s) => globToRegExp6(s, globOptions));
  const shouldInclude = (path) => !excludePatterns.some((p) => !!path.match(p));
  let fixedRoot = isGlobAbsolute ? winRoot !== void 0 ? winRoot : "/" : absRoot;
  while (segments.length > 0 && !isGlob2(segments[0])) {
    const seg = segments.shift();
    assert2(seg !== void 0);
    fixedRoot = joinGlobs6([fixedRoot, seg], globOptions);
  }
  let fixedRootInfo;
  try {
    fixedRootInfo = await createWalkEntry2(fixedRoot);
  } catch (error) {
    return throwUnlessNotFound(error);
  }
  async function* advanceMatch(walkInfo, globSegment) {
    if (!walkInfo.isDirectory) {
      return;
    } else if (globSegment === "..") {
      const parentPath = joinGlobs6([walkInfo.path, ".."], globOptions);
      try {
        if (shouldInclude(parentPath)) {
          return yield await createWalkEntry2(parentPath);
        }
      } catch (error) {
        throwUnlessNotFound(error);
      }
      return;
    } else if (globSegment === "**") {
      return yield* walk2(walkInfo.path, {
        skip: excludePatterns,
        maxDepth: globstar ? Infinity : 1,
        followSymlinks,
        canonicalize
      });
    }
    const globPattern = globToRegExp6(globSegment, globOptions);
    for await (const walkEntry of walk2(walkInfo.path, {
      maxDepth: 1,
      skip: excludePatterns,
      followSymlinks
    })) {
      if (walkEntry.path !== walkInfo.path && walkEntry.name.match(globPattern)) {
        yield walkEntry;
      }
    }
  }
  let currentMatches = [fixedRootInfo];
  for (const segment of segments) {
    const nextMatchMap = /* @__PURE__ */ new Map();
    await Promise.all(
      currentMatches.map(async (currentMatch) => {
        for await (const nextMatch of advanceMatch(currentMatch, segment)) {
          nextMatchMap.set(nextMatch.path, nextMatch);
        }
      })
    );
    currentMatches = [...nextMatchMap.values()].sort(comparePath);
  }
  if (hasTrailingSep) {
    currentMatches = currentMatches.filter(
      (entry) => entry.isDirectory
    );
  }
  if (!includeDirs) {
    currentMatches = currentMatches.filter(
      (entry) => !entry.isDirectory
    );
  }
  yield* currentMatches;
}
function* expandGlobSync(glob, {
  root,
  exclude = [],
  includeDirs = true,
  extended = true,
  globstar = true,
  caseInsensitive,
  followSymlinks,
  canonicalize
} = {}) {
  const {
    segments,
    isAbsolute: isGlobAbsolute,
    hasTrailingSep,
    winRoot
  } = split(toPathString2(glob));
  root ??= isGlobAbsolute ? winRoot ?? "/" : Deno.cwd();
  const globOptions = { extended, globstar, caseInsensitive };
  const absRoot = isGlobAbsolute ? root : resolve6(root);
  const resolveFromRoot = (path) => resolve6(absRoot, path);
  const excludePatterns = exclude.map(resolveFromRoot).map((s) => globToRegExp6(s, globOptions));
  const shouldInclude = (path) => !excludePatterns.some((p) => !!path.match(p));
  let fixedRoot = isGlobAbsolute ? winRoot !== void 0 ? winRoot : "/" : absRoot;
  while (segments.length > 0 && !isGlob2(segments[0])) {
    const seg = segments.shift();
    assert2(seg !== void 0);
    fixedRoot = joinGlobs6([fixedRoot, seg], globOptions);
  }
  let fixedRootInfo;
  try {
    fixedRootInfo = createWalkEntrySync2(fixedRoot);
  } catch (error) {
    return throwUnlessNotFound(error);
  }
  function* advanceMatch(walkInfo, globSegment) {
    if (!walkInfo.isDirectory) {
      return;
    } else if (globSegment === "..") {
      const parentPath = joinGlobs6([walkInfo.path, ".."], globOptions);
      try {
        if (shouldInclude(parentPath)) {
          return yield createWalkEntrySync2(parentPath);
        }
      } catch (error) {
        throwUnlessNotFound(error);
      }
      return;
    } else if (globSegment === "**") {
      return yield* walkSync2(walkInfo.path, {
        skip: excludePatterns,
        maxDepth: globstar ? Infinity : 1,
        followSymlinks,
        canonicalize
      });
    }
    const globPattern = globToRegExp6(globSegment, globOptions);
    for (const walkEntry of walkSync2(walkInfo.path, {
      maxDepth: 1,
      skip: excludePatterns,
      followSymlinks
    })) {
      if (walkEntry.path !== walkInfo.path && walkEntry.name.match(globPattern)) {
        yield walkEntry;
      }
    }
  }
  let currentMatches = [fixedRootInfo];
  for (const segment of segments) {
    const nextMatchMap = /* @__PURE__ */ new Map();
    for (const currentMatch of currentMatches) {
      for (const nextMatch of advanceMatch(currentMatch, segment)) {
        nextMatchMap.set(nextMatch.path, nextMatch);
      }
    }
    currentMatches = [...nextMatchMap.values()].sort(comparePath);
  }
  if (hasTrailingSep) {
    currentMatches = currentMatches.filter(
      (entry) => entry.isDirectory
    );
  }
  if (!includeDirs) {
    currentMatches = currentMatches.filter(
      (entry) => !entry.isDirectory
    );
  }
  yield* currentMatches;
}
var PERIOD_CHAR_CODE = ".".charCodeAt(0);
function createPath2(path) {
  if (path instanceof Path2) {
    return path;
  } else {
    return new Path2(path);
  }
}
var Path2 = class _Path2 {
  #path;
  #knownResolved = false;
  /** This is a special symbol that allows different versions of
   * Dax's `Path` API to match on `instanceof` checks. Ideally
   * people shouldn't be mixing versions, but if it happens then
   * this will maybe reduce some bugs (or cause some... tbd).
   * @internal
   */
  static instanceofSymbol = Symbol.for("dax.Path");
  constructor(path) {
    if (path instanceof URL) {
      this.#path = fromFileUrl6(path);
    } else if (path instanceof _Path2) {
      this.#path = path.toString();
    } else if (typeof path === "string") {
      if (path.startsWith("file://")) {
        this.#path = fromFileUrl6(path);
      } else {
        this.#path = path;
      }
    } else {
      this.#path = fromFileUrl6(path.url);
    }
  }
  /** @internal */
  static [Symbol.hasInstance](instance) {
    return instance?.constructor?.instanceofSymbol === _Path2.instanceofSymbol;
  }
  /** @internal */
  [Symbol.for("Deno.customInspect")]() {
    return `Path("${this.#path}")`;
  }
  /** @internal */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Path("${this.#path}")`;
  }
  /** Gets the string representation of this path. */
  toString() {
    return this.#path;
  }
  /** Resolves the path and gets the file URL. */
  toFileUrl() {
    const resolvedPath = this.resolve();
    return toFileUrl6(resolvedPath.toString());
  }
  /** If this path reference is the same as another one. */
  equals(otherPath) {
    return this.resolve().toString() === otherPath.resolve().toString();
  }
  /** Joins the provided path segments onto this path. */
  join(...pathSegments) {
    return new _Path2(join6(this.#path, ...pathSegments));
  }
  /** Resolves this path to an absolute path along with the provided path segments. */
  resolve(...pathSegments) {
    if (this.#knownResolved && pathSegments.length === 0) {
      return this;
    }
    const resolvedPath = resolve6(this.#path, ...pathSegments);
    if (pathSegments.length === 0 && resolvedPath === this.#path) {
      this.#knownResolved = true;
      return this;
    } else {
      const pathRef = new _Path2(resolvedPath);
      pathRef.#knownResolved = true;
      return pathRef;
    }
  }
  /**
   * Normalizes the `path`, resolving `'..'` and `'.'` segments.
   * Note that resolving these segments does not necessarily mean that all will be eliminated.
   * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.
   */
  normalize() {
    return new _Path2(normalize6(this.#path));
  }
  /** Follows symlinks and gets if this path is a directory. */
  isDirSync() {
    return this.statSync()?.isDirectory ?? false;
  }
  /** Follows symlinks and gets if this path is a file. */
  isFileSync() {
    return this.statSync()?.isFile ?? false;
  }
  /** Gets if this path is a symlink. */
  isSymlinkSync() {
    return this.lstatSync()?.isSymlink ?? false;
  }
  /** Gets if this path is an absolute path. */
  isAbsolute() {
    return isAbsolute6(this.#path);
  }
  /** Gets if this path is relative. */
  isRelative() {
    return !this.isAbsolute();
  }
  /** Resolves the `Deno.FileInfo` of this path following symlinks. */
  async stat() {
    try {
      return await Deno.stat(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /** Synchronously resolves the `Deno.FileInfo` of this
   * path following symlinks. */
  statSync() {
    try {
      return Deno.statSync(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /** Resolves the `Deno.FileInfo` of this path without
   * following symlinks. */
  async lstat() {
    try {
      return await Deno.lstat(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /** Synchronously resolves the `Deno.FileInfo` of this path
   * without following symlinks. */
  lstatSync() {
    try {
      return Deno.lstatSync(this.#path);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        return void 0;
      } else {
        throw err;
      }
    }
  }
  /**
   * Gets the directory path. In most cases, it is recommended
   * to use `.parent()` instead since it will give you a `Path`.
   */
  dirname() {
    return dirname6(this.#path);
  }
  /** Gets the file or directory name of the path. */
  basename() {
    return basename6(this.#path);
  }
  /** Resolves the path getting all its ancestor directories in order. */
  *ancestors() {
    let ancestor = this.parent();
    while (ancestor != null) {
      yield ancestor;
      ancestor = ancestor.parent();
    }
  }
  *components() {
    const path = this.normalize();
    let last_index = 0;
    if (path.#path.startsWith("\\\\?\\")) {
      last_index = nextSlash(path.#path, 4);
      if (last_index === -1) {
        yield path.#path;
        return;
      } else {
        yield path.#path.substring(0, last_index);
        last_index += 1;
      }
    } else if (path.#path.startsWith("/")) {
      last_index += 1;
    }
    while (true) {
      const index = nextSlash(path.#path, last_index);
      if (index < 0) {
        const part = path.#path.substring(last_index);
        if (part.length > 0) {
          yield part;
        }
        return;
      }
      yield path.#path.substring(last_index, index);
      last_index = index + 1;
    }
    function nextSlash(path2, start) {
      for (let i = start; i < path2.length; i++) {
        const c = path2.charCodeAt(i);
        if (c === 47 || c === 92) {
          return i;
        }
      }
      return -1;
    }
  }
  // This is private because this doesn't handle stuff like `\\?\` at the start
  // so it's only used internally with #endsWith for perf. API consumers should
  // use .components()
  *#rcomponents() {
    const path = this.normalize();
    let last_index = void 0;
    while (last_index == null || last_index > 0) {
      const index = nextSlash(path.#path, last_index == null ? void 0 : last_index - 1);
      if (index < 0) {
        const part2 = path.#path.substring(0, last_index);
        if (part2.length > 0) {
          yield part2;
        }
        return;
      }
      const part = path.#path.substring(index + 1, last_index);
      if (last_index != null || part.length > 0) {
        yield part;
      }
      last_index = index;
    }
    function nextSlash(path2, start) {
      for (let i = start ?? path2.length - 1; i >= 0; i--) {
        const c = path2.charCodeAt(i);
        if (c === 47 || c === 92) {
          return i;
        }
      }
      return -1;
    }
  }
  startsWith(path) {
    const startsWithComponents = ensurePath2(path).components();
    for (const component of this.components()) {
      const next = startsWithComponents.next();
      if (next.done) {
        return true;
      }
      if (next.value !== component) {
        return false;
      }
    }
    return startsWithComponents.next().done ?? true;
  }
  endsWith(path) {
    const endsWithComponents = ensurePath2(path).#rcomponents();
    for (const component of this.#rcomponents()) {
      const next = endsWithComponents.next();
      if (next.done) {
        return true;
      }
      if (next.value !== component) {
        return false;
      }
    }
    return endsWithComponents.next().done ?? true;
  }
  /** Gets the parent directory or returns undefined if the parent is the root directory. */
  parent() {
    const resolvedPath = this.resolve();
    const dirname7 = resolvedPath.dirname();
    if (dirname7 === resolvedPath.#path) {
      return void 0;
    } else {
      return new _Path2(dirname7);
    }
  }
  /** Gets the parent or throws if the current directory was the root. */
  parentOrThrow() {
    const parent = this.parent();
    if (parent == null) {
      throw new Error(`Cannot get the parent directory of '${this.#path}'.`);
    }
    return parent;
  }
  /**
   * Returns the extension of the path with leading period or undefined
   * if there is no extension.
   */
  extname() {
    const extName = extname6(this.#path);
    return extName.length === 0 ? void 0 : extName;
  }
  /** Gets a new path reference with the provided extension. */
  withExtname(ext) {
    const currentExt = this.extname();
    const hasLeadingPeriod = ext.charCodeAt(0) === PERIOD_CHAR_CODE;
    if (!hasLeadingPeriod && ext.length !== 0) {
      ext = "." + ext;
    }
    return new _Path2(this.#path.substring(0, this.#path.length - (currentExt?.length ?? 0)) + ext);
  }
  /** Gets a new path reference with the provided file or directory name. */
  withBasename(basename7) {
    const currentBaseName = this.basename();
    return new _Path2(this.#path.substring(0, this.#path.length - currentBaseName.length) + basename7);
  }
  /** Gets the relative path from this path to the specified path. */
  relative(to) {
    const toPath = ensurePath2(to);
    return relative6(this.resolve().#path, toPath.resolve().#path);
  }
  /** Gets if the path exists. Beware of TOCTOU issues. */
  exists() {
    return this.lstat().then((info) => info != null);
  }
  /** Synchronously gets if the path exists. Beware of TOCTOU issues. */
  existsSync() {
    return this.lstatSync() != null;
  }
  /** Resolves to the absolute normalized path, with symbolic links resolved. */
  realPath() {
    return Deno.realPath(this.#path).then((path) => new _Path2(path));
  }
  /** Synchronously resolves to the absolute normalized path, with symbolic links resolved. */
  realPathSync() {
    return new _Path2(Deno.realPathSync(this.#path));
  }
  /** Expands the glob using the current path as the root. */
  async *expandGlob(glob, options) {
    const entries = expandGlob(glob, {
      root: this.resolve().toString(),
      ...options
    });
    for await (const entry of entries) {
      yield this.#stdWalkEntryToDax(entry);
    }
  }
  /** Synchronously expands the glob using the current path as the root. */
  *expandGlobSync(glob, options) {
    const entries = expandGlobSync(glob, {
      root: this.resolve().toString(),
      ...options
    });
    for (const entry of entries) {
      yield this.#stdWalkEntryToDax(entry);
    }
  }
  /** Walks the file tree rooted at the current path, yielding each file or
   * directory in the tree filtered according to the given options. */
  async *walk(options) {
    for await (const entry of walk2(this.resolve().toString(), options)) {
      yield this.#stdWalkEntryToDax(entry);
    }
  }
  /** Synchronously walks the file tree rooted at the current path, yielding each
   * file or directory in the tree filtered according to the given options. */
  *walkSync(options) {
    for (const entry of walkSync2(this.resolve().toString(), options)) {
      yield this.#stdWalkEntryToDax(entry);
    }
  }
  #stdWalkEntryToDax(entry) {
    return {
      ...entry,
      path: new _Path2(entry.path)
    };
  }
  /** Creates a directory at this path.
   * @remarks By default, this is recursive.
   */
  async mkdir(options) {
    await Deno.mkdir(this.#path, {
      recursive: true,
      ...options
    });
    return this;
  }
  /** Synchronously creates a directory at this path.
   * @remarks By default, this is recursive.
   */
  mkdirSync(options) {
    Deno.mkdirSync(this.#path, {
      recursive: true,
      ...options
    });
    return this;
  }
  async symlinkTo(target, opts) {
    await createSymlink2(this.#resolveCreateSymlinkOpts(target, opts));
  }
  symlinkToSync(target, opts) {
    createSymlinkSync2(this.#resolveCreateSymlinkOpts(target, opts));
  }
  #resolveCreateSymlinkOpts(target, opts) {
    if (opts?.kind == null) {
      if (typeof target === "string") {
        return {
          fromPath: this.resolve(),
          targetPath: ensurePath2(target),
          text: target,
          type: opts?.type
        };
      } else {
        throw new Error("Please specify if this symlink is absolute or relative. Otherwise provide the target text.");
      }
    }
    const targetPath = ensurePath2(target).resolve();
    if (opts?.kind === "relative") {
      const fromPath = this.resolve();
      let relativePath;
      if (fromPath.dirname() === targetPath.dirname()) {
        relativePath = targetPath.basename();
      } else {
        relativePath = fromPath.relative(targetPath);
      }
      return {
        fromPath,
        targetPath,
        text: relativePath,
        type: opts?.type
      };
    } else {
      return {
        fromPath: this.resolve(),
        targetPath,
        text: targetPath.#path,
        type: opts?.type
      };
    }
  }
  /**
   * Creates a hardlink to the provided target path.
   */
  async linkTo(targetPath) {
    const targetPathRef = ensurePath2(targetPath).resolve();
    await Deno.link(targetPathRef.toString(), this.resolve().toString());
  }
  /**
   * Synchronously creates a hardlink to the provided target path.
   */
  linkToSync(targetPath) {
    const targetPathRef = ensurePath2(targetPath).resolve();
    Deno.linkSync(targetPathRef.toString(), this.resolve().toString());
  }
  /** Reads the entries in the directory. */
  async *readDir() {
    const dir = this.resolve();
    for await (const entry of Deno.readDir(dir.#path)) {
      yield {
        ...entry,
        path: dir.join(entry.name)
      };
    }
  }
  /** Synchronously reads the entries in the directory. */
  *readDirSync() {
    const dir = this.resolve();
    for (const entry of Deno.readDirSync(dir.#path)) {
      yield {
        ...entry,
        path: dir.join(entry.name)
      };
    }
  }
  /** Reads only the directory file paths, not including symlinks. */
  async *readDirFilePaths() {
    const dir = this.resolve();
    for await (const entry of Deno.readDir(dir.#path)) {
      if (entry.isFile) {
        yield dir.join(entry.name);
      }
    }
  }
  /** Synchronously reads only the directory file paths, not including symlinks. */
  *readDirFilePathsSync() {
    const dir = this.resolve();
    for (const entry of Deno.readDirSync(dir.#path)) {
      if (entry.isFile) {
        yield dir.join(entry.name);
      }
    }
  }
  /** Reads the bytes from the file. */
  readBytes(options) {
    return Deno.readFile(this.#path, options);
  }
  /** Synchronously reads the bytes from the file. */
  readBytesSync() {
    return Deno.readFileSync(this.#path);
  }
  /** Calls `.readBytes()`, but returns undefined if the path doesn't exist. */
  readMaybeBytes(options) {
    return notFoundToUndefined2(() => this.readBytes(options));
  }
  /** Calls `.readBytesSync()`, but returns undefined if the path doesn't exist. */
  readMaybeBytesSync() {
    return notFoundToUndefinedSync2(() => this.readBytesSync());
  }
  /** Reads the text from the file. */
  readText(options) {
    return Deno.readTextFile(this.#path, options);
  }
  /** Synchronously reads the text from the file. */
  readTextSync() {
    return Deno.readTextFileSync(this.#path);
  }
  /** Calls `.readText()`, but returns undefined when the path doesn't exist.
   * @remarks This still errors for other kinds of errors reading a file.
   */
  readMaybeText(options) {
    return notFoundToUndefined2(() => this.readText(options));
  }
  /** Calls `.readTextSync()`, but returns undefined when the path doesn't exist.
   * @remarks This still errors for other kinds of errors reading a file.
   */
  readMaybeTextSync() {
    return notFoundToUndefinedSync2(() => this.readTextSync());
  }
  /** Reads and parses the file as JSON, throwing if it doesn't exist or is not valid JSON. */
  async readJson(options) {
    return this.#parseJson(await this.readText(options));
  }
  /** Synchronously reads and parses the file as JSON, throwing if it doesn't
   * exist or is not valid JSON. */
  readJsonSync() {
    return this.#parseJson(this.readTextSync());
  }
  #parseJson(text) {
    try {
      return JSON.parse(text);
    } catch (err) {
      throw new Error(`Failed parsing JSON in '${this.toString()}'.`, {
        cause: err
      });
    }
  }
  /**
   * Calls `.readJson()`, but returns undefined if the file doesn't exist.
   * @remarks This method will still throw if the file cannot be parsed as JSON.
   */
  readMaybeJson(options) {
    return notFoundToUndefined2(() => this.readJson(options));
  }
  /**
   * Calls `.readJsonSync()`, but returns undefined if the file doesn't exist.
   * @remarks This method will still throw if the file cannot be parsed as JSON.
   */
  readMaybeJsonSync() {
    return notFoundToUndefinedSync2(() => this.readJsonSync());
  }
  /** Writes out the provided bytes to the file. */
  async write(data, options) {
    await this.#withFileForWriting(options, (file) => file.write(data));
    return this;
  }
  /** Synchronously writes out the provided bytes to the file. */
  writeSync(data, options) {
    this.#withFileForWritingSync(options, (file) => {
      file.writeSync(data);
    });
    return this;
  }
  /** Writes out the provided text to the file. */
  async writeText(text, options) {
    await this.#withFileForWriting(options, (file) => file.writeText(text));
    return this;
  }
  /** Synchronously writes out the provided text to the file. */
  writeTextSync(text, options) {
    this.#withFileForWritingSync(options, (file) => {
      file.writeTextSync(text);
    });
    return this;
  }
  /** Writes out the provided object as compact JSON. */
  async writeJson(obj, options) {
    const text = JSON.stringify(obj);
    await this.#writeTextWithEndNewLine(text, options);
    return this;
  }
  /** Synchronously writes out the provided object as compact JSON. */
  writeJsonSync(obj, options) {
    const text = JSON.stringify(obj);
    this.#writeTextWithEndNewLineSync(text, options);
    return this;
  }
  /** Writes out the provided object as formatted JSON. */
  async writeJsonPretty(obj, options) {
    const text = JSON.stringify(obj, void 0, 2);
    await this.#writeTextWithEndNewLine(text, options);
    return this;
  }
  /** Synchronously writes out the provided object as formatted JSON. */
  writeJsonPrettySync(obj, options) {
    const text = JSON.stringify(obj, void 0, 2);
    this.#writeTextWithEndNewLineSync(text, options);
    return this;
  }
  #writeTextWithEndNewLine(text, options) {
    return this.#withFileForWriting(options, async (file) => {
      await file.writeText(text);
      await file.writeText("\n");
    });
  }
  /** Appends the provided bytes to the file. */
  async append(data, options) {
    await this.#withFileForAppending(options, (file) => file.write(data));
    return this;
  }
  /** Synchronously appends the provided bytes to the file. */
  appendSync(data, options) {
    this.#withFileForAppendingSync(options, (file) => {
      file.writeSync(data);
    });
    return this;
  }
  /** Appends the provided text to the file. */
  async appendText(text, options) {
    await this.#withFileForAppending(options, (file) => file.writeText(text));
    return this;
  }
  /** Synchronously appends the provided text to the file. */
  appendTextSync(text, options) {
    this.#withFileForAppendingSync(options, (file) => {
      file.writeTextSync(text);
    });
    return this;
  }
  #withFileForAppending(options, action) {
    return this.#withFileForWriting({
      append: true,
      ...options
    }, action);
  }
  async #withFileForWriting(options, action) {
    const file = await this.#openFileMaybeCreatingDirectory({
      write: true,
      create: true,
      truncate: options?.append !== true,
      ...options
    });
    try {
      return await action(file);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
  }
  /** Opens a file, but handles if the directory does not exist. */
  async #openFileMaybeCreatingDirectory(options) {
    const resolvedPath = this.resolve();
    try {
      return await resolvedPath.open(options);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        const parent = resolvedPath.parent();
        if (parent != null) {
          try {
            await parent.mkdir();
          } catch {
            throw err;
          }
        }
        return await resolvedPath.open(options);
      } else {
        throw err;
      }
    }
  }
  #writeTextWithEndNewLineSync(text, options) {
    this.#withFileForWritingSync(options, (file) => {
      file.writeTextSync(text);
      file.writeTextSync("\n");
    });
  }
  #withFileForAppendingSync(options, action) {
    return this.#withFileForWritingSync({
      append: true,
      ...options
    }, action);
  }
  #withFileForWritingSync(options, action) {
    const file = this.#openFileForWritingSync(options);
    try {
      return action(file);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
  }
  /** Opens a file for writing, but handles if the directory does not exist. */
  #openFileForWritingSync(options) {
    return this.#openFileMaybeCreatingDirectorySync({
      write: true,
      create: true,
      truncate: options?.append !== true,
      ...options
    });
  }
  /** Opens a file for writing, but handles if the directory does not exist. */
  #openFileMaybeCreatingDirectorySync(options) {
    try {
      return this.openSync(options);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        const parent = this.resolve().parent();
        if (parent != null) {
          try {
            parent.mkdirSync();
          } catch {
            throw err;
          }
        }
        return this.openSync(options);
      } else {
        throw err;
      }
    }
  }
  /** Changes the permissions of the file or directory. */
  async chmod(mode) {
    await Deno.chmod(this.#path, mode);
    return this;
  }
  /** Synchronously changes the permissions of the file or directory. */
  chmodSync(mode) {
    Deno.chmodSync(this.#path, mode);
    return this;
  }
  /** Changes the ownership permissions of the file. */
  async chown(uid, gid) {
    await Deno.chown(this.#path, uid, gid);
    return this;
  }
  /** Synchronously changes the ownership permissions of the file. */
  chownSync(uid, gid) {
    Deno.chownSync(this.#path, uid, gid);
    return this;
  }
  /** Creates a new file or opens the existing one. */
  create() {
    return Deno.create(this.#path).then((file) => createFsFileWrapper2(file));
  }
  /** Synchronously creates a new file or opens the existing one. */
  createSync() {
    return createFsFileWrapper2(Deno.createSync(this.#path));
  }
  /** Creates a file throwing if a file previously existed. */
  createNew() {
    return this.open({
      createNew: true,
      read: true,
      write: true
    });
  }
  /** Synchronously creates a file throwing if a file previously existed. */
  createNewSync() {
    return this.openSync({
      createNew: true,
      read: true,
      write: true
    });
  }
  /** Opens a file. */
  open(options) {
    return Deno.open(this.#path, options).then((file) => createFsFileWrapper2(file));
  }
  /** Opens a file synchronously. */
  openSync(options) {
    return createFsFileWrapper2(Deno.openSync(this.#path, options));
  }
  /** Removes the file or directory from the file system. */
  async remove(options) {
    await Deno.remove(this.#path, options);
    return this;
  }
  /** Removes the file or directory from the file system synchronously. */
  removeSync(options) {
    Deno.removeSync(this.#path, options);
    return this;
  }
  /**
   * Ensures that a directory is empty.
   * Deletes directory contents if the directory is not empty.
   * If the directory does not exist, it is created.
   * The directory itself is not deleted.
   */
  async emptyDir() {
    await emptyDir2(this.toString());
    return this;
  }
  /** Synchronous version of `emptyDir()` */
  emptyDirSync() {
    emptyDirSync2(this.toString());
    return this;
  }
  /** Ensures that the directory exists.
   * If the directory structure does not exist, it is created. Like mkdir -p.
   */
  async ensureDir() {
    await ensureDir2(this.toString());
    return this;
  }
  /** Synchronously ensures that the directory exists.
   * If the directory structure does not exist, it is created. Like mkdir -p.
   */
  ensureDirSync() {
    ensureDirSync2(this.toString());
    return this;
  }
  /**
   * Ensures that the file exists.
   * If the file that is requested to be created is in directories that do
   * not exist these directories are created. If the file already exists,
   * it is NOTMODIFIED.
   */
  async ensureFile() {
    await ensureFile2(this.toString());
    return this;
  }
  /**
   * Synchronously ensures that the file exists.
   * If the file that is requested to be created is in directories that do
   * not exist these directories are created. If the file already exists,
   * it is NOTMODIFIED.
   */
  ensureFileSync() {
    ensureFileSync2(this.toString());
    return this;
  }
  /** Copies a file or directory to the provided destination.
   * @returns The destination file path.
   */
  async copy(destinationPath, options) {
    const pathRef = ensurePath2(destinationPath);
    await copy3(this.#path, pathRef.#path, options);
    return pathRef;
  }
  /** Copies a file or directory to the provided destination synchronously.
   * @returns The destination file path.
   */
  copySync(destinationPath, options) {
    const pathRef = ensurePath2(destinationPath);
    copySync2(this.#path, pathRef.#path, options);
    return pathRef;
  }
  /**
   * Copies the file or directory to the specified directory.
   * @returns The destination file path.
   */
  copyToDir(destinationDirPath, options) {
    const destinationPath = ensurePath2(destinationDirPath).join(this.basename());
    return this.copy(destinationPath, options);
  }
  /**
   * Copies the file or directory to the specified directory synchronously.
   * @returns The destination file path.
   */
  copyToDirSync(destinationDirPath, options) {
    const destinationPath = ensurePath2(destinationDirPath).join(this.basename());
    return this.copySync(destinationPath, options);
  }
  /**
   * Moves the file or directory returning a promise that resolves to
   * the renamed path.
   */
  rename(newPath) {
    const pathRef = ensurePath2(newPath);
    return Deno.rename(this.#path, pathRef.#path).then(() => pathRef);
  }
  /**
   * Moves the file or directory returning the renamed path synchronously.
   */
  renameSync(newPath) {
    const pathRef = ensurePath2(newPath);
    Deno.renameSync(this.#path, pathRef.#path);
    return pathRef;
  }
  /**
   * Moves the file or directory to the specified directory.
   * @returns The destination file path.
   */
  renameToDir(destinationDirPath) {
    const destinationPath = ensurePath2(destinationDirPath).join(this.basename());
    return this.rename(destinationPath);
  }
  /**
   * Moves the file or directory to the specified directory synchronously.
   * @returns The destination file path.
   */
  renameToDirSync(destinationDirPath) {
    const destinationPath = ensurePath2(destinationDirPath).join(this.basename());
    return this.renameSync(destinationPath);
  }
  /** Opens the file and pipes it to the writable stream. */
  async pipeTo(dest, options) {
    const file = await Deno.open(this.#path, { read: true });
    try {
      await file.readable.pipeTo(dest, options);
    } finally {
      try {
        file.close();
      } catch {
      }
    }
    return this;
  }
};
function ensurePath2(path) {
  return path instanceof Path2 ? path : new Path2(path);
}
async function createSymlink2(opts) {
  let kind = opts.type;
  if (kind == null && Deno.build.os === "windows") {
    const info = await opts.targetPath.lstat();
    if (info?.isDirectory) {
      kind = "dir";
    } else if (info?.isFile) {
      kind = "file";
    } else {
      throw new Deno.errors.NotFound(
        `The target path '${opts.targetPath}' did not exist or path kind could not be determined. When the path doesn't exist, you need to specify a symlink type on Windows.`
      );
    }
  }
  await Deno.symlink(
    opts.text,
    opts.fromPath.toString(),
    kind == null ? void 0 : {
      type: kind
    }
  );
}
function createSymlinkSync2(opts) {
  let kind = opts.type;
  if (kind == null && Deno.build.os === "windows") {
    const info = opts.targetPath.lstatSync();
    if (info?.isDirectory) {
      kind = "dir";
    } else if (info?.isFile) {
      kind = "file";
    } else {
      throw new Deno.errors.NotFound(
        `The target path '${opts.targetPath}' did not exist or path kind could not be determined. When the path doesn't exist, you need to specify a symlink type on Windows.`
      );
    }
  }
  Deno.symlinkSync(
    opts.text,
    opts.fromPath.toString(),
    kind == null ? void 0 : {
      type: kind
    }
  );
}
function createFsFileWrapper2(file) {
  Object.setPrototypeOf(file, FsFileWrapper2.prototype);
  return file;
}
var FsFileWrapper2 = class extends Deno.FsFile {
  [symbols2.readable]() {
    return this.readable;
  }
  [symbols2.writable]() {
    return this.writable;
  }
  /** Writes the provided text to this file. */
  writeText(text) {
    return this.writeBytes(new TextEncoder().encode(text));
  }
  /** Synchronously writes the provided text to this file. */
  writeTextSync(text) {
    return this.writeBytesSync(new TextEncoder().encode(text));
  }
  /** Writes the provided bytes to the file. */
  async writeBytes(bytes) {
    await writeAll2(this, bytes);
    return this;
  }
  /** Synchronously writes the provided bytes to the file. */
  writeBytesSync(bytes) {
    writeAllSync2(this, bytes);
    return this;
  }
};
async function notFoundToUndefined2(action) {
  try {
    return await action();
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return void 0;
    } else {
      throw err;
    }
  }
}
function notFoundToUndefinedSync2(action) {
  try {
    return action();
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return void 0;
    } else {
      throw err;
    }
  }
}
var withProgressBarFactorySymbol2 = Symbol();
var RequestBuilder2 = class _RequestBuilder2 {
  #state = void 0;
  #getClonedState() {
    const state = this.#state;
    if (state == null) {
      return this.#getDefaultState();
    }
    return {
      // be explicit here in order to force evaluation
      // of each property on a case by case basis
      noThrow: typeof state.noThrow === "boolean" ? state.noThrow : [...state.noThrow],
      url: state.url,
      body: state.body,
      cache: state.cache,
      headers: state.headers,
      integrity: state.integrity,
      keepalive: state.keepalive,
      method: state.method,
      mode: state.mode,
      redirect: state.redirect,
      referrer: state.referrer,
      referrerPolicy: state.referrerPolicy,
      progressBarFactory: state.progressBarFactory,
      progressOptions: state.progressOptions == null ? void 0 : {
        ...state.progressOptions
      },
      timeout: state.timeout
    };
  }
  #getDefaultState() {
    return {
      noThrow: false,
      url: void 0,
      body: void 0,
      cache: void 0,
      headers: {},
      integrity: void 0,
      keepalive: void 0,
      method: void 0,
      mode: void 0,
      redirect: void 0,
      referrer: void 0,
      referrerPolicy: void 0,
      progressBarFactory: void 0,
      progressOptions: void 0,
      timeout: void 0
    };
  }
  #newWithState(action) {
    const builder = new _RequestBuilder2();
    const state = this.#getClonedState();
    action(state);
    builder.#state = state;
    return builder;
  }
  [symbols2.readable]() {
    const self = this;
    let streamReader;
    let response;
    let wasCancelled = false;
    let cancelledReason;
    return new ReadableStream({
      async start() {
        response = await self.fetch();
        const readable = response.readable;
        if (wasCancelled) {
          readable.cancel(cancelledReason);
        } else {
          streamReader = readable.getReader();
        }
      },
      async pull(controller) {
        const { done, value } = await streamReader.read();
        if (done || value == null) {
          if (response?.signal?.aborted) {
            controller.error(response?.signal?.reason);
          } else {
            controller.close();
          }
        } else {
          controller.enqueue(value);
        }
      },
      cancel(reason) {
        streamReader?.cancel(reason);
        wasCancelled = true;
        cancelledReason = reason;
      }
    });
  }
  then(onfulfilled, onrejected) {
    return this.fetch().then(onfulfilled).catch(onrejected);
  }
  /** Fetches and gets the response. */
  fetch() {
    return makeRequest2(this.#getClonedState()).catch((err) => {
      if (err instanceof TimeoutError2) {
        Error.captureStackTrace(err, TimeoutError2);
      }
      return Promise.reject(err);
    });
  }
  /** Specifies the URL to send the request to. */
  url(value) {
    return this.#newWithState((state) => {
      state.url = value;
    });
  }
  header(nameOrItems, value) {
    return this.#newWithState((state) => {
      if (typeof nameOrItems === "string") {
        setHeader(state, nameOrItems, value);
      } else {
        for (const [name, value2] of Object.entries(nameOrItems)) {
          setHeader(state, name, value2);
        }
      }
    });
    function setHeader(state, name, value2) {
      name = name.toUpperCase();
      state.headers[name] = value2;
    }
  }
  noThrow(value, ...additional) {
    return this.#newWithState((state) => {
      if (typeof value === "boolean" || value == null) {
        state.noThrow = value ?? true;
      } else {
        state.noThrow = [value, ...additional];
      }
    });
  }
  body(value) {
    return this.#newWithState((state) => {
      state.body = value;
    });
  }
  cache(value) {
    return this.#newWithState((state) => {
      state.cache = value;
    });
  }
  integrity(value) {
    return this.#newWithState((state) => {
      state.integrity = value;
    });
  }
  keepalive(value) {
    return this.#newWithState((state) => {
      state.keepalive = value;
    });
  }
  method(value) {
    return this.#newWithState((state) => {
      state.method = value;
    });
  }
  mode(value) {
    return this.#newWithState((state) => {
      state.mode = value;
    });
  }
  /** @internal */
  [withProgressBarFactorySymbol2](factory) {
    return this.#newWithState((state) => {
      state.progressBarFactory = factory;
    });
  }
  redirect(value) {
    return this.#newWithState((state) => {
      state.redirect = value;
    });
  }
  referrer(value) {
    return this.#newWithState((state) => {
      state.referrer = value;
    });
  }
  referrerPolicy(value) {
    return this.#newWithState((state) => {
      state.referrerPolicy = value;
    });
  }
  showProgress(value) {
    return this.#newWithState((state) => {
      if (value === true || value == null) {
        state.progressOptions = { noClear: false };
      } else if (value === false) {
        state.progressOptions = void 0;
      } else {
        state.progressOptions = {
          noClear: value.noClear ?? false
        };
      }
    });
  }
  /** Timeout the request after the specified delay throwing a `TimeoutError`. */
  timeout(delay) {
    return this.#newWithState((state) => {
      state.timeout = delay == null ? void 0 : delayToMs2(delay);
    });
  }
  /** Fetches and gets the response as an array buffer. */
  async arrayBuffer() {
    const response = await this.fetch();
    return response.arrayBuffer();
  }
  /** Fetches and gets the response as a blob. */
  async blob() {
    const response = await this.fetch();
    return response.blob();
  }
  /** Fetches and gets the response as form data. */
  async formData() {
    const response = await this.fetch();
    return response.formData();
  }
  /** Fetches and gets the response as JSON additionally setting
   * a JSON accept header if not set. */
  async json() {
    let builder = this;
    const acceptHeaderName = "ACCEPT";
    if (builder.#state == null || !Object.hasOwn(builder.#state.headers, acceptHeaderName)) {
      builder = builder.header(acceptHeaderName, "application/json");
    }
    const response = await builder.fetch();
    return response.json();
  }
  /** Fetches and gets the response as text. */
  async text() {
    const response = await this.fetch();
    return response.text();
  }
  /** Pipes the response body to the provided writable stream. */
  async pipeTo(dest, options) {
    const response = await this.fetch();
    return await response.pipeTo(dest, options);
  }
  async pipeToPath(filePathOrOptions, maybeOptions) {
    const { filePath, options } = resolvePipeToPathParams2(filePathOrOptions, maybeOptions, this.#state?.url);
    const response = await this.fetch();
    return await response.pipeToPath(filePath, options);
  }
  /** Pipes the response body through the provided transform. */
  async pipeThrough(transform) {
    const response = await this.fetch();
    return response.pipeThrough(transform);
  }
};
var RequestResponse2 = class {
  #response;
  #downloadResponse;
  #originalUrl;
  #abortController;
  /** @internal */
  constructor(opts) {
    this.#originalUrl = opts.originalUrl;
    this.#response = opts.response;
    this.#abortController = opts.abortController;
    if (opts.response.body == null) {
      opts.abortController.clearTimeout();
    }
    if (opts.progressBar != null) {
      const pb = opts.progressBar;
      this.#downloadResponse = new Response(
        new ReadableStream({
          async start(controller) {
            const reader = opts.response.body?.getReader();
            if (reader == null) {
              return;
            }
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done || value == null) {
                  break;
                }
                pb.increment(value.byteLength);
                controller.enqueue(value);
              }
              const signal = opts.abortController.controller.signal;
              if (signal.aborted) {
                controller.error(signal.reason);
              } else {
                controller.close();
              }
            } finally {
              reader.releaseLock();
              pb.finish();
            }
          }
        })
      );
    } else {
      this.#downloadResponse = opts.response;
    }
  }
  /** Raw response. */
  get response() {
    return this.#response;
  }
  /** Response headers. */
  get headers() {
    return this.#response.headers;
  }
  /** If the response had a 2xx code. */
  get ok() {
    return this.#response.ok;
  }
  /** If the response is the result of a redirect. */
  get redirected() {
    return this.#response.redirected;
  }
  /** The underlying `AbortSignal` used to abort the request body
   * when a timeout is reached or when the `.abort()` method is called. */
  get signal() {
    return this.#abortController.controller.signal;
  }
  /** Status code of the response. */
  get status() {
    return this.#response.status;
  }
  /** Status text of the response. */
  get statusText() {
    return this.#response.statusText;
  }
  /** URL of the response. */
  get url() {
    return this.#response.url;
  }
  /** Aborts  */
  abort(reason) {
    this.#abortController?.controller.abort(reason);
  }
  /**
   * Throws if the response doesn't have a 2xx code.
   *
   * This might be useful if the request was built with `.noThrow()`, but
   * otherwise this is called automatically for any non-2xx response codes.
   */
  throwIfNotOk() {
    if (!this.ok) {
      this.#response.body?.cancel().catch(() => {
      });
      throw new Error(`Error making request to ${this.#originalUrl}: ${this.statusText}`);
    }
  }
  /**
   * Respose body as an array buffer.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  arrayBuffer() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return this.#downloadResponse.arrayBuffer();
    });
  }
  /**
   * Response body as a blog.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  blob() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.blob();
    });
  }
  /**
   * Response body as a form data.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  formData() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.formData();
    });
  }
  /**
   * Respose body as JSON.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  json() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.json();
    });
  }
  /**
   * Respose body as text.
   *
   * Note: Returns `undefined` when `.noThrow(404)` and status code is 404.
   */
  text() {
    return this.#withReturnHandling(async () => {
      if (this.#response.status === 404) {
        await this.#response.body?.cancel();
        return void 0;
      }
      return await this.#downloadResponse.text();
    });
  }
  /** Pipes the response body to the provided writable stream. */
  pipeTo(dest, options) {
    return this.#withReturnHandling(() => this.readable.pipeTo(dest, options));
  }
  async pipeToPath(filePathOrOptions, maybeOptions) {
    const { filePath, options } = resolvePipeToPathParams2(filePathOrOptions, maybeOptions, this.#originalUrl);
    const body = this.readable;
    try {
      const file = await filePath.open({
        write: true,
        create: true,
        ...options ?? {}
      });
      try {
        await body.pipeTo(file.writable, {
          preventClose: true
        });
        await file.writable.close();
      } finally {
        try {
          file.close();
        } catch {
        }
        this.#abortController?.clearTimeout();
      }
    } catch (err) {
      await this.#response.body?.cancel();
      throw err;
    }
    return filePath;
  }
  /** Pipes the response body through the provided transform. */
  pipeThrough(transform) {
    return this.readable.pipeThrough(transform);
  }
  get readable() {
    const body = this.#downloadResponse.body;
    if (body == null) {
      throw new Error("Response had no body.");
    }
    return body;
  }
  async #withReturnHandling(action) {
    try {
      return await action();
    } catch (err) {
      if (err instanceof TimeoutError2) {
        Error.captureStackTrace(err);
      }
      throw err;
    } finally {
      this.#abortController.clearTimeout();
    }
  }
};
async function makeRequest2(state) {
  if (state.url == null) {
    throw new Error("You must specify a URL before fetching.");
  }
  const abortController = getTimeoutAbortController() ?? {
    controller: new AbortController(),
    clearTimeout() {
    }
  };
  const response = await fetch(state.url, {
    body: state.body,
    // @ts-ignore not supported in Node.js yet?
    cache: state.cache,
    headers: filterEmptyRecordValues2(state.headers),
    integrity: state.integrity,
    keepalive: state.keepalive,
    method: state.method,
    mode: state.mode,
    redirect: state.redirect,
    referrer: state.referrer,
    referrerPolicy: state.referrerPolicy,
    signal: abortController.controller.signal
  });
  const result = new RequestResponse2({
    response,
    originalUrl: state.url.toString(),
    progressBar: getProgressBar(),
    abortController
  });
  if (!state.noThrow) {
    result.throwIfNotOk();
  } else if (state.noThrow instanceof Array) {
    if (!state.noThrow.includes(response.status)) {
      result.throwIfNotOk();
    }
  }
  return result;
  function getProgressBar() {
    if (state.progressOptions == null || state.progressBarFactory == null) {
      return void 0;
    }
    return state.progressBarFactory(`Download ${state.url}`).noClear(state.progressOptions.noClear).kind("bytes").length(getContentLength());
    function getContentLength() {
      const contentLength = response.headers.get("content-length");
      if (contentLength == null) {
        return void 0;
      }
      const length = parseInt(contentLength, 10);
      return isNaN(length) ? void 0 : length;
    }
  }
  function getTimeoutAbortController() {
    if (state.timeout == null) {
      return void 0;
    }
    const timeout = state.timeout;
    const controller = new AbortController();
    const timeoutId = setTimeout(
      () => controller.abort(new TimeoutError2(`Request timed out after ${formatMillis2(timeout)}.`)),
      timeout
    );
    return {
      controller,
      clearTimeout() {
        clearTimeout(timeoutId);
      }
    };
  }
}
function resolvePipeToPathParams2(pathOrOptions, maybeOptions, originalUrl) {
  let filePath;
  let options;
  if (typeof pathOrOptions === "string" || pathOrOptions instanceof URL) {
    filePath = new Path2(pathOrOptions).resolve();
    options = maybeOptions;
  } else if (pathOrOptions instanceof Path2) {
    filePath = pathOrOptions.resolve();
    options = maybeOptions;
  } else if (typeof pathOrOptions === "object") {
    options = pathOrOptions;
  } else if (pathOrOptions === void 0) {
    options = maybeOptions;
  }
  if (filePath === void 0) {
    filePath = new Path2(getFileNameFromUrlOrThrow(originalUrl));
  } else if (filePath.isDirSync()) {
    filePath = filePath.join(getFileNameFromUrlOrThrow(originalUrl));
  }
  filePath = filePath.resolve();
  return {
    filePath,
    options
  };
  function getFileNameFromUrlOrThrow(url) {
    const fileName = url == null ? void 0 : getFileNameFromUrl2(url);
    if (fileName == null) {
      throw new Error(
        "Could not derive the path from the request URL. Please explicitly provide a path."
      );
    }
    return fileName;
  }
}
var Deferred2 = class {
  #create;
  constructor(create) {
    this.#create = create;
  }
  create() {
    return this.#create();
  }
};
var textDecoder3 = new TextDecoder();
var builtInCommands2 = {
  cd: cdCommand2,
  printenv: printEnvCommand2,
  echo: echoCommand2,
  cat: catCommand2,
  exit: exitCommand2,
  export: exportCommand2,
  sleep: sleepCommand2,
  test: testCommand2,
  rm: rmCommand2,
  mkdir: mkdirCommand2,
  cp: cpCommand2,
  mv: mvCommand2,
  pwd: pwdCommand2,
  touch: touchCommand2,
  unset: unsetCommand2,
  which: whichCommand2
};
var getRegisteredCommandNamesSymbol2 = Symbol();
var setCommandTextStateSymbol2 = Symbol();
var CommandBuilder2 = class _CommandBuilder2 {
  #state = {
    command: void 0,
    combinedStdoutStderr: false,
    stdin: "inherit",
    stdout: {
      kind: "inherit"
    },
    stderr: {
      kind: "inherit"
    },
    noThrow: false,
    env: {},
    cwd: void 0,
    commands: { ...builtInCommands2 },
    clearEnv: false,
    exportEnv: false,
    printCommand: false,
    printCommandLogger: new LoggerTreeBox2(
      // deno-lint-ignore no-console
      (cmd) => console.error(white3(">"), blue2(cmd))
    ),
    timeout: void 0,
    signal: void 0
  };
  #getClonedState() {
    const state = this.#state;
    return {
      // be explicit here in order to evaluate each property on a case by case basis
      command: state.command,
      combinedStdoutStderr: state.combinedStdoutStderr,
      stdin: state.stdin,
      stdout: {
        kind: state.stdout.kind,
        options: state.stdout.options
      },
      stderr: {
        kind: state.stderr.kind,
        options: state.stderr.options
      },
      noThrow: state.noThrow instanceof Array ? [...state.noThrow] : state.noThrow,
      env: { ...state.env },
      cwd: state.cwd,
      commands: { ...state.commands },
      clearEnv: state.clearEnv,
      exportEnv: state.exportEnv,
      printCommand: state.printCommand,
      printCommandLogger: state.printCommandLogger.createChild(),
      timeout: state.timeout,
      signal: state.signal
    };
  }
  #newWithState(action) {
    const builder = new _CommandBuilder2();
    const state = this.#getClonedState();
    action(state);
    builder.#state = state;
    return builder;
  }
  then(onfulfilled, onrejected) {
    return this.spawn().then(onfulfilled).catch(onrejected);
  }
  /**
   * Explicit way to spawn a command.
   *
   * This is an alias for awaiting the command builder or calling `.then(...)`
   */
  spawn() {
    return parseAndSpawnCommand2(this.#getClonedState());
  }
  /**
   * Register a command.
   */
  registerCommand(command, handleFn) {
    validateCommandName2(command);
    return this.#newWithState((state) => {
      state.commands[command] = handleFn;
    });
  }
  /**
   * Register multilple commands.
   */
  registerCommands(commands) {
    let command = this;
    for (const [key, value] of Object.entries(commands)) {
      command = command.registerCommand(key, value);
    }
    return command;
  }
  /**
   * Unregister a command.
   */
  unregisterCommand(command) {
    return this.#newWithState((state) => {
      delete state.commands[command];
    });
  }
  /** Sets the raw command to execute. */
  command(command) {
    return this.#newWithState((state) => {
      if (command instanceof Array) {
        command = command.map(escapeArg2).join(" ");
      }
      state.command = {
        text: command,
        fds: void 0
      };
    });
  }
  noThrow(value, ...additional) {
    return this.#newWithState((state) => {
      if (typeof value === "boolean" || value == null) {
        state.noThrow = value ?? true;
      } else {
        state.noThrow = [value, ...additional];
      }
    });
  }
  /** Sets the command signal that will be passed to all commands
   * created with this command builder.
   */
  signal(killSignal) {
    return this.#newWithState((state) => {
      if (state.signal != null) {
        state.signal.linkChild(killSignal);
      }
      state.signal = killSignal;
    });
  }
  /**
   * Whether to capture a combined buffer of both stdout and stderr.
   *
   * This will set both stdout and stderr to "piped" if not already "piped"
   * or "inheritPiped".
   */
  captureCombined(value = true) {
    return this.#newWithState((state) => {
      state.combinedStdoutStderr = value;
      if (value) {
        if (state.stdout.kind !== "piped" && state.stdout.kind !== "inheritPiped") {
          state.stdout.kind = "piped";
        }
        if (state.stderr.kind !== "piped" && state.stderr.kind !== "inheritPiped") {
          state.stderr.kind = "piped";
        }
      }
    });
  }
  /**
   * Sets the stdin to use for the command.
   *
   * @remarks If multiple launches of a command occurs, then stdin will only be
   * read from the first consumed reader or readable stream and error otherwise.
   * For this reason, if you are setting stdin to something other than "inherit" or
   * "null", then it's recommended to set this each time you spawn a command.
   */
  stdin(reader) {
    return this.#newWithState((state) => {
      if (reader === "inherit" || reader === "null") {
        state.stdin = reader;
      } else if (reader instanceof Uint8Array) {
        state.stdin = new Deferred2(() => new Buffer(reader));
      } else if (reader instanceof Path2) {
        state.stdin = new Deferred2(async () => {
          const file = await reader.open();
          return file.readable;
        });
      } else if (reader instanceof RequestBuilder2) {
        state.stdin = new Deferred2(async () => {
          const body = await reader;
          return body.readable;
        });
      } else if (reader instanceof _CommandBuilder2) {
        state.stdin = new Deferred2(() => {
          return reader.stdout("piped").spawn().stdout();
        });
      } else {
        state.stdin = new Box2(reader);
      }
    });
  }
  /**
   * Sets the stdin string to use for a command.
   *
   * @remarks See the remarks on stdin. The same applies here.
   */
  stdinText(text) {
    return this.stdin(new TextEncoder().encode(text));
  }
  stdout(kind, options) {
    return this.#newWithState((state) => {
      if (state.combinedStdoutStderr && kind !== "piped" && kind !== "inheritPiped") {
        throw new Error(
          "Cannot set stdout's kind to anything but 'piped' or 'inheritPiped' when combined is true."
        );
      }
      if (options?.signal != null) {
        throw new Error("Setting a signal for a stdout WritableStream is not yet supported.");
      }
      state.stdout = {
        kind,
        options
      };
    });
  }
  stderr(kind, options) {
    return this.#newWithState((state) => {
      if (state.combinedStdoutStderr && kind !== "piped" && kind !== "inheritPiped") {
        throw new Error(
          "Cannot set stderr's kind to anything but 'piped' or 'inheritPiped' when combined is true."
        );
      }
      if (options?.signal != null) {
        throw new Error("Setting a signal for a stderr WritableStream is not yet supported.");
      }
      state.stderr = {
        kind,
        options
      };
    });
  }
  /** Pipes the current command to the provided command returning the
   * provided command builder. When chaining, it's important to call this
   * after you are done configuring the current command or else you will
   * start modifying the provided command instead.
   *
   * @example
   * ```ts
   * const lineCount = await $`echo 1 && echo 2`
   *  .pipe($`wc -l`)
   *  .text();
   * ```
   */
  pipe(builder) {
    return builder.stdin(this.stdout("piped"));
  }
  env(nameOrItems, value) {
    return this.#newWithState((state) => {
      if (typeof nameOrItems === "string") {
        setEnv(state, nameOrItems, value);
      } else {
        for (const [key, value2] of Object.entries(nameOrItems)) {
          setEnv(state, key, value2);
        }
      }
    });
    function setEnv(state, key, value2) {
      if (Deno.build.os === "windows") {
        key = key.toUpperCase();
      }
      state.env[key] = value2;
    }
  }
  /** Sets the current working directory to use when executing this command. */
  cwd(dirPath) {
    return this.#newWithState((state) => {
      state.cwd = dirPath instanceof URL ? fromFileUrl6(dirPath) : dirPath instanceof Path2 ? dirPath.resolve().toString() : resolve6(dirPath);
    });
  }
  /**
   * Exports the environment of the command to the executing process.
   *
   * So for example, changing the directory in a command or exporting
   * an environment variable will actually change the environment
   * of the executing process.
   *
   * ```ts
   * await $`cd src && export SOME_VALUE=5`;
   * console.log(Deno.env.get("SOME_VALUE")); // 5
   * console.log(Deno.cwd()); // will be in the src directory
   * ```
   */
  exportEnv(value = true) {
    return this.#newWithState((state) => {
      state.exportEnv = value;
    });
  }
  /**
   * Clear environmental variables from parent process.
   *
   * Doesn't guarantee that only `env` variables are present, as the OS may
   * set environmental variables for processes.
   */
  clearEnv(value = true) {
    return this.#newWithState((state) => {
      state.clearEnv = value;
    });
  }
  /**
   * Prints the command text before executing the command.
   *
   * For example:
   *
   * ```ts
   * const text = "example";
   * await $`echo ${text}`.printCommand();
   * ```
   *
   * Outputs:
   *
   * ```
   * > echo example
   * example
   * ```
   */
  printCommand(value = true) {
    return this.#newWithState((state) => {
      state.printCommand = value;
    });
  }
  /**
   * Mutates the command builder to change the logger used
   * for `printCommand()`.
   */
  setPrintCommandLogger(logger3) {
    this.#state.printCommandLogger.setValue(logger3);
  }
  /**
   * Ensures stdout and stderr are piped if they have the default behaviour or are inherited.
   *
   * ```ts
   * // ensure both stdout and stderr is not logged to the console
   * await $`echo 1`.quiet();
   * // ensure stdout is not logged to the console
   * await $`echo 1`.quiet("stdout");
   * // ensure stderr is not logged to the console
   * await $`echo 1`.quiet("stderr");
   * ```
   */
  quiet(kind = "combined") {
    kind = kind === "both" ? "combined" : kind;
    return this.#newWithState((state) => {
      if (kind === "combined" || kind === "stdout") {
        state.stdout.kind = getQuietKind(state.stdout.kind);
      }
      if (kind === "combined" || kind === "stderr") {
        state.stderr.kind = getQuietKind(state.stderr.kind);
      }
    });
    function getQuietKind(kind2) {
      if (typeof kind2 === "object") {
        return kind2;
      }
      switch (kind2) {
        case "inheritPiped":
        case "inherit":
          return "piped";
        case "null":
        case "piped":
          return kind2;
        default: {
          const _assertNever = kind2;
          throw new Error(`Unhandled kind ${kind2}.`);
        }
      }
    }
  }
  /**
   * Specifies a timeout for the command. The command will exit with
   * exit code `124` (timeout) if it times out.
   *
   * Note that when using `.noThrow()` this won't cause an error to
   * be thrown when timing out.
   */
  timeout(delay) {
    return this.#newWithState((state) => {
      state.timeout = delay == null ? void 0 : delayToMs2(delay);
    });
  }
  /**
   * Sets stdout as quiet, spawns the command, and gets stdout as a Uint8Array.
   *
   * Shorthand for:
   *
   * ```ts
   * const data = (await $`command`.quiet("stdout")).stdoutBytes;
   * ```
   */
  async bytes(kind = "stdout") {
    const command = kind === "combined" ? this.quiet(kind).captureCombined() : this.quiet(kind);
    return (await command)[`${kind}Bytes`];
  }
  /**
   * Sets the provided stream (stdout by default) as quiet, spawns the command, and gets the stream as a string without the last newline.
   * Can be used to get stdout, stderr, or both.
   *
   * Shorthand for:
   *
   * ```ts
   * const data = (await $`command`.quiet("stdout")).stdout.replace(/\r?\n$/, "");
   * ```
   */
  async text(kind = "stdout") {
    const command = kind === "combined" ? this.quiet(kind).captureCombined() : this.quiet(kind);
    return (await command)[kind].replace(/\r?\n$/, "");
  }
  /** Gets the text as an array of lines. */
  async lines(kind = "stdout") {
    const text = await this.text(kind);
    return text.split(/\r?\n/g);
  }
  /**
   * Sets stream (stdout by default) as quiet, spawns the command, and gets stream as JSON.
   *
   * Shorthand for:
   *
   * ```ts
   * const data = (await $`command`.quiet("stdout")).stdoutJson;
   * ```
   */
  async json(kind = "stdout") {
    return (await this.quiet(kind))[`${kind}Json`];
  }
  /** @internal */
  [getRegisteredCommandNamesSymbol2]() {
    return Object.keys(this.#state.commands);
  }
  /** @internal */
  [setCommandTextStateSymbol2](textState) {
    return this.#newWithState((state) => {
      state.command = textState;
    });
  }
};
var CommandChild2 = class extends Promise {
  #pipedStdoutBuffer;
  #pipedStderrBuffer;
  #killSignalController;
  /** @internal */
  constructor(executor, options = { pipedStderrBuffer: void 0, pipedStdoutBuffer: void 0, killSignalController: void 0 }) {
    super(executor);
    this.#pipedStdoutBuffer = options.pipedStdoutBuffer;
    this.#pipedStderrBuffer = options.pipedStderrBuffer;
    this.#killSignalController = options.killSignalController;
  }
  /** Send a signal to the executing command's child process. Note that SIGTERM,
   * SIGKILL, SIGABRT, SIGQUIT, SIGINT, or SIGSTOP will cause the entire command
   * to be considered "aborted" and if part of a command runs after this has occurred
   * it will return a 124 exit code. Other signals will just be forwarded to the command.
   *
   * Defaults to "SIGTERM".
   */
  kill(signal) {
    this.#killSignalController?.kill(signal);
  }
  stdout() {
    const buffer = this.#pipedStdoutBuffer;
    this.#assertBufferStreamable("stdout", buffer);
    this.#pipedStdoutBuffer = "consumed";
    this.catch(() => {
    });
    return this.#bufferToStream(buffer);
  }
  stderr() {
    const buffer = this.#pipedStderrBuffer;
    this.#assertBufferStreamable("stderr", buffer);
    this.#pipedStderrBuffer = "consumed";
    this.catch(() => {
    });
    return this.#bufferToStream(buffer);
  }
  #assertBufferStreamable(name, buffer) {
    if (buffer == null) {
      throw new Error(
        `No pipe available. Ensure ${name} is "piped" (not "inheritPiped") and combinedOutput is not enabled.`
      );
    }
    if (buffer === "consumed") {
      throw new Error(`Streamable ${name} was already consumed. Use the previously acquired stream instead.`);
    }
  }
  #bufferToStream(buffer) {
    const self = this;
    return new ReadableStream({
      start(controller) {
        buffer.setListener({
          writeSync(data) {
            controller.enqueue(data);
            return data.length;
          },
          setError(err) {
            controller.error(err);
          },
          close() {
            controller.close();
          }
        });
      },
      cancel(_reason) {
        self.kill();
      }
    });
  }
};
function parseAndSpawnCommand2(state) {
  if (state.command == null) {
    throw new Error("A command must be set before it can be spawned.");
  }
  if (state.printCommand) {
    state.printCommandLogger.getValue()(state.command.text);
  }
  const disposables = [];
  const asyncDisposables = [];
  const parentSignal = state.signal;
  const killSignalController = new KillSignalController2();
  if (parentSignal != null) {
    const parentSignalListener = (signal2) => {
      killSignalController.kill(signal2);
    };
    parentSignal.addListener(parentSignalListener);
    disposables.push({
      [Symbol.dispose]() {
        parentSignal.removeListener(parentSignalListener);
      }
    });
  }
  let timedOut = false;
  if (state.timeout != null) {
    const timeoutId = setTimeout(() => {
      timedOut = true;
      killSignalController.kill();
    }, state.timeout);
    disposables.push({
      [Symbol.dispose]() {
        clearTimeout(timeoutId);
      }
    });
  }
  const [stdoutBuffer, stderrBuffer, combinedBuffer] = getBuffers();
  const stdout = new ShellPipeWriter2(
    state.stdout.kind,
    stdoutBuffer === "null" ? new NullPipeWriter2() : stdoutBuffer === "inherit" ? Deno.stdout : stdoutBuffer
  );
  const stderr = new ShellPipeWriter2(
    state.stderr.kind,
    stderrBuffer === "null" ? new NullPipeWriter2() : stderrBuffer === "inherit" ? Deno.stderr : stderrBuffer
  );
  const { text: commandText, fds } = state.command;
  const signal = killSignalController.signal;
  return new CommandChild2(async (resolve7, reject) => {
    try {
      const list = parseCommand2(commandText);
      const stdin = await takeStdin();
      let code4 = await spawn2(list, {
        stdin: stdin instanceof ReadableStream ? readerFromStreamReader2(stdin.getReader()) : stdin,
        stdout,
        stderr,
        env: buildEnv2(state.env, state.clearEnv),
        commands: state.commands,
        cwd: state.cwd ?? Deno.cwd(),
        exportEnv: state.exportEnv,
        clearedEnv: state.clearEnv,
        signal,
        fds
      });
      if (code4 !== 0) {
        if (timedOut) {
          code4 = 124;
        }
        const noThrow = state.noThrow instanceof Array ? state.noThrow.includes(code4) : state.noThrow;
        if (!noThrow) {
          if (stdin instanceof ReadableStream) {
            if (!stdin.locked) {
              stdin.cancel();
            }
          }
          if (timedOut) {
            throw new Error(`Timed out with exit code: ${code4}`);
          } else if (signal.aborted) {
            throw new Error(`${timedOut ? "Timed out" : "Aborted"} with exit code: ${code4}`);
          } else {
            throw new Error(`Exited with code: ${code4}`);
          }
        }
      }
      const result = new CommandResult2(
        code4,
        finalizeCommandResultBuffer(stdoutBuffer),
        finalizeCommandResultBuffer(stderrBuffer),
        combinedBuffer instanceof Buffer ? combinedBuffer : void 0
      );
      const maybeError = await cleanupDisposablesAndMaybeGetError(void 0);
      if (maybeError) {
        reject(maybeError);
      } else {
        resolve7(result);
      }
    } catch (err) {
      finalizeCommandResultBufferForError(stdoutBuffer, err);
      finalizeCommandResultBufferForError(stderrBuffer, err);
      reject(await cleanupDisposablesAndMaybeGetError(err));
    }
  }, {
    pipedStdoutBuffer: stdoutBuffer instanceof PipedBuffer2 ? stdoutBuffer : void 0,
    pipedStderrBuffer: stderrBuffer instanceof PipedBuffer2 ? stderrBuffer : void 0,
    killSignalController
  });
  async function cleanupDisposablesAndMaybeGetError(maybeError) {
    const errors = [];
    if (maybeError) {
      errors.push(maybeError);
    }
    for (const disposable of disposables) {
      try {
        disposable[Symbol.dispose]();
      } catch (err) {
        errors.push(err);
      }
    }
    if (asyncDisposables.length > 0) {
      await Promise.all(asyncDisposables.map(async (d) => {
        try {
          await d[Symbol.asyncDispose]();
        } catch (err) {
          errors.push(err);
        }
      }));
    }
    if (errors.length === 1) {
      return errors[0];
    } else if (errors.length > 1) {
      return new AggregateError(errors);
    } else {
      return void 0;
    }
  }
  async function takeStdin() {
    if (state.stdin instanceof Box2) {
      const stdin = state.stdin.value;
      if (stdin === "consumed") {
        throw new Error(
          "Cannot spawn command. Stdin was already consumed when a previous command using the same stdin was spawned. You need to call `.stdin(...)` again with a new value before spawning."
        );
      }
      state.stdin.value = "consumed";
      return stdin;
    } else if (state.stdin instanceof Deferred2) {
      const stdin = await state.stdin.create();
      if (stdin instanceof ReadableStream) {
        asyncDisposables.push({
          async [Symbol.asyncDispose]() {
            if (!stdin.locked) {
              await stdin.cancel();
            }
          }
        });
      }
      return stdin;
    } else {
      return state.stdin;
    }
  }
  function getBuffers() {
    const hasProgressBars = isShowingProgressBars2();
    const stdoutBuffer2 = getOutputBuffer(Deno.stdout, state.stdout);
    const stderrBuffer2 = getOutputBuffer(Deno.stderr, state.stderr);
    if (state.combinedStdoutStderr) {
      if (typeof stdoutBuffer2 === "string" || typeof stderrBuffer2 === "string") {
        throw new Error("Internal programming error. Expected writers for stdout and stderr.");
      }
      const combinedBuffer2 = new Buffer();
      return [
        getCapturingBuffer(stdoutBuffer2, combinedBuffer2),
        getCapturingBuffer(stderrBuffer2, combinedBuffer2),
        combinedBuffer2
      ];
    }
    return [stdoutBuffer2, stderrBuffer2, void 0];
    function getCapturingBuffer(buffer, combinedBuffer2) {
      if ("write" in buffer) {
        return new CapturingBufferWriter2(buffer, combinedBuffer2);
      } else {
        return new CapturingBufferWriterSync2(buffer, combinedBuffer2);
      }
    }
    function getOutputBuffer(inheritWriter, { kind, options }) {
      if (typeof kind === "object") {
        if (kind instanceof Path2) {
          const file = kind.openSync({ write: true, truncate: true, create: true });
          disposables.push(file);
          return file;
        } else if (kind instanceof WritableStream) {
          const streamWriter = kind.getWriter();
          asyncDisposables.push({
            async [Symbol.asyncDispose]() {
              streamWriter.releaseLock();
              if (!options?.preventClose) {
                try {
                  await kind.close();
                } catch {
                }
              }
            }
          });
          return writerFromStreamWriter(streamWriter);
        } else {
          return kind;
        }
      }
      switch (kind) {
        case "inherit":
          if (hasProgressBars) {
            return new InheritStaticTextBypassWriter2(inheritWriter);
          } else {
            return "inherit";
          }
        case "piped":
          return new PipedBuffer2();
        case "inheritPiped":
          return new CapturingBufferWriterSync2(inheritWriter, new Buffer());
        case "null":
          return "null";
        default: {
          const _assertNever = kind;
          throw new Error("Unhandled.");
        }
      }
    }
  }
  function finalizeCommandResultBuffer(buffer) {
    if (buffer instanceof CapturingBufferWriterSync2 || buffer instanceof CapturingBufferWriter2) {
      return buffer.getBuffer();
    } else if (buffer instanceof InheritStaticTextBypassWriter2) {
      buffer.flush();
      return "inherit";
    } else if (buffer instanceof PipedBuffer2) {
      buffer.close();
      return buffer.getBuffer() ?? "streamed";
    } else if (typeof buffer === "object") {
      return "streamed";
    } else {
      return buffer;
    }
  }
  function finalizeCommandResultBufferForError(buffer, error) {
    if (buffer instanceof InheritStaticTextBypassWriter2) {
      buffer.flush();
    } else if (buffer instanceof PipedBuffer2) {
      buffer.setError(error);
    }
  }
}
var CommandResult2 = class {
  #stdout;
  #stderr;
  #combined;
  /** The exit code. */
  code;
  /** @internal */
  constructor(code4, stdout, stderr, combined) {
    this.code = code4;
    this.#stdout = stdout;
    this.#stderr = stderr;
    this.#combined = combined;
  }
  #memoizedStdout;
  /** Raw decoded stdout text. */
  get stdout() {
    if (!this.#memoizedStdout) {
      this.#memoizedStdout = textDecoder3.decode(this.stdoutBytes);
    }
    return this.#memoizedStdout;
  }
  #memoizedStdoutJson;
  /**
   * Stdout text as JSON.
   *
   * @remarks Will throw if it can't be parsed as JSON.
   */
  get stdoutJson() {
    if (this.#memoizedStdoutJson == null) {
      this.#memoizedStdoutJson = JSON.parse(this.stdout);
    }
    return this.#memoizedStdoutJson;
  }
  /** Raw stdout bytes. */
  get stdoutBytes() {
    if (this.#stdout === "streamed") {
      throw new Error(
        `Stdout was streamed to another source and is no longer available.`
      );
    }
    if (typeof this.#stdout === "string") {
      throw new Error(
        `Stdout was not piped (was ${this.#stdout}). Call .stdout("piped") or .stdout("inheritPiped") when building the command.`
      );
    }
    return this.#stdout.bytes({ copy: false });
  }
  #memoizedStderr;
  /** Raw decoded stdout text. */
  get stderr() {
    if (!this.#memoizedStderr) {
      this.#memoizedStderr = textDecoder3.decode(this.stderrBytes);
    }
    return this.#memoizedStderr;
  }
  #memoizedStderrJson;
  /**
   * Stderr text as JSON.
   *
   * @remarks Will throw if it can't be parsed as JSON.
   */
  get stderrJson() {
    if (this.#memoizedStderrJson == null) {
      this.#memoizedStderrJson = JSON.parse(this.stderr);
    }
    return this.#memoizedStderrJson;
  }
  /** Raw stderr bytes. */
  get stderrBytes() {
    if (this.#stderr === "streamed") {
      throw new Error(
        `Stderr was streamed to another source and is no longer available.`
      );
    }
    if (typeof this.#stderr === "string") {
      throw new Error(
        `Stderr was not piped (was ${this.#stderr}). Call .stderr("piped") or .stderr("inheritPiped") when building the command.`
      );
    }
    return this.#stderr.bytes({ copy: false });
  }
  #memoizedCombined;
  /** Raw combined stdout and stderr text. */
  get combined() {
    if (!this.#memoizedCombined) {
      this.#memoizedCombined = textDecoder3.decode(this.combinedBytes);
    }
    return this.#memoizedCombined;
  }
  /** Raw combined stdout and stderr bytes. */
  get combinedBytes() {
    if (this.#combined == null) {
      throw new Error("Stdout and stderr were not combined. Call .captureCombined() when building the command.");
    }
    return this.#combined.bytes({ copy: false });
  }
};
function buildEnv2(env, clearEnv) {
  const result = clearEnv ? {} : Deno.env.toObject();
  for (const [key, value] of Object.entries(env)) {
    if (value == null) {
      delete result[key];
    } else {
      result[key] = value;
    }
  }
  return result;
}
function escapeArg2(arg) {
  if (/^[A-Za-z0-9]+$/.test(arg)) {
    return arg;
  } else {
    return `'${arg.replaceAll("'", `'"'"'`)}'`;
  }
}
function validateCommandName2(command) {
  if (command.match(/^[a-zA-Z0-9-_]+$/) == null) {
    throw new Error("Invalid command name");
  }
}
var SHELL_SIGNAL_CTOR_SYMBOL2 = Symbol();
var KillSignalController2 = class {
  #state;
  #killSignal;
  constructor() {
    this.#state = {
      abortedCode: void 0,
      listeners: []
    };
    this.#killSignal = new KillSignal2(SHELL_SIGNAL_CTOR_SYMBOL2, this.#state);
  }
  get signal() {
    return this.#killSignal;
  }
  /** Send a signal to the downstream child process. Note that SIGTERM,
   * SIGKILL, SIGABRT, SIGQUIT, SIGINT, or SIGSTOP will cause all the commands
   * to be considered "aborted" and will return a 124 exit code, while other
   * signals will just be forwarded to the commands.
   */
  kill(signal = "SIGTERM") {
    sendSignalToState2(this.#state, signal);
  }
};
var KillSignal2 = class {
  #state;
  /** @internal */
  constructor(symbol, state) {
    if (symbol !== SHELL_SIGNAL_CTOR_SYMBOL2) {
      throw new Error("Constructing instances of KillSignal is not permitted.");
    }
    this.#state = state;
  }
  /** Returns if the command signal has ever received a SIGTERM,
   * SIGKILL, SIGABRT, SIGQUIT, SIGINT, or SIGSTOP
   */
  get aborted() {
    return this.#state.abortedCode !== void 0;
  }
  /** Gets the exit code to use if aborted. */
  get abortedExitCode() {
    return this.#state.abortedCode;
  }
  /**
   * Causes the provided kill signal to be triggered when this
   * signal receives a signal.
   */
  linkChild(killSignal) {
    const listener = (signal) => {
      sendSignalToState2(killSignal.#state, signal);
    };
    this.addListener(listener);
    return {
      unsubscribe: () => {
        this.removeListener(listener);
      }
    };
  }
  addListener(listener) {
    this.#state.listeners.push(listener);
  }
  removeListener(listener) {
    const index = this.#state.listeners.indexOf(listener);
    if (index >= 0) {
      this.#state.listeners.splice(index, 1);
    }
  }
};
function sendSignalToState2(state, signal) {
  const code4 = getSignalAbortCode2(signal);
  if (code4 !== void 0) {
    state.abortedCode = code4;
  }
  for (const listener of state.listeners) {
    listener(signal);
  }
}
function getSignalAbortCode2(signal) {
  switch (signal) {
    case "SIGTERM":
      return 128 + 15;
    case "SIGKILL":
      return 128 + 9;
    case "SIGABRT":
      return 128 + 6;
    case "SIGQUIT":
      return 128 + 3;
    case "SIGINT":
      return 128 + 2;
    case "SIGSTOP":
      return 128 + 19;
    default:
      return void 0;
  }
}
function template2(strings, exprs) {
  return templateInner2(strings, exprs, escapeArg2);
}
function templateRaw2(strings, exprs) {
  return templateInner2(strings, exprs, void 0);
}
function templateInner2(strings, exprs, escape) {
  let nextStreamFd = 3;
  let text = "";
  let streams;
  const exprsCount = exprs.length;
  for (let i = 0; i < Math.max(strings.length, exprs.length); i++) {
    if (strings.length > i) {
      text += strings[i];
    }
    if (exprs.length > i) {
      try {
        const expr = exprs[i];
        if (expr == null) {
          throw "Expression was null or undefined.";
        }
        const inputOrOutputRedirect = detectInputOrOutputRedirect2(text);
        if (inputOrOutputRedirect === "<") {
          if (expr instanceof Path2) {
            text += templateLiteralExprToString2(expr, escape);
          } else if (typeof expr === "string") {
            handleReadableStream(
              () => new ReadableStream({
                start(controller) {
                  controller.enqueue(new TextEncoder().encode(expr));
                  controller.close();
                }
              })
            );
          } else if (expr instanceof ReadableStream) {
            handleReadableStream(() => expr);
          } else if (expr?.[symbols2.readable]) {
            handleReadableStream(() => {
              const stream = expr[symbols2.readable]?.();
              if (!(stream instanceof ReadableStream)) {
                throw new Error(
                  `Expected a ReadableStream or an object with a [$.symbols.readable] method that returns a ReadableStream at expression ${i + 1}/${exprsCount}.`
                );
              }
              return stream;
            });
          } else if (expr instanceof Uint8Array) {
            handleReadableStream(() => {
              return new ReadableStream({
                start(controller) {
                  controller.enqueue(expr);
                  controller.close();
                }
              });
            });
          } else if (expr instanceof Response) {
            handleReadableStream(() => {
              return expr.body ?? new ReadableStream({
                start(controller) {
                  controller.close();
                }
              });
            });
          } else if (expr instanceof Function) {
            handleReadableStream(() => {
              try {
                const result = expr();
                if (!(result instanceof ReadableStream)) {
                  throw new Error("Function did not return a ReadableStream.");
                }
                return result;
              } catch (err) {
                throw new Error(
                  `Error getting ReadableStream from function at expression ${i + 1}/${exprsCount}. ${errorToString2(err)}`
                );
              }
            });
          } else {
            throw new Error("Unsupported object provided to input redirect.");
          }
        } else if (inputOrOutputRedirect === ">") {
          if (expr instanceof Path2) {
            text += templateLiteralExprToString2(expr, escape);
          } else if (expr instanceof WritableStream) {
            handleWritableStream(() => expr);
          } else if (expr instanceof Uint8Array) {
            let pos = 0;
            handleWritableStream(() => {
              return new WritableStream({
                write(chunk) {
                  const nextPos = chunk.length + pos;
                  if (nextPos > expr.length) {
                    const chunkLength = expr.length - pos;
                    expr.set(chunk.slice(0, chunkLength), pos);
                    throw new Error(`Overflow writing ${nextPos} bytes to Uint8Array (length: ${exprsCount}).`);
                  }
                  expr.set(chunk, pos);
                  pos = nextPos;
                }
              });
            });
          } else if (expr?.[symbols2.writable]) {
            handleWritableStream(() => {
              const stream = expr[symbols2.writable]?.();
              if (!(stream instanceof WritableStream)) {
                throw new Error(
                  `Expected a WritableStream or an object with a [$.symbols.writable] method that returns a WritableStream at expression ${i + 1}/${exprsCount}.`
                );
              }
              return stream;
            });
          } else if (expr instanceof Function) {
            handleWritableStream(() => {
              try {
                const result = expr();
                if (!(result instanceof WritableStream)) {
                  throw new Error("Function did not return a WritableStream.");
                }
                return result;
              } catch (err) {
                throw new Error(
                  `Error getting WritableStream from function at expression ${i + 1}/${exprsCount}. ${errorToString2(err)}`
                );
              }
            });
          } else if (typeof expr === "string") {
            throw new Error(
              "Cannot provide strings to output redirects. Did you mean to provide a path instead via the `$.path(...)` API?"
            );
          } else {
            throw new Error("Unsupported object provided to output redirect.");
          }
        } else {
          text += templateLiteralExprToString2(expr, escape);
        }
      } catch (err) {
        const startMessage = exprsCount === 1 ? "Failed resolving expression in command." : `Failed resolving expression ${i + 1}/${exprsCount} in command.`;
        throw new Error(`${startMessage} ${errorToString2(err)}`);
      }
    }
  }
  return {
    text,
    fds: streams
  };
  function handleReadableStream(createStream) {
    streams ??= new StreamFds2();
    const fd = nextStreamFd++;
    streams.insertReader(fd, () => {
      const reader = createStream().getReader();
      return {
        ...readerFromStreamReader2(reader),
        [Symbol.dispose]() {
          reader.releaseLock();
        }
      };
    });
    text = text.trimEnd() + "&" + fd;
  }
  function handleWritableStream(createStream) {
    streams ??= new StreamFds2();
    const fd = nextStreamFd++;
    streams.insertWriter(fd, () => {
      const stream = createStream();
      const writer = stream.getWriter();
      return {
        ...writerFromStreamWriter(writer),
        async [Symbol.asyncDispose]() {
          writer.releaseLock();
          try {
            await stream.close();
          } catch {
          }
        }
      };
    });
    text = text.trimEnd() + "&" + fd;
  }
}
function detectInputOrOutputRedirect2(text) {
  text = text.trimEnd();
  if (text.endsWith(">")) {
    return ">";
  } else if (text.endsWith("<")) {
    return "<";
  } else {
    return void 0;
  }
}
function templateLiteralExprToString2(expr, escape) {
  let result;
  if (typeof expr === "string") {
    result = expr;
  } else if (expr instanceof Array) {
    return expr.map((e) => templateLiteralExprToString2(e, escape)).join(" ");
  } else if (expr instanceof CommandResult2) {
    result = expr.stdout.replace(/\r?\n$/, "");
  } else if (expr instanceof CommandBuilder2) {
    throw new Error(
      "Providing a command builder is not yet supported (https://github.com/dsherret/dax/issues/239). Await the command builder's text before using it in an expression (ex. await $`cmd`.text())."
    );
  } else if (typeof expr === "object" && expr.toString === Object.prototype.toString) {
    throw new Error("Provided object does not override `toString()`.");
  } else {
    result = `${expr}`;
  }
  return escape ? escape(result) : result;
}
function extend2(target, source) {
  for (const prop in source) {
    if (Object.hasOwn(source, prop)) {
      target[prop] = source[prop];
    }
  }
  return target;
}
var reLeadingNewline2 = /^[ \t]*(?:\r\n|\r|\n)/;
var reTrailingNewline2 = /(?:\r\n|\r|\n)[ \t]*$/;
var reStartsWithNewlineOrIsEmpty2 = /^(?:[\r\n]|$)/;
var reDetectIndentation2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/;
var reOnlyWhitespaceWithAtLeastOneNewline2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
function _outdentArray2(strings, firstInterpolatedValueSetsIndentationLevel, options) {
  let indentationLevel = 0;
  const match = strings[0].match(reDetectIndentation2);
  if (match) {
    indentationLevel = match[1].length;
  }
  const reSource = `(\\r\\n|\\r|\\n).{0,${indentationLevel}}`;
  const reMatchIndent = new RegExp(reSource, "g");
  if (firstInterpolatedValueSetsIndentationLevel) {
    strings = strings.slice(1);
  }
  const { newline, trimLeadingNewline, trimTrailingNewline } = options;
  const normalizeNewlines = typeof newline === "string";
  const l = strings.length;
  const outdentedStrings = strings.map((v, i) => {
    v = v.replace(reMatchIndent, "$1");
    if (i === 0 && trimLeadingNewline) {
      v = v.replace(reLeadingNewline2, "");
    }
    if (i === l - 1 && trimTrailingNewline) {
      v = v.replace(reTrailingNewline2, "");
    }
    if (normalizeNewlines) {
      v = v.replace(/\r\n|\n|\r/g, (_) => newline);
    }
    return v;
  });
  return outdentedStrings;
}
function concatStringsAndValues2(strings, values) {
  let ret = "";
  for (let i = 0, l = strings.length; i < l; i++) {
    ret += strings[i];
    if (i < l - 1) {
      ret += values[i];
    }
  }
  return ret;
}
function isTemplateStringsArray2(v) {
  return Object.hasOwn(v, "raw") && Object.hasOwn(v, "length");
}
function createInstance2(options) {
  const arrayAutoIndentCache = /* @__PURE__ */ new WeakMap();
  const arrayFirstInterpSetsIndentCache = /* @__PURE__ */ new WeakMap();
  function outdent(stringsOrOptions, ...values) {
    if (isTemplateStringsArray2(stringsOrOptions)) {
      const strings = stringsOrOptions;
      const firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent2) && reOnlyWhitespaceWithAtLeastOneNewline2.test(strings[0]) && reStartsWithNewlineOrIsEmpty2.test(strings[1]);
      const cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;
      let renderedArray = cache.get(strings);
      if (!renderedArray) {
        renderedArray = _outdentArray2(
          strings,
          firstInterpolatedValueSetsIndentationLevel,
          options
        );
        cache.set(strings, renderedArray);
      }
      if (values.length === 0) {
        return renderedArray[0];
      }
      const rendered = concatStringsAndValues2(
        renderedArray,
        firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values
      );
      return rendered;
    } else {
      return createInstance2(
        extend2(extend2({}, options), stringsOrOptions || {})
      );
    }
  }
  const fullOutdent = extend2(outdent, {
    string(str) {
      return _outdentArray2([str], false, options)[0];
    }
  });
  return fullOutdent;
}
var defaultOutdent2 = createInstance2({
  trimLeadingNewline: true,
  trimTrailingNewline: true
});
function sleep2(delay) {
  const ms = delayToMs2(delay);
  return new Promise((resolve7) => setTimeout(resolve7, ms));
}
async function withRetries2($local, errorLogger, opts) {
  const delayIterator = delayToIterator2(opts.delay);
  for (let i = 0; i < opts.count; i++) {
    if (i > 0) {
      const nextDelay = delayIterator.next();
      if (!opts.quiet) {
        $local.logWarn(`Failed. Trying again in ${formatMillis2(nextDelay)}...`);
      }
      await sleep2(nextDelay);
      if (!opts.quiet) {
        $local.logStep(`Retrying attempt ${i + 1}/${opts.count}...`);
      }
    }
    try {
      return await opts.action();
    } catch (err) {
      errorLogger(err);
    }
  }
  throw new Error(`Failed after ${opts.count} attempts.`);
}
function cd2(path) {
  if (typeof path === "string" || path instanceof URL) {
    path = new Path2(path);
  } else if (!(path instanceof Path2)) {
    path = new Path2(path).parentOrThrow();
  }
  Deno.chdir(path.toString());
}
function buildInitial$State2(opts) {
  return {
    commandBuilder: new TreeBox2(opts.commandBuilder ?? new CommandBuilder2()),
    requestBuilder: opts.requestBuilder ?? new RequestBuilder2(),
    // deno-lint-ignore no-console
    infoLogger: new LoggerTreeBox2(console.error),
    // deno-lint-ignore no-console
    warnLogger: new LoggerTreeBox2(console.error),
    // deno-lint-ignore no-console
    errorLogger: new LoggerTreeBox2(console.error),
    indentLevel: new Box2(0),
    extras: opts.extras
  };
}
var helperObject2 = {
  path: createPath2,
  cd: cd2,
  escapeArg: escapeArg2,
  stripAnsi(text) {
    return wasmInstance2.strip_ansi_codes(text);
  },
  dedent: defaultOutdent2,
  sleep: sleep2,
  which(commandName) {
    if (commandName.toUpperCase() === "DENO") {
      return Promise.resolve(Deno.execPath());
    } else {
      return which(commandName, denoWhichRealEnv2);
    }
  },
  whichSync(commandName) {
    if (commandName.toUpperCase() === "DENO") {
      return Deno.execPath();
    } else {
      return whichSync(commandName, denoWhichRealEnv2);
    }
  }
};
function build$FromState2(state) {
  const logDepthObj = {
    get logDepth() {
      return state.indentLevel.value;
    },
    set logDepth(value) {
      if (value < 0 || value % 1 !== 0) {
        throw new Error("Expected a positive integer.");
      }
      state.indentLevel.value = value;
    }
  };
  const result = Object.assign(
    (strings, ...exprs) => {
      const textState = template2(strings, exprs);
      return state.commandBuilder.getValue()[setCommandTextStateSymbol2](textState);
    },
    helperObject2,
    logDepthObj,
    {
      build$(opts = {}) {
        return build$FromState2({
          commandBuilder: opts.commandBuilder != null ? new TreeBox2(opts.commandBuilder) : state.commandBuilder.createChild(),
          requestBuilder: opts.requestBuilder ?? state.requestBuilder,
          errorLogger: state.errorLogger.createChild(),
          infoLogger: state.infoLogger.createChild(),
          warnLogger: state.warnLogger.createChild(),
          indentLevel: state.indentLevel,
          extras: {
            ...state.extras,
            ...opts.extras
          }
        });
      },
      log(...data) {
        state.infoLogger.getValue()(getLogText(data));
      },
      logLight(...data) {
        state.infoLogger.getValue()(gray4(getLogText(data)));
      },
      logStep(firstArg, ...data) {
        logStep(firstArg, data, (t) => bold4(green3(t)), state.infoLogger.getValue());
      },
      logError(firstArg, ...data) {
        logStep(firstArg, data, (t) => bold4(red3(t)), state.errorLogger.getValue());
      },
      logWarn(firstArg, ...data) {
        logStep(firstArg, data, (t) => bold4(yellow2(t)), state.warnLogger.getValue());
      },
      logGroup(labelOrAction, maybeAction) {
        const label = typeof labelOrAction === "string" ? labelOrAction : void 0;
        if (label) {
          state.infoLogger.getValue()(getLogText([label]));
        }
        state.indentLevel.value++;
        const action = label != null ? maybeAction : labelOrAction;
        if (action != null) {
          let wasPromise = false;
          try {
            const result2 = action();
            if (result2 instanceof Promise) {
              wasPromise = true;
              return result2.finally(() => {
                if (state.indentLevel.value > 0) {
                  state.indentLevel.value--;
                }
              });
            } else {
              return result2;
            }
          } finally {
            if (!wasPromise) {
              if (state.indentLevel.value > 0) {
                state.indentLevel.value--;
              }
            }
          }
        }
      },
      logGroupEnd() {
        if (state.indentLevel.value > 0) {
          state.indentLevel.value--;
        }
      },
      commandExists(commandName) {
        if (state.commandBuilder.getValue()[getRegisteredCommandNamesSymbol2]().includes(commandName)) {
          return Promise.resolve(true);
        }
        return helperObject2.which(commandName).then((c) => c != null);
      },
      commandExistsSync(commandName) {
        if (state.commandBuilder.getValue()[getRegisteredCommandNamesSymbol2]().includes(commandName)) {
          return true;
        }
        return helperObject2.whichSync(commandName) != null;
      },
      maybeConfirm: maybeConfirm2,
      confirm: confirm2,
      maybeSelect: maybeSelect2,
      select: select2,
      maybeMultiSelect: maybeMultiSelect2,
      multiSelect: multiSelect2,
      maybePrompt: maybePrompt2,
      prompt: prompt2,
      progress(messageOrText, options) {
        const opts = typeof messageOrText === "string" ? (() => {
          const words = messageOrText.split(" ");
          return {
            prefix: words[0],
            message: words.length > 1 ? words.slice(1).join(" ") : void 0,
            ...options
          };
        })() : messageOrText;
        return new ProgressBar2((...data) => {
          state.infoLogger.getValue()(...data);
        }, opts);
      },
      setInfoLogger(logger3) {
        state.infoLogger.setValue(logger3);
      },
      setWarnLogger(logger3) {
        state.warnLogger.setValue(logger3);
      },
      setErrorLogger(logger3) {
        state.errorLogger.setValue(logger3);
        const commandBuilder = state.commandBuilder.getValue();
        commandBuilder.setPrintCommandLogger(
          (cmd) => logger3(white3(">"), blue2(cmd))
        );
        state.commandBuilder.setValue(commandBuilder);
      },
      setPrintCommand(value) {
        const commandBuilder = state.commandBuilder.getValue().printCommand(value);
        state.commandBuilder.setValue(commandBuilder);
      },
      symbols: symbols2,
      request(url) {
        return state.requestBuilder.url(url);
      },
      raw(strings, ...exprs) {
        const textState = templateRaw2(strings, exprs);
        return state.commandBuilder.getValue()[setCommandTextStateSymbol2](textState);
      },
      withRetries(opts) {
        return withRetries2(result, state.errorLogger.getValue(), opts);
      }
    },
    state.extras
  );
  const keyName = "logDepth";
  Object.defineProperty(result, keyName, Object.getOwnPropertyDescriptor(logDepthObj, keyName));
  state.requestBuilder = state.requestBuilder[withProgressBarFactorySymbol2]((message) => result.progress(message));
  return result;
  function getLogText(data) {
    const combinedText = data.map((d) => {
      const typeofD = typeof d;
      if (typeofD !== "object" && typeofD !== "undefined") {
        return d;
      } else {
        return Deno.inspect(d, { colors: true });
      }
    }).join(" ");
    if (state.indentLevel.value === 0) {
      return combinedText;
    } else {
      const indentText = "  ".repeat(state.indentLevel.value);
      return combinedText.split(/\n/).map((l) => `${indentText}${l}`).join("\n");
    }
  }
  function logStep(firstArg, data, colourize, logger3) {
    if (data.length === 0) {
      let i = 0;
      while (i < firstArg.length && firstArg[i] === " ") {
        i++;
      }
      while (i < firstArg.length && firstArg[i] !== " ") {
        i++;
      }
      firstArg = colourize(firstArg.substring(0, i)) + firstArg.substring(i);
    } else {
      firstArg = colourize(firstArg);
    }
    logger3(getLogText([firstArg, ...data]));
  }
}
var $2 = build$FromState2(buildInitial$State2({
  isGlobal: true
}));
var mod_default2 = $2;
async function getHamsterReport(begin, end, ignore) {
  if ((await Deno.permissions.query({ name: "run" })).state !== "granted") {
    throw new Error(`Missing Deno run permission"`);
  }
  const hamsterReport = await mod_default2`hamster export tsv ${begin} ${end}`.lines();
  return hamsterReport.slice(1).filter((line) => line).map((line) => {
    const [comment, date, , minutes, category] = line.split("	");
    return { comment: `${comment}@${category}`, date, minutes };
  }).filter(({ comment }) => !ignore || !comment || !comment.match(ignore)).map(({ comment, date, minutes }) => {
    return {
      comment,
      date: date?.substr(0, 10),
      hours: Math.round(100 * parseFloat(minutes) / 60) / 100
    };
  });
}
if (import.meta.main) {
  console.log(await getHamsterReport("2020-01-01", "2020-12-31"));
}
var MAX_SIZE2 = 2 ** 32 - 2;
var ByteSliceStream = class extends TransformStream {
  #offsetStart = 0;
  #offsetEnd = 0;
  /**
   * Constructs a new instance.
   *
   * @param start The zero-indexed byte index to start reading from.
   * @param end The zero-indexed byte index to stop reading at. Inclusive.
   */
  constructor(start = 0, end = Infinity) {
    super({
      start: () => {
        if (start < 0) {
          throw new RangeError(
            `Cannot construct ByteSliceStream as start must be >= 0: received ${start}`
          );
        }
        end += 1;
      },
      transform: (chunk, controller) => {
        this.#offsetStart = this.#offsetEnd;
        this.#offsetEnd += chunk.byteLength;
        if (this.#offsetEnd > start) {
          if (this.#offsetStart < start) {
            chunk = chunk.slice(start - this.#offsetStart);
          }
          if (this.#offsetEnd >= end) {
            chunk = chunk.slice(0, chunk.byteLength - this.#offsetEnd + end);
            controller.enqueue(chunk);
            controller.terminate();
          } else {
            controller.enqueue(chunk);
          }
        }
      }
    });
  }
};
function concat(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var DEFAULT_BUFFER_SIZE = 32 * 1024;
function createLPS(pat) {
  const length = pat.length;
  const lps = new Uint8Array(length);
  lps[0] = 0;
  let prefixEnd = 0;
  let i = 1;
  while (i < length) {
    if (pat[i] === pat[prefixEnd]) {
      prefixEnd++;
      lps[i] = prefixEnd;
      i++;
    } else if (prefixEnd === 0) {
      lps[i] = 0;
      i++;
    } else {
      prefixEnd = lps[prefixEnd - 1];
    }
  }
  return lps;
}
var DelimiterStream = class extends TransformStream {
  #bufs = [];
  #delimiter;
  #matchIndex = 0;
  #delimLPS;
  #disp;
  /**
   * Constructs a new instance.
   *
   * @param delimiter A delimiter to split the stream by.
   * @param options Options for the delimiter stream.
   */
  constructor(delimiter, options = {}) {
    super({
      transform: (chunk, controller) => delimiter.length === 1 ? this.#handleChar(chunk, controller) : this.#handle(chunk, controller),
      flush: (controller) => this.#flush(controller)
    });
    this.#delimiter = delimiter;
    this.#delimLPS = delimiter.length > 1 ? createLPS(delimiter) : null;
    this.#disp = options.disposition ?? "discard";
  }
  #handle(chunk, controller) {
    const bufs = this.#bufs;
    const length = chunk.byteLength;
    const disposition = this.#disp;
    const delimiter = this.#delimiter;
    const delimLen = delimiter.length;
    const lps = this.#delimLPS;
    let chunkStart = 0;
    let matchIndex = this.#matchIndex;
    let inspectIndex = 0;
    while (inspectIndex < length) {
      if (chunk[inspectIndex] === delimiter[matchIndex]) {
        inspectIndex++;
        matchIndex++;
        if (matchIndex === delimLen) {
          matchIndex = 0;
          const delimiterStartIndex = inspectIndex - delimLen;
          const delimitedChunkEnd = disposition === "suffix" ? inspectIndex : delimiterStartIndex;
          if (delimitedChunkEnd <= 0 && bufs.length === 0) {
            controller.enqueue(new Uint8Array());
            chunkStart = disposition === "prefix" ? 0 : inspectIndex;
          } else if (delimitedChunkEnd > 0 && bufs.length === 0) {
            controller.enqueue(chunk.subarray(chunkStart, delimitedChunkEnd));
            chunkStart = disposition === "prefix" ? delimiterStartIndex : inspectIndex;
          } else if (delimitedChunkEnd === 0 && bufs.length > 0) {
            if (bufs.length === 1) {
              controller.enqueue(bufs[0]);
            } else {
              controller.enqueue(concat(bufs));
            }
            bufs.length = 0;
            if (disposition !== "prefix") {
              chunkStart = inspectIndex;
            } else {
              chunkStart = 0;
            }
          } else if (delimitedChunkEnd < 0 && bufs.length > 0) {
            const lastIndex = bufs.length - 1;
            const last = bufs[lastIndex];
            const lastSliceIndex = last.byteLength + delimitedChunkEnd;
            const lastSliced = last.subarray(0, lastSliceIndex);
            if (lastIndex === 0) {
              controller.enqueue(lastSliced);
            } else {
              bufs[lastIndex] = lastSliced;
              controller.enqueue(concat(bufs));
            }
            bufs.length = 0;
            if (disposition === "prefix") {
              bufs.push(last.subarray(lastSliceIndex));
              chunkStart = 0;
            } else {
              chunkStart = inspectIndex;
            }
          } else if (delimitedChunkEnd > 0 && bufs.length > 0) {
            const chunkSliced = chunk.subarray(chunkStart, delimitedChunkEnd);
            const result = concat([...bufs, chunkSliced]);
            bufs.length = 0;
            controller.enqueue(result);
            chunkStart = disposition === "prefix" ? delimitedChunkEnd : inspectIndex;
          } else {
            throw new Error(
              "This should be unreachable, please file a bug report against Deno at https://github.com/denoland/std/issues"
            );
          }
        }
      } else if (matchIndex === 0) {
        inspectIndex++;
      } else {
        matchIndex = lps[matchIndex - 1];
      }
    }
    this.#matchIndex = matchIndex;
    if (chunkStart === 0) {
      bufs.push(chunk);
    } else if (chunkStart < length) {
      bufs.push(chunk.subarray(chunkStart));
    }
  }
  /**
   * Optimized handler for a char delimited stream:
   *
   * For char delimited streams we do not need to keep track of
   * the match index, removing the need for a fair bit of work.
   */
  #handleChar(chunk, controller) {
    const bufs = this.#bufs;
    const length = chunk.byteLength;
    const disposition = this.#disp;
    const delimiter = this.#delimiter[0];
    let chunkStart = 0;
    let inspectIndex = 0;
    while (inspectIndex < length) {
      if (chunk[inspectIndex] === delimiter) {
        inspectIndex++;
        const delimitedChunkEnd = disposition === "suffix" ? inspectIndex : inspectIndex - 1;
        if (delimitedChunkEnd === 0 && bufs.length === 0) {
          controller.enqueue(new Uint8Array());
          chunkStart = disposition === "prefix" ? 0 : 1;
        } else if (delimitedChunkEnd > 0 && bufs.length === 0) {
          controller.enqueue(chunk.subarray(chunkStart, delimitedChunkEnd));
          chunkStart = disposition === "prefix" ? inspectIndex - 1 : inspectIndex;
        } else if (delimitedChunkEnd === 0 && bufs.length > 0) {
          if (bufs.length === 1) {
            controller.enqueue(bufs[0]);
          } else {
            controller.enqueue(concat(bufs));
          }
          bufs.length = 0;
          if (disposition !== "prefix") {
            chunkStart = inspectIndex;
          }
        } else if (delimitedChunkEnd > 0 && bufs.length > 0) {
          const chunkSliced = chunk.subarray(chunkStart, delimitedChunkEnd);
          const result = concat([...bufs, chunkSliced]);
          bufs.length = 0;
          chunkStart = disposition === "prefix" ? delimitedChunkEnd : inspectIndex;
          controller.enqueue(result);
        } else {
          throw new Error(
            "This should be unreachable, please file a bug report against Deno at https://github.com/denoland/std/issues"
          );
        }
      } else {
        inspectIndex++;
      }
    }
    if (chunkStart === 0) {
      bufs.push(chunk);
    } else if (chunkStart < length) {
      bufs.push(chunk.subarray(chunkStart));
    }
  }
  #flush(controller) {
    const bufs = this.#bufs;
    const length = bufs.length;
    if (length === 0) {
      controller.enqueue(new Uint8Array());
    } else if (length === 1) {
      controller.enqueue(bufs[0]);
    } else {
      controller.enqueue(concat(bufs));
    }
  }
};
var LimitedBytesTransformStream = class extends TransformStream {
  #read = 0;
  /**
   * Constructs a new instance.
   *
   * @param size A size limit in bytes.
   * @param options Options for the stream.
   */
  constructor(size, options = { error: false }) {
    super({
      transform: (chunk, controller) => {
        if (this.#read + chunk.byteLength > size) {
          if (options.error) {
            throw new RangeError(`Exceeded byte size limit of '${size}'`);
          } else {
            controller.terminate();
          }
        } else {
          this.#read += chunk.byteLength;
          controller.enqueue(chunk);
        }
      }
    });
  }
};
var LimitedTransformStream = class extends TransformStream {
  #read = 0;
  /**
   * Constructs a new instance.
   *
   * @param size The maximum number of chunks to read.
   * @param options Options for the stream.
   */
  constructor(size, options = { error: false }) {
    super({
      transform: (chunk, controller) => {
        if (this.#read + 1 > size) {
          if (options.error) {
            throw new RangeError(`Exceeded chunk limit of '${size}'`);
          } else {
            controller.terminate();
          }
        } else {
          this.#read++;
          controller.enqueue(chunk);
        }
      }
    });
  }
};
var TextDelimiterStream = class extends TransformStream {
  #buf = "";
  #delimiter;
  #inspectIndex = 0;
  #matchIndex = 0;
  #delimLPS;
  #disp;
  /**
   * Constructs a new instance.
   *
   * @param delimiter A delimiter to split the stream by.
   * @param options Options for the stream.
   */
  constructor(delimiter, options) {
    super({
      transform: (chunk, controller) => {
        this.#handle(chunk, controller);
      },
      flush: (controller) => {
        controller.enqueue(this.#buf);
      }
    });
    this.#delimiter = delimiter;
    this.#delimLPS = createLPS(new TextEncoder().encode(delimiter));
    this.#disp = options?.disposition ?? "discard";
  }
  #handle(chunk, controller) {
    this.#buf += chunk;
    let localIndex = 0;
    while (this.#inspectIndex < this.#buf.length) {
      if (chunk[localIndex] === this.#delimiter[this.#matchIndex]) {
        this.#inspectIndex++;
        localIndex++;
        this.#matchIndex++;
        if (this.#matchIndex === this.#delimiter.length) {
          const start = this.#inspectIndex - this.#delimiter.length;
          const end = this.#disp === "suffix" ? this.#inspectIndex : start;
          const copy5 = this.#buf.slice(0, end);
          controller.enqueue(copy5);
          const shift = this.#disp === "prefix" ? start : this.#inspectIndex;
          this.#buf = this.#buf.slice(shift);
          this.#inspectIndex = this.#disp === "prefix" ? this.#delimiter.length : 0;
          this.#matchIndex = 0;
        }
      } else {
        if (this.#matchIndex === 0) {
          this.#inspectIndex++;
          localIndex++;
        } else {
          this.#matchIndex = this.#delimLPS[this.#matchIndex - 1];
        }
      }
    }
  }
};
var TextLineStream = class extends TransformStream {
  #currentLine = "";
  /**
   * Constructs a new instance.
   *
   * @param options Options for the stream.
   */
  constructor(options = { allowCR: false }) {
    super({
      transform: (chars, controller) => {
        chars = this.#currentLine + chars;
        while (true) {
          const lfIndex = chars.indexOf("\n");
          const crIndex = options.allowCR ? chars.indexOf("\r") : -1;
          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
            controller.enqueue(chars.slice(0, crIndex));
            chars = chars.slice(crIndex + 1);
            continue;
          }
          if (lfIndex === -1) break;
          const endIndex = chars[lfIndex - 1] === "\r" ? lfIndex - 1 : lfIndex;
          controller.enqueue(chars.slice(0, endIndex));
          chars = chars.slice(lfIndex + 1);
        }
        this.#currentLine = chars;
      },
      flush: (controller) => {
        if (this.#currentLine === "") return;
        const currentLine = options.allowCR && this.#currentLine.endsWith("\r") ? this.#currentLine.slice(0, -1) : this.#currentLine;
        controller.enqueue(currentLine);
      }
    });
  }
};
async function toText(stream) {
  const textDecoder4 = new TextDecoder();
  const reader = stream.getReader();
  let result = "";
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += typeof value === "string" ? value : textDecoder4.decode(value, { stream: true });
  }
  result += textDecoder4.decode();
  return result;
}
var useCookies = true;
async function jiraApi(config, query, options) {
  if (!config.jiraUrl.match(/^http/)) {
    throw new Error("bad jira url configuration");
  }
  const headers = new Headers();
  if (config.token) {
    headers.append("Authorization", "Bearer " + config.token);
  } else {
    if (useCookies) {
      const resp = await fetch(
        `${config.jiraUrl.replace(/\/$/, "")}/login.jsp`,
        {
          method: "POST",
          headers: { "content-type": "application/x-www-form-urlencoded" },
          body: `os_username=${encodeURI(config.username).replaceAll("&", "%26")}&os_password=${encodeURI(
            config.password
          ).replaceAll("&", "%26")}&os_destination=&user_role=&atl_token=&login=Log+In`,
          redirect: "manual"
        }
      );
      if (resp.headers.get("x-seraph-loginreason") !== "OK") {
        throw new Error("auth KO");
      }
      headers.append("cookie", resp.headers.get("set-cookie") || "");
    } else {
      headers.append(
        "Authorization",
        "Basic " + btoa(`${config.username}:${config.password}`)
      );
    }
  }
  if (options?.body) {
    headers.append("Content-Type", "application/json");
  }
  const url = `${config.jiraUrl.replace(/\/$/, "")}/rest/api/2/${query}`;
  const response = await fetch(url, { ...options, headers });
  console.log(
    `%c[jiraApi] ${response.status} ${options?.method || "GET"} ${url}`,
    "color:green"
  );
  return await response.json();
}
async function jiraJql(config, jql) {
  return await jiraApi(
    config,
    `search?fields=summary,worklog&maxResults=20&jql=${jql.replace(/\s+/g, " ")}`
  );
}
function myLastIssues(config) {
  const jql = `
      (
        assignee = currentUser()
        AND ( resolution = Unresolved OR updatedDate >= "-14d" )
        AND updatedDate >= startOfYear()
      ) OR (
        worklogAuthor = currentUser() AND worklogDate > "-14d"
      )
      order by updatedDate DESC`;
  return jiraJql(config, jql);
}
function logElement(config, log) {
  return jiraApi(config, `issue/${log.key}/worklog`, {
    method: "POST",
    body: JSON.stringify({
      comment: log.comment,
      started: `${log.date}T20:00:00.000+0000`,
      timeSpent: `${log.hours}h`
    })
  });
}
function issueSummary(config, issueKey) {
  return jiraApi(config, `issue/${issueKey}?fields=summary`);
}
var JiraWorkLogger = (_c = class extends (_b = DesktopWebApp, _notExitIfNoClient_dec = [help("Keep the server alive after the last client disconnects")], _sockets_dec = [hidden()], _issuesCache_dec = [hidden()], _b) {
  constructor() {
    super({
      assetsFromJson: assets_bundle_default,
      frontendPath: "frontend/dist",
      openInBrowser: "google-chrome",
      openInBrowserAppMode: true,
      port: 8e3
    });
    __publicField(this, "notExitIfNoClient", __runInitializers(_init2, 8, this, false)), __runInitializers(_init2, 11, this);
    __publicField(this, "sockets", __runInitializers(_init2, 12, this, /* @__PURE__ */ new Set())), __runInitializers(_init2, 15, this);
    __publicField(this, "issuesCache", __runInitializers(_init2, 16, this, {})), __runInitializers(_init2, 19, this);
    __publicField(this, "routes", [
      {
        route: new URLPattern({ pathname: "/api/hamsterExport" }),
        exec: async (_match, request) => {
          const params = new URL(request.url).searchParams;
          const ignore = params.get("ignore");
          const hamsterDaysToImport = Number(
            params.get("hamsterDaysToImport") || 5
          );
          const begin = new Date(
            Date.now() - 1e3 * 60 * 60 * 24 * hamsterDaysToImport
          ).toISOString().substring(0, 10);
          const end = (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
          console.log(
            `%c[hamsterExport] hamsterDaysToImport=${hamsterDaysToImport} begin=${begin} end=${end}`,
            "color:indigo"
          );
          const body = await getHamsterReport(begin, end, ignore);
          return new Response(JSON.stringify(body));
        }
      },
      {
        route: new URLPattern({ pathname: "/api/stop" }),
        exec: () => {
          console.log("Stop");
          setTimeout(() => Deno.exit(0), 100);
          return new Response("stop ok");
        }
      },
      {
        route: new URLPattern({ pathname: "/api/myLastIssues" }),
        exec: async (_match, request) => {
          const config = JSON.parse(await toText(request.body));
          const body = await myLastIssues(config);
          return new Response(JSON.stringify(body));
        }
      },
      {
        route: new URLPattern({ pathname: "/issue/:issueKey" }),
        exec: async (match, request) => {
          const issueKey = match.pathname.groups.issueKey;
          if (issueKey) {
            let issue;
            if (this.issuesCache[issueKey]) {
              console.log(`%c[jiraIssuesCache] ${issueKey}`, "color:green");
              issue = this.issuesCache[issueKey];
            } else {
              const config = JSON.parse(await toText(request.body));
              issue = await issueSummary(config, issueKey);
              this.issuesCache[issueKey] = issue;
            }
            return new Response(JSON.stringify(issue));
          }
          return new Response(null, { status: 404 });
        }
      },
      {
        route: new URLPattern({ pathname: "/createWorkLogs" }),
        exec: async (_match, request) => {
          const { config, toLog } = JSON.parse(await toText(request.body));
          for (const log of toLog) {
            await logElement(config, log);
            await mod_default2.sleep(800);
          }
          return new Response(JSON.stringify({ "status": "OK" }));
        }
      },
      {
        // WebSocket
        route: new URLPattern({ pathname: "/api/events-ws" }),
        exec: (_match, request) => {
          if (request.headers.get("upgrade") != "websocket") {
            return new Response(null, { status: 501 });
          }
          const { socket, response } = Deno.upgradeWebSocket(request);
          socket.addEventListener("open", () => {
            this.sockets.add(socket);
            console.log(`a client connected! ${this.sockets.size} clients`);
          });
          socket.addEventListener("close", () => {
            this.sockets.delete(socket);
            console.log(`a client disconnected! ${this.sockets.size} clients`);
            if (!this.notExitIfNoClient && this.sockets.size === 0) {
              console.log(`\u2192 ExitIfNoClient \u2192 shutdown the server !`);
              Deno.exit(0);
            }
          });
          return response;
        }
      }
    ]);
    __publicField(this, "onListen", async () => {
    });
  }
}, _init2 = __decoratorStart(_b), __decorateElement(_init2, 5, "notExitIfNoClient", _notExitIfNoClient_dec, _c), __decorateElement(_init2, 5, "sockets", _sockets_dec, _c), __decorateElement(_init2, 5, "issuesCache", _issuesCache_dec, _c), __decoratorMetadata(_init2, _c), _c);
if (import.meta.main) {
  cliteRun(JiraWorkLogger, { meta: import.meta });
}
